package artifact_store

import (
	"fmt"
	"strings"

	"github.com/ipfs/go-cid"
)

// CIDValidator provides validation utilities for IPFS Content Identifiers.
// This ensures that only valid CIDs are used in production, preventing
// fake or malformed CID strings from entering the system.
type CIDValidator struct {
	// allowStubCIDs allows stub CIDs for testing purposes.
	// This should be false in production.
	allowStubCIDs bool
}

// NewCIDValidator creates a CID validator for production use.
// Stub CIDs are rejected in production mode.
func NewCIDValidator() *CIDValidator {
	return &CIDValidator{
		allowStubCIDs: false,
	}
}

// NewTestCIDValidator creates a CID validator that allows stub CIDs.
// This should ONLY be used in test code.
func NewTestCIDValidator() *CIDValidator {
	return &CIDValidator{
		allowStubCIDs: true,
	}
}

// ValidateCID validates that a CID string is a valid IPFS Content Identifier.
// Returns an error if the CID is invalid, empty, or a stub CID in production mode.
func (v *CIDValidator) ValidateCID(cidStr string) error {
	if cidStr == "" {
		return ErrInvalidContentAddress.Wrap("CID cannot be empty")
	}

	// Check for stub CIDs (they use hex encoding after "Qm" prefix)
	if isStubCID(cidStr) {
		if !v.allowStubCIDs {
			return ErrInvalidContentAddress.Wrap("stub CIDs are not allowed in production; use real IPFS node")
		}
		// Allow stub CIDs in test mode
		return nil
	}

	// Parse and validate the CID using go-cid library
	_, err := cid.Decode(cidStr)
	if err != nil {
		return ErrInvalidContentAddress.Wrapf("invalid CID format: %v", err)
	}

	return nil
}

// IsValidCID returns true if the CID is valid, false otherwise.
func (v *CIDValidator) IsValidCID(cidStr string) bool {
	return v.ValidateCID(cidStr) == nil
}

// isStubCID detects stub CIDs generated by the StubIPFSClient.
// Stub CIDs have the format: Qm + hex encoding (32 hex chars).
// Real CIDv0 uses base58 encoding and would not have hex-only chars after "Qm".
func isStubCID(cidStr string) bool {
	if !strings.HasPrefix(cidStr, "Qm") {
		return false
	}

	// Stub CIDs are exactly "Qm" + 32 hex chars = 34 chars total
	if len(cidStr) != 34 {
		return false
	}

	// Check if the suffix is pure hex (stub) vs base58 (real)
	suffix := cidStr[2:]
	for _, c := range suffix {
		isHex := (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')
		if !isHex {
			// Contains non-hex chars, likely a real CID
			return false
		}
	}

	// All hex chars after "Qm" indicates a stub CID
	return true
}

// ParseCID parses a CID string and returns the parsed CID.
// This is useful for extracting CID properties like version, codec, and multihash.
func ParseCID(cidStr string) (*ParsedCID, error) {
	if cidStr == "" {
		return nil, ErrInvalidContentAddress.Wrap("CID cannot be empty")
	}

	c, err := cid.Decode(cidStr)
	if err != nil {
		// Check if it's a stub CID
		if isStubCID(cidStr) {
			return &ParsedCID{
				Raw:     cidStr,
				Version: 0,
				IsStub:  true,
			}, nil
		}
		return nil, ErrInvalidContentAddress.Wrapf("failed to parse CID: %v", err)
	}

	return &ParsedCID{
		Raw:      cidStr,
		Version:  int(c.Version()),
		Codec:    c.Type(),
		Hash:     c.Hash(),
		IsStub:   false,
		StringV1: c.String(),
		BytesCID: c.Bytes(),
	}, nil
}

// ParsedCID contains parsed CID information
type ParsedCID struct {
	// Raw is the original CID string
	Raw string

	// Version is the CID version (0 or 1)
	Version int

	// Codec is the content codec (e.g., dag-pb, raw)
	Codec uint64

	// Hash is the multihash bytes
	Hash []byte

	// IsStub indicates if this is a stub CID (for testing only)
	IsStub bool

	// StringV1 is the CIDv1 string representation
	StringV1 string

	// BytesCID is the binary representation
	BytesCID []byte
}

// String returns a human-readable representation of the parsed CID
func (p *ParsedCID) String() string {
	if p.IsStub {
		return fmt.Sprintf("StubCID{%s}", p.Raw)
	}
	return fmt.Sprintf("CID{v%d, codec=%d, hash=%x}", p.Version, p.Codec, p.Hash[:8])
}

// ValidateCIDForBackend validates a CID for a specific backend type.
// For IPFS backend, it validates proper CID format.
// For other backends, the BackendRef format may differ.
func ValidateCIDForBackend(backendRef string, backend BackendType) error {
	switch backend {
	case BackendIPFS:
		validator := NewCIDValidator()
		return validator.ValidateCID(backendRef)
	case BackendWaldur:
		// Waldur uses different reference format (e.g., UUIDs)
		if backendRef == "" {
			return ErrInvalidContentAddress.Wrap("waldur reference cannot be empty")
		}
		return nil
	default:
		return ErrBackendNotSupported.Wrapf("unknown backend: %s", backend)
	}
}

// ValidateCIDForBackendAllowStub is like ValidateCIDForBackend but allows stub CIDs.
// This is for testing purposes only.
func ValidateCIDForBackendAllowStub(backendRef string, backend BackendType) error {
	switch backend {
	case BackendIPFS:
		validator := NewTestCIDValidator()
		return validator.ValidateCID(backendRef)
	case BackendWaldur:
		if backendRef == "" {
			return ErrInvalidContentAddress.Wrap("waldur reference cannot be empty")
		}
		return nil
	default:
		return ErrBackendNotSupported.Wrapf("unknown backend: %s", backend)
	}
}
