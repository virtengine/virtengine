#!/usr/bin/env -S node --experimental-strip-types --no-warnings

import standaloneCode from "ajv/dist/standalone/index.js";
import {Ajv} from "ajv";
import fs from "node:fs";
import path from "node:path";
import YAML from "js-yaml";
import { compile as compileSchemaToTypes } from 'json-schema-to-typescript'
import esbuild from "esbuild";

const SCHEMAS = {
  jwtTokenPayload: {
    output: path.join(import.meta.dirname, "../src/sdk/provider/auth/jwt/validateJwtPayload.ts"),
    get content() {
      return JSON.parse(fs.readFileSync(path.join(import.meta.dirname, "../../specs/jwt-schema.json"), "utf8"));
    },
  },
  sdlInput: {
    typeName: "SDLInput",
    output: path.join(import.meta.dirname, "../src/sdl/SDL/validateSDL/validateSDLInput.ts"),
    get content() {
      return YAML.load(fs.readFileSync(path.join(import.meta.dirname, "../src/sdl/sdl-schema.yaml"), "utf8"));
    },
  },
};

const ajv = new Ajv({
  allErrors: true,
  strict: false,
  code: { source: true, esm: true },
});

for (const schemaConfig of Object.values(SCHEMAS)) {
  const schema = schemaConfig.content;
  const types = 'typeName' in schemaConfig
    ? await compileSchemaToTypes({ ...normalizeSchema(schema), title: schemaConfig.typeName }, schemaConfig.typeName, {
      enableConstEnums: false,
      ignoreMinAndMaxItems: true,
      bannerComment: '',
    })
    : '';

  const validate = ajv.compile(schema);
  let moduleCode = (standaloneCode as any)(ajv, validate);

  const schemaMatches = moduleCode.match(/const\s+(schema\d+)\s*=\s*\{/);
  if (!schemaMatches) {
    throw new Error("Failed to find schema in generated json-schema based module code");
  }

  moduleCode += `\n\nexport const schema = ${schemaMatches[1]};`;

  // bundle result because it contains imports from ajv library
  const result = await esbuild.build({
    stdin: {
      contents: moduleCode,
      resolveDir: import.meta.dirname,
    },
    write: false,
    bundle: true,
    format: "esm",
    target: ["es2020"],
    external: [],
  });

  fs.writeFileSync(schemaConfig.output,
    `// DO NOT EDIT THIS FILE\n` +
    `// This file is generated by the script/compile-json-schema-to-ts.ts script\n` +
    '/* eslint-disable */\n' +
    `// @ts-nocheck\n\n` +
    types +
    result.outputFiles[0].text
  );
}

// json-schema-to-typescript doesn't work well with conditional schemas.
// So we remove all conditional schemas from the schema, since they enforce additional validation rules which are not important for ts types.
function normalizeSchema(schema: Record<string, unknown>): Record<string, unknown> {
  const result = JSON.parse(JSON.stringify(schema));

  function processObject(obj: unknown): unknown {
    if (obj === null || typeof obj !== 'object') {
      return obj;
    }

    if (Array.isArray(obj)) {
      return obj.map(processObject);
    }

    const record = obj as Record<string, unknown>;

    // Process all properties first
    for (const key of Object.keys(record)) {
      record[key] = processObject(record[key]);
    }

    // Handle allOf, anyOf, oneOf
    for (const combiner of ['allOf', 'anyOf', 'oneOf']) {
      if (Array.isArray(record[combiner])) {
        // Filter out items that only contain 'if' (conditional schemas without then/else)
        record[combiner] = (record[combiner] as unknown[]).filter((item) => {
          if (item !== null && typeof item === 'object' && !Array.isArray(item)) {
            const itemRecord = item as Record<string, unknown>;
            // Remove if the item only has '$ref' pointing to a conditional schema or only has 'if'
            if (Object.hasOwn(itemRecord, 'if')) {
              return false;
            }

            if (typeof itemRecord.$ref === 'string') {
              const ref = itemRecord.$ref.slice(2).split('/').reduce((acc, key) => acc?.[key] as any, schema);
              if (ref && typeof ref === 'object' && Object.hasOwn(ref, 'if')) {
                return false;
              }
            }
          }
          return true;
        });

        // Remove the combiner if it's now empty
        if ((record[combiner] as unknown[]).length === 0) {
          delete record[combiner];
        }
      }
    }

    return record;
  }

  return processObject(result) as Record<string, unknown>;
}
