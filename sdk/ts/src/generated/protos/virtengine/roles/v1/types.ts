import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/roles/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** Role represents the different roles in the VirtEngine system */
export enum Role {
  /** ROLE_UNSPECIFIED - ROLE_UNSPECIFIED is the default/invalid role */
  ROLE_UNSPECIFIED = 0,
  /** ROLE_GENESIS_ACCOUNT - ROLE_GENESIS_ACCOUNT represents the highest privilege role - initial chain authority */
  ROLE_GENESIS_ACCOUNT = 1,
  /** ROLE_ADMINISTRATOR - ROLE_ADMINISTRATOR represents platform operations with high trust level */
  ROLE_ADMINISTRATOR = 2,
  /** ROLE_MODERATOR - ROLE_MODERATOR represents content/user moderation with medium-high trust level */
  ROLE_MODERATOR = 3,
  /** ROLE_VALIDATOR - ROLE_VALIDATOR represents consensus participants with high trust level */
  ROLE_VALIDATOR = 4,
  /** ROLE_SERVICE_PROVIDER - ROLE_SERVICE_PROVIDER represents infrastructure operators with medium trust level */
  ROLE_SERVICE_PROVIDER = 5,
  /** ROLE_CUSTOMER - ROLE_CUSTOMER represents end users with standard trust level */
  ROLE_CUSTOMER = 6,
  /** ROLE_SUPPORT_AGENT - ROLE_SUPPORT_AGENT represents customer support with medium trust level */
  ROLE_SUPPORT_AGENT = 7,
  UNRECOGNIZED = -1,
}

export function roleFromJSON(object: any): Role {
  switch (object) {
    case 0:
    case "ROLE_UNSPECIFIED":
      return Role.ROLE_UNSPECIFIED;
    case 1:
    case "ROLE_GENESIS_ACCOUNT":
      return Role.ROLE_GENESIS_ACCOUNT;
    case 2:
    case "ROLE_ADMINISTRATOR":
      return Role.ROLE_ADMINISTRATOR;
    case 3:
    case "ROLE_MODERATOR":
      return Role.ROLE_MODERATOR;
    case 4:
    case "ROLE_VALIDATOR":
      return Role.ROLE_VALIDATOR;
    case 5:
    case "ROLE_SERVICE_PROVIDER":
      return Role.ROLE_SERVICE_PROVIDER;
    case 6:
    case "ROLE_CUSTOMER":
      return Role.ROLE_CUSTOMER;
    case 7:
    case "ROLE_SUPPORT_AGENT":
      return Role.ROLE_SUPPORT_AGENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Role.UNRECOGNIZED;
  }
}

export function roleToJSON(object: Role): string {
  switch (object) {
    case Role.ROLE_UNSPECIFIED:
      return "ROLE_UNSPECIFIED";
    case Role.ROLE_GENESIS_ACCOUNT:
      return "ROLE_GENESIS_ACCOUNT";
    case Role.ROLE_ADMINISTRATOR:
      return "ROLE_ADMINISTRATOR";
    case Role.ROLE_MODERATOR:
      return "ROLE_MODERATOR";
    case Role.ROLE_VALIDATOR:
      return "ROLE_VALIDATOR";
    case Role.ROLE_SERVICE_PROVIDER:
      return "ROLE_SERVICE_PROVIDER";
    case Role.ROLE_CUSTOMER:
      return "ROLE_CUSTOMER";
    case Role.ROLE_SUPPORT_AGENT:
      return "ROLE_SUPPORT_AGENT";
    case Role.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AccountState represents the state of an account */
export enum AccountState {
  /** ACCOUNT_STATE_UNSPECIFIED - ACCOUNT_STATE_UNSPECIFIED is the default/invalid state */
  ACCOUNT_STATE_UNSPECIFIED = 0,
  /** ACCOUNT_STATE_ACTIVE - ACCOUNT_STATE_ACTIVE represents an active account */
  ACCOUNT_STATE_ACTIVE = 1,
  /** ACCOUNT_STATE_SUSPENDED - ACCOUNT_STATE_SUSPENDED represents a temporarily suspended account */
  ACCOUNT_STATE_SUSPENDED = 2,
  /** ACCOUNT_STATE_TERMINATED - ACCOUNT_STATE_TERMINATED represents a permanently terminated account */
  ACCOUNT_STATE_TERMINATED = 3,
  UNRECOGNIZED = -1,
}

export function accountStateFromJSON(object: any): AccountState {
  switch (object) {
    case 0:
    case "ACCOUNT_STATE_UNSPECIFIED":
      return AccountState.ACCOUNT_STATE_UNSPECIFIED;
    case 1:
    case "ACCOUNT_STATE_ACTIVE":
      return AccountState.ACCOUNT_STATE_ACTIVE;
    case 2:
    case "ACCOUNT_STATE_SUSPENDED":
      return AccountState.ACCOUNT_STATE_SUSPENDED;
    case 3:
    case "ACCOUNT_STATE_TERMINATED":
      return AccountState.ACCOUNT_STATE_TERMINATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountState.UNRECOGNIZED;
  }
}

export function accountStateToJSON(object: AccountState): string {
  switch (object) {
    case AccountState.ACCOUNT_STATE_UNSPECIFIED:
      return "ACCOUNT_STATE_UNSPECIFIED";
    case AccountState.ACCOUNT_STATE_ACTIVE:
      return "ACCOUNT_STATE_ACTIVE";
    case AccountState.ACCOUNT_STATE_SUSPENDED:
      return "ACCOUNT_STATE_SUSPENDED";
    case AccountState.ACCOUNT_STATE_TERMINATED:
      return "ACCOUNT_STATE_TERMINATED";
    case AccountState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RoleAssignment represents a role assigned to an account */
export interface RoleAssignment {
  /** Address is the account address that has the role */
  address: string;
  /** Role is the assigned role */
  role: Role;
  /** AssignedBy is the address that assigned this role */
  assignedBy: string;
  /** AssignedAt is the Unix timestamp when the role was assigned */
  assignedAt: Long;
}

/** AccountStateRecord represents the stored state of an account */
export interface AccountStateRecord {
  /** Address is the account address */
  address: string;
  /** State is the current account state */
  state: AccountState;
  /** Reason is the reason for the current state */
  reason: string;
  /** ModifiedBy is the address that last modified the state */
  modifiedBy: string;
  /** ModifiedAt is the Unix timestamp when the state was last modified */
  modifiedAt: Long;
  /** PreviousState is the previous account state */
  previousState: AccountState;
}

/** Params defines the parameters for the roles module */
export interface Params {
  /** MaxRolesPerAccount is the maximum number of roles an account can have */
  maxRolesPerAccount: number;
  /** AllowSelfRevoke determines if accounts can revoke their own roles */
  allowSelfRevoke: boolean;
}

/** EventRoleAssigned is emitted when a role is assigned to an account */
export interface EventRoleAssigned {
  /** Address is the account that received the role */
  address: string;
  /** Role is the assigned role */
  role: string;
  /** AssignedBy is the address that assigned the role */
  assignedBy: string;
}

/** EventRoleRevoked is emitted when a role is revoked from an account */
export interface EventRoleRevoked {
  /** Address is the account that lost the role */
  address: string;
  /** Role is the revoked role */
  role: string;
  /** RevokedBy is the address that revoked the role */
  revokedBy: string;
}

/** EventAccountStateChanged is emitted when an account state changes */
export interface EventAccountStateChanged {
  /** Address is the account whose state changed */
  address: string;
  /** PreviousState is the previous state */
  previousState: string;
  /** NewState is the new state */
  newState: string;
  /** ModifiedBy is the address that modified the state */
  modifiedBy: string;
  /** Reason is the reason for the state change */
  reason: string;
}

/** EventAdminNominated is emitted when a new administrator is nominated */
export interface EventAdminNominated {
  /** Address is the nominated administrator */
  address: string;
  /** NominatedBy is the address that made the nomination */
  nominatedBy: string;
}

function createBaseRoleAssignment(): RoleAssignment {
  return { address: "", role: 0, assignedBy: "", assignedAt: Long.ZERO };
}

export const RoleAssignment: MessageFns<RoleAssignment, "virtengine.roles.v1.RoleAssignment"> = {
  $type: "virtengine.roles.v1.RoleAssignment" as const,

  encode(message: RoleAssignment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.role !== 0) {
      writer.uint32(16).int32(message.role);
    }
    if (message.assignedBy !== "") {
      writer.uint32(26).string(message.assignedBy);
    }
    if (!message.assignedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.assignedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoleAssignment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoleAssignment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.role = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assignedBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.assignedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoleAssignment {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      role: isSet(object.role) ? roleFromJSON(object.role) : 0,
      assignedBy: isSet(object.assigned_by) ? globalThis.String(object.assigned_by) : "",
      assignedAt: isSet(object.assigned_at) ? Long.fromValue(object.assigned_at) : Long.ZERO,
    };
  },

  toJSON(message: RoleAssignment): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.role !== 0) {
      obj.role = roleToJSON(message.role);
    }
    if (message.assignedBy !== "") {
      obj.assigned_by = message.assignedBy;
    }
    if (!message.assignedAt.equals(Long.ZERO)) {
      obj.assigned_at = (message.assignedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<RoleAssignment>): RoleAssignment {
    const message = createBaseRoleAssignment();
    message.address = object.address ?? "";
    message.role = object.role ?? 0;
    message.assignedBy = object.assignedBy ?? "";
    message.assignedAt = (object.assignedAt !== undefined && object.assignedAt !== null)
      ? Long.fromValue(object.assignedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseAccountStateRecord(): AccountStateRecord {
  return { address: "", state: 0, reason: "", modifiedBy: "", modifiedAt: Long.ZERO, previousState: 0 };
}

export const AccountStateRecord: MessageFns<AccountStateRecord, "virtengine.roles.v1.AccountStateRecord"> = {
  $type: "virtengine.roles.v1.AccountStateRecord" as const,

  encode(message: AccountStateRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.state !== 0) {
      writer.uint32(16).int32(message.state);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.modifiedBy !== "") {
      writer.uint32(34).string(message.modifiedBy);
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.modifiedAt.toString());
    }
    if (message.previousState !== 0) {
      writer.uint32(48).int32(message.previousState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AccountStateRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAccountStateRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifiedBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.modifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.previousState = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AccountStateRecord {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      state: isSet(object.state) ? accountStateFromJSON(object.state) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      modifiedBy: isSet(object.modified_by) ? globalThis.String(object.modified_by) : "",
      modifiedAt: isSet(object.modified_at) ? Long.fromValue(object.modified_at) : Long.ZERO,
      previousState: isSet(object.previous_state) ? accountStateFromJSON(object.previous_state) : 0,
    };
  },

  toJSON(message: AccountStateRecord): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.state !== 0) {
      obj.state = accountStateToJSON(message.state);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.modifiedBy !== "") {
      obj.modified_by = message.modifiedBy;
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      obj.modified_at = (message.modifiedAt || Long.ZERO).toString();
    }
    if (message.previousState !== 0) {
      obj.previous_state = accountStateToJSON(message.previousState);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AccountStateRecord>): AccountStateRecord {
    const message = createBaseAccountStateRecord();
    message.address = object.address ?? "";
    message.state = object.state ?? 0;
    message.reason = object.reason ?? "";
    message.modifiedBy = object.modifiedBy ?? "";
    message.modifiedAt = (object.modifiedAt !== undefined && object.modifiedAt !== null)
      ? Long.fromValue(object.modifiedAt)
      : Long.ZERO;
    message.previousState = object.previousState ?? 0;
    return message;
  },
};

function createBaseParams(): Params {
  return { maxRolesPerAccount: 0, allowSelfRevoke: false };
}

export const Params: MessageFns<Params, "virtengine.roles.v1.Params"> = {
  $type: "virtengine.roles.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxRolesPerAccount !== 0) {
      writer.uint32(8).uint32(message.maxRolesPerAccount);
    }
    if (message.allowSelfRevoke !== false) {
      writer.uint32(16).bool(message.allowSelfRevoke);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxRolesPerAccount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allowSelfRevoke = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxRolesPerAccount: isSet(object.max_roles_per_account) ? globalThis.Number(object.max_roles_per_account) : 0,
      allowSelfRevoke: isSet(object.allow_self_revoke) ? globalThis.Boolean(object.allow_self_revoke) : false,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.maxRolesPerAccount !== 0) {
      obj.max_roles_per_account = Math.round(message.maxRolesPerAccount);
    }
    if (message.allowSelfRevoke !== false) {
      obj.allow_self_revoke = message.allowSelfRevoke;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.maxRolesPerAccount = object.maxRolesPerAccount ?? 0;
    message.allowSelfRevoke = object.allowSelfRevoke ?? false;
    return message;
  },
};

function createBaseEventRoleAssigned(): EventRoleAssigned {
  return { address: "", role: "", assignedBy: "" };
}

export const EventRoleAssigned: MessageFns<EventRoleAssigned, "virtengine.roles.v1.EventRoleAssigned"> = {
  $type: "virtengine.roles.v1.EventRoleAssigned" as const,

  encode(message: EventRoleAssigned, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.assignedBy !== "") {
      writer.uint32(26).string(message.assignedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRoleAssigned {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRoleAssigned();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.assignedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRoleAssigned {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      assignedBy: isSet(object.assigned_by) ? globalThis.String(object.assigned_by) : "",
    };
  },

  toJSON(message: EventRoleAssigned): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.assignedBy !== "") {
      obj.assigned_by = message.assignedBy;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventRoleAssigned>): EventRoleAssigned {
    const message = createBaseEventRoleAssigned();
    message.address = object.address ?? "";
    message.role = object.role ?? "";
    message.assignedBy = object.assignedBy ?? "";
    return message;
  },
};

function createBaseEventRoleRevoked(): EventRoleRevoked {
  return { address: "", role: "", revokedBy: "" };
}

export const EventRoleRevoked: MessageFns<EventRoleRevoked, "virtengine.roles.v1.EventRoleRevoked"> = {
  $type: "virtengine.roles.v1.EventRoleRevoked" as const,

  encode(message: EventRoleRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.role !== "") {
      writer.uint32(18).string(message.role);
    }
    if (message.revokedBy !== "") {
      writer.uint32(26).string(message.revokedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventRoleRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventRoleRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.role = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventRoleRevoked {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      role: isSet(object.role) ? globalThis.String(object.role) : "",
      revokedBy: isSet(object.revoked_by) ? globalThis.String(object.revoked_by) : "",
    };
  },

  toJSON(message: EventRoleRevoked): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.role !== "") {
      obj.role = message.role;
    }
    if (message.revokedBy !== "") {
      obj.revoked_by = message.revokedBy;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventRoleRevoked>): EventRoleRevoked {
    const message = createBaseEventRoleRevoked();
    message.address = object.address ?? "";
    message.role = object.role ?? "";
    message.revokedBy = object.revokedBy ?? "";
    return message;
  },
};

function createBaseEventAccountStateChanged(): EventAccountStateChanged {
  return { address: "", previousState: "", newState: "", modifiedBy: "", reason: "" };
}

export const EventAccountStateChanged: MessageFns<
  EventAccountStateChanged,
  "virtengine.roles.v1.EventAccountStateChanged"
> = {
  $type: "virtengine.roles.v1.EventAccountStateChanged" as const,

  encode(message: EventAccountStateChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.previousState !== "") {
      writer.uint32(18).string(message.previousState);
    }
    if (message.newState !== "") {
      writer.uint32(26).string(message.newState);
    }
    if (message.modifiedBy !== "") {
      writer.uint32(34).string(message.modifiedBy);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAccountStateChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAccountStateChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.previousState = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newState = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modifiedBy = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAccountStateChanged {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      previousState: isSet(object.previous_state) ? globalThis.String(object.previous_state) : "",
      newState: isSet(object.new_state) ? globalThis.String(object.new_state) : "",
      modifiedBy: isSet(object.modified_by) ? globalThis.String(object.modified_by) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: EventAccountStateChanged): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.previousState !== "") {
      obj.previous_state = message.previousState;
    }
    if (message.newState !== "") {
      obj.new_state = message.newState;
    }
    if (message.modifiedBy !== "") {
      obj.modified_by = message.modifiedBy;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventAccountStateChanged>): EventAccountStateChanged {
    const message = createBaseEventAccountStateChanged();
    message.address = object.address ?? "";
    message.previousState = object.previousState ?? "";
    message.newState = object.newState ?? "";
    message.modifiedBy = object.modifiedBy ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventAdminNominated(): EventAdminNominated {
  return { address: "", nominatedBy: "" };
}

export const EventAdminNominated: MessageFns<EventAdminNominated, "virtengine.roles.v1.EventAdminNominated"> = {
  $type: "virtengine.roles.v1.EventAdminNominated" as const,

  encode(message: EventAdminNominated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.nominatedBy !== "") {
      writer.uint32(18).string(message.nominatedBy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventAdminNominated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventAdminNominated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nominatedBy = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventAdminNominated {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      nominatedBy: isSet(object.nominated_by) ? globalThis.String(object.nominated_by) : "",
    };
  },

  toJSON(message: EventAdminNominated): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.nominatedBy !== "") {
      obj.nominated_by = message.nominatedBy;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventAdminNominated>): EventAdminNominated {
    const message = createBaseEventAdminNominated();
    message.address = object.address ?? "";
    message.nominatedBy = object.nominatedBy ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
