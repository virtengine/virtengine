import { bytesFromBase64, base64FromBytes, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/encryption/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** RecipientMode defines how recipients are selected for encryption */
export enum RecipientMode {
  /** RECIPIENT_MODE_UNSPECIFIED - RECIPIENT_MODE_UNSPECIFIED is the unspecified recipient mode */
  RECIPIENT_MODE_UNSPECIFIED = 0,
  /** RECIPIENT_MODE_FULL_VALIDATOR_SET - RECIPIENT_MODE_FULL_VALIDATOR_SET encrypts to all active validators */
  RECIPIENT_MODE_FULL_VALIDATOR_SET = 1,
  /** RECIPIENT_MODE_COMMITTEE - RECIPIENT_MODE_COMMITTEE encrypts to a designated identity committee subset */
  RECIPIENT_MODE_COMMITTEE = 2,
  /** RECIPIENT_MODE_SPECIFIC - RECIPIENT_MODE_SPECIFIC encrypts to specific recipients */
  RECIPIENT_MODE_SPECIFIC = 3,
  UNRECOGNIZED = -1,
}

export function recipientModeFromJSON(object: any): RecipientMode {
  switch (object) {
    case 0:
    case "RECIPIENT_MODE_UNSPECIFIED":
      return RecipientMode.RECIPIENT_MODE_UNSPECIFIED;
    case 1:
    case "RECIPIENT_MODE_FULL_VALIDATOR_SET":
      return RecipientMode.RECIPIENT_MODE_FULL_VALIDATOR_SET;
    case 2:
    case "RECIPIENT_MODE_COMMITTEE":
      return RecipientMode.RECIPIENT_MODE_COMMITTEE;
    case 3:
    case "RECIPIENT_MODE_SPECIFIC":
      return RecipientMode.RECIPIENT_MODE_SPECIFIC;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RecipientMode.UNRECOGNIZED;
  }
}

export function recipientModeToJSON(object: RecipientMode): string {
  switch (object) {
    case RecipientMode.RECIPIENT_MODE_UNSPECIFIED:
      return "RECIPIENT_MODE_UNSPECIFIED";
    case RecipientMode.RECIPIENT_MODE_FULL_VALIDATOR_SET:
      return "RECIPIENT_MODE_FULL_VALIDATOR_SET";
    case RecipientMode.RECIPIENT_MODE_COMMITTEE:
      return "RECIPIENT_MODE_COMMITTEE";
    case RecipientMode.RECIPIENT_MODE_SPECIFIC:
      return "RECIPIENT_MODE_SPECIFIC";
    case RecipientMode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AlgorithmInfo contains metadata about an encryption algorithm */
export interface AlgorithmInfo {
  /** ID is the algorithm identifier */
  id: string;
  /** Version is the algorithm version */
  version: number;
  /** Description is a human-readable description */
  description: string;
  /** KeySize is the public key size in bytes */
  keySize: number;
  /** NonceSize is the nonce/IV size in bytes */
  nonceSize: number;
  /** Deprecated indicates if this algorithm should no longer be used for new encryptions */
  deprecated: boolean;
}

/** RecipientKeyRecord represents a registered public key for receiving encrypted data */
export interface RecipientKeyRecord {
  /** Address is the account address that owns this key */
  address: string;
  /** PublicKey is the X25519 public key bytes */
  publicKey: Uint8Array;
  /** KeyFingerprint is a unique identifier derived from the public key */
  keyFingerprint: string;
  /** AlgorithmID specifies which algorithm this key is for */
  algorithmId: string;
  /** RegisteredAt is the block time when the key was registered */
  registeredAt: Long;
  /** RevokedAt is the block time when the key was revoked (0 if active) */
  revokedAt: Long;
  /** Label is an optional human-readable label for the key */
  label: string;
}

/** WrappedKeyEntry represents a per-recipient wrapped key */
export interface WrappedKeyEntry {
  /** RecipientID is the unique identifier for the recipient (key fingerprint or validator address) */
  recipientId: string;
  /** WrappedKey is the data encryption key wrapped for this recipient */
  wrappedKey: Uint8Array;
  /** Algorithm is the key wrapping algorithm used */
  algorithm: string;
  /** EphemeralPubKey is the ephemeral public key used for this recipient (if applicable) */
  ephemeralPubKey: Uint8Array;
}

/**
 * EncryptedPayloadEnvelope is the canonical encrypted payload structure
 * for all sensitive fields stored on-chain.
 */
export interface EncryptedPayloadEnvelope {
  /** Version is the envelope format version for future compatibility */
  version: number;
  /** AlgorithmID identifies the encryption algorithm used */
  algorithmId: string;
  /** AlgorithmVersion is the version of the algorithm used */
  algorithmVersion: number;
  /** RecipientKeyIDs are the fingerprints of intended recipients' public keys */
  recipientKeyIds: string[];
  /** RecipientPublicKeys are the public keys for intended recipients */
  recipientPublicKeys: Uint8Array[];
  /** EncryptedKeys contains the data encryption key encrypted for each recipient */
  encryptedKeys: Uint8Array[];
  /** WrappedKeys contains per-recipient wrapped DEKs keyed by recipient ID */
  wrappedKeys: WrappedKeyEntry[];
  /** Nonce is the initialization vector / nonce for encryption */
  nonce: Uint8Array;
  /** Ciphertext is the encrypted payload data */
  ciphertext: Uint8Array;
  /** SenderSignature is the signature over hash(version || algorithm || ciphertext || nonce || recipients) */
  senderSignature: Uint8Array;
  /** SenderPubKey is the sender's public key for signature verification */
  senderPubKey: Uint8Array;
  /** Metadata contains optional public or encrypted metadata */
  metadata: { [key: string]: string };
}

export interface EncryptedPayloadEnvelope_MetadataEntry {
  key: string;
  value: string;
}

/**
 * MultiRecipientEnvelope extends the encrypted envelope to support
 * encrypting to multiple validator enclaves for consensus recomputation.
 */
export interface MultiRecipientEnvelope {
  /** Version is the envelope format version */
  version: number;
  /** AlgorithmID identifies the payload encryption algorithm */
  algorithmId: string;
  /** AlgorithmVersion is the version of the payload encryption algorithm */
  algorithmVersion: number;
  /** RecipientMode specifies how recipients were selected */
  recipientMode: RecipientMode;
  /** PayloadCiphertext is the encrypted payload (symmetric encryption) */
  payloadCiphertext: Uint8Array;
  /** PayloadNonce is the nonce used for payload encryption */
  payloadNonce: Uint8Array;
  /** WrappedKeys contains the data encryption key wrapped for each recipient */
  wrappedKeys: WrappedKeyEntry[];
  /** ClientSignature is the approved client's signature over the payload */
  clientSignature: Uint8Array;
  /** ClientID is the approved client identifier */
  clientId: string;
  /** UserSignature is the user's signature over the payload */
  userSignature: Uint8Array;
  /** UserPubKey is the user's public key for signature verification */
  userPubKey: Uint8Array;
  /** Metadata contains additional public metadata */
  metadata: { [key: string]: string };
  /** CommitteeEpoch is the committee epoch if RecipientMode is committee */
  committeeEpoch: Long;
}

export interface MultiRecipientEnvelope_MetadataEntry {
  key: string;
  value: string;
}

/** Params defines the parameters for the encryption module */
export interface Params {
  /** MaxRecipientsPerEnvelope is the maximum number of recipients per envelope */
  maxRecipientsPerEnvelope: number;
  /** MaxKeysPerAccount is the maximum number of keys an account can register */
  maxKeysPerAccount: number;
  /**
   * AllowedAlgorithms is the list of allowed encryption algorithms
   * Empty means all supported algorithms are allowed
   */
  allowedAlgorithms: string[];
  /** RequireSignature determines if envelope signatures are mandatory */
  requireSignature: boolean;
}

/** EventKeyRegistered is emitted when a recipient key is registered */
export interface EventKeyRegistered {
  address: string;
  fingerprint: string;
  algorithm: string;
  label: string;
  registeredAt: Long;
}

/** EventKeyRevoked is emitted when a recipient key is revoked */
export interface EventKeyRevoked {
  address: string;
  fingerprint: string;
  revokedBy: string;
  revokedAt: Long;
}

/** EventKeyUpdated is emitted when a recipient key is updated (e.g., label changed) */
export interface EventKeyUpdated {
  address: string;
  fingerprint: string;
  field: string;
  oldValue: string;
  newValue: string;
}

function createBaseAlgorithmInfo(): AlgorithmInfo {
  return { id: "", version: 0, description: "", keySize: 0, nonceSize: 0, deprecated: false };
}

export const AlgorithmInfo: MessageFns<AlgorithmInfo, "virtengine.encryption.v1.AlgorithmInfo"> = {
  $type: "virtengine.encryption.v1.AlgorithmInfo" as const,

  encode(message: AlgorithmInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.version !== 0) {
      writer.uint32(16).uint32(message.version);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.keySize !== 0) {
      writer.uint32(32).int32(message.keySize);
    }
    if (message.nonceSize !== 0) {
      writer.uint32(40).int32(message.nonceSize);
    }
    if (message.deprecated !== false) {
      writer.uint32(48).bool(message.deprecated);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlgorithmInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlgorithmInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.keySize = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.nonceSize = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deprecated = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlgorithmInfo {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      keySize: isSet(object.key_size) ? globalThis.Number(object.key_size) : 0,
      nonceSize: isSet(object.nonce_size) ? globalThis.Number(object.nonce_size) : 0,
      deprecated: isSet(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
    };
  },

  toJSON(message: AlgorithmInfo): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.keySize !== 0) {
      obj.key_size = Math.round(message.keySize);
    }
    if (message.nonceSize !== 0) {
      obj.nonce_size = Math.round(message.nonceSize);
    }
    if (message.deprecated !== false) {
      obj.deprecated = message.deprecated;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AlgorithmInfo>): AlgorithmInfo {
    const message = createBaseAlgorithmInfo();
    message.id = object.id ?? "";
    message.version = object.version ?? 0;
    message.description = object.description ?? "";
    message.keySize = object.keySize ?? 0;
    message.nonceSize = object.nonceSize ?? 0;
    message.deprecated = object.deprecated ?? false;
    return message;
  },
};

function createBaseRecipientKeyRecord(): RecipientKeyRecord {
  return {
    address: "",
    publicKey: new Uint8Array(0),
    keyFingerprint: "",
    algorithmId: "",
    registeredAt: Long.ZERO,
    revokedAt: Long.ZERO,
    label: "",
  };
}

export const RecipientKeyRecord: MessageFns<RecipientKeyRecord, "virtengine.encryption.v1.RecipientKeyRecord"> = {
  $type: "virtengine.encryption.v1.RecipientKeyRecord" as const,

  encode(message: RecipientKeyRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.keyFingerprint !== "") {
      writer.uint32(26).string(message.keyFingerprint);
    }
    if (message.algorithmId !== "") {
      writer.uint32(34).string(message.algorithmId);
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.registeredAt.toString());
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.revokedAt.toString());
    }
    if (message.label !== "") {
      writer.uint32(58).string(message.label);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RecipientKeyRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecipientKeyRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.keyFingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.algorithmId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.label = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RecipientKeyRecord {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      publicKey: isSet(object.public_key) ? bytesFromBase64(object.public_key) : new Uint8Array(0),
      keyFingerprint: isSet(object.key_fingerprint) ? globalThis.String(object.key_fingerprint) : "",
      algorithmId: isSet(object.algorithm_id) ? globalThis.String(object.algorithm_id) : "",
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
      label: isSet(object.label) ? globalThis.String(object.label) : "",
    };
  },

  toJSON(message: RecipientKeyRecord): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.publicKey.length !== 0) {
      obj.public_key = base64FromBytes(message.publicKey);
    }
    if (message.keyFingerprint !== "") {
      obj.key_fingerprint = message.keyFingerprint;
    }
    if (message.algorithmId !== "") {
      obj.algorithm_id = message.algorithmId;
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<RecipientKeyRecord>): RecipientKeyRecord {
    const message = createBaseRecipientKeyRecord();
    message.address = object.address ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.keyFingerprint = object.keyFingerprint ?? "";
    message.algorithmId = object.algorithmId ?? "";
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    message.label = object.label ?? "";
    return message;
  },
};

function createBaseWrappedKeyEntry(): WrappedKeyEntry {
  return { recipientId: "", wrappedKey: new Uint8Array(0), algorithm: "", ephemeralPubKey: new Uint8Array(0) };
}

export const WrappedKeyEntry: MessageFns<WrappedKeyEntry, "virtengine.encryption.v1.WrappedKeyEntry"> = {
  $type: "virtengine.encryption.v1.WrappedKeyEntry" as const,

  encode(message: WrappedKeyEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recipientId !== "") {
      writer.uint32(10).string(message.recipientId);
    }
    if (message.wrappedKey.length !== 0) {
      writer.uint32(18).bytes(message.wrappedKey);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.ephemeralPubKey.length !== 0) {
      writer.uint32(34).bytes(message.ephemeralPubKey);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WrappedKeyEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWrappedKeyEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recipientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.wrappedKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ephemeralPubKey = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WrappedKeyEntry {
    return {
      recipientId: isSet(object.recipient_id) ? globalThis.String(object.recipient_id) : "",
      wrappedKey: isSet(object.wrapped_key) ? bytesFromBase64(object.wrapped_key) : new Uint8Array(0),
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      ephemeralPubKey: isSet(object.ephemeral_pub_key) ? bytesFromBase64(object.ephemeral_pub_key) : new Uint8Array(0),
    };
  },

  toJSON(message: WrappedKeyEntry): unknown {
    const obj: any = {};
    if (message.recipientId !== "") {
      obj.recipient_id = message.recipientId;
    }
    if (message.wrappedKey.length !== 0) {
      obj.wrapped_key = base64FromBytes(message.wrappedKey);
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.ephemeralPubKey.length !== 0) {
      obj.ephemeral_pub_key = base64FromBytes(message.ephemeralPubKey);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<WrappedKeyEntry>): WrappedKeyEntry {
    const message = createBaseWrappedKeyEntry();
    message.recipientId = object.recipientId ?? "";
    message.wrappedKey = object.wrappedKey ?? new Uint8Array(0);
    message.algorithm = object.algorithm ?? "";
    message.ephemeralPubKey = object.ephemeralPubKey ?? new Uint8Array(0);
    return message;
  },
};

function createBaseEncryptedPayloadEnvelope(): EncryptedPayloadEnvelope {
  return {
    version: 0,
    algorithmId: "",
    algorithmVersion: 0,
    recipientKeyIds: [],
    recipientPublicKeys: [],
    encryptedKeys: [],
    wrappedKeys: [],
    nonce: new Uint8Array(0),
    ciphertext: new Uint8Array(0),
    senderSignature: new Uint8Array(0),
    senderPubKey: new Uint8Array(0),
    metadata: {},
  };
}

export const EncryptedPayloadEnvelope: MessageFns<
  EncryptedPayloadEnvelope,
  "virtengine.encryption.v1.EncryptedPayloadEnvelope"
> = {
  $type: "virtengine.encryption.v1.EncryptedPayloadEnvelope" as const,

  encode(message: EncryptedPayloadEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.algorithmId !== "") {
      writer.uint32(18).string(message.algorithmId);
    }
    if (message.algorithmVersion !== 0) {
      writer.uint32(24).uint32(message.algorithmVersion);
    }
    for (const v of message.recipientKeyIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.recipientPublicKeys) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.encryptedKeys) {
      writer.uint32(50).bytes(v!);
    }
    for (const v of message.wrappedKeys) {
      WrappedKeyEntry.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.nonce.length !== 0) {
      writer.uint32(66).bytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(74).bytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      writer.uint32(82).bytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      writer.uint32(90).bytes(message.senderPubKey);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EncryptedPayloadEnvelope_MetadataEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedPayloadEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedPayloadEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithmId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.algorithmVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recipientKeyIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.recipientPublicKeys.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptedKeys.push(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.wrappedKeys.push(WrappedKeyEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.senderSignature = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.senderPubKey = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = EncryptedPayloadEnvelope_MetadataEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.metadata[entry12.key] = entry12.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedPayloadEnvelope {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      algorithmId: isSet(object.algorithm_id) ? globalThis.String(object.algorithm_id) : "",
      algorithmVersion: isSet(object.algorithm_version) ? globalThis.Number(object.algorithm_version) : 0,
      recipientKeyIds: globalThis.Array.isArray(object?.recipient_key_ids)
        ? object.recipient_key_ids.map((e: any) => globalThis.String(e))
        : [],
      recipientPublicKeys: globalThis.Array.isArray(object?.recipient_public_keys)
        ? object.recipient_public_keys.map((e: any) => bytesFromBase64(e))
        : [],
      encryptedKeys: globalThis.Array.isArray(object?.encrypted_keys)
        ? object.encrypted_keys.map((e: any) => bytesFromBase64(e))
        : [],
      wrappedKeys: globalThis.Array.isArray(object?.wrapped_keys)
        ? object.wrapped_keys.map((e: any) => WrappedKeyEntry.fromJSON(e))
        : [],
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      senderSignature: isSet(object.sender_signature) ? bytesFromBase64(object.sender_signature) : new Uint8Array(0),
      senderPubKey: isSet(object.sender_pub_key) ? bytesFromBase64(object.sender_pub_key) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EncryptedPayloadEnvelope): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.algorithmId !== "") {
      obj.algorithm_id = message.algorithmId;
    }
    if (message.algorithmVersion !== 0) {
      obj.algorithm_version = Math.round(message.algorithmVersion);
    }
    if (message.recipientKeyIds?.length) {
      obj.recipient_key_ids = message.recipientKeyIds;
    }
    if (message.recipientPublicKeys?.length) {
      obj.recipient_public_keys = message.recipientPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.encryptedKeys?.length) {
      obj.encrypted_keys = message.encryptedKeys.map((e) => base64FromBytes(e));
    }
    if (message.wrappedKeys?.length) {
      obj.wrapped_keys = message.wrappedKeys.map((e) => WrappedKeyEntry.toJSON(e));
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      obj.sender_signature = base64FromBytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      obj.sender_pub_key = base64FromBytes(message.senderPubKey);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EncryptedPayloadEnvelope>): EncryptedPayloadEnvelope {
    const message = createBaseEncryptedPayloadEnvelope();
    message.version = object.version ?? 0;
    message.algorithmId = object.algorithmId ?? "";
    message.algorithmVersion = object.algorithmVersion ?? 0;
    message.recipientKeyIds = object.recipientKeyIds?.map((e) => e) || [];
    message.recipientPublicKeys = object.recipientPublicKeys?.map((e) => e) || [];
    message.encryptedKeys = object.encryptedKeys?.map((e) => e) || [];
    message.wrappedKeys = object.wrappedKeys?.map((e) => WrappedKeyEntry.fromPartial(e)) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.senderSignature = object.senderSignature ?? new Uint8Array(0);
    message.senderPubKey = object.senderPubKey ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseEncryptedPayloadEnvelope_MetadataEntry(): EncryptedPayloadEnvelope_MetadataEntry {
  return { key: "", value: "" };
}

export const EncryptedPayloadEnvelope_MetadataEntry: MessageFns<
  EncryptedPayloadEnvelope_MetadataEntry,
  "virtengine.encryption.v1.EncryptedPayloadEnvelope.MetadataEntry"
> = {
  $type: "virtengine.encryption.v1.EncryptedPayloadEnvelope.MetadataEntry" as const,

  encode(message: EncryptedPayloadEnvelope_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedPayloadEnvelope_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedPayloadEnvelope_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedPayloadEnvelope_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EncryptedPayloadEnvelope_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EncryptedPayloadEnvelope_MetadataEntry>): EncryptedPayloadEnvelope_MetadataEntry {
    const message = createBaseEncryptedPayloadEnvelope_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMultiRecipientEnvelope(): MultiRecipientEnvelope {
  return {
    version: 0,
    algorithmId: "",
    algorithmVersion: 0,
    recipientMode: 0,
    payloadCiphertext: new Uint8Array(0),
    payloadNonce: new Uint8Array(0),
    wrappedKeys: [],
    clientSignature: new Uint8Array(0),
    clientId: "",
    userSignature: new Uint8Array(0),
    userPubKey: new Uint8Array(0),
    metadata: {},
    committeeEpoch: Long.UZERO,
  };
}

export const MultiRecipientEnvelope: MessageFns<
  MultiRecipientEnvelope,
  "virtengine.encryption.v1.MultiRecipientEnvelope"
> = {
  $type: "virtengine.encryption.v1.MultiRecipientEnvelope" as const,

  encode(message: MultiRecipientEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.algorithmId !== "") {
      writer.uint32(18).string(message.algorithmId);
    }
    if (message.algorithmVersion !== 0) {
      writer.uint32(24).uint32(message.algorithmVersion);
    }
    if (message.recipientMode !== 0) {
      writer.uint32(32).int32(message.recipientMode);
    }
    if (message.payloadCiphertext.length !== 0) {
      writer.uint32(42).bytes(message.payloadCiphertext);
    }
    if (message.payloadNonce.length !== 0) {
      writer.uint32(50).bytes(message.payloadNonce);
    }
    for (const v of message.wrappedKeys) {
      WrappedKeyEntry.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(66).bytes(message.clientSignature);
    }
    if (message.clientId !== "") {
      writer.uint32(74).string(message.clientId);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(82).bytes(message.userSignature);
    }
    if (message.userPubKey.length !== 0) {
      writer.uint32(90).bytes(message.userPubKey);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      MultiRecipientEnvelope_MetadataEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (!message.committeeEpoch.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.committeeEpoch.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiRecipientEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiRecipientEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithmId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.algorithmVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.recipientMode = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payloadCiphertext = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.payloadNonce = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.wrappedKeys.push(WrappedKeyEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.userPubKey = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = MultiRecipientEnvelope_MetadataEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.metadata[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.committeeEpoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiRecipientEnvelope {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      algorithmId: isSet(object.algorithm_id) ? globalThis.String(object.algorithm_id) : "",
      algorithmVersion: isSet(object.algorithm_version) ? globalThis.Number(object.algorithm_version) : 0,
      recipientMode: isSet(object.recipient_mode) ? recipientModeFromJSON(object.recipient_mode) : 0,
      payloadCiphertext: isSet(object.payload_ciphertext)
        ? bytesFromBase64(object.payload_ciphertext)
        : new Uint8Array(0),
      payloadNonce: isSet(object.payload_nonce) ? bytesFromBase64(object.payload_nonce) : new Uint8Array(0),
      wrappedKeys: globalThis.Array.isArray(object?.wrapped_keys)
        ? object.wrapped_keys.map((e: any) => WrappedKeyEntry.fromJSON(e))
        : [],
      clientSignature: isSet(object.client_signature) ? bytesFromBase64(object.client_signature) : new Uint8Array(0),
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
      userPubKey: isSet(object.user_pub_key) ? bytesFromBase64(object.user_pub_key) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      committeeEpoch: isSet(object.committee_epoch) ? Long.fromValue(object.committee_epoch) : Long.UZERO,
    };
  },

  toJSON(message: MultiRecipientEnvelope): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.algorithmId !== "") {
      obj.algorithm_id = message.algorithmId;
    }
    if (message.algorithmVersion !== 0) {
      obj.algorithm_version = Math.round(message.algorithmVersion);
    }
    if (message.recipientMode !== 0) {
      obj.recipient_mode = recipientModeToJSON(message.recipientMode);
    }
    if (message.payloadCiphertext.length !== 0) {
      obj.payload_ciphertext = base64FromBytes(message.payloadCiphertext);
    }
    if (message.payloadNonce.length !== 0) {
      obj.payload_nonce = base64FromBytes(message.payloadNonce);
    }
    if (message.wrappedKeys?.length) {
      obj.wrapped_keys = message.wrappedKeys.map((e) => WrappedKeyEntry.toJSON(e));
    }
    if (message.clientSignature.length !== 0) {
      obj.client_signature = base64FromBytes(message.clientSignature);
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    if (message.userPubKey.length !== 0) {
      obj.user_pub_key = base64FromBytes(message.userPubKey);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (!message.committeeEpoch.equals(Long.UZERO)) {
      obj.committee_epoch = (message.committeeEpoch || Long.UZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MultiRecipientEnvelope>): MultiRecipientEnvelope {
    const message = createBaseMultiRecipientEnvelope();
    message.version = object.version ?? 0;
    message.algorithmId = object.algorithmId ?? "";
    message.algorithmVersion = object.algorithmVersion ?? 0;
    message.recipientMode = object.recipientMode ?? 0;
    message.payloadCiphertext = object.payloadCiphertext ?? new Uint8Array(0);
    message.payloadNonce = object.payloadNonce ?? new Uint8Array(0);
    message.wrappedKeys = object.wrappedKeys?.map((e) => WrappedKeyEntry.fromPartial(e)) || [];
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    message.clientId = object.clientId ?? "";
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.userPubKey = object.userPubKey ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.committeeEpoch = (object.committeeEpoch !== undefined && object.committeeEpoch !== null)
      ? Long.fromValue(object.committeeEpoch)
      : Long.UZERO;
    return message;
  },
};

function createBaseMultiRecipientEnvelope_MetadataEntry(): MultiRecipientEnvelope_MetadataEntry {
  return { key: "", value: "" };
}

export const MultiRecipientEnvelope_MetadataEntry: MessageFns<
  MultiRecipientEnvelope_MetadataEntry,
  "virtengine.encryption.v1.MultiRecipientEnvelope.MetadataEntry"
> = {
  $type: "virtengine.encryption.v1.MultiRecipientEnvelope.MetadataEntry" as const,

  encode(message: MultiRecipientEnvelope_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiRecipientEnvelope_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiRecipientEnvelope_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiRecipientEnvelope_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MultiRecipientEnvelope_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MultiRecipientEnvelope_MetadataEntry>): MultiRecipientEnvelope_MetadataEntry {
    const message = createBaseMultiRecipientEnvelope_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseParams(): Params {
  return { maxRecipientsPerEnvelope: 0, maxKeysPerAccount: 0, allowedAlgorithms: [], requireSignature: false };
}

export const Params: MessageFns<Params, "virtengine.encryption.v1.Params"> = {
  $type: "virtengine.encryption.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxRecipientsPerEnvelope !== 0) {
      writer.uint32(8).uint32(message.maxRecipientsPerEnvelope);
    }
    if (message.maxKeysPerAccount !== 0) {
      writer.uint32(16).uint32(message.maxKeysPerAccount);
    }
    for (const v of message.allowedAlgorithms) {
      writer.uint32(26).string(v!);
    }
    if (message.requireSignature !== false) {
      writer.uint32(32).bool(message.requireSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxRecipientsPerEnvelope = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxKeysPerAccount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowedAlgorithms.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requireSignature = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxRecipientsPerEnvelope: isSet(object.max_recipients_per_envelope)
        ? globalThis.Number(object.max_recipients_per_envelope)
        : 0,
      maxKeysPerAccount: isSet(object.max_keys_per_account) ? globalThis.Number(object.max_keys_per_account) : 0,
      allowedAlgorithms: globalThis.Array.isArray(object?.allowed_algorithms)
        ? object.allowed_algorithms.map((e: any) => globalThis.String(e))
        : [],
      requireSignature: isSet(object.require_signature) ? globalThis.Boolean(object.require_signature) : false,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.maxRecipientsPerEnvelope !== 0) {
      obj.max_recipients_per_envelope = Math.round(message.maxRecipientsPerEnvelope);
    }
    if (message.maxKeysPerAccount !== 0) {
      obj.max_keys_per_account = Math.round(message.maxKeysPerAccount);
    }
    if (message.allowedAlgorithms?.length) {
      obj.allowed_algorithms = message.allowedAlgorithms;
    }
    if (message.requireSignature !== false) {
      obj.require_signature = message.requireSignature;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.maxRecipientsPerEnvelope = object.maxRecipientsPerEnvelope ?? 0;
    message.maxKeysPerAccount = object.maxKeysPerAccount ?? 0;
    message.allowedAlgorithms = object.allowedAlgorithms?.map((e) => e) || [];
    message.requireSignature = object.requireSignature ?? false;
    return message;
  },
};

function createBaseEventKeyRegistered(): EventKeyRegistered {
  return { address: "", fingerprint: "", algorithm: "", label: "", registeredAt: Long.ZERO };
}

export const EventKeyRegistered: MessageFns<EventKeyRegistered, "virtengine.encryption.v1.EventKeyRegistered"> = {
  $type: "virtengine.encryption.v1.EventKeyRegistered" as const,

  encode(message: EventKeyRegistered, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    if (message.algorithm !== "") {
      writer.uint32(26).string(message.algorithm);
    }
    if (message.label !== "") {
      writer.uint32(34).string(message.label);
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.registeredAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventKeyRegistered {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventKeyRegistered();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.algorithm = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventKeyRegistered {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      algorithm: isSet(object.algorithm) ? globalThis.String(object.algorithm) : "",
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
    };
  },

  toJSON(message: EventKeyRegistered): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.algorithm !== "") {
      obj.algorithm = message.algorithm;
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventKeyRegistered>): EventKeyRegistered {
    const message = createBaseEventKeyRegistered();
    message.address = object.address ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.algorithm = object.algorithm ?? "";
    message.label = object.label ?? "";
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventKeyRevoked(): EventKeyRevoked {
  return { address: "", fingerprint: "", revokedBy: "", revokedAt: Long.ZERO };
}

export const EventKeyRevoked: MessageFns<EventKeyRevoked, "virtengine.encryption.v1.EventKeyRevoked"> = {
  $type: "virtengine.encryption.v1.EventKeyRevoked" as const,

  encode(message: EventKeyRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    if (message.revokedBy !== "") {
      writer.uint32(26).string(message.revokedBy);
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.revokedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventKeyRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventKeyRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.revokedBy = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventKeyRevoked {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      revokedBy: isSet(object.revoked_by) ? globalThis.String(object.revoked_by) : "",
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
    };
  },

  toJSON(message: EventKeyRevoked): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.revokedBy !== "") {
      obj.revoked_by = message.revokedBy;
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventKeyRevoked>): EventKeyRevoked {
    const message = createBaseEventKeyRevoked();
    message.address = object.address ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.revokedBy = object.revokedBy ?? "";
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventKeyUpdated(): EventKeyUpdated {
  return { address: "", fingerprint: "", field: "", oldValue: "", newValue: "" };
}

export const EventKeyUpdated: MessageFns<EventKeyUpdated, "virtengine.encryption.v1.EventKeyUpdated"> = {
  $type: "virtengine.encryption.v1.EventKeyUpdated" as const,

  encode(message: EventKeyUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    if (message.fingerprint !== "") {
      writer.uint32(18).string(message.fingerprint);
    }
    if (message.field !== "") {
      writer.uint32(26).string(message.field);
    }
    if (message.oldValue !== "") {
      writer.uint32(34).string(message.oldValue);
    }
    if (message.newValue !== "") {
      writer.uint32(42).string(message.newValue);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventKeyUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventKeyUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.field = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oldValue = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newValue = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventKeyUpdated {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      field: isSet(object.field) ? globalThis.String(object.field) : "",
      oldValue: isSet(object.old_value) ? globalThis.String(object.old_value) : "",
      newValue: isSet(object.new_value) ? globalThis.String(object.new_value) : "",
    };
  },

  toJSON(message: EventKeyUpdated): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.field !== "") {
      obj.field = message.field;
    }
    if (message.oldValue !== "") {
      obj.old_value = message.oldValue;
    }
    if (message.newValue !== "") {
      obj.new_value = message.newValue;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventKeyUpdated>): EventKeyUpdated {
    const message = createBaseEventKeyUpdated();
    message.address = object.address ?? "";
    message.fingerprint = object.fingerprint ?? "";
    message.field = object.field ?? "";
    message.oldValue = object.oldValue ?? "";
    message.newValue = object.newValue ?? "";
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
