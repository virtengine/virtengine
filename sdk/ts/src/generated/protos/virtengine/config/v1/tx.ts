import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/config/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** MsgRegisterApprovedClient registers a new approved client */
export interface MsgRegisterApprovedClient {
  authority: string;
  clientId: string;
  publicKey: string;
  name: string;
  description: string;
  versionConstraint: string;
  allowedScopes: string[];
}

/** MsgRegisterApprovedClientResponse is the response for MsgRegisterApprovedClient */
export interface MsgRegisterApprovedClientResponse {
}

/** MsgUpdateApprovedClient updates an approved client */
export interface MsgUpdateApprovedClient {
  authority: string;
  clientId: string;
  publicKey: string;
  versionConstraint: string;
  allowedScopes: string[];
}

/** MsgUpdateApprovedClientResponse is the response for MsgUpdateApprovedClient */
export interface MsgUpdateApprovedClientResponse {
}

/** MsgSuspendApprovedClient suspends an approved client */
export interface MsgSuspendApprovedClient {
  authority: string;
  clientId: string;
  reason: string;
}

/** MsgSuspendApprovedClientResponse is the response for MsgSuspendApprovedClient */
export interface MsgSuspendApprovedClientResponse {
}

/** MsgRevokeApprovedClient revokes an approved client */
export interface MsgRevokeApprovedClient {
  authority: string;
  clientId: string;
  reason: string;
}

/** MsgRevokeApprovedClientResponse is the response for MsgRevokeApprovedClient */
export interface MsgRevokeApprovedClientResponse {
}

/** MsgReactivateApprovedClient reactivates a suspended client */
export interface MsgReactivateApprovedClient {
  authority: string;
  clientId: string;
}

/** MsgReactivateApprovedClientResponse is the response for MsgReactivateApprovedClient */
export interface MsgReactivateApprovedClientResponse {
}

/** MsgUpdateParams updates module parameters */
export interface MsgUpdateParams {
  authority: string;
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

/** EventClientRegistered is emitted when a client is registered */
export interface EventClientRegistered {
  clientId: string;
  name: string;
  registeredAt: Long;
}

/** EventClientUpdated is emitted when a client is updated */
export interface EventClientUpdated {
  clientId: string;
  updatedAt: Long;
}

/** EventClientSuspended is emitted when a client is suspended */
export interface EventClientSuspended {
  clientId: string;
  reason: string;
  suspendedAt: Long;
}

/** EventClientRevoked is emitted when a client is revoked */
export interface EventClientRevoked {
  clientId: string;
  reason: string;
  revokedAt: Long;
}

/** EventClientReactivated is emitted when a client is reactivated */
export interface EventClientReactivated {
  clientId: string;
  reactivatedAt: Long;
}

/** EventSignatureVerified is emitted when a signature is verified */
export interface EventSignatureVerified {
  clientId: string;
  signer: string;
  verifiedAt: Long;
}

/** Params defines the parameters for the config module */
export interface Params {
  maxClients: Long;
  signatureValidityPeriod: Long;
  requireClientSignature: boolean;
}

/** GenesisState is the genesis state for the config module */
export interface GenesisState {
  params: Params | undefined;
  approvedClients: ApprovedClient[];
}

/** ApprovedClient represents an approved client */
export interface ApprovedClient {
  clientId: string;
  publicKey: string;
  name: string;
  description: string;
  versionConstraint: string;
  allowedScopes: string[];
  status: string;
  registeredAt: Long;
  updatedAt: Long;
}

function createBaseMsgRegisterApprovedClient(): MsgRegisterApprovedClient {
  return {
    authority: "",
    clientId: "",
    publicKey: "",
    name: "",
    description: "",
    versionConstraint: "",
    allowedScopes: [],
  };
}

export const MsgRegisterApprovedClient: MessageFns<
  MsgRegisterApprovedClient,
  "virtengine.config.v1.MsgRegisterApprovedClient"
> = {
  $type: "virtengine.config.v1.MsgRegisterApprovedClient" as const,

  encode(message: MsgRegisterApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    if (message.versionConstraint !== "") {
      writer.uint32(50).string(message.versionConstraint);
    }
    for (const v of message.allowedScopes) {
      writer.uint32(58).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.versionConstraint = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.allowedScopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterApprovedClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      publicKey: isSet(object.public_key) ? globalThis.String(object.public_key) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      versionConstraint: isSet(object.version_constraint) ? globalThis.String(object.version_constraint) : "",
      allowedScopes: globalThis.Array.isArray(object?.allowed_scopes)
        ? object.allowed_scopes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgRegisterApprovedClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.versionConstraint !== "") {
      obj.version_constraint = message.versionConstraint;
    }
    if (message.allowedScopes?.length) {
      obj.allowed_scopes = message.allowedScopes;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterApprovedClient>): MsgRegisterApprovedClient {
    const message = createBaseMsgRegisterApprovedClient();
    message.authority = object.authority ?? "";
    message.clientId = object.clientId ?? "";
    message.publicKey = object.publicKey ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.versionConstraint = object.versionConstraint ?? "";
    message.allowedScopes = object.allowedScopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgRegisterApprovedClientResponse(): MsgRegisterApprovedClientResponse {
  return {};
}

export const MsgRegisterApprovedClientResponse: MessageFns<
  MsgRegisterApprovedClientResponse,
  "virtengine.config.v1.MsgRegisterApprovedClientResponse"
> = {
  $type: "virtengine.config.v1.MsgRegisterApprovedClientResponse" as const,

  encode(_: MsgRegisterApprovedClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterApprovedClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterApprovedClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRegisterApprovedClientResponse {
    return {};
  },

  toJSON(_: MsgRegisterApprovedClientResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgRegisterApprovedClientResponse>): MsgRegisterApprovedClientResponse {
    const message = createBaseMsgRegisterApprovedClientResponse();
    return message;
  },
};

function createBaseMsgUpdateApprovedClient(): MsgUpdateApprovedClient {
  return { authority: "", clientId: "", publicKey: "", versionConstraint: "", allowedScopes: [] };
}

export const MsgUpdateApprovedClient: MessageFns<
  MsgUpdateApprovedClient,
  "virtengine.config.v1.MsgUpdateApprovedClient"
> = {
  $type: "virtengine.config.v1.MsgUpdateApprovedClient" as const,

  encode(message: MsgUpdateApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.publicKey !== "") {
      writer.uint32(26).string(message.publicKey);
    }
    if (message.versionConstraint !== "") {
      writer.uint32(34).string(message.versionConstraint);
    }
    for (const v of message.allowedScopes) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.versionConstraint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.allowedScopes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateApprovedClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      publicKey: isSet(object.public_key) ? globalThis.String(object.public_key) : "",
      versionConstraint: isSet(object.version_constraint) ? globalThis.String(object.version_constraint) : "",
      allowedScopes: globalThis.Array.isArray(object?.allowed_scopes)
        ? object.allowed_scopes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgUpdateApprovedClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.versionConstraint !== "") {
      obj.version_constraint = message.versionConstraint;
    }
    if (message.allowedScopes?.length) {
      obj.allowed_scopes = message.allowedScopes;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateApprovedClient>): MsgUpdateApprovedClient {
    const message = createBaseMsgUpdateApprovedClient();
    message.authority = object.authority ?? "";
    message.clientId = object.clientId ?? "";
    message.publicKey = object.publicKey ?? "";
    message.versionConstraint = object.versionConstraint ?? "";
    message.allowedScopes = object.allowedScopes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgUpdateApprovedClientResponse(): MsgUpdateApprovedClientResponse {
  return {};
}

export const MsgUpdateApprovedClientResponse: MessageFns<
  MsgUpdateApprovedClientResponse,
  "virtengine.config.v1.MsgUpdateApprovedClientResponse"
> = {
  $type: "virtengine.config.v1.MsgUpdateApprovedClientResponse" as const,

  encode(_: MsgUpdateApprovedClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateApprovedClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateApprovedClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateApprovedClientResponse {
    return {};
  },

  toJSON(_: MsgUpdateApprovedClientResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateApprovedClientResponse>): MsgUpdateApprovedClientResponse {
    const message = createBaseMsgUpdateApprovedClientResponse();
    return message;
  },
};

function createBaseMsgSuspendApprovedClient(): MsgSuspendApprovedClient {
  return { authority: "", clientId: "", reason: "" };
}

export const MsgSuspendApprovedClient: MessageFns<
  MsgSuspendApprovedClient,
  "virtengine.config.v1.MsgSuspendApprovedClient"
> = {
  $type: "virtengine.config.v1.MsgSuspendApprovedClient" as const,

  encode(message: MsgSuspendApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSuspendApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSuspendApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSuspendApprovedClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgSuspendApprovedClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSuspendApprovedClient>): MsgSuspendApprovedClient {
    const message = createBaseMsgSuspendApprovedClient();
    message.authority = object.authority ?? "";
    message.clientId = object.clientId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgSuspendApprovedClientResponse(): MsgSuspendApprovedClientResponse {
  return {};
}

export const MsgSuspendApprovedClientResponse: MessageFns<
  MsgSuspendApprovedClientResponse,
  "virtengine.config.v1.MsgSuspendApprovedClientResponse"
> = {
  $type: "virtengine.config.v1.MsgSuspendApprovedClientResponse" as const,

  encode(_: MsgSuspendApprovedClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSuspendApprovedClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSuspendApprovedClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSuspendApprovedClientResponse {
    return {};
  },

  toJSON(_: MsgSuspendApprovedClientResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgSuspendApprovedClientResponse>): MsgSuspendApprovedClientResponse {
    const message = createBaseMsgSuspendApprovedClientResponse();
    return message;
  },
};

function createBaseMsgRevokeApprovedClient(): MsgRevokeApprovedClient {
  return { authority: "", clientId: "", reason: "" };
}

export const MsgRevokeApprovedClient: MessageFns<
  MsgRevokeApprovedClient,
  "virtengine.config.v1.MsgRevokeApprovedClient"
> = {
  $type: "virtengine.config.v1.MsgRevokeApprovedClient" as const,

  encode(message: MsgRevokeApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeApprovedClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgRevokeApprovedClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeApprovedClient>): MsgRevokeApprovedClient {
    const message = createBaseMsgRevokeApprovedClient();
    message.authority = object.authority ?? "";
    message.clientId = object.clientId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgRevokeApprovedClientResponse(): MsgRevokeApprovedClientResponse {
  return {};
}

export const MsgRevokeApprovedClientResponse: MessageFns<
  MsgRevokeApprovedClientResponse,
  "virtengine.config.v1.MsgRevokeApprovedClientResponse"
> = {
  $type: "virtengine.config.v1.MsgRevokeApprovedClientResponse" as const,

  encode(_: MsgRevokeApprovedClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeApprovedClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeApprovedClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeApprovedClientResponse {
    return {};
  },

  toJSON(_: MsgRevokeApprovedClientResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgRevokeApprovedClientResponse>): MsgRevokeApprovedClientResponse {
    const message = createBaseMsgRevokeApprovedClientResponse();
    return message;
  },
};

function createBaseMsgReactivateApprovedClient(): MsgReactivateApprovedClient {
  return { authority: "", clientId: "" };
}

export const MsgReactivateApprovedClient: MessageFns<
  MsgReactivateApprovedClient,
  "virtengine.config.v1.MsgReactivateApprovedClient"
> = {
  $type: "virtengine.config.v1.MsgReactivateApprovedClient" as const,

  encode(message: MsgReactivateApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.clientId !== "") {
      writer.uint32(18).string(message.clientId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReactivateApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReactivateApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReactivateApprovedClient {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
    };
  },

  toJSON(message: MsgReactivateApprovedClient): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgReactivateApprovedClient>): MsgReactivateApprovedClient {
    const message = createBaseMsgReactivateApprovedClient();
    message.authority = object.authority ?? "";
    message.clientId = object.clientId ?? "";
    return message;
  },
};

function createBaseMsgReactivateApprovedClientResponse(): MsgReactivateApprovedClientResponse {
  return {};
}

export const MsgReactivateApprovedClientResponse: MessageFns<
  MsgReactivateApprovedClientResponse,
  "virtengine.config.v1.MsgReactivateApprovedClientResponse"
> = {
  $type: "virtengine.config.v1.MsgReactivateApprovedClientResponse" as const,

  encode(_: MsgReactivateApprovedClientResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReactivateApprovedClientResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReactivateApprovedClientResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgReactivateApprovedClientResponse {
    return {};
  },

  toJSON(_: MsgReactivateApprovedClientResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgReactivateApprovedClientResponse>): MsgReactivateApprovedClientResponse {
    const message = createBaseMsgReactivateApprovedClientResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams, "virtengine.config.v1.MsgUpdateParams"> = {
  $type: "virtengine.config.v1.MsgUpdateParams" as const,

  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<
  MsgUpdateParamsResponse,
  "virtengine.config.v1.MsgUpdateParamsResponse"
> = {
  $type: "virtengine.config.v1.MsgUpdateParamsResponse" as const,

  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseEventClientRegistered(): EventClientRegistered {
  return { clientId: "", name: "", registeredAt: Long.ZERO };
}

export const EventClientRegistered: MessageFns<EventClientRegistered, "virtengine.config.v1.EventClientRegistered"> = {
  $type: "virtengine.config.v1.EventClientRegistered" as const,

  encode(message: EventClientRegistered, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.registeredAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventClientRegistered {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventClientRegistered();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventClientRegistered {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
    };
  },

  toJSON(message: EventClientRegistered): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventClientRegistered>): EventClientRegistered {
    const message = createBaseEventClientRegistered();
    message.clientId = object.clientId ?? "";
    message.name = object.name ?? "";
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventClientUpdated(): EventClientUpdated {
  return { clientId: "", updatedAt: Long.ZERO };
}

export const EventClientUpdated: MessageFns<EventClientUpdated, "virtengine.config.v1.EventClientUpdated"> = {
  $type: "virtengine.config.v1.EventClientUpdated" as const,

  encode(message: EventClientUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventClientUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventClientUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventClientUpdated {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
    };
  },

  toJSON(message: EventClientUpdated): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventClientUpdated>): EventClientUpdated {
    const message = createBaseEventClientUpdated();
    message.clientId = object.clientId ?? "";
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventClientSuspended(): EventClientSuspended {
  return { clientId: "", reason: "", suspendedAt: Long.ZERO };
}

export const EventClientSuspended: MessageFns<EventClientSuspended, "virtengine.config.v1.EventClientSuspended"> = {
  $type: "virtengine.config.v1.EventClientSuspended" as const,

  encode(message: EventClientSuspended, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (!message.suspendedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.suspendedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventClientSuspended {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventClientSuspended();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.suspendedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventClientSuspended {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      suspendedAt: isSet(object.suspended_at) ? Long.fromValue(object.suspended_at) : Long.ZERO,
    };
  },

  toJSON(message: EventClientSuspended): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (!message.suspendedAt.equals(Long.ZERO)) {
      obj.suspended_at = (message.suspendedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventClientSuspended>): EventClientSuspended {
    const message = createBaseEventClientSuspended();
    message.clientId = object.clientId ?? "";
    message.reason = object.reason ?? "";
    message.suspendedAt = (object.suspendedAt !== undefined && object.suspendedAt !== null)
      ? Long.fromValue(object.suspendedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventClientRevoked(): EventClientRevoked {
  return { clientId: "", reason: "", revokedAt: Long.ZERO };
}

export const EventClientRevoked: MessageFns<EventClientRevoked, "virtengine.config.v1.EventClientRevoked"> = {
  $type: "virtengine.config.v1.EventClientRevoked" as const,

  encode(message: EventClientRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.revokedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventClientRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventClientRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventClientRevoked {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
    };
  },

  toJSON(message: EventClientRevoked): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventClientRevoked>): EventClientRevoked {
    const message = createBaseEventClientRevoked();
    message.clientId = object.clientId ?? "";
    message.reason = object.reason ?? "";
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventClientReactivated(): EventClientReactivated {
  return { clientId: "", reactivatedAt: Long.ZERO };
}

export const EventClientReactivated: MessageFns<EventClientReactivated, "virtengine.config.v1.EventClientReactivated"> =
  {
    $type: "virtengine.config.v1.EventClientReactivated" as const,

    encode(message: EventClientReactivated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.clientId !== "") {
        writer.uint32(10).string(message.clientId);
      }
      if (!message.reactivatedAt.equals(Long.ZERO)) {
        writer.uint32(16).int64(message.reactivatedAt.toString());
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventClientReactivated {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventClientReactivated();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.clientId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 16) {
              break;
            }

            message.reactivatedAt = Long.fromString(reader.int64().toString());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventClientReactivated {
      return {
        clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
        reactivatedAt: isSet(object.reactivated_at) ? Long.fromValue(object.reactivated_at) : Long.ZERO,
      };
    },

    toJSON(message: EventClientReactivated): unknown {
      const obj: any = {};
      if (message.clientId !== "") {
        obj.client_id = message.clientId;
      }
      if (!message.reactivatedAt.equals(Long.ZERO)) {
        obj.reactivated_at = (message.reactivatedAt || Long.ZERO).toString();
      }
      return obj;
    },
    fromPartial(object: DeepPartial<EventClientReactivated>): EventClientReactivated {
      const message = createBaseEventClientReactivated();
      message.clientId = object.clientId ?? "";
      message.reactivatedAt = (object.reactivatedAt !== undefined && object.reactivatedAt !== null)
        ? Long.fromValue(object.reactivatedAt)
        : Long.ZERO;
      return message;
    },
  };

function createBaseEventSignatureVerified(): EventSignatureVerified {
  return { clientId: "", signer: "", verifiedAt: Long.ZERO };
}

export const EventSignatureVerified: MessageFns<EventSignatureVerified, "virtengine.config.v1.EventSignatureVerified"> =
  {
    $type: "virtengine.config.v1.EventSignatureVerified" as const,

    encode(message: EventSignatureVerified, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      if (message.clientId !== "") {
        writer.uint32(10).string(message.clientId);
      }
      if (message.signer !== "") {
        writer.uint32(18).string(message.signer);
      }
      if (!message.verifiedAt.equals(Long.ZERO)) {
        writer.uint32(24).int64(message.verifiedAt.toString());
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventSignatureVerified {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseEventSignatureVerified();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.clientId = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.signer = reader.string();
            continue;
          }
          case 3: {
            if (tag !== 24) {
              break;
            }

            message.verifiedAt = Long.fromString(reader.int64().toString());
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): EventSignatureVerified {
      return {
        clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
        signer: isSet(object.signer) ? globalThis.String(object.signer) : "",
        verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      };
    },

    toJSON(message: EventSignatureVerified): unknown {
      const obj: any = {};
      if (message.clientId !== "") {
        obj.client_id = message.clientId;
      }
      if (message.signer !== "") {
        obj.signer = message.signer;
      }
      if (!message.verifiedAt.equals(Long.ZERO)) {
        obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
      }
      return obj;
    },
    fromPartial(object: DeepPartial<EventSignatureVerified>): EventSignatureVerified {
      const message = createBaseEventSignatureVerified();
      message.clientId = object.clientId ?? "";
      message.signer = object.signer ?? "";
      message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
        ? Long.fromValue(object.verifiedAt)
        : Long.ZERO;
      return message;
    },
  };

function createBaseParams(): Params {
  return { maxClients: Long.UZERO, signatureValidityPeriod: Long.UZERO, requireClientSignature: false };
}

export const Params: MessageFns<Params, "virtengine.config.v1.Params"> = {
  $type: "virtengine.config.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.maxClients.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.maxClients.toString());
    }
    if (!message.signatureValidityPeriod.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.signatureValidityPeriod.toString());
    }
    if (message.requireClientSignature !== false) {
      writer.uint32(24).bool(message.requireClientSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxClients = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.signatureValidityPeriod = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requireClientSignature = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxClients: isSet(object.max_clients) ? Long.fromValue(object.max_clients) : Long.UZERO,
      signatureValidityPeriod: isSet(object.signature_validity_period)
        ? Long.fromValue(object.signature_validity_period)
        : Long.UZERO,
      requireClientSignature: isSet(object.require_client_signature)
        ? globalThis.Boolean(object.require_client_signature)
        : false,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (!message.maxClients.equals(Long.UZERO)) {
      obj.max_clients = (message.maxClients || Long.UZERO).toString();
    }
    if (!message.signatureValidityPeriod.equals(Long.UZERO)) {
      obj.signature_validity_period = (message.signatureValidityPeriod || Long.UZERO).toString();
    }
    if (message.requireClientSignature !== false) {
      obj.require_client_signature = message.requireClientSignature;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.maxClients = (object.maxClients !== undefined && object.maxClients !== null)
      ? Long.fromValue(object.maxClients)
      : Long.UZERO;
    message.signatureValidityPeriod =
      (object.signatureValidityPeriod !== undefined && object.signatureValidityPeriod !== null)
        ? Long.fromValue(object.signatureValidityPeriod)
        : Long.UZERO;
    message.requireClientSignature = object.requireClientSignature ?? false;
    return message;
  },
};

function createBaseGenesisState(): GenesisState {
  return { params: undefined, approvedClients: [] };
}

export const GenesisState: MessageFns<GenesisState, "virtengine.config.v1.GenesisState"> = {
  $type: "virtengine.config.v1.GenesisState" as const,

  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    for (const v of message.approvedClients) {
      ApprovedClient.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.approvedClients.push(ApprovedClient.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      approvedClients: globalThis.Array.isArray(object?.approved_clients)
        ? object.approved_clients.map((e: any) => ApprovedClient.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.approvedClients?.length) {
      obj.approved_clients = message.approvedClients.map((e) => ApprovedClient.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<GenesisState>): GenesisState {
    const message = createBaseGenesisState();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.approvedClients = object.approvedClients?.map((e) => ApprovedClient.fromPartial(e)) || [];
    return message;
  },
};

function createBaseApprovedClient(): ApprovedClient {
  return {
    clientId: "",
    publicKey: "",
    name: "",
    description: "",
    versionConstraint: "",
    allowedScopes: [],
    status: "",
    registeredAt: Long.ZERO,
    updatedAt: Long.ZERO,
  };
}

export const ApprovedClient: MessageFns<ApprovedClient, "virtengine.config.v1.ApprovedClient"> = {
  $type: "virtengine.config.v1.ApprovedClient" as const,

  encode(message: ApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.publicKey !== "") {
      writer.uint32(18).string(message.publicKey);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.versionConstraint !== "") {
      writer.uint32(42).string(message.versionConstraint);
    }
    for (const v of message.allowedScopes) {
      writer.uint32(50).string(v!);
    }
    if (message.status !== "") {
      writer.uint32(58).string(message.status);
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.registeredAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.versionConstraint = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allowedScopes.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovedClient {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      publicKey: isSet(object.public_key) ? globalThis.String(object.public_key) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      versionConstraint: isSet(object.version_constraint) ? globalThis.String(object.version_constraint) : "",
      allowedScopes: globalThis.Array.isArray(object?.allowed_scopes)
        ? object.allowed_scopes.map((e: any) => globalThis.String(e))
        : [],
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
    };
  },

  toJSON(message: ApprovedClient): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.publicKey !== "") {
      obj.public_key = message.publicKey;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.versionConstraint !== "") {
      obj.version_constraint = message.versionConstraint;
    }
    if (message.allowedScopes?.length) {
      obj.allowed_scopes = message.allowedScopes;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ApprovedClient>): ApprovedClient {
    const message = createBaseApprovedClient();
    message.clientId = object.clientId ?? "";
    message.publicKey = object.publicKey ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.versionConstraint = object.versionConstraint ?? "";
    message.allowedScopes = object.allowedScopes?.map((e) => e) || [];
    message.status = object.status ?? "";
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
