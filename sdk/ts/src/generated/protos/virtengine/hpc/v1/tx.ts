import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/hpc/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin.ts";
import {
  ClusterMetadata,
  ClusterState,
  clusterStateFromJSON,
  clusterStateToJSON,
  DataReference,
  DisputeStatus,
  disputeStatusFromJSON,
  disputeStatusToJSON,
  HPCPricing,
  HPCUsageMetrics,
  JobResources,
  JobState,
  jobStateFromJSON,
  jobStateToJSON,
  JobWorkloadSpec,
  LatencyMeasurement,
  NodeResources,
  Params,
  Partition,
  PreconfiguredWorkload,
  QueueOption,
} from "./types.ts";

/** MsgRegisterCluster registers a new HPC cluster */
export interface MsgRegisterCluster {
  providerAddress: string;
  name: string;
  description: string;
  region: string;
  partitions: Partition[];
  totalNodes: number;
  clusterMetadata: ClusterMetadata | undefined;
  slurmVersion: string;
}

/** MsgRegisterClusterResponse is the response for MsgRegisterCluster */
export interface MsgRegisterClusterResponse {
  clusterId: string;
}

/** MsgUpdateCluster updates an existing HPC cluster */
export interface MsgUpdateCluster {
  providerAddress: string;
  clusterId: string;
  name: string;
  description: string;
  state: ClusterState;
  partitions: Partition[];
  totalNodes: number;
  availableNodes: number;
  clusterMetadata: ClusterMetadata | undefined;
}

/** MsgUpdateClusterResponse is the response for MsgUpdateCluster */
export interface MsgUpdateClusterResponse {
}

/** MsgDeregisterCluster deregisters an HPC cluster */
export interface MsgDeregisterCluster {
  providerAddress: string;
  clusterId: string;
}

/** MsgDeregisterClusterResponse is the response for MsgDeregisterCluster */
export interface MsgDeregisterClusterResponse {
}

/** MsgCreateOffering creates a new HPC offering */
export interface MsgCreateOffering {
  providerAddress: string;
  clusterId: string;
  name: string;
  description: string;
  queueOptions: QueueOption[];
  pricing: HPCPricing | undefined;
  requiredIdentityThreshold: number;
  maxRuntimeSeconds: Long;
  preconfiguredWorkloads: PreconfiguredWorkload[];
  supportsCustomWorkloads: boolean;
}

/** MsgCreateOfferingResponse is the response for MsgCreateOffering */
export interface MsgCreateOfferingResponse {
  offeringId: string;
}

/** MsgUpdateOffering updates an existing HPC offering */
export interface MsgUpdateOffering {
  providerAddress: string;
  offeringId: string;
  name: string;
  description: string;
  queueOptions: QueueOption[];
  pricing: HPCPricing | undefined;
  requiredIdentityThreshold: number;
  maxRuntimeSeconds: Long;
  preconfiguredWorkloads: PreconfiguredWorkload[];
  supportsCustomWorkloads: boolean;
  active: boolean;
}

/** MsgUpdateOfferingResponse is the response for MsgUpdateOffering */
export interface MsgUpdateOfferingResponse {
}

/** MsgSubmitJob submits a new HPC job */
export interface MsgSubmitJob {
  customerAddress: string;
  offeringId: string;
  queueName: string;
  workloadSpec: JobWorkloadSpec | undefined;
  resources: JobResources | undefined;
  dataReferences: DataReference[];
  encryptedInputsPointer: string;
  encryptedOutputsPointer: string;
  maxRuntimeSeconds: Long;
  maxPrice: Coin[];
}

/** MsgSubmitJobResponse is the response for MsgSubmitJob */
export interface MsgSubmitJobResponse {
  jobId: string;
  escrowId: string;
}

/** MsgCancelJob cancels an HPC job */
export interface MsgCancelJob {
  requesterAddress: string;
  jobId: string;
  reason: string;
}

/** MsgCancelJobResponse is the response for MsgCancelJob */
export interface MsgCancelJobResponse {
}

/** MsgReportJobStatus reports job status from the provider daemon */
export interface MsgReportJobStatus {
  providerAddress: string;
  jobId: string;
  slurmJobId: string;
  state: JobState;
  statusMessage: string;
  exitCode: number;
  usageMetrics: HPCUsageMetrics | undefined;
  signature: string;
  signedTimestamp: Long;
}

/** MsgReportJobStatusResponse is the response for MsgReportJobStatus */
export interface MsgReportJobStatusResponse {
}

/** MsgUpdateNodeMetadata updates node metadata */
export interface MsgUpdateNodeMetadata {
  providerAddress: string;
  nodeId: string;
  clusterId: string;
  region: string;
  datacenter: string;
  latencyMeasurements: LatencyMeasurement[];
  networkBandwidthMbps: Long;
  resources: NodeResources | undefined;
  active: boolean;
}

/** MsgUpdateNodeMetadataResponse is the response for MsgUpdateNodeMetadata */
export interface MsgUpdateNodeMetadataResponse {
}

/** MsgFlagDispute flags a dispute for moderation */
export interface MsgFlagDispute {
  disputerAddress: string;
  jobId: string;
  rewardId: string;
  disputeType: string;
  reason: string;
  evidence: string;
}

/** MsgFlagDisputeResponse is the response for MsgFlagDispute */
export interface MsgFlagDisputeResponse {
  disputeId: string;
}

/** MsgResolveDispute resolves a dispute (moderator only) */
export interface MsgResolveDispute {
  resolverAddress: string;
  disputeId: string;
  status: DisputeStatus;
  resolution: string;
}

/** MsgResolveDisputeResponse is the response for MsgResolveDispute */
export interface MsgResolveDisputeResponse {
}

/** MsgUpdateParams updates module parameters (governance only) */
export interface MsgUpdateParams {
  authority: string;
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgRegisterCluster(): MsgRegisterCluster {
  return {
    providerAddress: "",
    name: "",
    description: "",
    region: "",
    partitions: [],
    totalNodes: 0,
    clusterMetadata: undefined,
    slurmVersion: "",
  };
}

export const MsgRegisterCluster: MessageFns<MsgRegisterCluster, "virtengine.hpc.v1.MsgRegisterCluster"> = {
  $type: "virtengine.hpc.v1.MsgRegisterCluster" as const,

  encode(message: MsgRegisterCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    for (const v of message.partitions) {
      Partition.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.totalNodes !== 0) {
      writer.uint32(48).int32(message.totalNodes);
    }
    if (message.clusterMetadata !== undefined) {
      ClusterMetadata.encode(message.clusterMetadata, writer.uint32(58).fork()).join();
    }
    if (message.slurmVersion !== "") {
      writer.uint32(66).string(message.slurmVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.partitions.push(Partition.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalNodes = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clusterMetadata = ClusterMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slurmVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterCluster {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => Partition.fromJSON(e))
        : [],
      totalNodes: isSet(object.total_nodes) ? globalThis.Number(object.total_nodes) : 0,
      clusterMetadata: isSet(object.cluster_metadata) ? ClusterMetadata.fromJSON(object.cluster_metadata) : undefined,
      slurmVersion: isSet(object.slurm_version) ? globalThis.String(object.slurm_version) : "",
    };
  },

  toJSON(message: MsgRegisterCluster): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => Partition.toJSON(e));
    }
    if (message.totalNodes !== 0) {
      obj.total_nodes = Math.round(message.totalNodes);
    }
    if (message.clusterMetadata !== undefined) {
      obj.cluster_metadata = ClusterMetadata.toJSON(message.clusterMetadata);
    }
    if (message.slurmVersion !== "") {
      obj.slurm_version = message.slurmVersion;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterCluster>): MsgRegisterCluster {
    const message = createBaseMsgRegisterCluster();
    message.providerAddress = object.providerAddress ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.region = object.region ?? "";
    message.partitions = object.partitions?.map((e) => Partition.fromPartial(e)) || [];
    message.totalNodes = object.totalNodes ?? 0;
    message.clusterMetadata = (object.clusterMetadata !== undefined && object.clusterMetadata !== null)
      ? ClusterMetadata.fromPartial(object.clusterMetadata)
      : undefined;
    message.slurmVersion = object.slurmVersion ?? "";
    return message;
  },
};

function createBaseMsgRegisterClusterResponse(): MsgRegisterClusterResponse {
  return { clusterId: "" };
}

export const MsgRegisterClusterResponse: MessageFns<
  MsgRegisterClusterResponse,
  "virtengine.hpc.v1.MsgRegisterClusterResponse"
> = {
  $type: "virtengine.hpc.v1.MsgRegisterClusterResponse" as const,

  encode(message: MsgRegisterClusterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterClusterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterClusterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterClusterResponse {
    return { clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "" };
  },

  toJSON(message: MsgRegisterClusterResponse): unknown {
    const obj: any = {};
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterClusterResponse>): MsgRegisterClusterResponse {
    const message = createBaseMsgRegisterClusterResponse();
    message.clusterId = object.clusterId ?? "";
    return message;
  },
};

function createBaseMsgUpdateCluster(): MsgUpdateCluster {
  return {
    providerAddress: "",
    clusterId: "",
    name: "",
    description: "",
    state: 0,
    partitions: [],
    totalNodes: 0,
    availableNodes: 0,
    clusterMetadata: undefined,
  };
}

export const MsgUpdateCluster: MessageFns<MsgUpdateCluster, "virtengine.hpc.v1.MsgUpdateCluster"> = {
  $type: "virtengine.hpc.v1.MsgUpdateCluster" as const,

  encode(message: MsgUpdateCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    for (const v of message.partitions) {
      Partition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.totalNodes !== 0) {
      writer.uint32(56).int32(message.totalNodes);
    }
    if (message.availableNodes !== 0) {
      writer.uint32(64).int32(message.availableNodes);
    }
    if (message.clusterMetadata !== undefined) {
      ClusterMetadata.encode(message.clusterMetadata, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.partitions.push(Partition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalNodes = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.availableNodes = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.clusterMetadata = ClusterMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateCluster {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? clusterStateFromJSON(object.state) : 0,
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => Partition.fromJSON(e))
        : [],
      totalNodes: isSet(object.total_nodes) ? globalThis.Number(object.total_nodes) : 0,
      availableNodes: isSet(object.available_nodes) ? globalThis.Number(object.available_nodes) : 0,
      clusterMetadata: isSet(object.cluster_metadata) ? ClusterMetadata.fromJSON(object.cluster_metadata) : undefined,
    };
  },

  toJSON(message: MsgUpdateCluster): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = clusterStateToJSON(message.state);
    }
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => Partition.toJSON(e));
    }
    if (message.totalNodes !== 0) {
      obj.total_nodes = Math.round(message.totalNodes);
    }
    if (message.availableNodes !== 0) {
      obj.available_nodes = Math.round(message.availableNodes);
    }
    if (message.clusterMetadata !== undefined) {
      obj.cluster_metadata = ClusterMetadata.toJSON(message.clusterMetadata);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateCluster>): MsgUpdateCluster {
    const message = createBaseMsgUpdateCluster();
    message.providerAddress = object.providerAddress ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.partitions = object.partitions?.map((e) => Partition.fromPartial(e)) || [];
    message.totalNodes = object.totalNodes ?? 0;
    message.availableNodes = object.availableNodes ?? 0;
    message.clusterMetadata = (object.clusterMetadata !== undefined && object.clusterMetadata !== null)
      ? ClusterMetadata.fromPartial(object.clusterMetadata)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateClusterResponse(): MsgUpdateClusterResponse {
  return {};
}

export const MsgUpdateClusterResponse: MessageFns<
  MsgUpdateClusterResponse,
  "virtengine.hpc.v1.MsgUpdateClusterResponse"
> = {
  $type: "virtengine.hpc.v1.MsgUpdateClusterResponse" as const,

  encode(_: MsgUpdateClusterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateClusterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateClusterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateClusterResponse {
    return {};
  },

  toJSON(_: MsgUpdateClusterResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateClusterResponse>): MsgUpdateClusterResponse {
    const message = createBaseMsgUpdateClusterResponse();
    return message;
  },
};

function createBaseMsgDeregisterCluster(): MsgDeregisterCluster {
  return { providerAddress: "", clusterId: "" };
}

export const MsgDeregisterCluster: MessageFns<MsgDeregisterCluster, "virtengine.hpc.v1.MsgDeregisterCluster"> = {
  $type: "virtengine.hpc.v1.MsgDeregisterCluster" as const,

  encode(message: MsgDeregisterCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeregisterCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeregisterCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeregisterCluster {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
    };
  },

  toJSON(message: MsgDeregisterCluster): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgDeregisterCluster>): MsgDeregisterCluster {
    const message = createBaseMsgDeregisterCluster();
    message.providerAddress = object.providerAddress ?? "";
    message.clusterId = object.clusterId ?? "";
    return message;
  },
};

function createBaseMsgDeregisterClusterResponse(): MsgDeregisterClusterResponse {
  return {};
}

export const MsgDeregisterClusterResponse: MessageFns<
  MsgDeregisterClusterResponse,
  "virtengine.hpc.v1.MsgDeregisterClusterResponse"
> = {
  $type: "virtengine.hpc.v1.MsgDeregisterClusterResponse" as const,

  encode(_: MsgDeregisterClusterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeregisterClusterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeregisterClusterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeregisterClusterResponse {
    return {};
  },

  toJSON(_: MsgDeregisterClusterResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgDeregisterClusterResponse>): MsgDeregisterClusterResponse {
    const message = createBaseMsgDeregisterClusterResponse();
    return message;
  },
};

function createBaseMsgCreateOffering(): MsgCreateOffering {
  return {
    providerAddress: "",
    clusterId: "",
    name: "",
    description: "",
    queueOptions: [],
    pricing: undefined,
    requiredIdentityThreshold: 0,
    maxRuntimeSeconds: Long.ZERO,
    preconfiguredWorkloads: [],
    supportsCustomWorkloads: false,
  };
}

export const MsgCreateOffering: MessageFns<MsgCreateOffering, "virtengine.hpc.v1.MsgCreateOffering"> = {
  $type: "virtengine.hpc.v1.MsgCreateOffering" as const,

  encode(message: MsgCreateOffering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.queueOptions) {
      QueueOption.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.pricing !== undefined) {
      HPCPricing.encode(message.pricing, writer.uint32(50).fork()).join();
    }
    if (message.requiredIdentityThreshold !== 0) {
      writer.uint32(56).int32(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.maxRuntimeSeconds.toString());
    }
    for (const v of message.preconfiguredWorkloads) {
      PreconfiguredWorkload.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.supportsCustomWorkloads !== false) {
      writer.uint32(80).bool(message.supportsCustomWorkloads);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateOffering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOffering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queueOptions.push(QueueOption.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pricing = HPCPricing.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.requiredIdentityThreshold = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxRuntimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.preconfiguredWorkloads.push(PreconfiguredWorkload.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.supportsCustomWorkloads = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateOffering {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      queueOptions: globalThis.Array.isArray(object?.queue_options)
        ? object.queue_options.map((e: any) => QueueOption.fromJSON(e))
        : [],
      pricing: isSet(object.pricing) ? HPCPricing.fromJSON(object.pricing) : undefined,
      requiredIdentityThreshold: isSet(object.required_identity_threshold)
        ? globalThis.Number(object.required_identity_threshold)
        : 0,
      maxRuntimeSeconds: isSet(object.max_runtime_seconds) ? Long.fromValue(object.max_runtime_seconds) : Long.ZERO,
      preconfiguredWorkloads: globalThis.Array.isArray(object?.preconfigured_workloads)
        ? object.preconfigured_workloads.map((e: any) => PreconfiguredWorkload.fromJSON(e))
        : [],
      supportsCustomWorkloads: isSet(object.supports_custom_workloads)
        ? globalThis.Boolean(object.supports_custom_workloads)
        : false,
    };
  },

  toJSON(message: MsgCreateOffering): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.queueOptions?.length) {
      obj.queue_options = message.queueOptions.map((e) => QueueOption.toJSON(e));
    }
    if (message.pricing !== undefined) {
      obj.pricing = HPCPricing.toJSON(message.pricing);
    }
    if (message.requiredIdentityThreshold !== 0) {
      obj.required_identity_threshold = Math.round(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      obj.max_runtime_seconds = (message.maxRuntimeSeconds || Long.ZERO).toString();
    }
    if (message.preconfiguredWorkloads?.length) {
      obj.preconfigured_workloads = message.preconfiguredWorkloads.map((e) => PreconfiguredWorkload.toJSON(e));
    }
    if (message.supportsCustomWorkloads !== false) {
      obj.supports_custom_workloads = message.supportsCustomWorkloads;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCreateOffering>): MsgCreateOffering {
    const message = createBaseMsgCreateOffering();
    message.providerAddress = object.providerAddress ?? "";
    message.clusterId = object.clusterId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.queueOptions = object.queueOptions?.map((e) => QueueOption.fromPartial(e)) || [];
    message.pricing = (object.pricing !== undefined && object.pricing !== null)
      ? HPCPricing.fromPartial(object.pricing)
      : undefined;
    message.requiredIdentityThreshold = object.requiredIdentityThreshold ?? 0;
    message.maxRuntimeSeconds = (object.maxRuntimeSeconds !== undefined && object.maxRuntimeSeconds !== null)
      ? Long.fromValue(object.maxRuntimeSeconds)
      : Long.ZERO;
    message.preconfiguredWorkloads = object.preconfiguredWorkloads?.map((e) => PreconfiguredWorkload.fromPartial(e)) ||
      [];
    message.supportsCustomWorkloads = object.supportsCustomWorkloads ?? false;
    return message;
  },
};

function createBaseMsgCreateOfferingResponse(): MsgCreateOfferingResponse {
  return { offeringId: "" };
}

export const MsgCreateOfferingResponse: MessageFns<
  MsgCreateOfferingResponse,
  "virtengine.hpc.v1.MsgCreateOfferingResponse"
> = {
  $type: "virtengine.hpc.v1.MsgCreateOfferingResponse" as const,

  encode(message: MsgCreateOfferingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offeringId !== "") {
      writer.uint32(10).string(message.offeringId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateOfferingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateOfferingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offeringId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateOfferingResponse {
    return { offeringId: isSet(object.offering_id) ? globalThis.String(object.offering_id) : "" };
  },

  toJSON(message: MsgCreateOfferingResponse): unknown {
    const obj: any = {};
    if (message.offeringId !== "") {
      obj.offering_id = message.offeringId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCreateOfferingResponse>): MsgCreateOfferingResponse {
    const message = createBaseMsgCreateOfferingResponse();
    message.offeringId = object.offeringId ?? "";
    return message;
  },
};

function createBaseMsgUpdateOffering(): MsgUpdateOffering {
  return {
    providerAddress: "",
    offeringId: "",
    name: "",
    description: "",
    queueOptions: [],
    pricing: undefined,
    requiredIdentityThreshold: 0,
    maxRuntimeSeconds: Long.ZERO,
    preconfiguredWorkloads: [],
    supportsCustomWorkloads: false,
    active: false,
  };
}

export const MsgUpdateOffering: MessageFns<MsgUpdateOffering, "virtengine.hpc.v1.MsgUpdateOffering"> = {
  $type: "virtengine.hpc.v1.MsgUpdateOffering" as const,

  encode(message: MsgUpdateOffering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.offeringId !== "") {
      writer.uint32(18).string(message.offeringId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    for (const v of message.queueOptions) {
      QueueOption.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.pricing !== undefined) {
      HPCPricing.encode(message.pricing, writer.uint32(50).fork()).join();
    }
    if (message.requiredIdentityThreshold !== 0) {
      writer.uint32(56).int32(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.maxRuntimeSeconds.toString());
    }
    for (const v of message.preconfiguredWorkloads) {
      PreconfiguredWorkload.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.supportsCustomWorkloads !== false) {
      writer.uint32(80).bool(message.supportsCustomWorkloads);
    }
    if (message.active !== false) {
      writer.uint32(88).bool(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOffering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOffering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.offeringId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.queueOptions.push(QueueOption.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.pricing = HPCPricing.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.requiredIdentityThreshold = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxRuntimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.preconfiguredWorkloads.push(PreconfiguredWorkload.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.supportsCustomWorkloads = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateOffering {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      offeringId: isSet(object.offering_id) ? globalThis.String(object.offering_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      queueOptions: globalThis.Array.isArray(object?.queue_options)
        ? object.queue_options.map((e: any) => QueueOption.fromJSON(e))
        : [],
      pricing: isSet(object.pricing) ? HPCPricing.fromJSON(object.pricing) : undefined,
      requiredIdentityThreshold: isSet(object.required_identity_threshold)
        ? globalThis.Number(object.required_identity_threshold)
        : 0,
      maxRuntimeSeconds: isSet(object.max_runtime_seconds) ? Long.fromValue(object.max_runtime_seconds) : Long.ZERO,
      preconfiguredWorkloads: globalThis.Array.isArray(object?.preconfigured_workloads)
        ? object.preconfigured_workloads.map((e: any) => PreconfiguredWorkload.fromJSON(e))
        : [],
      supportsCustomWorkloads: isSet(object.supports_custom_workloads)
        ? globalThis.Boolean(object.supports_custom_workloads)
        : false,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: MsgUpdateOffering): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.offeringId !== "") {
      obj.offering_id = message.offeringId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.queueOptions?.length) {
      obj.queue_options = message.queueOptions.map((e) => QueueOption.toJSON(e));
    }
    if (message.pricing !== undefined) {
      obj.pricing = HPCPricing.toJSON(message.pricing);
    }
    if (message.requiredIdentityThreshold !== 0) {
      obj.required_identity_threshold = Math.round(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      obj.max_runtime_seconds = (message.maxRuntimeSeconds || Long.ZERO).toString();
    }
    if (message.preconfiguredWorkloads?.length) {
      obj.preconfigured_workloads = message.preconfiguredWorkloads.map((e) => PreconfiguredWorkload.toJSON(e));
    }
    if (message.supportsCustomWorkloads !== false) {
      obj.supports_custom_workloads = message.supportsCustomWorkloads;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateOffering>): MsgUpdateOffering {
    const message = createBaseMsgUpdateOffering();
    message.providerAddress = object.providerAddress ?? "";
    message.offeringId = object.offeringId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.queueOptions = object.queueOptions?.map((e) => QueueOption.fromPartial(e)) || [];
    message.pricing = (object.pricing !== undefined && object.pricing !== null)
      ? HPCPricing.fromPartial(object.pricing)
      : undefined;
    message.requiredIdentityThreshold = object.requiredIdentityThreshold ?? 0;
    message.maxRuntimeSeconds = (object.maxRuntimeSeconds !== undefined && object.maxRuntimeSeconds !== null)
      ? Long.fromValue(object.maxRuntimeSeconds)
      : Long.ZERO;
    message.preconfiguredWorkloads = object.preconfiguredWorkloads?.map((e) => PreconfiguredWorkload.fromPartial(e)) ||
      [];
    message.supportsCustomWorkloads = object.supportsCustomWorkloads ?? false;
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseMsgUpdateOfferingResponse(): MsgUpdateOfferingResponse {
  return {};
}

export const MsgUpdateOfferingResponse: MessageFns<
  MsgUpdateOfferingResponse,
  "virtengine.hpc.v1.MsgUpdateOfferingResponse"
> = {
  $type: "virtengine.hpc.v1.MsgUpdateOfferingResponse" as const,

  encode(_: MsgUpdateOfferingResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateOfferingResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateOfferingResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateOfferingResponse {
    return {};
  },

  toJSON(_: MsgUpdateOfferingResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateOfferingResponse>): MsgUpdateOfferingResponse {
    const message = createBaseMsgUpdateOfferingResponse();
    return message;
  },
};

function createBaseMsgSubmitJob(): MsgSubmitJob {
  return {
    customerAddress: "",
    offeringId: "",
    queueName: "",
    workloadSpec: undefined,
    resources: undefined,
    dataReferences: [],
    encryptedInputsPointer: "",
    encryptedOutputsPointer: "",
    maxRuntimeSeconds: Long.ZERO,
    maxPrice: [],
  };
}

export const MsgSubmitJob: MessageFns<MsgSubmitJob, "virtengine.hpc.v1.MsgSubmitJob"> = {
  $type: "virtengine.hpc.v1.MsgSubmitJob" as const,

  encode(message: MsgSubmitJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.customerAddress !== "") {
      writer.uint32(10).string(message.customerAddress);
    }
    if (message.offeringId !== "") {
      writer.uint32(18).string(message.offeringId);
    }
    if (message.queueName !== "") {
      writer.uint32(26).string(message.queueName);
    }
    if (message.workloadSpec !== undefined) {
      JobWorkloadSpec.encode(message.workloadSpec, writer.uint32(34).fork()).join();
    }
    if (message.resources !== undefined) {
      JobResources.encode(message.resources, writer.uint32(42).fork()).join();
    }
    for (const v of message.dataReferences) {
      DataReference.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.encryptedInputsPointer !== "") {
      writer.uint32(58).string(message.encryptedInputsPointer);
    }
    if (message.encryptedOutputsPointer !== "") {
      writer.uint32(66).string(message.encryptedOutputsPointer);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.maxRuntimeSeconds.toString());
    }
    for (const v of message.maxPrice) {
      Coin.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.customerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.offeringId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queueName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workloadSpec = JobWorkloadSpec.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.resources = JobResources.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.dataReferences.push(DataReference.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.encryptedInputsPointer = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.encryptedOutputsPointer = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxRuntimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.maxPrice.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitJob {
    return {
      customerAddress: isSet(object.customer_address) ? globalThis.String(object.customer_address) : "",
      offeringId: isSet(object.offering_id) ? globalThis.String(object.offering_id) : "",
      queueName: isSet(object.queue_name) ? globalThis.String(object.queue_name) : "",
      workloadSpec: isSet(object.workload_spec) ? JobWorkloadSpec.fromJSON(object.workload_spec) : undefined,
      resources: isSet(object.resources) ? JobResources.fromJSON(object.resources) : undefined,
      dataReferences: globalThis.Array.isArray(object?.data_references)
        ? object.data_references.map((e: any) => DataReference.fromJSON(e))
        : [],
      encryptedInputsPointer: isSet(object.encrypted_inputs_pointer)
        ? globalThis.String(object.encrypted_inputs_pointer)
        : "",
      encryptedOutputsPointer: isSet(object.encrypted_outputs_pointer)
        ? globalThis.String(object.encrypted_outputs_pointer)
        : "",
      maxRuntimeSeconds: isSet(object.max_runtime_seconds) ? Long.fromValue(object.max_runtime_seconds) : Long.ZERO,
      maxPrice: globalThis.Array.isArray(object?.max_price) ? object.max_price.map((e: any) => Coin.fromJSON(e)) : [],
    };
  },

  toJSON(message: MsgSubmitJob): unknown {
    const obj: any = {};
    if (message.customerAddress !== "") {
      obj.customer_address = message.customerAddress;
    }
    if (message.offeringId !== "") {
      obj.offering_id = message.offeringId;
    }
    if (message.queueName !== "") {
      obj.queue_name = message.queueName;
    }
    if (message.workloadSpec !== undefined) {
      obj.workload_spec = JobWorkloadSpec.toJSON(message.workloadSpec);
    }
    if (message.resources !== undefined) {
      obj.resources = JobResources.toJSON(message.resources);
    }
    if (message.dataReferences?.length) {
      obj.data_references = message.dataReferences.map((e) => DataReference.toJSON(e));
    }
    if (message.encryptedInputsPointer !== "") {
      obj.encrypted_inputs_pointer = message.encryptedInputsPointer;
    }
    if (message.encryptedOutputsPointer !== "") {
      obj.encrypted_outputs_pointer = message.encryptedOutputsPointer;
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      obj.max_runtime_seconds = (message.maxRuntimeSeconds || Long.ZERO).toString();
    }
    if (message.maxPrice?.length) {
      obj.max_price = message.maxPrice.map((e) => Coin.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitJob>): MsgSubmitJob {
    const message = createBaseMsgSubmitJob();
    message.customerAddress = object.customerAddress ?? "";
    message.offeringId = object.offeringId ?? "";
    message.queueName = object.queueName ?? "";
    message.workloadSpec = (object.workloadSpec !== undefined && object.workloadSpec !== null)
      ? JobWorkloadSpec.fromPartial(object.workloadSpec)
      : undefined;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? JobResources.fromPartial(object.resources)
      : undefined;
    message.dataReferences = object.dataReferences?.map((e) => DataReference.fromPartial(e)) || [];
    message.encryptedInputsPointer = object.encryptedInputsPointer ?? "";
    message.encryptedOutputsPointer = object.encryptedOutputsPointer ?? "";
    message.maxRuntimeSeconds = (object.maxRuntimeSeconds !== undefined && object.maxRuntimeSeconds !== null)
      ? Long.fromValue(object.maxRuntimeSeconds)
      : Long.ZERO;
    message.maxPrice = object.maxPrice?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMsgSubmitJobResponse(): MsgSubmitJobResponse {
  return { jobId: "", escrowId: "" };
}

export const MsgSubmitJobResponse: MessageFns<MsgSubmitJobResponse, "virtengine.hpc.v1.MsgSubmitJobResponse"> = {
  $type: "virtengine.hpc.v1.MsgSubmitJobResponse" as const,

  encode(message: MsgSubmitJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.escrowId !== "") {
      writer.uint32(18).string(message.escrowId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.escrowId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitJobResponse {
    return {
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      escrowId: isSet(object.escrow_id) ? globalThis.String(object.escrow_id) : "",
    };
  },

  toJSON(message: MsgSubmitJobResponse): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.escrowId !== "") {
      obj.escrow_id = message.escrowId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitJobResponse>): MsgSubmitJobResponse {
    const message = createBaseMsgSubmitJobResponse();
    message.jobId = object.jobId ?? "";
    message.escrowId = object.escrowId ?? "";
    return message;
  },
};

function createBaseMsgCancelJob(): MsgCancelJob {
  return { requesterAddress: "", jobId: "", reason: "" };
}

export const MsgCancelJob: MessageFns<MsgCancelJob, "virtengine.hpc.v1.MsgCancelJob"> = {
  $type: "virtengine.hpc.v1.MsgCancelJob" as const,

  encode(message: MsgCancelJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requesterAddress !== "") {
      writer.uint32(10).string(message.requesterAddress);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requesterAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCancelJob {
    return {
      requesterAddress: isSet(object.requester_address) ? globalThis.String(object.requester_address) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgCancelJob): unknown {
    const obj: any = {};
    if (message.requesterAddress !== "") {
      obj.requester_address = message.requesterAddress;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCancelJob>): MsgCancelJob {
    const message = createBaseMsgCancelJob();
    message.requesterAddress = object.requesterAddress ?? "";
    message.jobId = object.jobId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgCancelJobResponse(): MsgCancelJobResponse {
  return {};
}

export const MsgCancelJobResponse: MessageFns<MsgCancelJobResponse, "virtengine.hpc.v1.MsgCancelJobResponse"> = {
  $type: "virtengine.hpc.v1.MsgCancelJobResponse" as const,

  encode(_: MsgCancelJobResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCancelJobResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCancelJobResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgCancelJobResponse {
    return {};
  },

  toJSON(_: MsgCancelJobResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgCancelJobResponse>): MsgCancelJobResponse {
    const message = createBaseMsgCancelJobResponse();
    return message;
  },
};

function createBaseMsgReportJobStatus(): MsgReportJobStatus {
  return {
    providerAddress: "",
    jobId: "",
    slurmJobId: "",
    state: 0,
    statusMessage: "",
    exitCode: 0,
    usageMetrics: undefined,
    signature: "",
    signedTimestamp: Long.ZERO,
  };
}

export const MsgReportJobStatus: MessageFns<MsgReportJobStatus, "virtengine.hpc.v1.MsgReportJobStatus"> = {
  $type: "virtengine.hpc.v1.MsgReportJobStatus" as const,

  encode(message: MsgReportJobStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.slurmJobId !== "") {
      writer.uint32(26).string(message.slurmJobId);
    }
    if (message.state !== 0) {
      writer.uint32(32).int32(message.state);
    }
    if (message.statusMessage !== "") {
      writer.uint32(42).string(message.statusMessage);
    }
    if (message.exitCode !== 0) {
      writer.uint32(48).int32(message.exitCode);
    }
    if (message.usageMetrics !== undefined) {
      HPCUsageMetrics.encode(message.usageMetrics, writer.uint32(58).fork()).join();
    }
    if (message.signature !== "") {
      writer.uint32(66).string(message.signature);
    }
    if (!message.signedTimestamp.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.signedTimestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReportJobStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReportJobStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slurmJobId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.usageMetrics = HPCUsageMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.signature = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.signedTimestamp = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReportJobStatus {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      slurmJobId: isSet(object.slurm_job_id) ? globalThis.String(object.slurm_job_id) : "",
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      statusMessage: isSet(object.status_message) ? globalThis.String(object.status_message) : "",
      exitCode: isSet(object.exit_code) ? globalThis.Number(object.exit_code) : 0,
      usageMetrics: isSet(object.usage_metrics) ? HPCUsageMetrics.fromJSON(object.usage_metrics) : undefined,
      signature: isSet(object.signature) ? globalThis.String(object.signature) : "",
      signedTimestamp: isSet(object.signed_timestamp) ? Long.fromValue(object.signed_timestamp) : Long.ZERO,
    };
  },

  toJSON(message: MsgReportJobStatus): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.slurmJobId !== "") {
      obj.slurm_job_id = message.slurmJobId;
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.statusMessage !== "") {
      obj.status_message = message.statusMessage;
    }
    if (message.exitCode !== 0) {
      obj.exit_code = Math.round(message.exitCode);
    }
    if (message.usageMetrics !== undefined) {
      obj.usage_metrics = HPCUsageMetrics.toJSON(message.usageMetrics);
    }
    if (message.signature !== "") {
      obj.signature = message.signature;
    }
    if (!message.signedTimestamp.equals(Long.ZERO)) {
      obj.signed_timestamp = (message.signedTimestamp || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgReportJobStatus>): MsgReportJobStatus {
    const message = createBaseMsgReportJobStatus();
    message.providerAddress = object.providerAddress ?? "";
    message.jobId = object.jobId ?? "";
    message.slurmJobId = object.slurmJobId ?? "";
    message.state = object.state ?? 0;
    message.statusMessage = object.statusMessage ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.usageMetrics = (object.usageMetrics !== undefined && object.usageMetrics !== null)
      ? HPCUsageMetrics.fromPartial(object.usageMetrics)
      : undefined;
    message.signature = object.signature ?? "";
    message.signedTimestamp = (object.signedTimestamp !== undefined && object.signedTimestamp !== null)
      ? Long.fromValue(object.signedTimestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgReportJobStatusResponse(): MsgReportJobStatusResponse {
  return {};
}

export const MsgReportJobStatusResponse: MessageFns<
  MsgReportJobStatusResponse,
  "virtengine.hpc.v1.MsgReportJobStatusResponse"
> = {
  $type: "virtengine.hpc.v1.MsgReportJobStatusResponse" as const,

  encode(_: MsgReportJobStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReportJobStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReportJobStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgReportJobStatusResponse {
    return {};
  },

  toJSON(_: MsgReportJobStatusResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgReportJobStatusResponse>): MsgReportJobStatusResponse {
    const message = createBaseMsgReportJobStatusResponse();
    return message;
  },
};

function createBaseMsgUpdateNodeMetadata(): MsgUpdateNodeMetadata {
  return {
    providerAddress: "",
    nodeId: "",
    clusterId: "",
    region: "",
    datacenter: "",
    latencyMeasurements: [],
    networkBandwidthMbps: Long.ZERO,
    resources: undefined,
    active: false,
  };
}

export const MsgUpdateNodeMetadata: MessageFns<MsgUpdateNodeMetadata, "virtengine.hpc.v1.MsgUpdateNodeMetadata"> = {
  $type: "virtengine.hpc.v1.MsgUpdateNodeMetadata" as const,

  encode(message: MsgUpdateNodeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.nodeId !== "") {
      writer.uint32(18).string(message.nodeId);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    if (message.datacenter !== "") {
      writer.uint32(42).string(message.datacenter);
    }
    for (const v of message.latencyMeasurements) {
      LatencyMeasurement.encode(v!, writer.uint32(50).fork()).join();
    }
    if (!message.networkBandwidthMbps.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.networkBandwidthMbps.toString());
    }
    if (message.resources !== undefined) {
      NodeResources.encode(message.resources, writer.uint32(66).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(72).bool(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNodeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNodeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datacenter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.latencyMeasurements.push(LatencyMeasurement.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.networkBandwidthMbps = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.resources = NodeResources.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateNodeMetadata {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      nodeId: isSet(object.node_id) ? globalThis.String(object.node_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      datacenter: isSet(object.datacenter) ? globalThis.String(object.datacenter) : "",
      latencyMeasurements: globalThis.Array.isArray(object?.latency_measurements)
        ? object.latency_measurements.map((e: any) => LatencyMeasurement.fromJSON(e))
        : [],
      networkBandwidthMbps: isSet(object.network_bandwidth_mbps)
        ? Long.fromValue(object.network_bandwidth_mbps)
        : Long.ZERO,
      resources: isSet(object.resources) ? NodeResources.fromJSON(object.resources) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
    };
  },

  toJSON(message: MsgUpdateNodeMetadata): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.nodeId !== "") {
      obj.node_id = message.nodeId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.datacenter !== "") {
      obj.datacenter = message.datacenter;
    }
    if (message.latencyMeasurements?.length) {
      obj.latency_measurements = message.latencyMeasurements.map((e) => LatencyMeasurement.toJSON(e));
    }
    if (!message.networkBandwidthMbps.equals(Long.ZERO)) {
      obj.network_bandwidth_mbps = (message.networkBandwidthMbps || Long.ZERO).toString();
    }
    if (message.resources !== undefined) {
      obj.resources = NodeResources.toJSON(message.resources);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateNodeMetadata>): MsgUpdateNodeMetadata {
    const message = createBaseMsgUpdateNodeMetadata();
    message.providerAddress = object.providerAddress ?? "";
    message.nodeId = object.nodeId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.region = object.region ?? "";
    message.datacenter = object.datacenter ?? "";
    message.latencyMeasurements = object.latencyMeasurements?.map((e) => LatencyMeasurement.fromPartial(e)) || [];
    message.networkBandwidthMbps = (object.networkBandwidthMbps !== undefined && object.networkBandwidthMbps !== null)
      ? Long.fromValue(object.networkBandwidthMbps)
      : Long.ZERO;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? NodeResources.fromPartial(object.resources)
      : undefined;
    message.active = object.active ?? false;
    return message;
  },
};

function createBaseMsgUpdateNodeMetadataResponse(): MsgUpdateNodeMetadataResponse {
  return {};
}

export const MsgUpdateNodeMetadataResponse: MessageFns<
  MsgUpdateNodeMetadataResponse,
  "virtengine.hpc.v1.MsgUpdateNodeMetadataResponse"
> = {
  $type: "virtengine.hpc.v1.MsgUpdateNodeMetadataResponse" as const,

  encode(_: MsgUpdateNodeMetadataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateNodeMetadataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateNodeMetadataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateNodeMetadataResponse {
    return {};
  },

  toJSON(_: MsgUpdateNodeMetadataResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateNodeMetadataResponse>): MsgUpdateNodeMetadataResponse {
    const message = createBaseMsgUpdateNodeMetadataResponse();
    return message;
  },
};

function createBaseMsgFlagDispute(): MsgFlagDispute {
  return { disputerAddress: "", jobId: "", rewardId: "", disputeType: "", reason: "", evidence: "" };
}

export const MsgFlagDispute: MessageFns<MsgFlagDispute, "virtengine.hpc.v1.MsgFlagDispute"> = {
  $type: "virtengine.hpc.v1.MsgFlagDispute" as const,

  encode(message: MsgFlagDispute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disputerAddress !== "") {
      writer.uint32(10).string(message.disputerAddress);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.rewardId !== "") {
      writer.uint32(26).string(message.rewardId);
    }
    if (message.disputeType !== "") {
      writer.uint32(34).string(message.disputeType);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    if (message.evidence !== "") {
      writer.uint32(50).string(message.evidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFlagDispute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFlagDispute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.disputerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.disputeType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evidence = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFlagDispute {
    return {
      disputerAddress: isSet(object.disputer_address) ? globalThis.String(object.disputer_address) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      rewardId: isSet(object.reward_id) ? globalThis.String(object.reward_id) : "",
      disputeType: isSet(object.dispute_type) ? globalThis.String(object.dispute_type) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      evidence: isSet(object.evidence) ? globalThis.String(object.evidence) : "",
    };
  },

  toJSON(message: MsgFlagDispute): unknown {
    const obj: any = {};
    if (message.disputerAddress !== "") {
      obj.disputer_address = message.disputerAddress;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.rewardId !== "") {
      obj.reward_id = message.rewardId;
    }
    if (message.disputeType !== "") {
      obj.dispute_type = message.disputeType;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.evidence !== "") {
      obj.evidence = message.evidence;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgFlagDispute>): MsgFlagDispute {
    const message = createBaseMsgFlagDispute();
    message.disputerAddress = object.disputerAddress ?? "";
    message.jobId = object.jobId ?? "";
    message.rewardId = object.rewardId ?? "";
    message.disputeType = object.disputeType ?? "";
    message.reason = object.reason ?? "";
    message.evidence = object.evidence ?? "";
    return message;
  },
};

function createBaseMsgFlagDisputeResponse(): MsgFlagDisputeResponse {
  return { disputeId: "" };
}

export const MsgFlagDisputeResponse: MessageFns<MsgFlagDisputeResponse, "virtengine.hpc.v1.MsgFlagDisputeResponse"> = {
  $type: "virtengine.hpc.v1.MsgFlagDisputeResponse" as const,

  encode(message: MsgFlagDisputeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disputeId !== "") {
      writer.uint32(10).string(message.disputeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgFlagDisputeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgFlagDisputeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.disputeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgFlagDisputeResponse {
    return { disputeId: isSet(object.dispute_id) ? globalThis.String(object.dispute_id) : "" };
  },

  toJSON(message: MsgFlagDisputeResponse): unknown {
    const obj: any = {};
    if (message.disputeId !== "") {
      obj.dispute_id = message.disputeId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgFlagDisputeResponse>): MsgFlagDisputeResponse {
    const message = createBaseMsgFlagDisputeResponse();
    message.disputeId = object.disputeId ?? "";
    return message;
  },
};

function createBaseMsgResolveDispute(): MsgResolveDispute {
  return { resolverAddress: "", disputeId: "", status: 0, resolution: "" };
}

export const MsgResolveDispute: MessageFns<MsgResolveDispute, "virtengine.hpc.v1.MsgResolveDispute"> = {
  $type: "virtengine.hpc.v1.MsgResolveDispute" as const,

  encode(message: MsgResolveDispute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resolverAddress !== "") {
      writer.uint32(10).string(message.resolverAddress);
    }
    if (message.disputeId !== "") {
      writer.uint32(18).string(message.disputeId);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.resolution !== "") {
      writer.uint32(34).string(message.resolution);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveDispute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveDispute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resolverAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.disputeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.resolution = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResolveDispute {
    return {
      resolverAddress: isSet(object.resolver_address) ? globalThis.String(object.resolver_address) : "",
      disputeId: isSet(object.dispute_id) ? globalThis.String(object.dispute_id) : "",
      status: isSet(object.status) ? disputeStatusFromJSON(object.status) : 0,
      resolution: isSet(object.resolution) ? globalThis.String(object.resolution) : "",
    };
  },

  toJSON(message: MsgResolveDispute): unknown {
    const obj: any = {};
    if (message.resolverAddress !== "") {
      obj.resolver_address = message.resolverAddress;
    }
    if (message.disputeId !== "") {
      obj.dispute_id = message.disputeId;
    }
    if (message.status !== 0) {
      obj.status = disputeStatusToJSON(message.status);
    }
    if (message.resolution !== "") {
      obj.resolution = message.resolution;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgResolveDispute>): MsgResolveDispute {
    const message = createBaseMsgResolveDispute();
    message.resolverAddress = object.resolverAddress ?? "";
    message.disputeId = object.disputeId ?? "";
    message.status = object.status ?? 0;
    message.resolution = object.resolution ?? "";
    return message;
  },
};

function createBaseMsgResolveDisputeResponse(): MsgResolveDisputeResponse {
  return {};
}

export const MsgResolveDisputeResponse: MessageFns<
  MsgResolveDisputeResponse,
  "virtengine.hpc.v1.MsgResolveDisputeResponse"
> = {
  $type: "virtengine.hpc.v1.MsgResolveDisputeResponse" as const,

  encode(_: MsgResolveDisputeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveDisputeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveDisputeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgResolveDisputeResponse {
    return {};
  },

  toJSON(_: MsgResolveDisputeResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgResolveDisputeResponse>): MsgResolveDisputeResponse {
    const message = createBaseMsgResolveDisputeResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams, "virtengine.hpc.v1.MsgUpdateParams"> = {
  $type: "virtengine.hpc.v1.MsgUpdateParams" as const,

  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<MsgUpdateParamsResponse, "virtengine.hpc.v1.MsgUpdateParamsResponse"> =
  {
    $type: "virtengine.hpc.v1.MsgUpdateParamsResponse" as const,

    encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      const end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseMsgUpdateParamsResponse();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(_: any): MsgUpdateParamsResponse {
      return {};
    },

    toJSON(_: MsgUpdateParamsResponse): unknown {
      const obj: any = {};
      return obj;
    },
    fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
      const message = createBaseMsgUpdateParamsResponse();
      return message;
    },
  };

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
