import { toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/hpc/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin.ts";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** ClusterState represents the state of an HPC cluster */
export enum ClusterState {
  /** CLUSTER_STATE_UNSPECIFIED - CLUSTER_STATE_UNSPECIFIED represents an unspecified cluster state */
  CLUSTER_STATE_UNSPECIFIED = 0,
  /** CLUSTER_STATE_PENDING - CLUSTER_STATE_PENDING indicates the cluster is pending registration */
  CLUSTER_STATE_PENDING = 1,
  /** CLUSTER_STATE_ACTIVE - CLUSTER_STATE_ACTIVE indicates the cluster is active and accepting jobs */
  CLUSTER_STATE_ACTIVE = 2,
  /** CLUSTER_STATE_DRAINING - CLUSTER_STATE_DRAINING indicates the cluster is draining (not accepting new jobs) */
  CLUSTER_STATE_DRAINING = 3,
  /** CLUSTER_STATE_OFFLINE - CLUSTER_STATE_OFFLINE indicates the cluster is offline */
  CLUSTER_STATE_OFFLINE = 4,
  /** CLUSTER_STATE_DEREGISTERED - CLUSTER_STATE_DEREGISTERED indicates the cluster has been deregistered */
  CLUSTER_STATE_DEREGISTERED = 5,
  UNRECOGNIZED = -1,
}

export function clusterStateFromJSON(object: any): ClusterState {
  switch (object) {
    case 0:
    case "CLUSTER_STATE_UNSPECIFIED":
      return ClusterState.CLUSTER_STATE_UNSPECIFIED;
    case 1:
    case "CLUSTER_STATE_PENDING":
      return ClusterState.CLUSTER_STATE_PENDING;
    case 2:
    case "CLUSTER_STATE_ACTIVE":
      return ClusterState.CLUSTER_STATE_ACTIVE;
    case 3:
    case "CLUSTER_STATE_DRAINING":
      return ClusterState.CLUSTER_STATE_DRAINING;
    case 4:
    case "CLUSTER_STATE_OFFLINE":
      return ClusterState.CLUSTER_STATE_OFFLINE;
    case 5:
    case "CLUSTER_STATE_DEREGISTERED":
      return ClusterState.CLUSTER_STATE_DEREGISTERED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ClusterState.UNRECOGNIZED;
  }
}

export function clusterStateToJSON(object: ClusterState): string {
  switch (object) {
    case ClusterState.CLUSTER_STATE_UNSPECIFIED:
      return "CLUSTER_STATE_UNSPECIFIED";
    case ClusterState.CLUSTER_STATE_PENDING:
      return "CLUSTER_STATE_PENDING";
    case ClusterState.CLUSTER_STATE_ACTIVE:
      return "CLUSTER_STATE_ACTIVE";
    case ClusterState.CLUSTER_STATE_DRAINING:
      return "CLUSTER_STATE_DRAINING";
    case ClusterState.CLUSTER_STATE_OFFLINE:
      return "CLUSTER_STATE_OFFLINE";
    case ClusterState.CLUSTER_STATE_DEREGISTERED:
      return "CLUSTER_STATE_DEREGISTERED";
    case ClusterState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** JobState represents the state of an HPC job */
export enum JobState {
  /** JOB_STATE_UNSPECIFIED - JOB_STATE_UNSPECIFIED represents an unspecified job state */
  JOB_STATE_UNSPECIFIED = 0,
  /** JOB_STATE_PENDING - JOB_STATE_PENDING indicates the job is pending */
  JOB_STATE_PENDING = 1,
  /** JOB_STATE_QUEUED - JOB_STATE_QUEUED indicates the job is queued in SLURM */
  JOB_STATE_QUEUED = 2,
  /** JOB_STATE_RUNNING - JOB_STATE_RUNNING indicates the job is running */
  JOB_STATE_RUNNING = 3,
  /** JOB_STATE_COMPLETED - JOB_STATE_COMPLETED indicates the job completed successfully */
  JOB_STATE_COMPLETED = 4,
  /** JOB_STATE_FAILED - JOB_STATE_FAILED indicates the job failed */
  JOB_STATE_FAILED = 5,
  /** JOB_STATE_CANCELLED - JOB_STATE_CANCELLED indicates the job was cancelled */
  JOB_STATE_CANCELLED = 6,
  /** JOB_STATE_TIMEOUT - JOB_STATE_TIMEOUT indicates the job timed out */
  JOB_STATE_TIMEOUT = 7,
  UNRECOGNIZED = -1,
}

export function jobStateFromJSON(object: any): JobState {
  switch (object) {
    case 0:
    case "JOB_STATE_UNSPECIFIED":
      return JobState.JOB_STATE_UNSPECIFIED;
    case 1:
    case "JOB_STATE_PENDING":
      return JobState.JOB_STATE_PENDING;
    case 2:
    case "JOB_STATE_QUEUED":
      return JobState.JOB_STATE_QUEUED;
    case 3:
    case "JOB_STATE_RUNNING":
      return JobState.JOB_STATE_RUNNING;
    case 4:
    case "JOB_STATE_COMPLETED":
      return JobState.JOB_STATE_COMPLETED;
    case 5:
    case "JOB_STATE_FAILED":
      return JobState.JOB_STATE_FAILED;
    case 6:
    case "JOB_STATE_CANCELLED":
      return JobState.JOB_STATE_CANCELLED;
    case 7:
    case "JOB_STATE_TIMEOUT":
      return JobState.JOB_STATE_TIMEOUT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return JobState.UNRECOGNIZED;
  }
}

export function jobStateToJSON(object: JobState): string {
  switch (object) {
    case JobState.JOB_STATE_UNSPECIFIED:
      return "JOB_STATE_UNSPECIFIED";
    case JobState.JOB_STATE_PENDING:
      return "JOB_STATE_PENDING";
    case JobState.JOB_STATE_QUEUED:
      return "JOB_STATE_QUEUED";
    case JobState.JOB_STATE_RUNNING:
      return "JOB_STATE_RUNNING";
    case JobState.JOB_STATE_COMPLETED:
      return "JOB_STATE_COMPLETED";
    case JobState.JOB_STATE_FAILED:
      return "JOB_STATE_FAILED";
    case JobState.JOB_STATE_CANCELLED:
      return "JOB_STATE_CANCELLED";
    case JobState.JOB_STATE_TIMEOUT:
      return "JOB_STATE_TIMEOUT";
    case JobState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HPCRewardSource indicates the source of HPC rewards */
export enum HPCRewardSource {
  /** HPC_REWARD_SOURCE_UNSPECIFIED - HPC_REWARD_SOURCE_UNSPECIFIED represents an unspecified reward source */
  HPC_REWARD_SOURCE_UNSPECIFIED = 0,
  /** HPC_REWARD_SOURCE_JOB_COMPLETION - HPC_REWARD_SOURCE_JOB_COMPLETION is for completed job rewards */
  HPC_REWARD_SOURCE_JOB_COMPLETION = 1,
  /** HPC_REWARD_SOURCE_USAGE - HPC_REWARD_SOURCE_USAGE is for usage-based rewards */
  HPC_REWARD_SOURCE_USAGE = 2,
  /** HPC_REWARD_SOURCE_BONUS - HPC_REWARD_SOURCE_BONUS is for bonus rewards */
  HPC_REWARD_SOURCE_BONUS = 3,
  UNRECOGNIZED = -1,
}

export function hPCRewardSourceFromJSON(object: any): HPCRewardSource {
  switch (object) {
    case 0:
    case "HPC_REWARD_SOURCE_UNSPECIFIED":
      return HPCRewardSource.HPC_REWARD_SOURCE_UNSPECIFIED;
    case 1:
    case "HPC_REWARD_SOURCE_JOB_COMPLETION":
      return HPCRewardSource.HPC_REWARD_SOURCE_JOB_COMPLETION;
    case 2:
    case "HPC_REWARD_SOURCE_USAGE":
      return HPCRewardSource.HPC_REWARD_SOURCE_USAGE;
    case 3:
    case "HPC_REWARD_SOURCE_BONUS":
      return HPCRewardSource.HPC_REWARD_SOURCE_BONUS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HPCRewardSource.UNRECOGNIZED;
  }
}

export function hPCRewardSourceToJSON(object: HPCRewardSource): string {
  switch (object) {
    case HPCRewardSource.HPC_REWARD_SOURCE_UNSPECIFIED:
      return "HPC_REWARD_SOURCE_UNSPECIFIED";
    case HPCRewardSource.HPC_REWARD_SOURCE_JOB_COMPLETION:
      return "HPC_REWARD_SOURCE_JOB_COMPLETION";
    case HPCRewardSource.HPC_REWARD_SOURCE_USAGE:
      return "HPC_REWARD_SOURCE_USAGE";
    case HPCRewardSource.HPC_REWARD_SOURCE_BONUS:
      return "HPC_REWARD_SOURCE_BONUS";
    case HPCRewardSource.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** DisputeStatus indicates the status of a dispute */
export enum DisputeStatus {
  /** DISPUTE_STATUS_UNSPECIFIED - DISPUTE_STATUS_UNSPECIFIED represents an unspecified dispute status */
  DISPUTE_STATUS_UNSPECIFIED = 0,
  /** DISPUTE_STATUS_PENDING - DISPUTE_STATUS_PENDING indicates the dispute is pending */
  DISPUTE_STATUS_PENDING = 1,
  /** DISPUTE_STATUS_UNDER_REVIEW - DISPUTE_STATUS_UNDER_REVIEW indicates the dispute is under review */
  DISPUTE_STATUS_UNDER_REVIEW = 2,
  /** DISPUTE_STATUS_RESOLVED - DISPUTE_STATUS_RESOLVED indicates the dispute is resolved */
  DISPUTE_STATUS_RESOLVED = 3,
  /** DISPUTE_STATUS_REJECTED - DISPUTE_STATUS_REJECTED indicates the dispute was rejected */
  DISPUTE_STATUS_REJECTED = 4,
  UNRECOGNIZED = -1,
}

export function disputeStatusFromJSON(object: any): DisputeStatus {
  switch (object) {
    case 0:
    case "DISPUTE_STATUS_UNSPECIFIED":
      return DisputeStatus.DISPUTE_STATUS_UNSPECIFIED;
    case 1:
    case "DISPUTE_STATUS_PENDING":
      return DisputeStatus.DISPUTE_STATUS_PENDING;
    case 2:
    case "DISPUTE_STATUS_UNDER_REVIEW":
      return DisputeStatus.DISPUTE_STATUS_UNDER_REVIEW;
    case 3:
    case "DISPUTE_STATUS_RESOLVED":
      return DisputeStatus.DISPUTE_STATUS_RESOLVED;
    case 4:
    case "DISPUTE_STATUS_REJECTED":
      return DisputeStatus.DISPUTE_STATUS_REJECTED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DisputeStatus.UNRECOGNIZED;
  }
}

export function disputeStatusToJSON(object: DisputeStatus): string {
  switch (object) {
    case DisputeStatus.DISPUTE_STATUS_UNSPECIFIED:
      return "DISPUTE_STATUS_UNSPECIFIED";
    case DisputeStatus.DISPUTE_STATUS_PENDING:
      return "DISPUTE_STATUS_PENDING";
    case DisputeStatus.DISPUTE_STATUS_UNDER_REVIEW:
      return "DISPUTE_STATUS_UNDER_REVIEW";
    case DisputeStatus.DISPUTE_STATUS_RESOLVED:
      return "DISPUTE_STATUS_RESOLVED";
    case DisputeStatus.DISPUTE_STATUS_REJECTED:
      return "DISPUTE_STATUS_REJECTED";
    case DisputeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Partition represents a SLURM partition/queue */
export interface Partition {
  name: string;
  nodes: number;
  maxRuntime: Long;
  defaultRuntime: Long;
  maxNodes: number;
  features: string[];
  priority: number;
  state: string;
}

/** ClusterMetadata contains additional cluster metadata */
export interface ClusterMetadata {
  totalCpuCores: Long;
  totalMemoryGb: Long;
  totalGpus: Long;
  gpuTypes: string[];
  interconnectType: string;
  storageType: string;
  totalStorageGb: Long;
}

/** HPCCluster represents a SLURM cluster registered on-chain */
export interface HPCCluster {
  clusterId: string;
  providerAddress: string;
  name: string;
  description: string;
  state: ClusterState;
  partitions: Partition[];
  totalNodes: number;
  availableNodes: number;
  region: string;
  clusterMetadata: ClusterMetadata | undefined;
  slurmVersion: string;
  kubernetesClusterId: string;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  blockHeight: Long;
}

/** QueueOption represents a queue/partition option in an offering */
export interface QueueOption {
  partitionName: string;
  displayName: string;
  maxNodes: number;
  maxRuntime: Long;
  features: string[];
  priceMultiplier: string;
}

/** HPCPricing contains HPC pricing information */
export interface HPCPricing {
  baseNodeHourPrice: string;
  cpuCoreHourPrice: string;
  gpuHourPrice: string;
  memoryGbHourPrice: string;
  storageGbPrice: string;
  networkGbPrice: string;
  currency: string;
  minimumCharge: string;
}

/** JobResources defines resource requirements for an HPC job */
export interface JobResources {
  nodes: number;
  cpuCoresPerNode: number;
  memoryGbPerNode: number;
  gpusPerNode: number;
  storageGb: number;
  gpuType: string;
}

/** PreconfiguredWorkload represents a pre-approved workload */
export interface PreconfiguredWorkload {
  workloadId: string;
  name: string;
  description: string;
  containerImage: string;
  defaultCommand: string;
  requiredResources: JobResources | undefined;
  category: string;
  version: string;
}

/** HPCOffering represents an HPC service offering */
export interface HPCOffering {
  offeringId: string;
  clusterId: string;
  providerAddress: string;
  name: string;
  description: string;
  queueOptions: QueueOption[];
  pricing: HPCPricing | undefined;
  requiredIdentityThreshold: number;
  maxRuntimeSeconds: Long;
  preconfiguredWorkloads: PreconfiguredWorkload[];
  supportsCustomWorkloads: boolean;
  active: boolean;
  createdAt: Date | undefined;
  updatedAt: Date | undefined;
  blockHeight: Long;
}

/** JobWorkloadSpec defines the workload for an HPC job */
export interface JobWorkloadSpec {
  containerImage: string;
  command: string;
  arguments: string[];
  environment: { [key: string]: string };
  workingDirectory: string;
  preconfiguredWorkloadId: string;
  isPreconfigured: boolean;
}

export interface JobWorkloadSpec_EnvironmentEntry {
  key: string;
  value: string;
}

/** DataReference references external data */
export interface DataReference {
  referenceId: string;
  type: string;
  uri: string;
  encrypted: boolean;
  checksum: string;
  sizeBytes: Long;
}

/** HPCUsageMetrics contains usage metrics for an HPC job */
export interface HPCUsageMetrics {
  wallClockSeconds: Long;
  cpuCoreSeconds: Long;
  memoryGbSeconds: Long;
  gpuSeconds: Long;
  storageGbHours: Long;
  networkBytesIn: Long;
  networkBytesOut: Long;
  nodeHours: Long;
  nodesUsed: number;
}

/** HPCJob represents an HPC job request */
export interface HPCJob {
  jobId: string;
  offeringId: string;
  clusterId: string;
  providerAddress: string;
  customerAddress: string;
  slurmJobId: string;
  state: JobState;
  queueName: string;
  workloadSpec: JobWorkloadSpec | undefined;
  resources: JobResources | undefined;
  dataReferences: DataReference[];
  encryptedInputsPointer: string;
  encryptedOutputsPointer: string;
  maxRuntimeSeconds: Long;
  agreedPrice: Coin[];
  escrowId: string;
  schedulingDecisionId: string;
  statusMessage: string;
  exitCode: number;
  createdAt: Date | undefined;
  queuedAt: Date | undefined;
  startedAt: Date | undefined;
  completedAt: Date | undefined;
  blockHeight: Long;
}

/** NodeReward represents a reward for a specific node */
export interface NodeReward {
  nodeId: string;
  providerAddress: string;
  amount: Coin[];
  contributionWeight: string;
  usageSeconds: Long;
}

/** JobAccounting represents accounting data for an HPC job */
export interface JobAccounting {
  jobId: string;
  clusterId: string;
  providerAddress: string;
  customerAddress: string;
  usageMetrics: HPCUsageMetrics | undefined;
  totalCost: Coin[];
  providerReward: Coin[];
  nodeRewards: NodeReward[];
  platformFee: Coin[];
  settlementStatus: string;
  settlementId: string;
  signedUsageRecordIds: string[];
  jobCompletionStatus: JobState;
  createdAt: Date | undefined;
  finalizedAt: Date | undefined;
  blockHeight: Long;
}

/** LatencyMeasurement contains latency measurement to another node */
export interface LatencyMeasurement {
  targetNodeId: string;
  latencyMs: Long;
  measuredAt: Date | undefined;
}

/** NodeResources contains node resource capacity */
export interface NodeResources {
  cpuCores: number;
  memoryGb: number;
  gpus: number;
  gpuType: string;
  storageGb: number;
}

/** NodeMetadata contains metadata about a compute node */
export interface NodeMetadata {
  nodeId: string;
  clusterId: string;
  providerAddress: string;
  region: string;
  datacenter: string;
  latencyMeasurements: LatencyMeasurement[];
  avgLatencyMs: Long;
  networkBandwidthMbps: Long;
  resources: NodeResources | undefined;
  active: boolean;
  lastHeartbeat: Date | undefined;
  joinedAt: Date | undefined;
  updatedAt: Date | undefined;
  blockHeight: Long;
}

/** ClusterCandidate represents a candidate cluster for scheduling */
export interface ClusterCandidate {
  clusterId: string;
  region: string;
  avgLatencyMs: Long;
  availableNodes: number;
  latencyScore: string;
  capacityScore: string;
  combinedScore: string;
  eligible: boolean;
  ineligibilityReason: string;
}

/** SchedulingDecision records the decision trail for job scheduling */
export interface SchedulingDecision {
  decisionId: string;
  jobId: string;
  selectedClusterId: string;
  candidateClusters: ClusterCandidate[];
  decisionReason: string;
  isFallback: boolean;
  fallbackReason: string;
  latencyScore: string;
  capacityScore: string;
  combinedScore: string;
  createdAt: Date | undefined;
  blockHeight: Long;
}

/** HPCRewardRecipient represents a recipient of HPC rewards */
export interface HPCRewardRecipient {
  address: string;
  amount: Coin[];
  recipientType: string;
  nodeId: string;
  contributionWeight: string;
  reason: string;
}

/** RewardCalculationDetails contains transparency data for reward calculation */
export interface RewardCalculationDetails {
  totalUsageValue: string;
  rewardPoolContribution: string;
  platformFeeRate: string;
  nodeContributionFormula: string;
  inputMetrics: { [key: string]: string };
}

export interface RewardCalculationDetails_InputMetricsEntry {
  key: string;
  value: string;
}

/** HPCRewardRecord represents a reward distribution for HPC contribution */
export interface HPCRewardRecord {
  rewardId: string;
  jobId: string;
  clusterId: string;
  source: HPCRewardSource;
  totalReward: Coin[];
  recipients: HPCRewardRecipient[];
  referencedUsageRecords: string[];
  jobCompletionStatus: JobState;
  formulaVersion: string;
  calculationDetails: RewardCalculationDetails | undefined;
  disputed: boolean;
  disputeId: string;
  issuedAt: Date | undefined;
  blockHeight: Long;
}

/** HPCDispute represents a dispute for HPC rewards/usage */
export interface HPCDispute {
  disputeId: string;
  jobId: string;
  rewardId: string;
  disputerAddress: string;
  disputeType: string;
  reason: string;
  evidence: string;
  status: DisputeStatus;
  resolution: string;
  resolverAddress: string;
  createdAt: Date | undefined;
  resolvedAt: Date | undefined;
  blockHeight: Long;
}

/** Params defines the parameters for the HPC module */
export interface Params {
  platformFeeRate: string;
  providerRewardRate: string;
  nodeRewardRate: string;
  minJobDurationSeconds: Long;
  maxJobDurationSeconds: Long;
  defaultIdentityThreshold: number;
  clusterHeartbeatTimeout: Long;
  nodeHeartbeatTimeout: Long;
  latencyWeightFactor: string;
  capacityWeightFactor: string;
  maxLatencyMs: Long;
  disputeResolutionPeriod: Long;
  rewardFormulaVersion: string;
  enableProximityClustering: boolean;
}

function createBasePartition(): Partition {
  return {
    name: "",
    nodes: 0,
    maxRuntime: Long.ZERO,
    defaultRuntime: Long.ZERO,
    maxNodes: 0,
    features: [],
    priority: 0,
    state: "",
  };
}

export const Partition: MessageFns<Partition, "virtengine.hpc.v1.Partition"> = {
  $type: "virtengine.hpc.v1.Partition" as const,

  encode(message: Partition, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.nodes !== 0) {
      writer.uint32(16).int32(message.nodes);
    }
    if (!message.maxRuntime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.maxRuntime.toString());
    }
    if (!message.defaultRuntime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.defaultRuntime.toString());
    }
    if (message.maxNodes !== 0) {
      writer.uint32(40).int32(message.maxNodes);
    }
    for (const v of message.features) {
      writer.uint32(50).string(v!);
    }
    if (message.priority !== 0) {
      writer.uint32(56).int32(message.priority);
    }
    if (message.state !== "") {
      writer.uint32(66).string(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Partition {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePartition();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.nodes = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxRuntime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.defaultRuntime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxNodes = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.features.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.priority = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.state = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Partition {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      nodes: isSet(object.nodes) ? globalThis.Number(object.nodes) : 0,
      maxRuntime: isSet(object.max_runtime) ? Long.fromValue(object.max_runtime) : Long.ZERO,
      defaultRuntime: isSet(object.default_runtime) ? Long.fromValue(object.default_runtime) : Long.ZERO,
      maxNodes: isSet(object.max_nodes) ? globalThis.Number(object.max_nodes) : 0,
      features: globalThis.Array.isArray(object?.features) ? object.features.map((e: any) => globalThis.String(e)) : [],
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      state: isSet(object.state) ? globalThis.String(object.state) : "",
    };
  },

  toJSON(message: Partition): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.nodes !== 0) {
      obj.nodes = Math.round(message.nodes);
    }
    if (!message.maxRuntime.equals(Long.ZERO)) {
      obj.max_runtime = (message.maxRuntime || Long.ZERO).toString();
    }
    if (!message.defaultRuntime.equals(Long.ZERO)) {
      obj.default_runtime = (message.defaultRuntime || Long.ZERO).toString();
    }
    if (message.maxNodes !== 0) {
      obj.max_nodes = Math.round(message.maxNodes);
    }
    if (message.features?.length) {
      obj.features = message.features;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.state !== "") {
      obj.state = message.state;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Partition>): Partition {
    const message = createBasePartition();
    message.name = object.name ?? "";
    message.nodes = object.nodes ?? 0;
    message.maxRuntime = (object.maxRuntime !== undefined && object.maxRuntime !== null)
      ? Long.fromValue(object.maxRuntime)
      : Long.ZERO;
    message.defaultRuntime = (object.defaultRuntime !== undefined && object.defaultRuntime !== null)
      ? Long.fromValue(object.defaultRuntime)
      : Long.ZERO;
    message.maxNodes = object.maxNodes ?? 0;
    message.features = object.features?.map((e) => e) || [];
    message.priority = object.priority ?? 0;
    message.state = object.state ?? "";
    return message;
  },
};

function createBaseClusterMetadata(): ClusterMetadata {
  return {
    totalCpuCores: Long.ZERO,
    totalMemoryGb: Long.ZERO,
    totalGpus: Long.ZERO,
    gpuTypes: [],
    interconnectType: "",
    storageType: "",
    totalStorageGb: Long.ZERO,
  };
}

export const ClusterMetadata: MessageFns<ClusterMetadata, "virtengine.hpc.v1.ClusterMetadata"> = {
  $type: "virtengine.hpc.v1.ClusterMetadata" as const,

  encode(message: ClusterMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.totalCpuCores.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.totalCpuCores.toString());
    }
    if (!message.totalMemoryGb.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.totalMemoryGb.toString());
    }
    if (!message.totalGpus.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.totalGpus.toString());
    }
    for (const v of message.gpuTypes) {
      writer.uint32(34).string(v!);
    }
    if (message.interconnectType !== "") {
      writer.uint32(42).string(message.interconnectType);
    }
    if (message.storageType !== "") {
      writer.uint32(50).string(message.storageType);
    }
    if (!message.totalStorageGb.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.totalStorageGb.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalCpuCores = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalMemoryGb = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalGpus = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gpuTypes.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.interconnectType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.storageType = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalStorageGb = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterMetadata {
    return {
      totalCpuCores: isSet(object.total_cpu_cores) ? Long.fromValue(object.total_cpu_cores) : Long.ZERO,
      totalMemoryGb: isSet(object.total_memory_gb) ? Long.fromValue(object.total_memory_gb) : Long.ZERO,
      totalGpus: isSet(object.total_gpus) ? Long.fromValue(object.total_gpus) : Long.ZERO,
      gpuTypes: globalThis.Array.isArray(object?.gpu_types)
        ? object.gpu_types.map((e: any) => globalThis.String(e))
        : [],
      interconnectType: isSet(object.interconnect_type) ? globalThis.String(object.interconnect_type) : "",
      storageType: isSet(object.storage_type) ? globalThis.String(object.storage_type) : "",
      totalStorageGb: isSet(object.total_storage_gb) ? Long.fromValue(object.total_storage_gb) : Long.ZERO,
    };
  },

  toJSON(message: ClusterMetadata): unknown {
    const obj: any = {};
    if (!message.totalCpuCores.equals(Long.ZERO)) {
      obj.total_cpu_cores = (message.totalCpuCores || Long.ZERO).toString();
    }
    if (!message.totalMemoryGb.equals(Long.ZERO)) {
      obj.total_memory_gb = (message.totalMemoryGb || Long.ZERO).toString();
    }
    if (!message.totalGpus.equals(Long.ZERO)) {
      obj.total_gpus = (message.totalGpus || Long.ZERO).toString();
    }
    if (message.gpuTypes?.length) {
      obj.gpu_types = message.gpuTypes;
    }
    if (message.interconnectType !== "") {
      obj.interconnect_type = message.interconnectType;
    }
    if (message.storageType !== "") {
      obj.storage_type = message.storageType;
    }
    if (!message.totalStorageGb.equals(Long.ZERO)) {
      obj.total_storage_gb = (message.totalStorageGb || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ClusterMetadata>): ClusterMetadata {
    const message = createBaseClusterMetadata();
    message.totalCpuCores = (object.totalCpuCores !== undefined && object.totalCpuCores !== null)
      ? Long.fromValue(object.totalCpuCores)
      : Long.ZERO;
    message.totalMemoryGb = (object.totalMemoryGb !== undefined && object.totalMemoryGb !== null)
      ? Long.fromValue(object.totalMemoryGb)
      : Long.ZERO;
    message.totalGpus = (object.totalGpus !== undefined && object.totalGpus !== null)
      ? Long.fromValue(object.totalGpus)
      : Long.ZERO;
    message.gpuTypes = object.gpuTypes?.map((e) => e) || [];
    message.interconnectType = object.interconnectType ?? "";
    message.storageType = object.storageType ?? "";
    message.totalStorageGb = (object.totalStorageGb !== undefined && object.totalStorageGb !== null)
      ? Long.fromValue(object.totalStorageGb)
      : Long.ZERO;
    return message;
  },
};

function createBaseHPCCluster(): HPCCluster {
  return {
    clusterId: "",
    providerAddress: "",
    name: "",
    description: "",
    state: 0,
    partitions: [],
    totalNodes: 0,
    availableNodes: 0,
    region: "",
    clusterMetadata: undefined,
    slurmVersion: "",
    kubernetesClusterId: "",
    createdAt: undefined,
    updatedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const HPCCluster: MessageFns<HPCCluster, "virtengine.hpc.v1.HPCCluster"> = {
  $type: "virtengine.hpc.v1.HPCCluster" as const,

  encode(message: HPCCluster, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(18).string(message.providerAddress);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.state !== 0) {
      writer.uint32(40).int32(message.state);
    }
    for (const v of message.partitions) {
      Partition.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.totalNodes !== 0) {
      writer.uint32(56).int32(message.totalNodes);
    }
    if (message.availableNodes !== 0) {
      writer.uint32(64).int32(message.availableNodes);
    }
    if (message.region !== "") {
      writer.uint32(74).string(message.region);
    }
    if (message.clusterMetadata !== undefined) {
      ClusterMetadata.encode(message.clusterMetadata, writer.uint32(82).fork()).join();
    }
    if (message.slurmVersion !== "") {
      writer.uint32(90).string(message.slurmVersion);
    }
    if (message.kubernetesClusterId !== "") {
      writer.uint32(98).string(message.kubernetesClusterId);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(114).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCCluster {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCCluster();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.partitions.push(Partition.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalNodes = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.availableNodes = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.clusterMetadata = ClusterMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.slurmVersion = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.kubernetesClusterId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCCluster {
    return {
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      state: isSet(object.state) ? clusterStateFromJSON(object.state) : 0,
      partitions: globalThis.Array.isArray(object?.partitions)
        ? object.partitions.map((e: any) => Partition.fromJSON(e))
        : [],
      totalNodes: isSet(object.total_nodes) ? globalThis.Number(object.total_nodes) : 0,
      availableNodes: isSet(object.available_nodes) ? globalThis.Number(object.available_nodes) : 0,
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      clusterMetadata: isSet(object.cluster_metadata) ? ClusterMetadata.fromJSON(object.cluster_metadata) : undefined,
      slurmVersion: isSet(object.slurm_version) ? globalThis.String(object.slurm_version) : "",
      kubernetesClusterId: isSet(object.kubernetes_cluster_id) ? globalThis.String(object.kubernetes_cluster_id) : "",
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: HPCCluster): unknown {
    const obj: any = {};
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.state !== 0) {
      obj.state = clusterStateToJSON(message.state);
    }
    if (message.partitions?.length) {
      obj.partitions = message.partitions.map((e) => Partition.toJSON(e));
    }
    if (message.totalNodes !== 0) {
      obj.total_nodes = Math.round(message.totalNodes);
    }
    if (message.availableNodes !== 0) {
      obj.available_nodes = Math.round(message.availableNodes);
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.clusterMetadata !== undefined) {
      obj.cluster_metadata = ClusterMetadata.toJSON(message.clusterMetadata);
    }
    if (message.slurmVersion !== "") {
      obj.slurm_version = message.slurmVersion;
    }
    if (message.kubernetesClusterId !== "") {
      obj.kubernetes_cluster_id = message.kubernetesClusterId;
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCCluster>): HPCCluster {
    const message = createBaseHPCCluster();
    message.clusterId = object.clusterId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.state = object.state ?? 0;
    message.partitions = object.partitions?.map((e) => Partition.fromPartial(e)) || [];
    message.totalNodes = object.totalNodes ?? 0;
    message.availableNodes = object.availableNodes ?? 0;
    message.region = object.region ?? "";
    message.clusterMetadata = (object.clusterMetadata !== undefined && object.clusterMetadata !== null)
      ? ClusterMetadata.fromPartial(object.clusterMetadata)
      : undefined;
    message.slurmVersion = object.slurmVersion ?? "";
    message.kubernetesClusterId = object.kubernetesClusterId ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseQueueOption(): QueueOption {
  return { partitionName: "", displayName: "", maxNodes: 0, maxRuntime: Long.ZERO, features: [], priceMultiplier: "" };
}

export const QueueOption: MessageFns<QueueOption, "virtengine.hpc.v1.QueueOption"> = {
  $type: "virtengine.hpc.v1.QueueOption" as const,

  encode(message: QueueOption, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.partitionName !== "") {
      writer.uint32(10).string(message.partitionName);
    }
    if (message.displayName !== "") {
      writer.uint32(18).string(message.displayName);
    }
    if (message.maxNodes !== 0) {
      writer.uint32(24).int32(message.maxNodes);
    }
    if (!message.maxRuntime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.maxRuntime.toString());
    }
    for (const v of message.features) {
      writer.uint32(42).string(v!);
    }
    if (message.priceMultiplier !== "") {
      writer.uint32(50).string(message.priceMultiplier);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueueOption {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueueOption();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.partitionName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxNodes = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxRuntime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.features.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.priceMultiplier = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueueOption {
    return {
      partitionName: isSet(object.partition_name) ? globalThis.String(object.partition_name) : "",
      displayName: isSet(object.display_name) ? globalThis.String(object.display_name) : "",
      maxNodes: isSet(object.max_nodes) ? globalThis.Number(object.max_nodes) : 0,
      maxRuntime: isSet(object.max_runtime) ? Long.fromValue(object.max_runtime) : Long.ZERO,
      features: globalThis.Array.isArray(object?.features) ? object.features.map((e: any) => globalThis.String(e)) : [],
      priceMultiplier: isSet(object.price_multiplier) ? globalThis.String(object.price_multiplier) : "",
    };
  },

  toJSON(message: QueueOption): unknown {
    const obj: any = {};
    if (message.partitionName !== "") {
      obj.partition_name = message.partitionName;
    }
    if (message.displayName !== "") {
      obj.display_name = message.displayName;
    }
    if (message.maxNodes !== 0) {
      obj.max_nodes = Math.round(message.maxNodes);
    }
    if (!message.maxRuntime.equals(Long.ZERO)) {
      obj.max_runtime = (message.maxRuntime || Long.ZERO).toString();
    }
    if (message.features?.length) {
      obj.features = message.features;
    }
    if (message.priceMultiplier !== "") {
      obj.price_multiplier = message.priceMultiplier;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueueOption>): QueueOption {
    const message = createBaseQueueOption();
    message.partitionName = object.partitionName ?? "";
    message.displayName = object.displayName ?? "";
    message.maxNodes = object.maxNodes ?? 0;
    message.maxRuntime = (object.maxRuntime !== undefined && object.maxRuntime !== null)
      ? Long.fromValue(object.maxRuntime)
      : Long.ZERO;
    message.features = object.features?.map((e) => e) || [];
    message.priceMultiplier = object.priceMultiplier ?? "";
    return message;
  },
};

function createBaseHPCPricing(): HPCPricing {
  return {
    baseNodeHourPrice: "",
    cpuCoreHourPrice: "",
    gpuHourPrice: "",
    memoryGbHourPrice: "",
    storageGbPrice: "",
    networkGbPrice: "",
    currency: "",
    minimumCharge: "",
  };
}

export const HPCPricing: MessageFns<HPCPricing, "virtengine.hpc.v1.HPCPricing"> = {
  $type: "virtengine.hpc.v1.HPCPricing" as const,

  encode(message: HPCPricing, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.baseNodeHourPrice !== "") {
      writer.uint32(10).string(message.baseNodeHourPrice);
    }
    if (message.cpuCoreHourPrice !== "") {
      writer.uint32(18).string(message.cpuCoreHourPrice);
    }
    if (message.gpuHourPrice !== "") {
      writer.uint32(26).string(message.gpuHourPrice);
    }
    if (message.memoryGbHourPrice !== "") {
      writer.uint32(34).string(message.memoryGbHourPrice);
    }
    if (message.storageGbPrice !== "") {
      writer.uint32(42).string(message.storageGbPrice);
    }
    if (message.networkGbPrice !== "") {
      writer.uint32(50).string(message.networkGbPrice);
    }
    if (message.currency !== "") {
      writer.uint32(58).string(message.currency);
    }
    if (message.minimumCharge !== "") {
      writer.uint32(66).string(message.minimumCharge);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCPricing {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCPricing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.baseNodeHourPrice = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cpuCoreHourPrice = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gpuHourPrice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.memoryGbHourPrice = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.storageGbPrice = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.networkGbPrice = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.currency = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.minimumCharge = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCPricing {
    return {
      baseNodeHourPrice: isSet(object.base_node_hour_price) ? globalThis.String(object.base_node_hour_price) : "",
      cpuCoreHourPrice: isSet(object.cpu_core_hour_price) ? globalThis.String(object.cpu_core_hour_price) : "",
      gpuHourPrice: isSet(object.gpu_hour_price) ? globalThis.String(object.gpu_hour_price) : "",
      memoryGbHourPrice: isSet(object.memory_gb_hour_price) ? globalThis.String(object.memory_gb_hour_price) : "",
      storageGbPrice: isSet(object.storage_gb_price) ? globalThis.String(object.storage_gb_price) : "",
      networkGbPrice: isSet(object.network_gb_price) ? globalThis.String(object.network_gb_price) : "",
      currency: isSet(object.currency) ? globalThis.String(object.currency) : "",
      minimumCharge: isSet(object.minimum_charge) ? globalThis.String(object.minimum_charge) : "",
    };
  },

  toJSON(message: HPCPricing): unknown {
    const obj: any = {};
    if (message.baseNodeHourPrice !== "") {
      obj.base_node_hour_price = message.baseNodeHourPrice;
    }
    if (message.cpuCoreHourPrice !== "") {
      obj.cpu_core_hour_price = message.cpuCoreHourPrice;
    }
    if (message.gpuHourPrice !== "") {
      obj.gpu_hour_price = message.gpuHourPrice;
    }
    if (message.memoryGbHourPrice !== "") {
      obj.memory_gb_hour_price = message.memoryGbHourPrice;
    }
    if (message.storageGbPrice !== "") {
      obj.storage_gb_price = message.storageGbPrice;
    }
    if (message.networkGbPrice !== "") {
      obj.network_gb_price = message.networkGbPrice;
    }
    if (message.currency !== "") {
      obj.currency = message.currency;
    }
    if (message.minimumCharge !== "") {
      obj.minimum_charge = message.minimumCharge;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCPricing>): HPCPricing {
    const message = createBaseHPCPricing();
    message.baseNodeHourPrice = object.baseNodeHourPrice ?? "";
    message.cpuCoreHourPrice = object.cpuCoreHourPrice ?? "";
    message.gpuHourPrice = object.gpuHourPrice ?? "";
    message.memoryGbHourPrice = object.memoryGbHourPrice ?? "";
    message.storageGbPrice = object.storageGbPrice ?? "";
    message.networkGbPrice = object.networkGbPrice ?? "";
    message.currency = object.currency ?? "";
    message.minimumCharge = object.minimumCharge ?? "";
    return message;
  },
};

function createBaseJobResources(): JobResources {
  return { nodes: 0, cpuCoresPerNode: 0, memoryGbPerNode: 0, gpusPerNode: 0, storageGb: 0, gpuType: "" };
}

export const JobResources: MessageFns<JobResources, "virtengine.hpc.v1.JobResources"> = {
  $type: "virtengine.hpc.v1.JobResources" as const,

  encode(message: JobResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodes !== 0) {
      writer.uint32(8).int32(message.nodes);
    }
    if (message.cpuCoresPerNode !== 0) {
      writer.uint32(16).int32(message.cpuCoresPerNode);
    }
    if (message.memoryGbPerNode !== 0) {
      writer.uint32(24).int32(message.memoryGbPerNode);
    }
    if (message.gpusPerNode !== 0) {
      writer.uint32(32).int32(message.gpusPerNode);
    }
    if (message.storageGb !== 0) {
      writer.uint32(40).int32(message.storageGb);
    }
    if (message.gpuType !== "") {
      writer.uint32(50).string(message.gpuType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nodes = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cpuCoresPerNode = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memoryGbPerNode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gpusPerNode = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageGb = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gpuType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobResources {
    return {
      nodes: isSet(object.nodes) ? globalThis.Number(object.nodes) : 0,
      cpuCoresPerNode: isSet(object.cpu_cores_per_node) ? globalThis.Number(object.cpu_cores_per_node) : 0,
      memoryGbPerNode: isSet(object.memory_gb_per_node) ? globalThis.Number(object.memory_gb_per_node) : 0,
      gpusPerNode: isSet(object.gpus_per_node) ? globalThis.Number(object.gpus_per_node) : 0,
      storageGb: isSet(object.storage_gb) ? globalThis.Number(object.storage_gb) : 0,
      gpuType: isSet(object.gpu_type) ? globalThis.String(object.gpu_type) : "",
    };
  },

  toJSON(message: JobResources): unknown {
    const obj: any = {};
    if (message.nodes !== 0) {
      obj.nodes = Math.round(message.nodes);
    }
    if (message.cpuCoresPerNode !== 0) {
      obj.cpu_cores_per_node = Math.round(message.cpuCoresPerNode);
    }
    if (message.memoryGbPerNode !== 0) {
      obj.memory_gb_per_node = Math.round(message.memoryGbPerNode);
    }
    if (message.gpusPerNode !== 0) {
      obj.gpus_per_node = Math.round(message.gpusPerNode);
    }
    if (message.storageGb !== 0) {
      obj.storage_gb = Math.round(message.storageGb);
    }
    if (message.gpuType !== "") {
      obj.gpu_type = message.gpuType;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<JobResources>): JobResources {
    const message = createBaseJobResources();
    message.nodes = object.nodes ?? 0;
    message.cpuCoresPerNode = object.cpuCoresPerNode ?? 0;
    message.memoryGbPerNode = object.memoryGbPerNode ?? 0;
    message.gpusPerNode = object.gpusPerNode ?? 0;
    message.storageGb = object.storageGb ?? 0;
    message.gpuType = object.gpuType ?? "";
    return message;
  },
};

function createBasePreconfiguredWorkload(): PreconfiguredWorkload {
  return {
    workloadId: "",
    name: "",
    description: "",
    containerImage: "",
    defaultCommand: "",
    requiredResources: undefined,
    category: "",
    version: "",
  };
}

export const PreconfiguredWorkload: MessageFns<PreconfiguredWorkload, "virtengine.hpc.v1.PreconfiguredWorkload"> = {
  $type: "virtengine.hpc.v1.PreconfiguredWorkload" as const,

  encode(message: PreconfiguredWorkload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workloadId !== "") {
      writer.uint32(10).string(message.workloadId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.containerImage !== "") {
      writer.uint32(34).string(message.containerImage);
    }
    if (message.defaultCommand !== "") {
      writer.uint32(42).string(message.defaultCommand);
    }
    if (message.requiredResources !== undefined) {
      JobResources.encode(message.requiredResources, writer.uint32(50).fork()).join();
    }
    if (message.category !== "") {
      writer.uint32(58).string(message.category);
    }
    if (message.version !== "") {
      writer.uint32(66).string(message.version);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreconfiguredWorkload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreconfiguredWorkload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workloadId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.defaultCommand = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.requiredResources = JobResources.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.category = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.version = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreconfiguredWorkload {
    return {
      workloadId: isSet(object.workload_id) ? globalThis.String(object.workload_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      containerImage: isSet(object.container_image) ? globalThis.String(object.container_image) : "",
      defaultCommand: isSet(object.default_command) ? globalThis.String(object.default_command) : "",
      requiredResources: isSet(object.required_resources)
        ? JobResources.fromJSON(object.required_resources)
        : undefined,
      category: isSet(object.category) ? globalThis.String(object.category) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
    };
  },

  toJSON(message: PreconfiguredWorkload): unknown {
    const obj: any = {};
    if (message.workloadId !== "") {
      obj.workload_id = message.workloadId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.containerImage !== "") {
      obj.container_image = message.containerImage;
    }
    if (message.defaultCommand !== "") {
      obj.default_command = message.defaultCommand;
    }
    if (message.requiredResources !== undefined) {
      obj.required_resources = JobResources.toJSON(message.requiredResources);
    }
    if (message.category !== "") {
      obj.category = message.category;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<PreconfiguredWorkload>): PreconfiguredWorkload {
    const message = createBasePreconfiguredWorkload();
    message.workloadId = object.workloadId ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.containerImage = object.containerImage ?? "";
    message.defaultCommand = object.defaultCommand ?? "";
    message.requiredResources = (object.requiredResources !== undefined && object.requiredResources !== null)
      ? JobResources.fromPartial(object.requiredResources)
      : undefined;
    message.category = object.category ?? "";
    message.version = object.version ?? "";
    return message;
  },
};

function createBaseHPCOffering(): HPCOffering {
  return {
    offeringId: "",
    clusterId: "",
    providerAddress: "",
    name: "",
    description: "",
    queueOptions: [],
    pricing: undefined,
    requiredIdentityThreshold: 0,
    maxRuntimeSeconds: Long.ZERO,
    preconfiguredWorkloads: [],
    supportsCustomWorkloads: false,
    active: false,
    createdAt: undefined,
    updatedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const HPCOffering: MessageFns<HPCOffering, "virtengine.hpc.v1.HPCOffering"> = {
  $type: "virtengine.hpc.v1.HPCOffering" as const,

  encode(message: HPCOffering, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.offeringId !== "") {
      writer.uint32(10).string(message.offeringId);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(26).string(message.providerAddress);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.queueOptions) {
      QueueOption.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.pricing !== undefined) {
      HPCPricing.encode(message.pricing, writer.uint32(58).fork()).join();
    }
    if (message.requiredIdentityThreshold !== 0) {
      writer.uint32(64).int32(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.maxRuntimeSeconds.toString());
    }
    for (const v of message.preconfiguredWorkloads) {
      PreconfiguredWorkload.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.supportsCustomWorkloads !== false) {
      writer.uint32(88).bool(message.supportsCustomWorkloads);
    }
    if (message.active !== false) {
      writer.uint32(96).bool(message.active);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(106).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(114).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCOffering {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCOffering();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.offeringId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.queueOptions.push(QueueOption.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.pricing = HPCPricing.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.requiredIdentityThreshold = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.maxRuntimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.preconfiguredWorkloads.push(PreconfiguredWorkload.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.supportsCustomWorkloads = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCOffering {
    return {
      offeringId: isSet(object.offering_id) ? globalThis.String(object.offering_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      queueOptions: globalThis.Array.isArray(object?.queue_options)
        ? object.queue_options.map((e: any) => QueueOption.fromJSON(e))
        : [],
      pricing: isSet(object.pricing) ? HPCPricing.fromJSON(object.pricing) : undefined,
      requiredIdentityThreshold: isSet(object.required_identity_threshold)
        ? globalThis.Number(object.required_identity_threshold)
        : 0,
      maxRuntimeSeconds: isSet(object.max_runtime_seconds) ? Long.fromValue(object.max_runtime_seconds) : Long.ZERO,
      preconfiguredWorkloads: globalThis.Array.isArray(object?.preconfigured_workloads)
        ? object.preconfigured_workloads.map((e: any) => PreconfiguredWorkload.fromJSON(e))
        : [],
      supportsCustomWorkloads: isSet(object.supports_custom_workloads)
        ? globalThis.Boolean(object.supports_custom_workloads)
        : false,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: HPCOffering): unknown {
    const obj: any = {};
    if (message.offeringId !== "") {
      obj.offering_id = message.offeringId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.queueOptions?.length) {
      obj.queue_options = message.queueOptions.map((e) => QueueOption.toJSON(e));
    }
    if (message.pricing !== undefined) {
      obj.pricing = HPCPricing.toJSON(message.pricing);
    }
    if (message.requiredIdentityThreshold !== 0) {
      obj.required_identity_threshold = Math.round(message.requiredIdentityThreshold);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      obj.max_runtime_seconds = (message.maxRuntimeSeconds || Long.ZERO).toString();
    }
    if (message.preconfiguredWorkloads?.length) {
      obj.preconfigured_workloads = message.preconfiguredWorkloads.map((e) => PreconfiguredWorkload.toJSON(e));
    }
    if (message.supportsCustomWorkloads !== false) {
      obj.supports_custom_workloads = message.supportsCustomWorkloads;
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCOffering>): HPCOffering {
    const message = createBaseHPCOffering();
    message.offeringId = object.offeringId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.queueOptions = object.queueOptions?.map((e) => QueueOption.fromPartial(e)) || [];
    message.pricing = (object.pricing !== undefined && object.pricing !== null)
      ? HPCPricing.fromPartial(object.pricing)
      : undefined;
    message.requiredIdentityThreshold = object.requiredIdentityThreshold ?? 0;
    message.maxRuntimeSeconds = (object.maxRuntimeSeconds !== undefined && object.maxRuntimeSeconds !== null)
      ? Long.fromValue(object.maxRuntimeSeconds)
      : Long.ZERO;
    message.preconfiguredWorkloads = object.preconfiguredWorkloads?.map((e) => PreconfiguredWorkload.fromPartial(e)) ||
      [];
    message.supportsCustomWorkloads = object.supportsCustomWorkloads ?? false;
    message.active = object.active ?? false;
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseJobWorkloadSpec(): JobWorkloadSpec {
  return {
    containerImage: "",
    command: "",
    arguments: [],
    environment: {},
    workingDirectory: "",
    preconfiguredWorkloadId: "",
    isPreconfigured: false,
  };
}

export const JobWorkloadSpec: MessageFns<JobWorkloadSpec, "virtengine.hpc.v1.JobWorkloadSpec"> = {
  $type: "virtengine.hpc.v1.JobWorkloadSpec" as const,

  encode(message: JobWorkloadSpec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerImage !== "") {
      writer.uint32(10).string(message.containerImage);
    }
    if (message.command !== "") {
      writer.uint32(18).string(message.command);
    }
    for (const v of message.arguments) {
      writer.uint32(26).string(v!);
    }
    Object.entries(message.environment).forEach(([key, value]) => {
      JobWorkloadSpec_EnvironmentEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.workingDirectory !== "") {
      writer.uint32(42).string(message.workingDirectory);
    }
    if (message.preconfiguredWorkloadId !== "") {
      writer.uint32(50).string(message.preconfiguredWorkloadId);
    }
    if (message.isPreconfigured !== false) {
      writer.uint32(56).bool(message.isPreconfigured);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobWorkloadSpec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobWorkloadSpec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerImage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.arguments.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = JobWorkloadSpec_EnvironmentEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.environment[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.workingDirectory = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.preconfiguredWorkloadId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.isPreconfigured = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobWorkloadSpec {
    return {
      containerImage: isSet(object.container_image) ? globalThis.String(object.container_image) : "",
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => globalThis.String(e))
        : [],
      environment: isObject(object.environment)
        ? Object.entries(object.environment).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      workingDirectory: isSet(object.working_directory) ? globalThis.String(object.working_directory) : "",
      preconfiguredWorkloadId: isSet(object.preconfigured_workload_id)
        ? globalThis.String(object.preconfigured_workload_id)
        : "",
      isPreconfigured: isSet(object.is_preconfigured) ? globalThis.Boolean(object.is_preconfigured) : false,
    };
  },

  toJSON(message: JobWorkloadSpec): unknown {
    const obj: any = {};
    if (message.containerImage !== "") {
      obj.container_image = message.containerImage;
    }
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments;
    }
    if (message.environment) {
      const entries = Object.entries(message.environment);
      if (entries.length > 0) {
        obj.environment = {};
        entries.forEach(([k, v]) => {
          obj.environment[k] = v;
        });
      }
    }
    if (message.workingDirectory !== "") {
      obj.working_directory = message.workingDirectory;
    }
    if (message.preconfiguredWorkloadId !== "") {
      obj.preconfigured_workload_id = message.preconfiguredWorkloadId;
    }
    if (message.isPreconfigured !== false) {
      obj.is_preconfigured = message.isPreconfigured;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<JobWorkloadSpec>): JobWorkloadSpec {
    const message = createBaseJobWorkloadSpec();
    message.containerImage = object.containerImage ?? "";
    message.command = object.command ?? "";
    message.arguments = object.arguments?.map((e) => e) || [];
    message.environment = Object.entries(object.environment ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.workingDirectory = object.workingDirectory ?? "";
    message.preconfiguredWorkloadId = object.preconfiguredWorkloadId ?? "";
    message.isPreconfigured = object.isPreconfigured ?? false;
    return message;
  },
};

function createBaseJobWorkloadSpec_EnvironmentEntry(): JobWorkloadSpec_EnvironmentEntry {
  return { key: "", value: "" };
}

export const JobWorkloadSpec_EnvironmentEntry: MessageFns<
  JobWorkloadSpec_EnvironmentEntry,
  "virtengine.hpc.v1.JobWorkloadSpec.EnvironmentEntry"
> = {
  $type: "virtengine.hpc.v1.JobWorkloadSpec.EnvironmentEntry" as const,

  encode(message: JobWorkloadSpec_EnvironmentEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobWorkloadSpec_EnvironmentEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobWorkloadSpec_EnvironmentEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobWorkloadSpec_EnvironmentEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: JobWorkloadSpec_EnvironmentEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<JobWorkloadSpec_EnvironmentEntry>): JobWorkloadSpec_EnvironmentEntry {
    const message = createBaseJobWorkloadSpec_EnvironmentEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseDataReference(): DataReference {
  return { referenceId: "", type: "", uri: "", encrypted: false, checksum: "", sizeBytes: Long.ZERO };
}

export const DataReference: MessageFns<DataReference, "virtengine.hpc.v1.DataReference"> = {
  $type: "virtengine.hpc.v1.DataReference" as const,

  encode(message: DataReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.referenceId !== "") {
      writer.uint32(10).string(message.referenceId);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.uri !== "") {
      writer.uint32(26).string(message.uri);
    }
    if (message.encrypted !== false) {
      writer.uint32(32).bool(message.encrypted);
    }
    if (message.checksum !== "") {
      writer.uint32(42).string(message.checksum);
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.sizeBytes.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uri = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.encrypted = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.checksum = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sizeBytes = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataReference {
    return {
      referenceId: isSet(object.reference_id) ? globalThis.String(object.reference_id) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      uri: isSet(object.uri) ? globalThis.String(object.uri) : "",
      encrypted: isSet(object.encrypted) ? globalThis.Boolean(object.encrypted) : false,
      checksum: isSet(object.checksum) ? globalThis.String(object.checksum) : "",
      sizeBytes: isSet(object.size_bytes) ? Long.fromValue(object.size_bytes) : Long.ZERO,
    };
  },

  toJSON(message: DataReference): unknown {
    const obj: any = {};
    if (message.referenceId !== "") {
      obj.reference_id = message.referenceId;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.uri !== "") {
      obj.uri = message.uri;
    }
    if (message.encrypted !== false) {
      obj.encrypted = message.encrypted;
    }
    if (message.checksum !== "") {
      obj.checksum = message.checksum;
    }
    if (!message.sizeBytes.equals(Long.ZERO)) {
      obj.size_bytes = (message.sizeBytes || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DataReference>): DataReference {
    const message = createBaseDataReference();
    message.referenceId = object.referenceId ?? "";
    message.type = object.type ?? "";
    message.uri = object.uri ?? "";
    message.encrypted = object.encrypted ?? false;
    message.checksum = object.checksum ?? "";
    message.sizeBytes = (object.sizeBytes !== undefined && object.sizeBytes !== null)
      ? Long.fromValue(object.sizeBytes)
      : Long.ZERO;
    return message;
  },
};

function createBaseHPCUsageMetrics(): HPCUsageMetrics {
  return {
    wallClockSeconds: Long.ZERO,
    cpuCoreSeconds: Long.ZERO,
    memoryGbSeconds: Long.ZERO,
    gpuSeconds: Long.ZERO,
    storageGbHours: Long.ZERO,
    networkBytesIn: Long.ZERO,
    networkBytesOut: Long.ZERO,
    nodeHours: Long.ZERO,
    nodesUsed: 0,
  };
}

export const HPCUsageMetrics: MessageFns<HPCUsageMetrics, "virtengine.hpc.v1.HPCUsageMetrics"> = {
  $type: "virtengine.hpc.v1.HPCUsageMetrics" as const,

  encode(message: HPCUsageMetrics, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.wallClockSeconds.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.wallClockSeconds.toString());
    }
    if (!message.cpuCoreSeconds.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.cpuCoreSeconds.toString());
    }
    if (!message.memoryGbSeconds.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.memoryGbSeconds.toString());
    }
    if (!message.gpuSeconds.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.gpuSeconds.toString());
    }
    if (!message.storageGbHours.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.storageGbHours.toString());
    }
    if (!message.networkBytesIn.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.networkBytesIn.toString());
    }
    if (!message.networkBytesOut.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.networkBytesOut.toString());
    }
    if (!message.nodeHours.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.nodeHours.toString());
    }
    if (message.nodesUsed !== 0) {
      writer.uint32(72).int32(message.nodesUsed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCUsageMetrics {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCUsageMetrics();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.wallClockSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cpuCoreSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.memoryGbSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.gpuSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageGbHours = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.networkBytesIn = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.networkBytesOut = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.nodeHours = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.nodesUsed = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCUsageMetrics {
    return {
      wallClockSeconds: isSet(object.wall_clock_seconds) ? Long.fromValue(object.wall_clock_seconds) : Long.ZERO,
      cpuCoreSeconds: isSet(object.cpu_core_seconds) ? Long.fromValue(object.cpu_core_seconds) : Long.ZERO,
      memoryGbSeconds: isSet(object.memory_gb_seconds) ? Long.fromValue(object.memory_gb_seconds) : Long.ZERO,
      gpuSeconds: isSet(object.gpu_seconds) ? Long.fromValue(object.gpu_seconds) : Long.ZERO,
      storageGbHours: isSet(object.storage_gb_hours) ? Long.fromValue(object.storage_gb_hours) : Long.ZERO,
      networkBytesIn: isSet(object.network_bytes_in) ? Long.fromValue(object.network_bytes_in) : Long.ZERO,
      networkBytesOut: isSet(object.network_bytes_out) ? Long.fromValue(object.network_bytes_out) : Long.ZERO,
      nodeHours: isSet(object.node_hours) ? Long.fromValue(object.node_hours) : Long.ZERO,
      nodesUsed: isSet(object.nodes_used) ? globalThis.Number(object.nodes_used) : 0,
    };
  },

  toJSON(message: HPCUsageMetrics): unknown {
    const obj: any = {};
    if (!message.wallClockSeconds.equals(Long.ZERO)) {
      obj.wall_clock_seconds = (message.wallClockSeconds || Long.ZERO).toString();
    }
    if (!message.cpuCoreSeconds.equals(Long.ZERO)) {
      obj.cpu_core_seconds = (message.cpuCoreSeconds || Long.ZERO).toString();
    }
    if (!message.memoryGbSeconds.equals(Long.ZERO)) {
      obj.memory_gb_seconds = (message.memoryGbSeconds || Long.ZERO).toString();
    }
    if (!message.gpuSeconds.equals(Long.ZERO)) {
      obj.gpu_seconds = (message.gpuSeconds || Long.ZERO).toString();
    }
    if (!message.storageGbHours.equals(Long.ZERO)) {
      obj.storage_gb_hours = (message.storageGbHours || Long.ZERO).toString();
    }
    if (!message.networkBytesIn.equals(Long.ZERO)) {
      obj.network_bytes_in = (message.networkBytesIn || Long.ZERO).toString();
    }
    if (!message.networkBytesOut.equals(Long.ZERO)) {
      obj.network_bytes_out = (message.networkBytesOut || Long.ZERO).toString();
    }
    if (!message.nodeHours.equals(Long.ZERO)) {
      obj.node_hours = (message.nodeHours || Long.ZERO).toString();
    }
    if (message.nodesUsed !== 0) {
      obj.nodes_used = Math.round(message.nodesUsed);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCUsageMetrics>): HPCUsageMetrics {
    const message = createBaseHPCUsageMetrics();
    message.wallClockSeconds = (object.wallClockSeconds !== undefined && object.wallClockSeconds !== null)
      ? Long.fromValue(object.wallClockSeconds)
      : Long.ZERO;
    message.cpuCoreSeconds = (object.cpuCoreSeconds !== undefined && object.cpuCoreSeconds !== null)
      ? Long.fromValue(object.cpuCoreSeconds)
      : Long.ZERO;
    message.memoryGbSeconds = (object.memoryGbSeconds !== undefined && object.memoryGbSeconds !== null)
      ? Long.fromValue(object.memoryGbSeconds)
      : Long.ZERO;
    message.gpuSeconds = (object.gpuSeconds !== undefined && object.gpuSeconds !== null)
      ? Long.fromValue(object.gpuSeconds)
      : Long.ZERO;
    message.storageGbHours = (object.storageGbHours !== undefined && object.storageGbHours !== null)
      ? Long.fromValue(object.storageGbHours)
      : Long.ZERO;
    message.networkBytesIn = (object.networkBytesIn !== undefined && object.networkBytesIn !== null)
      ? Long.fromValue(object.networkBytesIn)
      : Long.ZERO;
    message.networkBytesOut = (object.networkBytesOut !== undefined && object.networkBytesOut !== null)
      ? Long.fromValue(object.networkBytesOut)
      : Long.ZERO;
    message.nodeHours = (object.nodeHours !== undefined && object.nodeHours !== null)
      ? Long.fromValue(object.nodeHours)
      : Long.ZERO;
    message.nodesUsed = object.nodesUsed ?? 0;
    return message;
  },
};

function createBaseHPCJob(): HPCJob {
  return {
    jobId: "",
    offeringId: "",
    clusterId: "",
    providerAddress: "",
    customerAddress: "",
    slurmJobId: "",
    state: 0,
    queueName: "",
    workloadSpec: undefined,
    resources: undefined,
    dataReferences: [],
    encryptedInputsPointer: "",
    encryptedOutputsPointer: "",
    maxRuntimeSeconds: Long.ZERO,
    agreedPrice: [],
    escrowId: "",
    schedulingDecisionId: "",
    statusMessage: "",
    exitCode: 0,
    createdAt: undefined,
    queuedAt: undefined,
    startedAt: undefined,
    completedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const HPCJob: MessageFns<HPCJob, "virtengine.hpc.v1.HPCJob"> = {
  $type: "virtengine.hpc.v1.HPCJob" as const,

  encode(message: HPCJob, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.offeringId !== "") {
      writer.uint32(18).string(message.offeringId);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(34).string(message.providerAddress);
    }
    if (message.customerAddress !== "") {
      writer.uint32(42).string(message.customerAddress);
    }
    if (message.slurmJobId !== "") {
      writer.uint32(50).string(message.slurmJobId);
    }
    if (message.state !== 0) {
      writer.uint32(56).int32(message.state);
    }
    if (message.queueName !== "") {
      writer.uint32(66).string(message.queueName);
    }
    if (message.workloadSpec !== undefined) {
      JobWorkloadSpec.encode(message.workloadSpec, writer.uint32(74).fork()).join();
    }
    if (message.resources !== undefined) {
      JobResources.encode(message.resources, writer.uint32(82).fork()).join();
    }
    for (const v of message.dataReferences) {
      DataReference.encode(v!, writer.uint32(90).fork()).join();
    }
    if (message.encryptedInputsPointer !== "") {
      writer.uint32(98).string(message.encryptedInputsPointer);
    }
    if (message.encryptedOutputsPointer !== "") {
      writer.uint32(106).string(message.encryptedOutputsPointer);
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.maxRuntimeSeconds.toString());
    }
    for (const v of message.agreedPrice) {
      Coin.encode(v!, writer.uint32(122).fork()).join();
    }
    if (message.escrowId !== "") {
      writer.uint32(130).string(message.escrowId);
    }
    if (message.schedulingDecisionId !== "") {
      writer.uint32(138).string(message.schedulingDecisionId);
    }
    if (message.statusMessage !== "") {
      writer.uint32(146).string(message.statusMessage);
    }
    if (message.exitCode !== 0) {
      writer.uint32(152).int32(message.exitCode);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(162).fork()).join();
    }
    if (message.queuedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.queuedAt), writer.uint32(170).fork()).join();
    }
    if (message.startedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.startedAt), writer.uint32(178).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(186).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(192).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCJob {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCJob();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.offeringId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.customerAddress = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.slurmJobId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.queueName = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.workloadSpec = JobWorkloadSpec.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.resources = JobResources.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.dataReferences.push(DataReference.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.encryptedInputsPointer = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.encryptedOutputsPointer = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.maxRuntimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.agreedPrice.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.escrowId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.schedulingDecisionId = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.queuedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.startedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCJob {
    return {
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      offeringId: isSet(object.offering_id) ? globalThis.String(object.offering_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      customerAddress: isSet(object.customer_address) ? globalThis.String(object.customer_address) : "",
      slurmJobId: isSet(object.slurm_job_id) ? globalThis.String(object.slurm_job_id) : "",
      state: isSet(object.state) ? jobStateFromJSON(object.state) : 0,
      queueName: isSet(object.queue_name) ? globalThis.String(object.queue_name) : "",
      workloadSpec: isSet(object.workload_spec) ? JobWorkloadSpec.fromJSON(object.workload_spec) : undefined,
      resources: isSet(object.resources) ? JobResources.fromJSON(object.resources) : undefined,
      dataReferences: globalThis.Array.isArray(object?.data_references)
        ? object.data_references.map((e: any) => DataReference.fromJSON(e))
        : [],
      encryptedInputsPointer: isSet(object.encrypted_inputs_pointer)
        ? globalThis.String(object.encrypted_inputs_pointer)
        : "",
      encryptedOutputsPointer: isSet(object.encrypted_outputs_pointer)
        ? globalThis.String(object.encrypted_outputs_pointer)
        : "",
      maxRuntimeSeconds: isSet(object.max_runtime_seconds) ? Long.fromValue(object.max_runtime_seconds) : Long.ZERO,
      agreedPrice: globalThis.Array.isArray(object?.agreed_price)
        ? object.agreed_price.map((e: any) => Coin.fromJSON(e))
        : [],
      escrowId: isSet(object.escrow_id) ? globalThis.String(object.escrow_id) : "",
      schedulingDecisionId: isSet(object.scheduling_decision_id)
        ? globalThis.String(object.scheduling_decision_id)
        : "",
      statusMessage: isSet(object.status_message) ? globalThis.String(object.status_message) : "",
      exitCode: isSet(object.exit_code) ? globalThis.Number(object.exit_code) : 0,
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      queuedAt: isSet(object.queued_at) ? fromJsonTimestamp(object.queued_at) : undefined,
      startedAt: isSet(object.started_at) ? fromJsonTimestamp(object.started_at) : undefined,
      completedAt: isSet(object.completed_at) ? fromJsonTimestamp(object.completed_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: HPCJob): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.offeringId !== "") {
      obj.offering_id = message.offeringId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.customerAddress !== "") {
      obj.customer_address = message.customerAddress;
    }
    if (message.slurmJobId !== "") {
      obj.slurm_job_id = message.slurmJobId;
    }
    if (message.state !== 0) {
      obj.state = jobStateToJSON(message.state);
    }
    if (message.queueName !== "") {
      obj.queue_name = message.queueName;
    }
    if (message.workloadSpec !== undefined) {
      obj.workload_spec = JobWorkloadSpec.toJSON(message.workloadSpec);
    }
    if (message.resources !== undefined) {
      obj.resources = JobResources.toJSON(message.resources);
    }
    if (message.dataReferences?.length) {
      obj.data_references = message.dataReferences.map((e) => DataReference.toJSON(e));
    }
    if (message.encryptedInputsPointer !== "") {
      obj.encrypted_inputs_pointer = message.encryptedInputsPointer;
    }
    if (message.encryptedOutputsPointer !== "") {
      obj.encrypted_outputs_pointer = message.encryptedOutputsPointer;
    }
    if (!message.maxRuntimeSeconds.equals(Long.ZERO)) {
      obj.max_runtime_seconds = (message.maxRuntimeSeconds || Long.ZERO).toString();
    }
    if (message.agreedPrice?.length) {
      obj.agreed_price = message.agreedPrice.map((e) => Coin.toJSON(e));
    }
    if (message.escrowId !== "") {
      obj.escrow_id = message.escrowId;
    }
    if (message.schedulingDecisionId !== "") {
      obj.scheduling_decision_id = message.schedulingDecisionId;
    }
    if (message.statusMessage !== "") {
      obj.status_message = message.statusMessage;
    }
    if (message.exitCode !== 0) {
      obj.exit_code = Math.round(message.exitCode);
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.queuedAt !== undefined) {
      obj.queued_at = message.queuedAt.toISOString();
    }
    if (message.startedAt !== undefined) {
      obj.started_at = message.startedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completed_at = message.completedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCJob>): HPCJob {
    const message = createBaseHPCJob();
    message.jobId = object.jobId ?? "";
    message.offeringId = object.offeringId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.customerAddress = object.customerAddress ?? "";
    message.slurmJobId = object.slurmJobId ?? "";
    message.state = object.state ?? 0;
    message.queueName = object.queueName ?? "";
    message.workloadSpec = (object.workloadSpec !== undefined && object.workloadSpec !== null)
      ? JobWorkloadSpec.fromPartial(object.workloadSpec)
      : undefined;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? JobResources.fromPartial(object.resources)
      : undefined;
    message.dataReferences = object.dataReferences?.map((e) => DataReference.fromPartial(e)) || [];
    message.encryptedInputsPointer = object.encryptedInputsPointer ?? "";
    message.encryptedOutputsPointer = object.encryptedOutputsPointer ?? "";
    message.maxRuntimeSeconds = (object.maxRuntimeSeconds !== undefined && object.maxRuntimeSeconds !== null)
      ? Long.fromValue(object.maxRuntimeSeconds)
      : Long.ZERO;
    message.agreedPrice = object.agreedPrice?.map((e) => Coin.fromPartial(e)) || [];
    message.escrowId = object.escrowId ?? "";
    message.schedulingDecisionId = object.schedulingDecisionId ?? "";
    message.statusMessage = object.statusMessage ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.queuedAt = object.queuedAt ?? undefined;
    message.startedAt = object.startedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseNodeReward(): NodeReward {
  return { nodeId: "", providerAddress: "", amount: [], contributionWeight: "", usageSeconds: Long.ZERO };
}

export const NodeReward: MessageFns<NodeReward, "virtengine.hpc.v1.NodeReward"> = {
  $type: "virtengine.hpc.v1.NodeReward" as const,

  encode(message: NodeReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(18).string(message.providerAddress);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.contributionWeight !== "") {
      writer.uint32(34).string(message.contributionWeight);
    }
    if (!message.usageSeconds.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.usageSeconds.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contributionWeight = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.usageSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeReward {
    return {
      nodeId: isSet(object.node_id) ? globalThis.String(object.node_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
      contributionWeight: isSet(object.contribution_weight) ? globalThis.String(object.contribution_weight) : "",
      usageSeconds: isSet(object.usage_seconds) ? Long.fromValue(object.usage_seconds) : Long.ZERO,
    };
  },

  toJSON(message: NodeReward): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.node_id = message.nodeId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    if (message.contributionWeight !== "") {
      obj.contribution_weight = message.contributionWeight;
    }
    if (!message.usageSeconds.equals(Long.ZERO)) {
      obj.usage_seconds = (message.usageSeconds || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<NodeReward>): NodeReward {
    const message = createBaseNodeReward();
    message.nodeId = object.nodeId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.contributionWeight = object.contributionWeight ?? "";
    message.usageSeconds = (object.usageSeconds !== undefined && object.usageSeconds !== null)
      ? Long.fromValue(object.usageSeconds)
      : Long.ZERO;
    return message;
  },
};

function createBaseJobAccounting(): JobAccounting {
  return {
    jobId: "",
    clusterId: "",
    providerAddress: "",
    customerAddress: "",
    usageMetrics: undefined,
    totalCost: [],
    providerReward: [],
    nodeRewards: [],
    platformFee: [],
    settlementStatus: "",
    settlementId: "",
    signedUsageRecordIds: [],
    jobCompletionStatus: 0,
    createdAt: undefined,
    finalizedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const JobAccounting: MessageFns<JobAccounting, "virtengine.hpc.v1.JobAccounting"> = {
  $type: "virtengine.hpc.v1.JobAccounting" as const,

  encode(message: JobAccounting, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jobId !== "") {
      writer.uint32(10).string(message.jobId);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(26).string(message.providerAddress);
    }
    if (message.customerAddress !== "") {
      writer.uint32(34).string(message.customerAddress);
    }
    if (message.usageMetrics !== undefined) {
      HPCUsageMetrics.encode(message.usageMetrics, writer.uint32(42).fork()).join();
    }
    for (const v of message.totalCost) {
      Coin.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.providerReward) {
      Coin.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.nodeRewards) {
      NodeReward.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.platformFee) {
      Coin.encode(v!, writer.uint32(74).fork()).join();
    }
    if (message.settlementStatus !== "") {
      writer.uint32(82).string(message.settlementStatus);
    }
    if (message.settlementId !== "") {
      writer.uint32(90).string(message.settlementId);
    }
    for (const v of message.signedUsageRecordIds) {
      writer.uint32(98).string(v!);
    }
    if (message.jobCompletionStatus !== 0) {
      writer.uint32(104).int32(message.jobCompletionStatus);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(114).fork()).join();
    }
    if (message.finalizedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.finalizedAt), writer.uint32(122).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JobAccounting {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJobAccounting();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.customerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.usageMetrics = HPCUsageMetrics.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalCost.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.providerReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.nodeRewards.push(NodeReward.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.platformFee.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.settlementStatus = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.settlementId = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.signedUsageRecordIds.push(reader.string());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.jobCompletionStatus = reader.int32() as any;
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.finalizedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JobAccounting {
    return {
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      customerAddress: isSet(object.customer_address) ? globalThis.String(object.customer_address) : "",
      usageMetrics: isSet(object.usage_metrics) ? HPCUsageMetrics.fromJSON(object.usage_metrics) : undefined,
      totalCost: globalThis.Array.isArray(object?.total_cost)
        ? object.total_cost.map((e: any) => Coin.fromJSON(e))
        : [],
      providerReward: globalThis.Array.isArray(object?.provider_reward)
        ? object.provider_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      nodeRewards: globalThis.Array.isArray(object?.node_rewards)
        ? object.node_rewards.map((e: any) => NodeReward.fromJSON(e))
        : [],
      platformFee: globalThis.Array.isArray(object?.platform_fee)
        ? object.platform_fee.map((e: any) => Coin.fromJSON(e))
        : [],
      settlementStatus: isSet(object.settlement_status) ? globalThis.String(object.settlement_status) : "",
      settlementId: isSet(object.settlement_id) ? globalThis.String(object.settlement_id) : "",
      signedUsageRecordIds: globalThis.Array.isArray(object?.signed_usage_record_ids)
        ? object.signed_usage_record_ids.map((e: any) => globalThis.String(e))
        : [],
      jobCompletionStatus: isSet(object.job_completion_status) ? jobStateFromJSON(object.job_completion_status) : 0,
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      finalizedAt: isSet(object.finalized_at) ? fromJsonTimestamp(object.finalized_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: JobAccounting): unknown {
    const obj: any = {};
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.customerAddress !== "") {
      obj.customer_address = message.customerAddress;
    }
    if (message.usageMetrics !== undefined) {
      obj.usage_metrics = HPCUsageMetrics.toJSON(message.usageMetrics);
    }
    if (message.totalCost?.length) {
      obj.total_cost = message.totalCost.map((e) => Coin.toJSON(e));
    }
    if (message.providerReward?.length) {
      obj.provider_reward = message.providerReward.map((e) => Coin.toJSON(e));
    }
    if (message.nodeRewards?.length) {
      obj.node_rewards = message.nodeRewards.map((e) => NodeReward.toJSON(e));
    }
    if (message.platformFee?.length) {
      obj.platform_fee = message.platformFee.map((e) => Coin.toJSON(e));
    }
    if (message.settlementStatus !== "") {
      obj.settlement_status = message.settlementStatus;
    }
    if (message.settlementId !== "") {
      obj.settlement_id = message.settlementId;
    }
    if (message.signedUsageRecordIds?.length) {
      obj.signed_usage_record_ids = message.signedUsageRecordIds;
    }
    if (message.jobCompletionStatus !== 0) {
      obj.job_completion_status = jobStateToJSON(message.jobCompletionStatus);
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.finalizedAt !== undefined) {
      obj.finalized_at = message.finalizedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<JobAccounting>): JobAccounting {
    const message = createBaseJobAccounting();
    message.jobId = object.jobId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.customerAddress = object.customerAddress ?? "";
    message.usageMetrics = (object.usageMetrics !== undefined && object.usageMetrics !== null)
      ? HPCUsageMetrics.fromPartial(object.usageMetrics)
      : undefined;
    message.totalCost = object.totalCost?.map((e) => Coin.fromPartial(e)) || [];
    message.providerReward = object.providerReward?.map((e) => Coin.fromPartial(e)) || [];
    message.nodeRewards = object.nodeRewards?.map((e) => NodeReward.fromPartial(e)) || [];
    message.platformFee = object.platformFee?.map((e) => Coin.fromPartial(e)) || [];
    message.settlementStatus = object.settlementStatus ?? "";
    message.settlementId = object.settlementId ?? "";
    message.signedUsageRecordIds = object.signedUsageRecordIds?.map((e) => e) || [];
    message.jobCompletionStatus = object.jobCompletionStatus ?? 0;
    message.createdAt = object.createdAt ?? undefined;
    message.finalizedAt = object.finalizedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseLatencyMeasurement(): LatencyMeasurement {
  return { targetNodeId: "", latencyMs: Long.ZERO, measuredAt: undefined };
}

export const LatencyMeasurement: MessageFns<LatencyMeasurement, "virtengine.hpc.v1.LatencyMeasurement"> = {
  $type: "virtengine.hpc.v1.LatencyMeasurement" as const,

  encode(message: LatencyMeasurement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetNodeId !== "") {
      writer.uint32(10).string(message.targetNodeId);
    }
    if (!message.latencyMs.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.latencyMs.toString());
    }
    if (message.measuredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.measuredAt), writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LatencyMeasurement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLatencyMeasurement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.targetNodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.latencyMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.measuredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LatencyMeasurement {
    return {
      targetNodeId: isSet(object.target_node_id) ? globalThis.String(object.target_node_id) : "",
      latencyMs: isSet(object.latency_ms) ? Long.fromValue(object.latency_ms) : Long.ZERO,
      measuredAt: isSet(object.measured_at) ? fromJsonTimestamp(object.measured_at) : undefined,
    };
  },

  toJSON(message: LatencyMeasurement): unknown {
    const obj: any = {};
    if (message.targetNodeId !== "") {
      obj.target_node_id = message.targetNodeId;
    }
    if (!message.latencyMs.equals(Long.ZERO)) {
      obj.latency_ms = (message.latencyMs || Long.ZERO).toString();
    }
    if (message.measuredAt !== undefined) {
      obj.measured_at = message.measuredAt.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<LatencyMeasurement>): LatencyMeasurement {
    const message = createBaseLatencyMeasurement();
    message.targetNodeId = object.targetNodeId ?? "";
    message.latencyMs = (object.latencyMs !== undefined && object.latencyMs !== null)
      ? Long.fromValue(object.latencyMs)
      : Long.ZERO;
    message.measuredAt = object.measuredAt ?? undefined;
    return message;
  },
};

function createBaseNodeResources(): NodeResources {
  return { cpuCores: 0, memoryGb: 0, gpus: 0, gpuType: "", storageGb: 0 };
}

export const NodeResources: MessageFns<NodeResources, "virtengine.hpc.v1.NodeResources"> = {
  $type: "virtengine.hpc.v1.NodeResources" as const,

  encode(message: NodeResources, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpuCores !== 0) {
      writer.uint32(8).int32(message.cpuCores);
    }
    if (message.memoryGb !== 0) {
      writer.uint32(16).int32(message.memoryGb);
    }
    if (message.gpus !== 0) {
      writer.uint32(24).int32(message.gpus);
    }
    if (message.gpuType !== "") {
      writer.uint32(34).string(message.gpuType);
    }
    if (message.storageGb !== 0) {
      writer.uint32(40).int32(message.storageGb);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeResources {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeResources();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.cpuCores = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.memoryGb = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.gpus = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.gpuType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.storageGb = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeResources {
    return {
      cpuCores: isSet(object.cpu_cores) ? globalThis.Number(object.cpu_cores) : 0,
      memoryGb: isSet(object.memory_gb) ? globalThis.Number(object.memory_gb) : 0,
      gpus: isSet(object.gpus) ? globalThis.Number(object.gpus) : 0,
      gpuType: isSet(object.gpu_type) ? globalThis.String(object.gpu_type) : "",
      storageGb: isSet(object.storage_gb) ? globalThis.Number(object.storage_gb) : 0,
    };
  },

  toJSON(message: NodeResources): unknown {
    const obj: any = {};
    if (message.cpuCores !== 0) {
      obj.cpu_cores = Math.round(message.cpuCores);
    }
    if (message.memoryGb !== 0) {
      obj.memory_gb = Math.round(message.memoryGb);
    }
    if (message.gpus !== 0) {
      obj.gpus = Math.round(message.gpus);
    }
    if (message.gpuType !== "") {
      obj.gpu_type = message.gpuType;
    }
    if (message.storageGb !== 0) {
      obj.storage_gb = Math.round(message.storageGb);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<NodeResources>): NodeResources {
    const message = createBaseNodeResources();
    message.cpuCores = object.cpuCores ?? 0;
    message.memoryGb = object.memoryGb ?? 0;
    message.gpus = object.gpus ?? 0;
    message.gpuType = object.gpuType ?? "";
    message.storageGb = object.storageGb ?? 0;
    return message;
  },
};

function createBaseNodeMetadata(): NodeMetadata {
  return {
    nodeId: "",
    clusterId: "",
    providerAddress: "",
    region: "",
    datacenter: "",
    latencyMeasurements: [],
    avgLatencyMs: Long.ZERO,
    networkBandwidthMbps: Long.ZERO,
    resources: undefined,
    active: false,
    lastHeartbeat: undefined,
    joinedAt: undefined,
    updatedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const NodeMetadata: MessageFns<NodeMetadata, "virtengine.hpc.v1.NodeMetadata"> = {
  $type: "virtengine.hpc.v1.NodeMetadata" as const,

  encode(message: NodeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.nodeId !== "") {
      writer.uint32(10).string(message.nodeId);
    }
    if (message.clusterId !== "") {
      writer.uint32(18).string(message.clusterId);
    }
    if (message.providerAddress !== "") {
      writer.uint32(26).string(message.providerAddress);
    }
    if (message.region !== "") {
      writer.uint32(34).string(message.region);
    }
    if (message.datacenter !== "") {
      writer.uint32(42).string(message.datacenter);
    }
    for (const v of message.latencyMeasurements) {
      LatencyMeasurement.encode(v!, writer.uint32(50).fork()).join();
    }
    if (!message.avgLatencyMs.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.avgLatencyMs.toString());
    }
    if (!message.networkBandwidthMbps.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.networkBandwidthMbps.toString());
    }
    if (message.resources !== undefined) {
      NodeResources.encode(message.resources, writer.uint32(74).fork()).join();
    }
    if (message.active !== false) {
      writer.uint32(80).bool(message.active);
    }
    if (message.lastHeartbeat !== undefined) {
      Timestamp.encode(toTimestamp(message.lastHeartbeat), writer.uint32(90).fork()).join();
    }
    if (message.joinedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.joinedAt), writer.uint32(98).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(106).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NodeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNodeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.datacenter = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.latencyMeasurements.push(LatencyMeasurement.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.avgLatencyMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.networkBandwidthMbps = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resources = NodeResources.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lastHeartbeat = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.joinedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): NodeMetadata {
    return {
      nodeId: isSet(object.node_id) ? globalThis.String(object.node_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      datacenter: isSet(object.datacenter) ? globalThis.String(object.datacenter) : "",
      latencyMeasurements: globalThis.Array.isArray(object?.latency_measurements)
        ? object.latency_measurements.map((e: any) => LatencyMeasurement.fromJSON(e))
        : [],
      avgLatencyMs: isSet(object.avg_latency_ms) ? Long.fromValue(object.avg_latency_ms) : Long.ZERO,
      networkBandwidthMbps: isSet(object.network_bandwidth_mbps)
        ? Long.fromValue(object.network_bandwidth_mbps)
        : Long.ZERO,
      resources: isSet(object.resources) ? NodeResources.fromJSON(object.resources) : undefined,
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      lastHeartbeat: isSet(object.last_heartbeat) ? fromJsonTimestamp(object.last_heartbeat) : undefined,
      joinedAt: isSet(object.joined_at) ? fromJsonTimestamp(object.joined_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: NodeMetadata): unknown {
    const obj: any = {};
    if (message.nodeId !== "") {
      obj.node_id = message.nodeId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.datacenter !== "") {
      obj.datacenter = message.datacenter;
    }
    if (message.latencyMeasurements?.length) {
      obj.latency_measurements = message.latencyMeasurements.map((e) => LatencyMeasurement.toJSON(e));
    }
    if (!message.avgLatencyMs.equals(Long.ZERO)) {
      obj.avg_latency_ms = (message.avgLatencyMs || Long.ZERO).toString();
    }
    if (!message.networkBandwidthMbps.equals(Long.ZERO)) {
      obj.network_bandwidth_mbps = (message.networkBandwidthMbps || Long.ZERO).toString();
    }
    if (message.resources !== undefined) {
      obj.resources = NodeResources.toJSON(message.resources);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.lastHeartbeat !== undefined) {
      obj.last_heartbeat = message.lastHeartbeat.toISOString();
    }
    if (message.joinedAt !== undefined) {
      obj.joined_at = message.joinedAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<NodeMetadata>): NodeMetadata {
    const message = createBaseNodeMetadata();
    message.nodeId = object.nodeId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.region = object.region ?? "";
    message.datacenter = object.datacenter ?? "";
    message.latencyMeasurements = object.latencyMeasurements?.map((e) => LatencyMeasurement.fromPartial(e)) || [];
    message.avgLatencyMs = (object.avgLatencyMs !== undefined && object.avgLatencyMs !== null)
      ? Long.fromValue(object.avgLatencyMs)
      : Long.ZERO;
    message.networkBandwidthMbps = (object.networkBandwidthMbps !== undefined && object.networkBandwidthMbps !== null)
      ? Long.fromValue(object.networkBandwidthMbps)
      : Long.ZERO;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? NodeResources.fromPartial(object.resources)
      : undefined;
    message.active = object.active ?? false;
    message.lastHeartbeat = object.lastHeartbeat ?? undefined;
    message.joinedAt = object.joinedAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseClusterCandidate(): ClusterCandidate {
  return {
    clusterId: "",
    region: "",
    avgLatencyMs: Long.ZERO,
    availableNodes: 0,
    latencyScore: "",
    capacityScore: "",
    combinedScore: "",
    eligible: false,
    ineligibilityReason: "",
  };
}

export const ClusterCandidate: MessageFns<ClusterCandidate, "virtengine.hpc.v1.ClusterCandidate"> = {
  $type: "virtengine.hpc.v1.ClusterCandidate" as const,

  encode(message: ClusterCandidate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clusterId !== "") {
      writer.uint32(10).string(message.clusterId);
    }
    if (message.region !== "") {
      writer.uint32(18).string(message.region);
    }
    if (!message.avgLatencyMs.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.avgLatencyMs.toString());
    }
    if (message.availableNodes !== 0) {
      writer.uint32(32).int32(message.availableNodes);
    }
    if (message.latencyScore !== "") {
      writer.uint32(42).string(message.latencyScore);
    }
    if (message.capacityScore !== "") {
      writer.uint32(50).string(message.capacityScore);
    }
    if (message.combinedScore !== "") {
      writer.uint32(58).string(message.combinedScore);
    }
    if (message.eligible !== false) {
      writer.uint32(64).bool(message.eligible);
    }
    if (message.ineligibilityReason !== "") {
      writer.uint32(74).string(message.ineligibilityReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterCandidate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterCandidate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.avgLatencyMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.availableNodes = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.latencyScore = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.capacityScore = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.combinedScore = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.eligible = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.ineligibilityReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterCandidate {
    return {
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      avgLatencyMs: isSet(object.avg_latency_ms) ? Long.fromValue(object.avg_latency_ms) : Long.ZERO,
      availableNodes: isSet(object.available_nodes) ? globalThis.Number(object.available_nodes) : 0,
      latencyScore: isSet(object.latency_score) ? globalThis.String(object.latency_score) : "",
      capacityScore: isSet(object.capacity_score) ? globalThis.String(object.capacity_score) : "",
      combinedScore: isSet(object.combined_score) ? globalThis.String(object.combined_score) : "",
      eligible: isSet(object.eligible) ? globalThis.Boolean(object.eligible) : false,
      ineligibilityReason: isSet(object.ineligibility_reason) ? globalThis.String(object.ineligibility_reason) : "",
    };
  },

  toJSON(message: ClusterCandidate): unknown {
    const obj: any = {};
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (!message.avgLatencyMs.equals(Long.ZERO)) {
      obj.avg_latency_ms = (message.avgLatencyMs || Long.ZERO).toString();
    }
    if (message.availableNodes !== 0) {
      obj.available_nodes = Math.round(message.availableNodes);
    }
    if (message.latencyScore !== "") {
      obj.latency_score = message.latencyScore;
    }
    if (message.capacityScore !== "") {
      obj.capacity_score = message.capacityScore;
    }
    if (message.combinedScore !== "") {
      obj.combined_score = message.combinedScore;
    }
    if (message.eligible !== false) {
      obj.eligible = message.eligible;
    }
    if (message.ineligibilityReason !== "") {
      obj.ineligibility_reason = message.ineligibilityReason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ClusterCandidate>): ClusterCandidate {
    const message = createBaseClusterCandidate();
    message.clusterId = object.clusterId ?? "";
    message.region = object.region ?? "";
    message.avgLatencyMs = (object.avgLatencyMs !== undefined && object.avgLatencyMs !== null)
      ? Long.fromValue(object.avgLatencyMs)
      : Long.ZERO;
    message.availableNodes = object.availableNodes ?? 0;
    message.latencyScore = object.latencyScore ?? "";
    message.capacityScore = object.capacityScore ?? "";
    message.combinedScore = object.combinedScore ?? "";
    message.eligible = object.eligible ?? false;
    message.ineligibilityReason = object.ineligibilityReason ?? "";
    return message;
  },
};

function createBaseSchedulingDecision(): SchedulingDecision {
  return {
    decisionId: "",
    jobId: "",
    selectedClusterId: "",
    candidateClusters: [],
    decisionReason: "",
    isFallback: false,
    fallbackReason: "",
    latencyScore: "",
    capacityScore: "",
    combinedScore: "",
    createdAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const SchedulingDecision: MessageFns<SchedulingDecision, "virtengine.hpc.v1.SchedulingDecision"> = {
  $type: "virtengine.hpc.v1.SchedulingDecision" as const,

  encode(message: SchedulingDecision, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.decisionId !== "") {
      writer.uint32(10).string(message.decisionId);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.selectedClusterId !== "") {
      writer.uint32(26).string(message.selectedClusterId);
    }
    for (const v of message.candidateClusters) {
      ClusterCandidate.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.decisionReason !== "") {
      writer.uint32(42).string(message.decisionReason);
    }
    if (message.isFallback !== false) {
      writer.uint32(48).bool(message.isFallback);
    }
    if (message.fallbackReason !== "") {
      writer.uint32(58).string(message.fallbackReason);
    }
    if (message.latencyScore !== "") {
      writer.uint32(66).string(message.latencyScore);
    }
    if (message.capacityScore !== "") {
      writer.uint32(74).string(message.capacityScore);
    }
    if (message.combinedScore !== "") {
      writer.uint32(82).string(message.combinedScore);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(90).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SchedulingDecision {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSchedulingDecision();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.decisionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.selectedClusterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.candidateClusters.push(ClusterCandidate.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.decisionReason = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isFallback = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.fallbackReason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.latencyScore = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.capacityScore = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.combinedScore = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SchedulingDecision {
    return {
      decisionId: isSet(object.decision_id) ? globalThis.String(object.decision_id) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      selectedClusterId: isSet(object.selected_cluster_id) ? globalThis.String(object.selected_cluster_id) : "",
      candidateClusters: globalThis.Array.isArray(object?.candidate_clusters)
        ? object.candidate_clusters.map((e: any) => ClusterCandidate.fromJSON(e))
        : [],
      decisionReason: isSet(object.decision_reason) ? globalThis.String(object.decision_reason) : "",
      isFallback: isSet(object.is_fallback) ? globalThis.Boolean(object.is_fallback) : false,
      fallbackReason: isSet(object.fallback_reason) ? globalThis.String(object.fallback_reason) : "",
      latencyScore: isSet(object.latency_score) ? globalThis.String(object.latency_score) : "",
      capacityScore: isSet(object.capacity_score) ? globalThis.String(object.capacity_score) : "",
      combinedScore: isSet(object.combined_score) ? globalThis.String(object.combined_score) : "",
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: SchedulingDecision): unknown {
    const obj: any = {};
    if (message.decisionId !== "") {
      obj.decision_id = message.decisionId;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.selectedClusterId !== "") {
      obj.selected_cluster_id = message.selectedClusterId;
    }
    if (message.candidateClusters?.length) {
      obj.candidate_clusters = message.candidateClusters.map((e) => ClusterCandidate.toJSON(e));
    }
    if (message.decisionReason !== "") {
      obj.decision_reason = message.decisionReason;
    }
    if (message.isFallback !== false) {
      obj.is_fallback = message.isFallback;
    }
    if (message.fallbackReason !== "") {
      obj.fallback_reason = message.fallbackReason;
    }
    if (message.latencyScore !== "") {
      obj.latency_score = message.latencyScore;
    }
    if (message.capacityScore !== "") {
      obj.capacity_score = message.capacityScore;
    }
    if (message.combinedScore !== "") {
      obj.combined_score = message.combinedScore;
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<SchedulingDecision>): SchedulingDecision {
    const message = createBaseSchedulingDecision();
    message.decisionId = object.decisionId ?? "";
    message.jobId = object.jobId ?? "";
    message.selectedClusterId = object.selectedClusterId ?? "";
    message.candidateClusters = object.candidateClusters?.map((e) => ClusterCandidate.fromPartial(e)) || [];
    message.decisionReason = object.decisionReason ?? "";
    message.isFallback = object.isFallback ?? false;
    message.fallbackReason = object.fallbackReason ?? "";
    message.latencyScore = object.latencyScore ?? "";
    message.capacityScore = object.capacityScore ?? "";
    message.combinedScore = object.combinedScore ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseHPCRewardRecipient(): HPCRewardRecipient {
  return { address: "", amount: [], recipientType: "", nodeId: "", contributionWeight: "", reason: "" };
}

export const HPCRewardRecipient: MessageFns<HPCRewardRecipient, "virtengine.hpc.v1.HPCRewardRecipient"> = {
  $type: "virtengine.hpc.v1.HPCRewardRecipient" as const,

  encode(message: HPCRewardRecipient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== "") {
      writer.uint32(10).string(message.address);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.recipientType !== "") {
      writer.uint32(26).string(message.recipientType);
    }
    if (message.nodeId !== "") {
      writer.uint32(34).string(message.nodeId);
    }
    if (message.contributionWeight !== "") {
      writer.uint32(42).string(message.contributionWeight);
    }
    if (message.reason !== "") {
      writer.uint32(50).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCRewardRecipient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCRewardRecipient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.recipientType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.contributionWeight = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCRewardRecipient {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
      recipientType: isSet(object.recipient_type) ? globalThis.String(object.recipient_type) : "",
      nodeId: isSet(object.node_id) ? globalThis.String(object.node_id) : "",
      contributionWeight: isSet(object.contribution_weight) ? globalThis.String(object.contribution_weight) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: HPCRewardRecipient): unknown {
    const obj: any = {};
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    if (message.recipientType !== "") {
      obj.recipient_type = message.recipientType;
    }
    if (message.nodeId !== "") {
      obj.node_id = message.nodeId;
    }
    if (message.contributionWeight !== "") {
      obj.contribution_weight = message.contributionWeight;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCRewardRecipient>): HPCRewardRecipient {
    const message = createBaseHPCRewardRecipient();
    message.address = object.address ?? "";
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.recipientType = object.recipientType ?? "";
    message.nodeId = object.nodeId ?? "";
    message.contributionWeight = object.contributionWeight ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseRewardCalculationDetails(): RewardCalculationDetails {
  return {
    totalUsageValue: "",
    rewardPoolContribution: "",
    platformFeeRate: "",
    nodeContributionFormula: "",
    inputMetrics: {},
  };
}

export const RewardCalculationDetails: MessageFns<
  RewardCalculationDetails,
  "virtengine.hpc.v1.RewardCalculationDetails"
> = {
  $type: "virtengine.hpc.v1.RewardCalculationDetails" as const,

  encode(message: RewardCalculationDetails, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalUsageValue !== "") {
      writer.uint32(10).string(message.totalUsageValue);
    }
    if (message.rewardPoolContribution !== "") {
      writer.uint32(18).string(message.rewardPoolContribution);
    }
    if (message.platformFeeRate !== "") {
      writer.uint32(26).string(message.platformFeeRate);
    }
    if (message.nodeContributionFormula !== "") {
      writer.uint32(34).string(message.nodeContributionFormula);
    }
    Object.entries(message.inputMetrics).forEach(([key, value]) => {
      RewardCalculationDetails_InputMetricsEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardCalculationDetails {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardCalculationDetails();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.totalUsageValue = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rewardPoolContribution = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.platformFeeRate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodeContributionFormula = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = RewardCalculationDetails_InputMetricsEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.inputMetrics[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardCalculationDetails {
    return {
      totalUsageValue: isSet(object.total_usage_value) ? globalThis.String(object.total_usage_value) : "",
      rewardPoolContribution: isSet(object.reward_pool_contribution)
        ? globalThis.String(object.reward_pool_contribution)
        : "",
      platformFeeRate: isSet(object.platform_fee_rate) ? globalThis.String(object.platform_fee_rate) : "",
      nodeContributionFormula: isSet(object.node_contribution_formula)
        ? globalThis.String(object.node_contribution_formula)
        : "",
      inputMetrics: isObject(object.input_metrics)
        ? Object.entries(object.input_metrics).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RewardCalculationDetails): unknown {
    const obj: any = {};
    if (message.totalUsageValue !== "") {
      obj.total_usage_value = message.totalUsageValue;
    }
    if (message.rewardPoolContribution !== "") {
      obj.reward_pool_contribution = message.rewardPoolContribution;
    }
    if (message.platformFeeRate !== "") {
      obj.platform_fee_rate = message.platformFeeRate;
    }
    if (message.nodeContributionFormula !== "") {
      obj.node_contribution_formula = message.nodeContributionFormula;
    }
    if (message.inputMetrics) {
      const entries = Object.entries(message.inputMetrics);
      if (entries.length > 0) {
        obj.input_metrics = {};
        entries.forEach(([k, v]) => {
          obj.input_metrics[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<RewardCalculationDetails>): RewardCalculationDetails {
    const message = createBaseRewardCalculationDetails();
    message.totalUsageValue = object.totalUsageValue ?? "";
    message.rewardPoolContribution = object.rewardPoolContribution ?? "";
    message.platformFeeRate = object.platformFeeRate ?? "";
    message.nodeContributionFormula = object.nodeContributionFormula ?? "";
    message.inputMetrics = Object.entries(object.inputMetrics ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseRewardCalculationDetails_InputMetricsEntry(): RewardCalculationDetails_InputMetricsEntry {
  return { key: "", value: "" };
}

export const RewardCalculationDetails_InputMetricsEntry: MessageFns<
  RewardCalculationDetails_InputMetricsEntry,
  "virtengine.hpc.v1.RewardCalculationDetails.InputMetricsEntry"
> = {
  $type: "virtengine.hpc.v1.RewardCalculationDetails.InputMetricsEntry" as const,

  encode(message: RewardCalculationDetails_InputMetricsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardCalculationDetails_InputMetricsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardCalculationDetails_InputMetricsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardCalculationDetails_InputMetricsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RewardCalculationDetails_InputMetricsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(
    object: DeepPartial<RewardCalculationDetails_InputMetricsEntry>,
  ): RewardCalculationDetails_InputMetricsEntry {
    const message = createBaseRewardCalculationDetails_InputMetricsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseHPCRewardRecord(): HPCRewardRecord {
  return {
    rewardId: "",
    jobId: "",
    clusterId: "",
    source: 0,
    totalReward: [],
    recipients: [],
    referencedUsageRecords: [],
    jobCompletionStatus: 0,
    formulaVersion: "",
    calculationDetails: undefined,
    disputed: false,
    disputeId: "",
    issuedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const HPCRewardRecord: MessageFns<HPCRewardRecord, "virtengine.hpc.v1.HPCRewardRecord"> = {
  $type: "virtengine.hpc.v1.HPCRewardRecord" as const,

  encode(message: HPCRewardRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.rewardId !== "") {
      writer.uint32(10).string(message.rewardId);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.clusterId !== "") {
      writer.uint32(26).string(message.clusterId);
    }
    if (message.source !== 0) {
      writer.uint32(32).int32(message.source);
    }
    for (const v of message.totalReward) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.recipients) {
      HPCRewardRecipient.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.referencedUsageRecords) {
      writer.uint32(58).string(v!);
    }
    if (message.jobCompletionStatus !== 0) {
      writer.uint32(64).int32(message.jobCompletionStatus);
    }
    if (message.formulaVersion !== "") {
      writer.uint32(74).string(message.formulaVersion);
    }
    if (message.calculationDetails !== undefined) {
      RewardCalculationDetails.encode(message.calculationDetails, writer.uint32(82).fork()).join();
    }
    if (message.disputed !== false) {
      writer.uint32(88).bool(message.disputed);
    }
    if (message.disputeId !== "") {
      writer.uint32(98).string(message.disputeId);
    }
    if (message.issuedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.issuedAt), writer.uint32(106).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCRewardRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCRewardRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clusterId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.totalReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.recipients.push(HPCRewardRecipient.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referencedUsageRecords.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.jobCompletionStatus = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.formulaVersion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.calculationDetails = RewardCalculationDetails.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.disputed = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.disputeId = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.issuedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCRewardRecord {
    return {
      rewardId: isSet(object.reward_id) ? globalThis.String(object.reward_id) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      clusterId: isSet(object.cluster_id) ? globalThis.String(object.cluster_id) : "",
      source: isSet(object.source) ? hPCRewardSourceFromJSON(object.source) : 0,
      totalReward: globalThis.Array.isArray(object?.total_reward)
        ? object.total_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      recipients: globalThis.Array.isArray(object?.recipients)
        ? object.recipients.map((e: any) => HPCRewardRecipient.fromJSON(e))
        : [],
      referencedUsageRecords: globalThis.Array.isArray(object?.referenced_usage_records)
        ? object.referenced_usage_records.map((e: any) => globalThis.String(e))
        : [],
      jobCompletionStatus: isSet(object.job_completion_status) ? jobStateFromJSON(object.job_completion_status) : 0,
      formulaVersion: isSet(object.formula_version) ? globalThis.String(object.formula_version) : "",
      calculationDetails: isSet(object.calculation_details)
        ? RewardCalculationDetails.fromJSON(object.calculation_details)
        : undefined,
      disputed: isSet(object.disputed) ? globalThis.Boolean(object.disputed) : false,
      disputeId: isSet(object.dispute_id) ? globalThis.String(object.dispute_id) : "",
      issuedAt: isSet(object.issued_at) ? fromJsonTimestamp(object.issued_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: HPCRewardRecord): unknown {
    const obj: any = {};
    if (message.rewardId !== "") {
      obj.reward_id = message.rewardId;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.clusterId !== "") {
      obj.cluster_id = message.clusterId;
    }
    if (message.source !== 0) {
      obj.source = hPCRewardSourceToJSON(message.source);
    }
    if (message.totalReward?.length) {
      obj.total_reward = message.totalReward.map((e) => Coin.toJSON(e));
    }
    if (message.recipients?.length) {
      obj.recipients = message.recipients.map((e) => HPCRewardRecipient.toJSON(e));
    }
    if (message.referencedUsageRecords?.length) {
      obj.referenced_usage_records = message.referencedUsageRecords;
    }
    if (message.jobCompletionStatus !== 0) {
      obj.job_completion_status = jobStateToJSON(message.jobCompletionStatus);
    }
    if (message.formulaVersion !== "") {
      obj.formula_version = message.formulaVersion;
    }
    if (message.calculationDetails !== undefined) {
      obj.calculation_details = RewardCalculationDetails.toJSON(message.calculationDetails);
    }
    if (message.disputed !== false) {
      obj.disputed = message.disputed;
    }
    if (message.disputeId !== "") {
      obj.dispute_id = message.disputeId;
    }
    if (message.issuedAt !== undefined) {
      obj.issued_at = message.issuedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCRewardRecord>): HPCRewardRecord {
    const message = createBaseHPCRewardRecord();
    message.rewardId = object.rewardId ?? "";
    message.jobId = object.jobId ?? "";
    message.clusterId = object.clusterId ?? "";
    message.source = object.source ?? 0;
    message.totalReward = object.totalReward?.map((e) => Coin.fromPartial(e)) || [];
    message.recipients = object.recipients?.map((e) => HPCRewardRecipient.fromPartial(e)) || [];
    message.referencedUsageRecords = object.referencedUsageRecords?.map((e) => e) || [];
    message.jobCompletionStatus = object.jobCompletionStatus ?? 0;
    message.formulaVersion = object.formulaVersion ?? "";
    message.calculationDetails = (object.calculationDetails !== undefined && object.calculationDetails !== null)
      ? RewardCalculationDetails.fromPartial(object.calculationDetails)
      : undefined;
    message.disputed = object.disputed ?? false;
    message.disputeId = object.disputeId ?? "";
    message.issuedAt = object.issuedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseHPCDispute(): HPCDispute {
  return {
    disputeId: "",
    jobId: "",
    rewardId: "",
    disputerAddress: "",
    disputeType: "",
    reason: "",
    evidence: "",
    status: 0,
    resolution: "",
    resolverAddress: "",
    createdAt: undefined,
    resolvedAt: undefined,
    blockHeight: Long.ZERO,
  };
}

export const HPCDispute: MessageFns<HPCDispute, "virtengine.hpc.v1.HPCDispute"> = {
  $type: "virtengine.hpc.v1.HPCDispute" as const,

  encode(message: HPCDispute, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.disputeId !== "") {
      writer.uint32(10).string(message.disputeId);
    }
    if (message.jobId !== "") {
      writer.uint32(18).string(message.jobId);
    }
    if (message.rewardId !== "") {
      writer.uint32(26).string(message.rewardId);
    }
    if (message.disputerAddress !== "") {
      writer.uint32(34).string(message.disputerAddress);
    }
    if (message.disputeType !== "") {
      writer.uint32(42).string(message.disputeType);
    }
    if (message.reason !== "") {
      writer.uint32(50).string(message.reason);
    }
    if (message.evidence !== "") {
      writer.uint32(58).string(message.evidence);
    }
    if (message.status !== 0) {
      writer.uint32(64).int32(message.status);
    }
    if (message.resolution !== "") {
      writer.uint32(74).string(message.resolution);
    }
    if (message.resolverAddress !== "") {
      writer.uint32(82).string(message.resolverAddress);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(90).fork()).join();
    }
    if (message.resolvedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.resolvedAt), writer.uint32(98).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HPCDispute {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHPCDispute();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.disputeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.jobId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rewardId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.disputerAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.disputeType = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.evidence = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.resolution = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.resolverAddress = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.resolvedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HPCDispute {
    return {
      disputeId: isSet(object.dispute_id) ? globalThis.String(object.dispute_id) : "",
      jobId: isSet(object.job_id) ? globalThis.String(object.job_id) : "",
      rewardId: isSet(object.reward_id) ? globalThis.String(object.reward_id) : "",
      disputerAddress: isSet(object.disputer_address) ? globalThis.String(object.disputer_address) : "",
      disputeType: isSet(object.dispute_type) ? globalThis.String(object.dispute_type) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      evidence: isSet(object.evidence) ? globalThis.String(object.evidence) : "",
      status: isSet(object.status) ? disputeStatusFromJSON(object.status) : 0,
      resolution: isSet(object.resolution) ? globalThis.String(object.resolution) : "",
      resolverAddress: isSet(object.resolver_address) ? globalThis.String(object.resolver_address) : "",
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      resolvedAt: isSet(object.resolved_at) ? fromJsonTimestamp(object.resolved_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: HPCDispute): unknown {
    const obj: any = {};
    if (message.disputeId !== "") {
      obj.dispute_id = message.disputeId;
    }
    if (message.jobId !== "") {
      obj.job_id = message.jobId;
    }
    if (message.rewardId !== "") {
      obj.reward_id = message.rewardId;
    }
    if (message.disputerAddress !== "") {
      obj.disputer_address = message.disputerAddress;
    }
    if (message.disputeType !== "") {
      obj.dispute_type = message.disputeType;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.evidence !== "") {
      obj.evidence = message.evidence;
    }
    if (message.status !== 0) {
      obj.status = disputeStatusToJSON(message.status);
    }
    if (message.resolution !== "") {
      obj.resolution = message.resolution;
    }
    if (message.resolverAddress !== "") {
      obj.resolver_address = message.resolverAddress;
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.resolvedAt !== undefined) {
      obj.resolved_at = message.resolvedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HPCDispute>): HPCDispute {
    const message = createBaseHPCDispute();
    message.disputeId = object.disputeId ?? "";
    message.jobId = object.jobId ?? "";
    message.rewardId = object.rewardId ?? "";
    message.disputerAddress = object.disputerAddress ?? "";
    message.disputeType = object.disputeType ?? "";
    message.reason = object.reason ?? "";
    message.evidence = object.evidence ?? "";
    message.status = object.status ?? 0;
    message.resolution = object.resolution ?? "";
    message.resolverAddress = object.resolverAddress ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.resolvedAt = object.resolvedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseParams(): Params {
  return {
    platformFeeRate: "",
    providerRewardRate: "",
    nodeRewardRate: "",
    minJobDurationSeconds: Long.ZERO,
    maxJobDurationSeconds: Long.ZERO,
    defaultIdentityThreshold: 0,
    clusterHeartbeatTimeout: Long.ZERO,
    nodeHeartbeatTimeout: Long.ZERO,
    latencyWeightFactor: "",
    capacityWeightFactor: "",
    maxLatencyMs: Long.ZERO,
    disputeResolutionPeriod: Long.ZERO,
    rewardFormulaVersion: "",
    enableProximityClustering: false,
  };
}

export const Params: MessageFns<Params, "virtengine.hpc.v1.Params"> = {
  $type: "virtengine.hpc.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.platformFeeRate !== "") {
      writer.uint32(10).string(message.platformFeeRate);
    }
    if (message.providerRewardRate !== "") {
      writer.uint32(18).string(message.providerRewardRate);
    }
    if (message.nodeRewardRate !== "") {
      writer.uint32(26).string(message.nodeRewardRate);
    }
    if (!message.minJobDurationSeconds.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.minJobDurationSeconds.toString());
    }
    if (!message.maxJobDurationSeconds.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.maxJobDurationSeconds.toString());
    }
    if (message.defaultIdentityThreshold !== 0) {
      writer.uint32(48).int32(message.defaultIdentityThreshold);
    }
    if (!message.clusterHeartbeatTimeout.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.clusterHeartbeatTimeout.toString());
    }
    if (!message.nodeHeartbeatTimeout.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.nodeHeartbeatTimeout.toString());
    }
    if (message.latencyWeightFactor !== "") {
      writer.uint32(74).string(message.latencyWeightFactor);
    }
    if (message.capacityWeightFactor !== "") {
      writer.uint32(82).string(message.capacityWeightFactor);
    }
    if (!message.maxLatencyMs.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.maxLatencyMs.toString());
    }
    if (!message.disputeResolutionPeriod.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.disputeResolutionPeriod.toString());
    }
    if (message.rewardFormulaVersion !== "") {
      writer.uint32(106).string(message.rewardFormulaVersion);
    }
    if (message.enableProximityClustering !== false) {
      writer.uint32(112).bool(message.enableProximityClustering);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.platformFeeRate = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerRewardRate = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nodeRewardRate = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minJobDurationSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxJobDurationSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.defaultIdentityThreshold = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.clusterHeartbeatTimeout = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.nodeHeartbeatTimeout = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.latencyWeightFactor = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.capacityWeightFactor = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.maxLatencyMs = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.disputeResolutionPeriod = Long.fromString(reader.int64().toString());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.rewardFormulaVersion = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.enableProximityClustering = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      platformFeeRate: isSet(object.platform_fee_rate) ? globalThis.String(object.platform_fee_rate) : "",
      providerRewardRate: isSet(object.provider_reward_rate) ? globalThis.String(object.provider_reward_rate) : "",
      nodeRewardRate: isSet(object.node_reward_rate) ? globalThis.String(object.node_reward_rate) : "",
      minJobDurationSeconds: isSet(object.min_job_duration_seconds)
        ? Long.fromValue(object.min_job_duration_seconds)
        : Long.ZERO,
      maxJobDurationSeconds: isSet(object.max_job_duration_seconds)
        ? Long.fromValue(object.max_job_duration_seconds)
        : Long.ZERO,
      defaultIdentityThreshold: isSet(object.default_identity_threshold)
        ? globalThis.Number(object.default_identity_threshold)
        : 0,
      clusterHeartbeatTimeout: isSet(object.cluster_heartbeat_timeout)
        ? Long.fromValue(object.cluster_heartbeat_timeout)
        : Long.ZERO,
      nodeHeartbeatTimeout: isSet(object.node_heartbeat_timeout)
        ? Long.fromValue(object.node_heartbeat_timeout)
        : Long.ZERO,
      latencyWeightFactor: isSet(object.latency_weight_factor) ? globalThis.String(object.latency_weight_factor) : "",
      capacityWeightFactor: isSet(object.capacity_weight_factor)
        ? globalThis.String(object.capacity_weight_factor)
        : "",
      maxLatencyMs: isSet(object.max_latency_ms) ? Long.fromValue(object.max_latency_ms) : Long.ZERO,
      disputeResolutionPeriod: isSet(object.dispute_resolution_period)
        ? Long.fromValue(object.dispute_resolution_period)
        : Long.ZERO,
      rewardFormulaVersion: isSet(object.reward_formula_version)
        ? globalThis.String(object.reward_formula_version)
        : "",
      enableProximityClustering: isSet(object.enable_proximity_clustering)
        ? globalThis.Boolean(object.enable_proximity_clustering)
        : false,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.platformFeeRate !== "") {
      obj.platform_fee_rate = message.platformFeeRate;
    }
    if (message.providerRewardRate !== "") {
      obj.provider_reward_rate = message.providerRewardRate;
    }
    if (message.nodeRewardRate !== "") {
      obj.node_reward_rate = message.nodeRewardRate;
    }
    if (!message.minJobDurationSeconds.equals(Long.ZERO)) {
      obj.min_job_duration_seconds = (message.minJobDurationSeconds || Long.ZERO).toString();
    }
    if (!message.maxJobDurationSeconds.equals(Long.ZERO)) {
      obj.max_job_duration_seconds = (message.maxJobDurationSeconds || Long.ZERO).toString();
    }
    if (message.defaultIdentityThreshold !== 0) {
      obj.default_identity_threshold = Math.round(message.defaultIdentityThreshold);
    }
    if (!message.clusterHeartbeatTimeout.equals(Long.ZERO)) {
      obj.cluster_heartbeat_timeout = (message.clusterHeartbeatTimeout || Long.ZERO).toString();
    }
    if (!message.nodeHeartbeatTimeout.equals(Long.ZERO)) {
      obj.node_heartbeat_timeout = (message.nodeHeartbeatTimeout || Long.ZERO).toString();
    }
    if (message.latencyWeightFactor !== "") {
      obj.latency_weight_factor = message.latencyWeightFactor;
    }
    if (message.capacityWeightFactor !== "") {
      obj.capacity_weight_factor = message.capacityWeightFactor;
    }
    if (!message.maxLatencyMs.equals(Long.ZERO)) {
      obj.max_latency_ms = (message.maxLatencyMs || Long.ZERO).toString();
    }
    if (!message.disputeResolutionPeriod.equals(Long.ZERO)) {
      obj.dispute_resolution_period = (message.disputeResolutionPeriod || Long.ZERO).toString();
    }
    if (message.rewardFormulaVersion !== "") {
      obj.reward_formula_version = message.rewardFormulaVersion;
    }
    if (message.enableProximityClustering !== false) {
      obj.enable_proximity_clustering = message.enableProximityClustering;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.platformFeeRate = object.platformFeeRate ?? "";
    message.providerRewardRate = object.providerRewardRate ?? "";
    message.nodeRewardRate = object.nodeRewardRate ?? "";
    message.minJobDurationSeconds =
      (object.minJobDurationSeconds !== undefined && object.minJobDurationSeconds !== null)
        ? Long.fromValue(object.minJobDurationSeconds)
        : Long.ZERO;
    message.maxJobDurationSeconds =
      (object.maxJobDurationSeconds !== undefined && object.maxJobDurationSeconds !== null)
        ? Long.fromValue(object.maxJobDurationSeconds)
        : Long.ZERO;
    message.defaultIdentityThreshold = object.defaultIdentityThreshold ?? 0;
    message.clusterHeartbeatTimeout =
      (object.clusterHeartbeatTimeout !== undefined && object.clusterHeartbeatTimeout !== null)
        ? Long.fromValue(object.clusterHeartbeatTimeout)
        : Long.ZERO;
    message.nodeHeartbeatTimeout = (object.nodeHeartbeatTimeout !== undefined && object.nodeHeartbeatTimeout !== null)
      ? Long.fromValue(object.nodeHeartbeatTimeout)
      : Long.ZERO;
    message.latencyWeightFactor = object.latencyWeightFactor ?? "";
    message.capacityWeightFactor = object.capacityWeightFactor ?? "";
    message.maxLatencyMs = (object.maxLatencyMs !== undefined && object.maxLatencyMs !== null)
      ? Long.fromValue(object.maxLatencyMs)
      : Long.ZERO;
    message.disputeResolutionPeriod =
      (object.disputeResolutionPeriod !== undefined && object.disputeResolutionPeriod !== null)
        ? Long.fromValue(object.disputeResolutionPeriod)
        : Long.ZERO;
    message.rewardFormulaVersion = object.rewardFormulaVersion ?? "";
    message.enableProximityClustering = object.enableProximityClustering ?? false;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
