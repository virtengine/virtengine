import { bytesFromBase64, base64FromBytes, toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/enclave/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** TEEType represents the type of Trusted Execution Environment */
export enum TEEType {
  /** TEE_TYPE_UNSPECIFIED - TEE_TYPE_UNSPECIFIED is the default/invalid TEE type */
  TEE_TYPE_UNSPECIFIED = 0,
  /** TEE_TYPE_SGX - TEE_TYPE_SGX is Intel SGX */
  TEE_TYPE_SGX = 1,
  /** TEE_TYPE_SEV_SNP - TEE_TYPE_SEV_SNP is AMD SEV-SNP */
  TEE_TYPE_SEV_SNP = 2,
  /** TEE_TYPE_NITRO - TEE_TYPE_NITRO is AWS Nitro Enclaves */
  TEE_TYPE_NITRO = 3,
  /** TEE_TYPE_TRUSTZONE - TEE_TYPE_TRUSTZONE is ARM TrustZone (future) */
  TEE_TYPE_TRUSTZONE = 4,
  UNRECOGNIZED = -1,
}

export function tEETypeFromJSON(object: any): TEEType {
  switch (object) {
    case 0:
    case "TEE_TYPE_UNSPECIFIED":
      return TEEType.TEE_TYPE_UNSPECIFIED;
    case 1:
    case "TEE_TYPE_SGX":
      return TEEType.TEE_TYPE_SGX;
    case 2:
    case "TEE_TYPE_SEV_SNP":
      return TEEType.TEE_TYPE_SEV_SNP;
    case 3:
    case "TEE_TYPE_NITRO":
      return TEEType.TEE_TYPE_NITRO;
    case 4:
    case "TEE_TYPE_TRUSTZONE":
      return TEEType.TEE_TYPE_TRUSTZONE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return TEEType.UNRECOGNIZED;
  }
}

export function tEETypeToJSON(object: TEEType): string {
  switch (object) {
    case TEEType.TEE_TYPE_UNSPECIFIED:
      return "TEE_TYPE_UNSPECIFIED";
    case TEEType.TEE_TYPE_SGX:
      return "TEE_TYPE_SGX";
    case TEEType.TEE_TYPE_SEV_SNP:
      return "TEE_TYPE_SEV_SNP";
    case TEEType.TEE_TYPE_NITRO:
      return "TEE_TYPE_NITRO";
    case TEEType.TEE_TYPE_TRUSTZONE:
      return "TEE_TYPE_TRUSTZONE";
    case TEEType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** EnclaveIdentityStatus represents the status of an enclave identity */
export enum EnclaveIdentityStatus {
  /** ENCLAVE_IDENTITY_STATUS_UNSPECIFIED - ENCLAVE_IDENTITY_STATUS_UNSPECIFIED is the default/invalid status */
  ENCLAVE_IDENTITY_STATUS_UNSPECIFIED = 0,
  /** ENCLAVE_IDENTITY_STATUS_ACTIVE - ENCLAVE_IDENTITY_STATUS_ACTIVE indicates the enclave identity is active */
  ENCLAVE_IDENTITY_STATUS_ACTIVE = 1,
  /** ENCLAVE_IDENTITY_STATUS_PENDING - ENCLAVE_IDENTITY_STATUS_PENDING indicates the enclave identity is pending verification */
  ENCLAVE_IDENTITY_STATUS_PENDING = 2,
  /** ENCLAVE_IDENTITY_STATUS_EXPIRED - ENCLAVE_IDENTITY_STATUS_EXPIRED indicates the enclave identity has expired */
  ENCLAVE_IDENTITY_STATUS_EXPIRED = 3,
  /** ENCLAVE_IDENTITY_STATUS_REVOKED - ENCLAVE_IDENTITY_STATUS_REVOKED indicates the enclave identity has been revoked */
  ENCLAVE_IDENTITY_STATUS_REVOKED = 4,
  /** ENCLAVE_IDENTITY_STATUS_ROTATING - ENCLAVE_IDENTITY_STATUS_ROTATING indicates key rotation is in progress */
  ENCLAVE_IDENTITY_STATUS_ROTATING = 5,
  UNRECOGNIZED = -1,
}

export function enclaveIdentityStatusFromJSON(object: any): EnclaveIdentityStatus {
  switch (object) {
    case 0:
    case "ENCLAVE_IDENTITY_STATUS_UNSPECIFIED":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_UNSPECIFIED;
    case 1:
    case "ENCLAVE_IDENTITY_STATUS_ACTIVE":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_ACTIVE;
    case 2:
    case "ENCLAVE_IDENTITY_STATUS_PENDING":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_PENDING;
    case 3:
    case "ENCLAVE_IDENTITY_STATUS_EXPIRED":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_EXPIRED;
    case 4:
    case "ENCLAVE_IDENTITY_STATUS_REVOKED":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_REVOKED;
    case 5:
    case "ENCLAVE_IDENTITY_STATUS_ROTATING":
      return EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_ROTATING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EnclaveIdentityStatus.UNRECOGNIZED;
  }
}

export function enclaveIdentityStatusToJSON(object: EnclaveIdentityStatus): string {
  switch (object) {
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_UNSPECIFIED:
      return "ENCLAVE_IDENTITY_STATUS_UNSPECIFIED";
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_ACTIVE:
      return "ENCLAVE_IDENTITY_STATUS_ACTIVE";
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_PENDING:
      return "ENCLAVE_IDENTITY_STATUS_PENDING";
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_EXPIRED:
      return "ENCLAVE_IDENTITY_STATUS_EXPIRED";
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_REVOKED:
      return "ENCLAVE_IDENTITY_STATUS_REVOKED";
    case EnclaveIdentityStatus.ENCLAVE_IDENTITY_STATUS_ROTATING:
      return "ENCLAVE_IDENTITY_STATUS_ROTATING";
    case EnclaveIdentityStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** KeyRotationStatus represents the status of a key rotation */
export enum KeyRotationStatus {
  /** KEY_ROTATION_STATUS_UNSPECIFIED - KEY_ROTATION_STATUS_UNSPECIFIED is the default/invalid status */
  KEY_ROTATION_STATUS_UNSPECIFIED = 0,
  /** KEY_ROTATION_STATUS_PENDING - KEY_ROTATION_STATUS_PENDING indicates rotation is pending */
  KEY_ROTATION_STATUS_PENDING = 1,
  /** KEY_ROTATION_STATUS_ACTIVE - KEY_ROTATION_STATUS_ACTIVE indicates rotation is active (overlap period) */
  KEY_ROTATION_STATUS_ACTIVE = 2,
  /** KEY_ROTATION_STATUS_COMPLETED - KEY_ROTATION_STATUS_COMPLETED indicates rotation is completed */
  KEY_ROTATION_STATUS_COMPLETED = 3,
  /** KEY_ROTATION_STATUS_CANCELLED - KEY_ROTATION_STATUS_CANCELLED indicates rotation was cancelled */
  KEY_ROTATION_STATUS_CANCELLED = 4,
  UNRECOGNIZED = -1,
}

export function keyRotationStatusFromJSON(object: any): KeyRotationStatus {
  switch (object) {
    case 0:
    case "KEY_ROTATION_STATUS_UNSPECIFIED":
      return KeyRotationStatus.KEY_ROTATION_STATUS_UNSPECIFIED;
    case 1:
    case "KEY_ROTATION_STATUS_PENDING":
      return KeyRotationStatus.KEY_ROTATION_STATUS_PENDING;
    case 2:
    case "KEY_ROTATION_STATUS_ACTIVE":
      return KeyRotationStatus.KEY_ROTATION_STATUS_ACTIVE;
    case 3:
    case "KEY_ROTATION_STATUS_COMPLETED":
      return KeyRotationStatus.KEY_ROTATION_STATUS_COMPLETED;
    case 4:
    case "KEY_ROTATION_STATUS_CANCELLED":
      return KeyRotationStatus.KEY_ROTATION_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return KeyRotationStatus.UNRECOGNIZED;
  }
}

export function keyRotationStatusToJSON(object: KeyRotationStatus): string {
  switch (object) {
    case KeyRotationStatus.KEY_ROTATION_STATUS_UNSPECIFIED:
      return "KEY_ROTATION_STATUS_UNSPECIFIED";
    case KeyRotationStatus.KEY_ROTATION_STATUS_PENDING:
      return "KEY_ROTATION_STATUS_PENDING";
    case KeyRotationStatus.KEY_ROTATION_STATUS_ACTIVE:
      return "KEY_ROTATION_STATUS_ACTIVE";
    case KeyRotationStatus.KEY_ROTATION_STATUS_COMPLETED:
      return "KEY_ROTATION_STATUS_COMPLETED";
    case KeyRotationStatus.KEY_ROTATION_STATUS_CANCELLED:
      return "KEY_ROTATION_STATUS_CANCELLED";
    case KeyRotationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** EnclaveIdentity represents a validator's enclave identity record */
export interface EnclaveIdentity {
  /** ValidatorAddress is the validator operator address */
  validatorAddress: string;
  /** TEEType is the type of TEE (SGX, SEV-SNP, NITRO) */
  teeType: TEEType;
  /** MeasurementHash is the enclave measurement (MRENCLAVE for SGX) */
  measurementHash: Uint8Array;
  /** SignerHash is the signer measurement (MRSIGNER for SGX) */
  signerHash: Uint8Array;
  /** EncryptionPubKey is the enclave's public key for encryption */
  encryptionPubKey: Uint8Array;
  /** SigningPubKey is the enclave's public key for signing attestations */
  signingPubKey: Uint8Array;
  /** AttestationQuote is the raw attestation quote from the TEE */
  attestationQuote: Uint8Array;
  /** AttestationChain is the certificate chain for attestation verification */
  attestationChain: Uint8Array[];
  /** ISVProdID is the Independent Software Vendor Product ID */
  isvProdId: number;
  /** ISVSVN is the Independent Software Vendor Security Version Number */
  isvSvn: number;
  /** QuoteVersion is the attestation quote format version */
  quoteVersion: number;
  /** DebugMode indicates if the enclave is in debug mode (must be false for production) */
  debugMode: boolean;
  /** Epoch is the registration epoch */
  epoch: Long;
  /** ExpiryHeight is the block height when this identity expires */
  expiryHeight: Long;
  /** RegisteredAt is the timestamp when this identity was registered */
  registeredAt:
    | Date
    | undefined;
  /** UpdatedAt is the timestamp when this identity was last updated */
  updatedAt:
    | Date
    | undefined;
  /** Status is the current status of the enclave identity */
  status: EnclaveIdentityStatus;
}

/** MeasurementRecord represents an approved enclave measurement in the allowlist */
export interface MeasurementRecord {
  /** MeasurementHash is the enclave measurement hash */
  measurementHash: Uint8Array;
  /** TEEType is the TEE type this measurement is for */
  teeType: TEEType;
  /** Description is a human-readable description */
  description: string;
  /** MinISVSVN is the minimum required security version */
  minIsvSvn: number;
  /** AddedAt is when this measurement was added */
  addedAt:
    | Date
    | undefined;
  /** AddedByProposal is the governance proposal ID that added this measurement */
  addedByProposal: Long;
  /** ExpiryHeight is when this measurement expires (0 for no expiry) */
  expiryHeight: Long;
  /** Revoked indicates if this measurement has been revoked */
  revoked: boolean;
  /** RevokedAt is when this measurement was revoked (if applicable) */
  revokedAt:
    | Date
    | undefined;
  /** RevokedByProposal is the governance proposal that revoked this (if applicable) */
  revokedByProposal: Long;
}

/** KeyRotationRecord represents a key rotation event */
export interface KeyRotationRecord {
  /** ValidatorAddress is the validator operator address */
  validatorAddress: string;
  /** Epoch is the epoch when rotation was initiated */
  epoch: Long;
  /** OldKeyFingerprint is the fingerprint of the old key */
  oldKeyFingerprint: string;
  /** NewKeyFingerprint is the fingerprint of the new key */
  newKeyFingerprint: string;
  /** OverlapStartHeight is when both keys become valid */
  overlapStartHeight: Long;
  /** OverlapEndHeight is when the old key becomes invalid */
  overlapEndHeight: Long;
  /** InitiatedAt is when the rotation was initiated */
  initiatedAt:
    | Date
    | undefined;
  /** CompletedAt is when the rotation was completed (old key invalidated) */
  completedAt:
    | Date
    | undefined;
  /** Status is the current status of the rotation */
  status: KeyRotationStatus;
}

/** AttestedScoringResult represents an enclave-attested scoring output */
export interface AttestedScoringResult {
  /** ScopeID is the identity scope that was scored */
  scopeId: string;
  /** AccountAddress is the account that owns the identity */
  accountAddress: string;
  /** Score is the computed identity score (0-100) */
  score: number;
  /** Status is the verification status */
  status: string;
  /** ReasonCodes are structured reason codes for the score */
  reasonCodes: string[];
  /** ModelVersionHash is the hash of the ML model used */
  modelVersionHash: Uint8Array;
  /** InputHash is the hash of the input data (for determinism verification) */
  inputHash: Uint8Array;
  /** EvidenceHashes are hashes of evidence artifacts (face embeddings, OCR, etc.) */
  evidenceHashes: Uint8Array[];
  /** EnclaveMeasurementHash is the measurement of the enclave that computed this */
  enclaveMeasurementHash: Uint8Array;
  /** EnclaveSignature is the signature from the enclave signing key */
  enclaveSignature: Uint8Array;
  /** AttestationReference is a reference to the attestation quote (hash or ID) */
  attestationReference: Uint8Array;
  /** ValidatorAddress is the validator that produced this result */
  validatorAddress: string;
  /** BlockHeight is the block height where this result was produced */
  blockHeight: Long;
  /** Timestamp is when this result was computed */
  timestamp: Date | undefined;
}

/** ValidatorKeyInfo contains key information for a validator */
export interface ValidatorKeyInfo {
  /** ValidatorAddress is the validator operator address */
  validatorAddress: string;
  /** EncryptionKeyID is the key identifier */
  encryptionKeyId: string;
  /** EncryptionPubKey is the public key for encryption */
  encryptionPubKey: Uint8Array;
  /** MeasurementHash is the enclave measurement hash */
  measurementHash: Uint8Array;
  /** ExpiryHeight is when the identity expires */
  expiryHeight: Long;
  /** IsInRotation indicates if key rotation is in progress */
  isInRotation: boolean;
}

/** Params defines the parameters for the enclave module */
export interface Params {
  /** MaxEnclaveKeysPerValidator is the maximum number of enclave keys a validator can have */
  maxEnclaveKeysPerValidator: number;
  /** DefaultExpiryBlocks is the default number of blocks until enclave identity expires */
  defaultExpiryBlocks: Long;
  /** KeyRotationOverlapBlocks is the default overlap period for key rotations */
  keyRotationOverlapBlocks: Long;
  /** MinQuoteVersion is the minimum attestation quote version required */
  minQuoteVersion: number;
  /** AllowedTEETypes is the list of allowed TEE types */
  allowedTeeTypes: TEEType[];
  /** ScoreTolerance is the maximum allowed score difference for consensus */
  scoreTolerance: number;
  /** RequireAttestationChain indicates if attestation chain verification is required */
  requireAttestationChain: boolean;
  /** MaxAttestationAge is the maximum age of attestation in blocks */
  maxAttestationAge: Long;
  /** EnableCommitteeMode enables committee-based identity processing */
  enableCommitteeMode: boolean;
  /** CommitteeSize is the size of the identity committee (if committee mode enabled) */
  committeeSize: number;
  /** CommitteeEpochBlocks is the number of blocks per committee epoch */
  committeeEpochBlocks: Long;
  /** EnableMeasurementCleanup enables automatic cleanup of expired measurements */
  enableMeasurementCleanup: boolean;
  /** MaxRegistrationsPerBlock limits registrations per block (0 = unlimited) */
  maxRegistrationsPerBlock: number;
  /** RegistrationCooldownBlocks enforces cooldown between re-registrations */
  registrationCooldownBlocks: Long;
}

function createBaseEnclaveIdentity(): EnclaveIdentity {
  return {
    validatorAddress: "",
    teeType: 0,
    measurementHash: new Uint8Array(0),
    signerHash: new Uint8Array(0),
    encryptionPubKey: new Uint8Array(0),
    signingPubKey: new Uint8Array(0),
    attestationQuote: new Uint8Array(0),
    attestationChain: [],
    isvProdId: 0,
    isvSvn: 0,
    quoteVersion: 0,
    debugMode: false,
    epoch: Long.UZERO,
    expiryHeight: Long.ZERO,
    registeredAt: undefined,
    updatedAt: undefined,
    status: 0,
  };
}

export const EnclaveIdentity: MessageFns<EnclaveIdentity, "virtengine.enclave.v1.EnclaveIdentity"> = {
  $type: "virtengine.enclave.v1.EnclaveIdentity" as const,

  encode(message: EnclaveIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.teeType !== 0) {
      writer.uint32(16).int32(message.teeType);
    }
    if (message.measurementHash.length !== 0) {
      writer.uint32(26).bytes(message.measurementHash);
    }
    if (message.signerHash.length !== 0) {
      writer.uint32(34).bytes(message.signerHash);
    }
    if (message.encryptionPubKey.length !== 0) {
      writer.uint32(42).bytes(message.encryptionPubKey);
    }
    if (message.signingPubKey.length !== 0) {
      writer.uint32(50).bytes(message.signingPubKey);
    }
    if (message.attestationQuote.length !== 0) {
      writer.uint32(58).bytes(message.attestationQuote);
    }
    for (const v of message.attestationChain) {
      writer.uint32(66).bytes(v!);
    }
    if (message.isvProdId !== 0) {
      writer.uint32(72).uint32(message.isvProdId);
    }
    if (message.isvSvn !== 0) {
      writer.uint32(80).uint32(message.isvSvn);
    }
    if (message.quoteVersion !== 0) {
      writer.uint32(88).uint32(message.quoteVersion);
    }
    if (message.debugMode !== false) {
      writer.uint32(96).bool(message.debugMode);
    }
    if (!message.epoch.equals(Long.UZERO)) {
      writer.uint32(104).uint64(message.epoch.toString());
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.expiryHeight.toString());
    }
    if (message.registeredAt !== undefined) {
      Timestamp.encode(toTimestamp(message.registeredAt), writer.uint32(122).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(130).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(136).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnclaveIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnclaveIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.teeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signerHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.encryptionPubKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signingPubKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attestationQuote = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attestationChain.push(reader.bytes());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isvProdId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isvSvn = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.quoteVersion = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.debugMode = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.epoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.registeredAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnclaveIdentity {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      teeType: isSet(object.tee_type) ? tEETypeFromJSON(object.tee_type) : 0,
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      signerHash: isSet(object.signer_hash) ? bytesFromBase64(object.signer_hash) : new Uint8Array(0),
      encryptionPubKey: isSet(object.encryption_pub_key)
        ? bytesFromBase64(object.encryption_pub_key)
        : new Uint8Array(0),
      signingPubKey: isSet(object.signing_pub_key) ? bytesFromBase64(object.signing_pub_key) : new Uint8Array(0),
      attestationQuote: isSet(object.attestation_quote) ? bytesFromBase64(object.attestation_quote) : new Uint8Array(0),
      attestationChain: globalThis.Array.isArray(object?.attestation_chain)
        ? object.attestation_chain.map((e: any) => bytesFromBase64(e))
        : [],
      isvProdId: isSet(object.isv_prod_id) ? globalThis.Number(object.isv_prod_id) : 0,
      isvSvn: isSet(object.isv_svn) ? globalThis.Number(object.isv_svn) : 0,
      quoteVersion: isSet(object.quote_version) ? globalThis.Number(object.quote_version) : 0,
      debugMode: isSet(object.debug_mode) ? globalThis.Boolean(object.debug_mode) : false,
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.UZERO,
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
      registeredAt: isSet(object.registered_at) ? fromJsonTimestamp(object.registered_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      status: isSet(object.status) ? enclaveIdentityStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: EnclaveIdentity): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.teeType !== 0) {
      obj.tee_type = tEETypeToJSON(message.teeType);
    }
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (message.signerHash.length !== 0) {
      obj.signer_hash = base64FromBytes(message.signerHash);
    }
    if (message.encryptionPubKey.length !== 0) {
      obj.encryption_pub_key = base64FromBytes(message.encryptionPubKey);
    }
    if (message.signingPubKey.length !== 0) {
      obj.signing_pub_key = base64FromBytes(message.signingPubKey);
    }
    if (message.attestationQuote.length !== 0) {
      obj.attestation_quote = base64FromBytes(message.attestationQuote);
    }
    if (message.attestationChain?.length) {
      obj.attestation_chain = message.attestationChain.map((e) => base64FromBytes(e));
    }
    if (message.isvProdId !== 0) {
      obj.isv_prod_id = Math.round(message.isvProdId);
    }
    if (message.isvSvn !== 0) {
      obj.isv_svn = Math.round(message.isvSvn);
    }
    if (message.quoteVersion !== 0) {
      obj.quote_version = Math.round(message.quoteVersion);
    }
    if (message.debugMode !== false) {
      obj.debug_mode = message.debugMode;
    }
    if (!message.epoch.equals(Long.UZERO)) {
      obj.epoch = (message.epoch || Long.UZERO).toString();
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    if (message.registeredAt !== undefined) {
      obj.registered_at = message.registeredAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = enclaveIdentityStatusToJSON(message.status);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EnclaveIdentity>): EnclaveIdentity {
    const message = createBaseEnclaveIdentity();
    message.validatorAddress = object.validatorAddress ?? "";
    message.teeType = object.teeType ?? 0;
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.signerHash = object.signerHash ?? new Uint8Array(0);
    message.encryptionPubKey = object.encryptionPubKey ?? new Uint8Array(0);
    message.signingPubKey = object.signingPubKey ?? new Uint8Array(0);
    message.attestationQuote = object.attestationQuote ?? new Uint8Array(0);
    message.attestationChain = object.attestationChain?.map((e) => e) || [];
    message.isvProdId = object.isvProdId ?? 0;
    message.isvSvn = object.isvSvn ?? 0;
    message.quoteVersion = object.quoteVersion ?? 0;
    message.debugMode = object.debugMode ?? false;
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.UZERO;
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    message.registeredAt = object.registeredAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMeasurementRecord(): MeasurementRecord {
  return {
    measurementHash: new Uint8Array(0),
    teeType: 0,
    description: "",
    minIsvSvn: 0,
    addedAt: undefined,
    addedByProposal: Long.UZERO,
    expiryHeight: Long.ZERO,
    revoked: false,
    revokedAt: undefined,
    revokedByProposal: Long.UZERO,
  };
}

export const MeasurementRecord: MessageFns<MeasurementRecord, "virtengine.enclave.v1.MeasurementRecord"> = {
  $type: "virtengine.enclave.v1.MeasurementRecord" as const,

  encode(message: MeasurementRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementHash.length !== 0) {
      writer.uint32(10).bytes(message.measurementHash);
    }
    if (message.teeType !== 0) {
      writer.uint32(16).int32(message.teeType);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.minIsvSvn !== 0) {
      writer.uint32(32).uint32(message.minIsvSvn);
    }
    if (message.addedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.addedAt), writer.uint32(42).fork()).join();
    }
    if (!message.addedByProposal.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.addedByProposal.toString());
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.expiryHeight.toString());
    }
    if (message.revoked !== false) {
      writer.uint32(64).bool(message.revoked);
    }
    if (message.revokedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.revokedAt), writer.uint32(74).fork()).join();
    }
    if (!message.revokedByProposal.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.revokedByProposal.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MeasurementRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMeasurementRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.teeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minIsvSvn = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.addedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.addedByProposal = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.revoked = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.revokedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.revokedByProposal = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MeasurementRecord {
    return {
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      teeType: isSet(object.tee_type) ? tEETypeFromJSON(object.tee_type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      minIsvSvn: isSet(object.min_isv_svn) ? globalThis.Number(object.min_isv_svn) : 0,
      addedAt: isSet(object.added_at) ? fromJsonTimestamp(object.added_at) : undefined,
      addedByProposal: isSet(object.added_by_proposal) ? Long.fromValue(object.added_by_proposal) : Long.UZERO,
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
      revoked: isSet(object.revoked) ? globalThis.Boolean(object.revoked) : false,
      revokedAt: isSet(object.revoked_at) ? fromJsonTimestamp(object.revoked_at) : undefined,
      revokedByProposal: isSet(object.revoked_by_proposal) ? Long.fromValue(object.revoked_by_proposal) : Long.UZERO,
    };
  },

  toJSON(message: MeasurementRecord): unknown {
    const obj: any = {};
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (message.teeType !== 0) {
      obj.tee_type = tEETypeToJSON(message.teeType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.minIsvSvn !== 0) {
      obj.min_isv_svn = Math.round(message.minIsvSvn);
    }
    if (message.addedAt !== undefined) {
      obj.added_at = message.addedAt.toISOString();
    }
    if (!message.addedByProposal.equals(Long.UZERO)) {
      obj.added_by_proposal = (message.addedByProposal || Long.UZERO).toString();
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    if (message.revoked !== false) {
      obj.revoked = message.revoked;
    }
    if (message.revokedAt !== undefined) {
      obj.revoked_at = message.revokedAt.toISOString();
    }
    if (!message.revokedByProposal.equals(Long.UZERO)) {
      obj.revoked_by_proposal = (message.revokedByProposal || Long.UZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MeasurementRecord>): MeasurementRecord {
    const message = createBaseMeasurementRecord();
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.teeType = object.teeType ?? 0;
    message.description = object.description ?? "";
    message.minIsvSvn = object.minIsvSvn ?? 0;
    message.addedAt = object.addedAt ?? undefined;
    message.addedByProposal = (object.addedByProposal !== undefined && object.addedByProposal !== null)
      ? Long.fromValue(object.addedByProposal)
      : Long.UZERO;
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    message.revoked = object.revoked ?? false;
    message.revokedAt = object.revokedAt ?? undefined;
    message.revokedByProposal = (object.revokedByProposal !== undefined && object.revokedByProposal !== null)
      ? Long.fromValue(object.revokedByProposal)
      : Long.UZERO;
    return message;
  },
};

function createBaseKeyRotationRecord(): KeyRotationRecord {
  return {
    validatorAddress: "",
    epoch: Long.UZERO,
    oldKeyFingerprint: "",
    newKeyFingerprint: "",
    overlapStartHeight: Long.ZERO,
    overlapEndHeight: Long.ZERO,
    initiatedAt: undefined,
    completedAt: undefined,
    status: 0,
  };
}

export const KeyRotationRecord: MessageFns<KeyRotationRecord, "virtengine.enclave.v1.KeyRotationRecord"> = {
  $type: "virtengine.enclave.v1.KeyRotationRecord" as const,

  encode(message: KeyRotationRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (!message.epoch.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.epoch.toString());
    }
    if (message.oldKeyFingerprint !== "") {
      writer.uint32(26).string(message.oldKeyFingerprint);
    }
    if (message.newKeyFingerprint !== "") {
      writer.uint32(34).string(message.newKeyFingerprint);
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.overlapStartHeight.toString());
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.overlapEndHeight.toString());
    }
    if (message.initiatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.initiatedAt), writer.uint32(58).fork()).join();
    }
    if (message.completedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.completedAt), writer.uint32(66).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): KeyRotationRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKeyRotationRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldKeyFingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newKeyFingerprint = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.overlapStartHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.overlapEndHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.initiatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.completedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): KeyRotationRecord {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.UZERO,
      oldKeyFingerprint: isSet(object.old_key_fingerprint) ? globalThis.String(object.old_key_fingerprint) : "",
      newKeyFingerprint: isSet(object.new_key_fingerprint) ? globalThis.String(object.new_key_fingerprint) : "",
      overlapStartHeight: isSet(object.overlap_start_height) ? Long.fromValue(object.overlap_start_height) : Long.ZERO,
      overlapEndHeight: isSet(object.overlap_end_height) ? Long.fromValue(object.overlap_end_height) : Long.ZERO,
      initiatedAt: isSet(object.initiated_at) ? fromJsonTimestamp(object.initiated_at) : undefined,
      completedAt: isSet(object.completed_at) ? fromJsonTimestamp(object.completed_at) : undefined,
      status: isSet(object.status) ? keyRotationStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: KeyRotationRecord): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.epoch.equals(Long.UZERO)) {
      obj.epoch = (message.epoch || Long.UZERO).toString();
    }
    if (message.oldKeyFingerprint !== "") {
      obj.old_key_fingerprint = message.oldKeyFingerprint;
    }
    if (message.newKeyFingerprint !== "") {
      obj.new_key_fingerprint = message.newKeyFingerprint;
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      obj.overlap_start_height = (message.overlapStartHeight || Long.ZERO).toString();
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      obj.overlap_end_height = (message.overlapEndHeight || Long.ZERO).toString();
    }
    if (message.initiatedAt !== undefined) {
      obj.initiated_at = message.initiatedAt.toISOString();
    }
    if (message.completedAt !== undefined) {
      obj.completed_at = message.completedAt.toISOString();
    }
    if (message.status !== 0) {
      obj.status = keyRotationStatusToJSON(message.status);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<KeyRotationRecord>): KeyRotationRecord {
    const message = createBaseKeyRotationRecord();
    message.validatorAddress = object.validatorAddress ?? "";
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.UZERO;
    message.oldKeyFingerprint = object.oldKeyFingerprint ?? "";
    message.newKeyFingerprint = object.newKeyFingerprint ?? "";
    message.overlapStartHeight = (object.overlapStartHeight !== undefined && object.overlapStartHeight !== null)
      ? Long.fromValue(object.overlapStartHeight)
      : Long.ZERO;
    message.overlapEndHeight = (object.overlapEndHeight !== undefined && object.overlapEndHeight !== null)
      ? Long.fromValue(object.overlapEndHeight)
      : Long.ZERO;
    message.initiatedAt = object.initiatedAt ?? undefined;
    message.completedAt = object.completedAt ?? undefined;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseAttestedScoringResult(): AttestedScoringResult {
  return {
    scopeId: "",
    accountAddress: "",
    score: 0,
    status: "",
    reasonCodes: [],
    modelVersionHash: new Uint8Array(0),
    inputHash: new Uint8Array(0),
    evidenceHashes: [],
    enclaveMeasurementHash: new Uint8Array(0),
    enclaveSignature: new Uint8Array(0),
    attestationReference: new Uint8Array(0),
    validatorAddress: "",
    blockHeight: Long.ZERO,
    timestamp: undefined,
  };
}

export const AttestedScoringResult: MessageFns<AttestedScoringResult, "virtengine.enclave.v1.AttestedScoringResult"> = {
  $type: "virtengine.enclave.v1.AttestedScoringResult" as const,

  encode(message: AttestedScoringResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.score !== 0) {
      writer.uint32(24).uint32(message.score);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    for (const v of message.reasonCodes) {
      writer.uint32(42).string(v!);
    }
    if (message.modelVersionHash.length !== 0) {
      writer.uint32(50).bytes(message.modelVersionHash);
    }
    if (message.inputHash.length !== 0) {
      writer.uint32(58).bytes(message.inputHash);
    }
    for (const v of message.evidenceHashes) {
      writer.uint32(66).bytes(v!);
    }
    if (message.enclaveMeasurementHash.length !== 0) {
      writer.uint32(74).bytes(message.enclaveMeasurementHash);
    }
    if (message.enclaveSignature.length !== 0) {
      writer.uint32(82).bytes(message.enclaveSignature);
    }
    if (message.attestationReference.length !== 0) {
      writer.uint32(90).bytes(message.attestationReference);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(98).string(message.validatorAddress);
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.blockHeight.toString());
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AttestedScoringResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAttestedScoringResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reasonCodes.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersionHash = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inputHash = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.evidenceHashes.push(reader.bytes());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.enclaveMeasurementHash = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.enclaveSignature = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.attestationReference = reader.bytes();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AttestedScoringResult {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      reasonCodes: globalThis.Array.isArray(object?.reason_codes)
        ? object.reason_codes.map((e: any) => globalThis.String(e))
        : [],
      modelVersionHash: isSet(object.model_version_hash)
        ? bytesFromBase64(object.model_version_hash)
        : new Uint8Array(0),
      inputHash: isSet(object.input_hash) ? bytesFromBase64(object.input_hash) : new Uint8Array(0),
      evidenceHashes: globalThis.Array.isArray(object?.evidence_hashes)
        ? object.evidence_hashes.map((e: any) => bytesFromBase64(e))
        : [],
      enclaveMeasurementHash: isSet(object.enclave_measurement_hash)
        ? bytesFromBase64(object.enclave_measurement_hash)
        : new Uint8Array(0),
      enclaveSignature: isSet(object.enclave_signature) ? bytesFromBase64(object.enclave_signature) : new Uint8Array(0),
      attestationReference: isSet(object.attestation_reference)
        ? bytesFromBase64(object.attestation_reference)
        : new Uint8Array(0),
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: AttestedScoringResult): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (message.reasonCodes?.length) {
      obj.reason_codes = message.reasonCodes;
    }
    if (message.modelVersionHash.length !== 0) {
      obj.model_version_hash = base64FromBytes(message.modelVersionHash);
    }
    if (message.inputHash.length !== 0) {
      obj.input_hash = base64FromBytes(message.inputHash);
    }
    if (message.evidenceHashes?.length) {
      obj.evidence_hashes = message.evidenceHashes.map((e) => base64FromBytes(e));
    }
    if (message.enclaveMeasurementHash.length !== 0) {
      obj.enclave_measurement_hash = base64FromBytes(message.enclaveMeasurementHash);
    }
    if (message.enclaveSignature.length !== 0) {
      obj.enclave_signature = base64FromBytes(message.enclaveSignature);
    }
    if (message.attestationReference.length !== 0) {
      obj.attestation_reference = base64FromBytes(message.attestationReference);
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AttestedScoringResult>): AttestedScoringResult {
    const message = createBaseAttestedScoringResult();
    message.scopeId = object.scopeId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.score = object.score ?? 0;
    message.status = object.status ?? "";
    message.reasonCodes = object.reasonCodes?.map((e) => e) || [];
    message.modelVersionHash = object.modelVersionHash ?? new Uint8Array(0);
    message.inputHash = object.inputHash ?? new Uint8Array(0);
    message.evidenceHashes = object.evidenceHashes?.map((e) => e) || [];
    message.enclaveMeasurementHash = object.enclaveMeasurementHash ?? new Uint8Array(0);
    message.enclaveSignature = object.enclaveSignature ?? new Uint8Array(0);
    message.attestationReference = object.attestationReference ?? new Uint8Array(0);
    message.validatorAddress = object.validatorAddress ?? "";
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBaseValidatorKeyInfo(): ValidatorKeyInfo {
  return {
    validatorAddress: "",
    encryptionKeyId: "",
    encryptionPubKey: new Uint8Array(0),
    measurementHash: new Uint8Array(0),
    expiryHeight: Long.ZERO,
    isInRotation: false,
  };
}

export const ValidatorKeyInfo: MessageFns<ValidatorKeyInfo, "virtengine.enclave.v1.ValidatorKeyInfo"> = {
  $type: "virtengine.enclave.v1.ValidatorKeyInfo" as const,

  encode(message: ValidatorKeyInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.encryptionKeyId !== "") {
      writer.uint32(18).string(message.encryptionKeyId);
    }
    if (message.encryptionPubKey.length !== 0) {
      writer.uint32(26).bytes(message.encryptionPubKey);
    }
    if (message.measurementHash.length !== 0) {
      writer.uint32(34).bytes(message.measurementHash);
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expiryHeight.toString());
    }
    if (message.isInRotation !== false) {
      writer.uint32(48).bool(message.isInRotation);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorKeyInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorKeyInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.encryptionKeyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encryptionPubKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isInRotation = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorKeyInfo {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      encryptionKeyId: isSet(object.encryption_key_id) ? globalThis.String(object.encryption_key_id) : "",
      encryptionPubKey: isSet(object.encryption_pub_key)
        ? bytesFromBase64(object.encryption_pub_key)
        : new Uint8Array(0),
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
      isInRotation: isSet(object.is_in_rotation) ? globalThis.Boolean(object.is_in_rotation) : false,
    };
  },

  toJSON(message: ValidatorKeyInfo): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.encryptionKeyId !== "") {
      obj.encryption_key_id = message.encryptionKeyId;
    }
    if (message.encryptionPubKey.length !== 0) {
      obj.encryption_pub_key = base64FromBytes(message.encryptionPubKey);
    }
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    if (message.isInRotation !== false) {
      obj.is_in_rotation = message.isInRotation;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorKeyInfo>): ValidatorKeyInfo {
    const message = createBaseValidatorKeyInfo();
    message.validatorAddress = object.validatorAddress ?? "";
    message.encryptionKeyId = object.encryptionKeyId ?? "";
    message.encryptionPubKey = object.encryptionPubKey ?? new Uint8Array(0);
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    message.isInRotation = object.isInRotation ?? false;
    return message;
  },
};

function createBaseParams(): Params {
  return {
    maxEnclaveKeysPerValidator: 0,
    defaultExpiryBlocks: Long.ZERO,
    keyRotationOverlapBlocks: Long.ZERO,
    minQuoteVersion: 0,
    allowedTeeTypes: [],
    scoreTolerance: 0,
    requireAttestationChain: false,
    maxAttestationAge: Long.ZERO,
    enableCommitteeMode: false,
    committeeSize: 0,
    committeeEpochBlocks: Long.ZERO,
    enableMeasurementCleanup: false,
    maxRegistrationsPerBlock: 0,
    registrationCooldownBlocks: Long.ZERO,
  };
}

export const Params: MessageFns<Params, "virtengine.enclave.v1.Params"> = {
  $type: "virtengine.enclave.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxEnclaveKeysPerValidator !== 0) {
      writer.uint32(8).uint32(message.maxEnclaveKeysPerValidator);
    }
    if (!message.defaultExpiryBlocks.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.defaultExpiryBlocks.toString());
    }
    if (!message.keyRotationOverlapBlocks.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.keyRotationOverlapBlocks.toString());
    }
    if (message.minQuoteVersion !== 0) {
      writer.uint32(32).uint32(message.minQuoteVersion);
    }
    for (const v of message.allowedTeeTypes) {
      writer.uint32(40).int32(v!);
    }
    if (message.scoreTolerance !== 0) {
      writer.uint32(48).uint32(message.scoreTolerance);
    }
    if (message.requireAttestationChain !== false) {
      writer.uint32(56).bool(message.requireAttestationChain);
    }
    if (!message.maxAttestationAge.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.maxAttestationAge.toString());
    }
    if (message.enableCommitteeMode !== false) {
      writer.uint32(72).bool(message.enableCommitteeMode);
    }
    if (message.committeeSize !== 0) {
      writer.uint32(80).uint32(message.committeeSize);
    }
    if (!message.committeeEpochBlocks.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.committeeEpochBlocks.toString());
    }
    if (message.enableMeasurementCleanup !== false) {
      writer.uint32(96).bool(message.enableMeasurementCleanup);
    }
    if (message.maxRegistrationsPerBlock !== 0) {
      writer.uint32(104).uint32(message.maxRegistrationsPerBlock);
    }
    if (!message.registrationCooldownBlocks.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.registrationCooldownBlocks.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxEnclaveKeysPerValidator = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.defaultExpiryBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.keyRotationOverlapBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minQuoteVersion = reader.uint32();
          continue;
        }
        case 5: {
          if (tag === 40) {
            message.allowedTeeTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 42) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedTeeTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scoreTolerance = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.requireAttestationChain = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxAttestationAge = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.enableCommitteeMode = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.committeeSize = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.committeeEpochBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.enableMeasurementCleanup = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.maxRegistrationsPerBlock = reader.uint32();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.registrationCooldownBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxEnclaveKeysPerValidator: isSet(object.max_enclave_keys_per_validator)
        ? globalThis.Number(object.max_enclave_keys_per_validator)
        : 0,
      defaultExpiryBlocks: isSet(object.default_expiry_blocks)
        ? Long.fromValue(object.default_expiry_blocks)
        : Long.ZERO,
      keyRotationOverlapBlocks: isSet(object.key_rotation_overlap_blocks)
        ? Long.fromValue(object.key_rotation_overlap_blocks)
        : Long.ZERO,
      minQuoteVersion: isSet(object.min_quote_version) ? globalThis.Number(object.min_quote_version) : 0,
      allowedTeeTypes: globalThis.Array.isArray(object?.allowed_tee_types)
        ? object.allowed_tee_types.map((e: any) => tEETypeFromJSON(e))
        : [],
      scoreTolerance: isSet(object.score_tolerance) ? globalThis.Number(object.score_tolerance) : 0,
      requireAttestationChain: isSet(object.require_attestation_chain)
        ? globalThis.Boolean(object.require_attestation_chain)
        : false,
      maxAttestationAge: isSet(object.max_attestation_age) ? Long.fromValue(object.max_attestation_age) : Long.ZERO,
      enableCommitteeMode: isSet(object.enable_committee_mode)
        ? globalThis.Boolean(object.enable_committee_mode)
        : false,
      committeeSize: isSet(object.committee_size) ? globalThis.Number(object.committee_size) : 0,
      committeeEpochBlocks: isSet(object.committee_epoch_blocks)
        ? Long.fromValue(object.committee_epoch_blocks)
        : Long.ZERO,
      enableMeasurementCleanup: isSet(object.enable_measurement_cleanup)
        ? globalThis.Boolean(object.enable_measurement_cleanup)
        : false,
      maxRegistrationsPerBlock: isSet(object.max_registrations_per_block)
        ? globalThis.Number(object.max_registrations_per_block)
        : 0,
      registrationCooldownBlocks: isSet(object.registration_cooldown_blocks)
        ? Long.fromValue(object.registration_cooldown_blocks)
        : Long.ZERO,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.maxEnclaveKeysPerValidator !== 0) {
      obj.max_enclave_keys_per_validator = Math.round(message.maxEnclaveKeysPerValidator);
    }
    if (!message.defaultExpiryBlocks.equals(Long.ZERO)) {
      obj.default_expiry_blocks = (message.defaultExpiryBlocks || Long.ZERO).toString();
    }
    if (!message.keyRotationOverlapBlocks.equals(Long.ZERO)) {
      obj.key_rotation_overlap_blocks = (message.keyRotationOverlapBlocks || Long.ZERO).toString();
    }
    if (message.minQuoteVersion !== 0) {
      obj.min_quote_version = Math.round(message.minQuoteVersion);
    }
    if (message.allowedTeeTypes?.length) {
      obj.allowed_tee_types = message.allowedTeeTypes.map((e) => tEETypeToJSON(e));
    }
    if (message.scoreTolerance !== 0) {
      obj.score_tolerance = Math.round(message.scoreTolerance);
    }
    if (message.requireAttestationChain !== false) {
      obj.require_attestation_chain = message.requireAttestationChain;
    }
    if (!message.maxAttestationAge.equals(Long.ZERO)) {
      obj.max_attestation_age = (message.maxAttestationAge || Long.ZERO).toString();
    }
    if (message.enableCommitteeMode !== false) {
      obj.enable_committee_mode = message.enableCommitteeMode;
    }
    if (message.committeeSize !== 0) {
      obj.committee_size = Math.round(message.committeeSize);
    }
    if (!message.committeeEpochBlocks.equals(Long.ZERO)) {
      obj.committee_epoch_blocks = (message.committeeEpochBlocks || Long.ZERO).toString();
    }
    if (message.enableMeasurementCleanup !== false) {
      obj.enable_measurement_cleanup = message.enableMeasurementCleanup;
    }
    if (message.maxRegistrationsPerBlock !== 0) {
      obj.max_registrations_per_block = Math.round(message.maxRegistrationsPerBlock);
    }
    if (!message.registrationCooldownBlocks.equals(Long.ZERO)) {
      obj.registration_cooldown_blocks = (message.registrationCooldownBlocks || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.maxEnclaveKeysPerValidator = object.maxEnclaveKeysPerValidator ?? 0;
    message.defaultExpiryBlocks = (object.defaultExpiryBlocks !== undefined && object.defaultExpiryBlocks !== null)
      ? Long.fromValue(object.defaultExpiryBlocks)
      : Long.ZERO;
    message.keyRotationOverlapBlocks =
      (object.keyRotationOverlapBlocks !== undefined && object.keyRotationOverlapBlocks !== null)
        ? Long.fromValue(object.keyRotationOverlapBlocks)
        : Long.ZERO;
    message.minQuoteVersion = object.minQuoteVersion ?? 0;
    message.allowedTeeTypes = object.allowedTeeTypes?.map((e) => e) || [];
    message.scoreTolerance = object.scoreTolerance ?? 0;
    message.requireAttestationChain = object.requireAttestationChain ?? false;
    message.maxAttestationAge = (object.maxAttestationAge !== undefined && object.maxAttestationAge !== null)
      ? Long.fromValue(object.maxAttestationAge)
      : Long.ZERO;
    message.enableCommitteeMode = object.enableCommitteeMode ?? false;
    message.committeeSize = object.committeeSize ?? 0;
    message.committeeEpochBlocks = (object.committeeEpochBlocks !== undefined && object.committeeEpochBlocks !== null)
      ? Long.fromValue(object.committeeEpochBlocks)
      : Long.ZERO;
    message.enableMeasurementCleanup = object.enableMeasurementCleanup ?? false;
    message.maxRegistrationsPerBlock = object.maxRegistrationsPerBlock ?? 0;
    message.registrationCooldownBlocks =
      (object.registrationCooldownBlocks !== undefined && object.registrationCooldownBlocks !== null)
        ? Long.fromValue(object.registrationCooldownBlocks)
        : Long.ZERO;
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
