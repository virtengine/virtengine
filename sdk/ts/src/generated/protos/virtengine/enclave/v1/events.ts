import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/enclave/v1/events.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** EventEnclaveIdentityRegistered is emitted when an enclave identity is registered */
export interface EventEnclaveIdentityRegistered {
  /** Validator is the validator address */
  validator: string;
  /** TEEType is the type of TEE */
  teeType: string;
  /** MeasurementHash is the enclave measurement hash (hex-encoded) */
  measurementHash: string;
  /** EncryptionKeyID is the encryption key identifier */
  encryptionKeyId: string;
  /** SigningKeyID is the signing key identifier */
  signingKeyId: string;
  /** Epoch is the registration epoch */
  epoch: Long;
  /** ExpiryHeight is the block height when this identity expires */
  expiryHeight: Long;
}

/** EventEnclaveIdentityUpdated is emitted when an enclave identity is updated */
export interface EventEnclaveIdentityUpdated {
  /** Validator is the validator address */
  validator: string;
  /** Status is the new status */
  status: string;
}

/** EventEnclaveIdentityRevoked is emitted when an enclave identity is revoked */
export interface EventEnclaveIdentityRevoked {
  /** Validator is the validator address */
  validator: string;
  /** Reason is the reason for revocation */
  reason: string;
}

/** EventEnclaveIdentityExpired is emitted when an enclave identity expires */
export interface EventEnclaveIdentityExpired {
  /** Validator is the validator address */
  validator: string;
  /** ExpiryHeight is the height at which the identity expired */
  expiryHeight: Long;
}

/** EventEnclaveKeyRotated is emitted when a key rotation is initiated */
export interface EventEnclaveKeyRotated {
  /** Validator is the validator address */
  validator: string;
  /** OldKeyFingerprint is the fingerprint of the old key */
  oldKeyFingerprint: string;
  /** NewKeyFingerprint is the fingerprint of the new key */
  newKeyFingerprint: string;
  /** OverlapStartHeight is when both keys become valid */
  overlapStartHeight: Long;
  /** OverlapEndHeight is when the old key becomes invalid */
  overlapEndHeight: Long;
}

/** EventKeyRotationCompleted is emitted when a key rotation completes */
export interface EventKeyRotationCompleted {
  /** Validator is the validator address */
  validator: string;
  /** NewKeyFingerprint is the fingerprint of the new active key */
  newKeyFingerprint: string;
}

/** EventMeasurementAdded is emitted when a measurement is added to the allowlist */
export interface EventMeasurementAdded {
  /** MeasurementHash is the measurement hash (hex-encoded) */
  measurementHash: string;
  /** TEEType is the TEE type */
  teeType: string;
  /** Description is the measurement description */
  description: string;
  /** MinISVSVN is the minimum security version */
  minIsvSvn: number;
}

/** EventMeasurementRevoked is emitted when a measurement is revoked */
export interface EventMeasurementRevoked {
  /** MeasurementHash is the measurement hash (hex-encoded) */
  measurementHash: string;
  /** Reason is the reason for revocation */
  reason: string;
}

/** EventVEIDScoreComputedAttested is emitted when a VEID score is computed with attestation */
export interface EventVEIDScoreComputedAttested {
  /** ScopeID is the identity scope */
  scopeId: string;
  /** AccountAddress is the account that owns the identity */
  accountAddress: string;
  /** Score is the computed score */
  score: number;
  /** Status is the verification status */
  status: string;
  /** BlockHeight is the block height */
  blockHeight: Long;
}

/** EventVEIDScoreRejectedAttestation is emitted when a VEID score fails attestation verification */
export interface EventVEIDScoreRejectedAttestation {
  /** ScopeID is the identity scope */
  scopeId: string;
  /** AccountAddress is the account that owns the identity */
  accountAddress: string;
  /** ProposedScore is the score proposed by the proposer */
  proposedScore: number;
  /** ComputedScore is the locally computed score */
  computedScore: number;
  /** Reason is the reason for rejection */
  reason: string;
}

/** EventConsensusVerificationFailed is emitted when consensus verification fails */
export interface EventConsensusVerificationFailed {
  /** ScopeID is the identity scope */
  scopeId: string;
  /** ProposedScore is the score proposed */
  proposedScore: number;
  /** ComputedScore is the locally recomputed score */
  computedScore: number;
  /** ScoreDifference is the absolute difference between scores */
  scoreDifference: number;
  /** Reason is the failure reason */
  reason: string;
}

function createBaseEventEnclaveIdentityRegistered(): EventEnclaveIdentityRegistered {
  return {
    validator: "",
    teeType: "",
    measurementHash: "",
    encryptionKeyId: "",
    signingKeyId: "",
    epoch: Long.UZERO,
    expiryHeight: Long.ZERO,
  };
}

export const EventEnclaveIdentityRegistered: MessageFns<
  EventEnclaveIdentityRegistered,
  "virtengine.enclave.v1.EventEnclaveIdentityRegistered"
> = {
  $type: "virtengine.enclave.v1.EventEnclaveIdentityRegistered" as const,

  encode(message: EventEnclaveIdentityRegistered, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.teeType !== "") {
      writer.uint32(18).string(message.teeType);
    }
    if (message.measurementHash !== "") {
      writer.uint32(26).string(message.measurementHash);
    }
    if (message.encryptionKeyId !== "") {
      writer.uint32(34).string(message.encryptionKeyId);
    }
    if (message.signingKeyId !== "") {
      writer.uint32(42).string(message.signingKeyId);
    }
    if (!message.epoch.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.epoch.toString());
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.expiryHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnclaveIdentityRegistered {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnclaveIdentityRegistered();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teeType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.measurementHash = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encryptionKeyId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.signingKeyId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.epoch = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnclaveIdentityRegistered {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      teeType: isSet(object.tee_type) ? globalThis.String(object.tee_type) : "",
      measurementHash: isSet(object.measurement_hash) ? globalThis.String(object.measurement_hash) : "",
      encryptionKeyId: isSet(object.encryption_key_id) ? globalThis.String(object.encryption_key_id) : "",
      signingKeyId: isSet(object.signing_key_id) ? globalThis.String(object.signing_key_id) : "",
      epoch: isSet(object.epoch) ? Long.fromValue(object.epoch) : Long.UZERO,
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
    };
  },

  toJSON(message: EventEnclaveIdentityRegistered): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.teeType !== "") {
      obj.tee_type = message.teeType;
    }
    if (message.measurementHash !== "") {
      obj.measurement_hash = message.measurementHash;
    }
    if (message.encryptionKeyId !== "") {
      obj.encryption_key_id = message.encryptionKeyId;
    }
    if (message.signingKeyId !== "") {
      obj.signing_key_id = message.signingKeyId;
    }
    if (!message.epoch.equals(Long.UZERO)) {
      obj.epoch = (message.epoch || Long.UZERO).toString();
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventEnclaveIdentityRegistered>): EventEnclaveIdentityRegistered {
    const message = createBaseEventEnclaveIdentityRegistered();
    message.validator = object.validator ?? "";
    message.teeType = object.teeType ?? "";
    message.measurementHash = object.measurementHash ?? "";
    message.encryptionKeyId = object.encryptionKeyId ?? "";
    message.signingKeyId = object.signingKeyId ?? "";
    message.epoch = (object.epoch !== undefined && object.epoch !== null) ? Long.fromValue(object.epoch) : Long.UZERO;
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventEnclaveIdentityUpdated(): EventEnclaveIdentityUpdated {
  return { validator: "", status: "" };
}

export const EventEnclaveIdentityUpdated: MessageFns<
  EventEnclaveIdentityUpdated,
  "virtengine.enclave.v1.EventEnclaveIdentityUpdated"
> = {
  $type: "virtengine.enclave.v1.EventEnclaveIdentityUpdated" as const,

  encode(message: EventEnclaveIdentityUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnclaveIdentityUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnclaveIdentityUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnclaveIdentityUpdated {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: EventEnclaveIdentityUpdated): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventEnclaveIdentityUpdated>): EventEnclaveIdentityUpdated {
    const message = createBaseEventEnclaveIdentityUpdated();
    message.validator = object.validator ?? "";
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseEventEnclaveIdentityRevoked(): EventEnclaveIdentityRevoked {
  return { validator: "", reason: "" };
}

export const EventEnclaveIdentityRevoked: MessageFns<
  EventEnclaveIdentityRevoked,
  "virtengine.enclave.v1.EventEnclaveIdentityRevoked"
> = {
  $type: "virtengine.enclave.v1.EventEnclaveIdentityRevoked" as const,

  encode(message: EventEnclaveIdentityRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnclaveIdentityRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnclaveIdentityRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnclaveIdentityRevoked {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: EventEnclaveIdentityRevoked): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventEnclaveIdentityRevoked>): EventEnclaveIdentityRevoked {
    const message = createBaseEventEnclaveIdentityRevoked();
    message.validator = object.validator ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventEnclaveIdentityExpired(): EventEnclaveIdentityExpired {
  return { validator: "", expiryHeight: Long.ZERO };
}

export const EventEnclaveIdentityExpired: MessageFns<
  EventEnclaveIdentityExpired,
  "virtengine.enclave.v1.EventEnclaveIdentityExpired"
> = {
  $type: "virtengine.enclave.v1.EventEnclaveIdentityExpired" as const,

  encode(message: EventEnclaveIdentityExpired, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiryHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnclaveIdentityExpired {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnclaveIdentityExpired();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnclaveIdentityExpired {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
    };
  },

  toJSON(message: EventEnclaveIdentityExpired): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventEnclaveIdentityExpired>): EventEnclaveIdentityExpired {
    const message = createBaseEventEnclaveIdentityExpired();
    message.validator = object.validator ?? "";
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventEnclaveKeyRotated(): EventEnclaveKeyRotated {
  return {
    validator: "",
    oldKeyFingerprint: "",
    newKeyFingerprint: "",
    overlapStartHeight: Long.ZERO,
    overlapEndHeight: Long.ZERO,
  };
}

export const EventEnclaveKeyRotated: MessageFns<
  EventEnclaveKeyRotated,
  "virtengine.enclave.v1.EventEnclaveKeyRotated"
> = {
  $type: "virtengine.enclave.v1.EventEnclaveKeyRotated" as const,

  encode(message: EventEnclaveKeyRotated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.oldKeyFingerprint !== "") {
      writer.uint32(18).string(message.oldKeyFingerprint);
    }
    if (message.newKeyFingerprint !== "") {
      writer.uint32(26).string(message.newKeyFingerprint);
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.overlapStartHeight.toString());
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.overlapEndHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventEnclaveKeyRotated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventEnclaveKeyRotated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.oldKeyFingerprint = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newKeyFingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.overlapStartHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.overlapEndHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventEnclaveKeyRotated {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      oldKeyFingerprint: isSet(object.old_key_fingerprint) ? globalThis.String(object.old_key_fingerprint) : "",
      newKeyFingerprint: isSet(object.new_key_fingerprint) ? globalThis.String(object.new_key_fingerprint) : "",
      overlapStartHeight: isSet(object.overlap_start_height) ? Long.fromValue(object.overlap_start_height) : Long.ZERO,
      overlapEndHeight: isSet(object.overlap_end_height) ? Long.fromValue(object.overlap_end_height) : Long.ZERO,
    };
  },

  toJSON(message: EventEnclaveKeyRotated): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.oldKeyFingerprint !== "") {
      obj.old_key_fingerprint = message.oldKeyFingerprint;
    }
    if (message.newKeyFingerprint !== "") {
      obj.new_key_fingerprint = message.newKeyFingerprint;
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      obj.overlap_start_height = (message.overlapStartHeight || Long.ZERO).toString();
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      obj.overlap_end_height = (message.overlapEndHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventEnclaveKeyRotated>): EventEnclaveKeyRotated {
    const message = createBaseEventEnclaveKeyRotated();
    message.validator = object.validator ?? "";
    message.oldKeyFingerprint = object.oldKeyFingerprint ?? "";
    message.newKeyFingerprint = object.newKeyFingerprint ?? "";
    message.overlapStartHeight = (object.overlapStartHeight !== undefined && object.overlapStartHeight !== null)
      ? Long.fromValue(object.overlapStartHeight)
      : Long.ZERO;
    message.overlapEndHeight = (object.overlapEndHeight !== undefined && object.overlapEndHeight !== null)
      ? Long.fromValue(object.overlapEndHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventKeyRotationCompleted(): EventKeyRotationCompleted {
  return { validator: "", newKeyFingerprint: "" };
}

export const EventKeyRotationCompleted: MessageFns<
  EventKeyRotationCompleted,
  "virtengine.enclave.v1.EventKeyRotationCompleted"
> = {
  $type: "virtengine.enclave.v1.EventKeyRotationCompleted" as const,

  encode(message: EventKeyRotationCompleted, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validator !== "") {
      writer.uint32(10).string(message.validator);
    }
    if (message.newKeyFingerprint !== "") {
      writer.uint32(18).string(message.newKeyFingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventKeyRotationCompleted {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventKeyRotationCompleted();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validator = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newKeyFingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventKeyRotationCompleted {
    return {
      validator: isSet(object.validator) ? globalThis.String(object.validator) : "",
      newKeyFingerprint: isSet(object.new_key_fingerprint) ? globalThis.String(object.new_key_fingerprint) : "",
    };
  },

  toJSON(message: EventKeyRotationCompleted): unknown {
    const obj: any = {};
    if (message.validator !== "") {
      obj.validator = message.validator;
    }
    if (message.newKeyFingerprint !== "") {
      obj.new_key_fingerprint = message.newKeyFingerprint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventKeyRotationCompleted>): EventKeyRotationCompleted {
    const message = createBaseEventKeyRotationCompleted();
    message.validator = object.validator ?? "";
    message.newKeyFingerprint = object.newKeyFingerprint ?? "";
    return message;
  },
};

function createBaseEventMeasurementAdded(): EventMeasurementAdded {
  return { measurementHash: "", teeType: "", description: "", minIsvSvn: 0 };
}

export const EventMeasurementAdded: MessageFns<EventMeasurementAdded, "virtengine.enclave.v1.EventMeasurementAdded"> = {
  $type: "virtengine.enclave.v1.EventMeasurementAdded" as const,

  encode(message: EventMeasurementAdded, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementHash !== "") {
      writer.uint32(10).string(message.measurementHash);
    }
    if (message.teeType !== "") {
      writer.uint32(18).string(message.teeType);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.minIsvSvn !== 0) {
      writer.uint32(32).uint32(message.minIsvSvn);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMeasurementAdded {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMeasurementAdded();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.measurementHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.teeType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.minIsvSvn = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMeasurementAdded {
    return {
      measurementHash: isSet(object.measurement_hash) ? globalThis.String(object.measurement_hash) : "",
      teeType: isSet(object.tee_type) ? globalThis.String(object.tee_type) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      minIsvSvn: isSet(object.min_isv_svn) ? globalThis.Number(object.min_isv_svn) : 0,
    };
  },

  toJSON(message: EventMeasurementAdded): unknown {
    const obj: any = {};
    if (message.measurementHash !== "") {
      obj.measurement_hash = message.measurementHash;
    }
    if (message.teeType !== "") {
      obj.tee_type = message.teeType;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.minIsvSvn !== 0) {
      obj.min_isv_svn = Math.round(message.minIsvSvn);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventMeasurementAdded>): EventMeasurementAdded {
    const message = createBaseEventMeasurementAdded();
    message.measurementHash = object.measurementHash ?? "";
    message.teeType = object.teeType ?? "";
    message.description = object.description ?? "";
    message.minIsvSvn = object.minIsvSvn ?? 0;
    return message;
  },
};

function createBaseEventMeasurementRevoked(): EventMeasurementRevoked {
  return { measurementHash: "", reason: "" };
}

export const EventMeasurementRevoked: MessageFns<
  EventMeasurementRevoked,
  "virtengine.enclave.v1.EventMeasurementRevoked"
> = {
  $type: "virtengine.enclave.v1.EventMeasurementRevoked" as const,

  encode(message: EventMeasurementRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementHash !== "") {
      writer.uint32(10).string(message.measurementHash);
    }
    if (message.reason !== "") {
      writer.uint32(18).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMeasurementRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMeasurementRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.measurementHash = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMeasurementRevoked {
    return {
      measurementHash: isSet(object.measurement_hash) ? globalThis.String(object.measurement_hash) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: EventMeasurementRevoked): unknown {
    const obj: any = {};
    if (message.measurementHash !== "") {
      obj.measurement_hash = message.measurementHash;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventMeasurementRevoked>): EventMeasurementRevoked {
    const message = createBaseEventMeasurementRevoked();
    message.measurementHash = object.measurementHash ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventVEIDScoreComputedAttested(): EventVEIDScoreComputedAttested {
  return { scopeId: "", accountAddress: "", score: 0, status: "", blockHeight: Long.ZERO };
}

export const EventVEIDScoreComputedAttested: MessageFns<
  EventVEIDScoreComputedAttested,
  "virtengine.enclave.v1.EventVEIDScoreComputedAttested"
> = {
  $type: "virtengine.enclave.v1.EventVEIDScoreComputedAttested" as const,

  encode(message: EventVEIDScoreComputedAttested, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.score !== 0) {
      writer.uint32(24).uint32(message.score);
    }
    if (message.status !== "") {
      writer.uint32(34).string(message.status);
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventVEIDScoreComputedAttested {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventVEIDScoreComputedAttested();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.status = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventVEIDScoreComputedAttested {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: EventVEIDScoreComputedAttested): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventVEIDScoreComputedAttested>): EventVEIDScoreComputedAttested {
    const message = createBaseEventVEIDScoreComputedAttested();
    message.scopeId = object.scopeId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.score = object.score ?? 0;
    message.status = object.status ?? "";
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseEventVEIDScoreRejectedAttestation(): EventVEIDScoreRejectedAttestation {
  return { scopeId: "", accountAddress: "", proposedScore: 0, computedScore: 0, reason: "" };
}

export const EventVEIDScoreRejectedAttestation: MessageFns<
  EventVEIDScoreRejectedAttestation,
  "virtengine.enclave.v1.EventVEIDScoreRejectedAttestation"
> = {
  $type: "virtengine.enclave.v1.EventVEIDScoreRejectedAttestation" as const,

  encode(message: EventVEIDScoreRejectedAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.proposedScore !== 0) {
      writer.uint32(24).uint32(message.proposedScore);
    }
    if (message.computedScore !== 0) {
      writer.uint32(32).uint32(message.computedScore);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventVEIDScoreRejectedAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventVEIDScoreRejectedAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.proposedScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.computedScore = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventVEIDScoreRejectedAttestation {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      proposedScore: isSet(object.proposed_score) ? globalThis.Number(object.proposed_score) : 0,
      computedScore: isSet(object.computed_score) ? globalThis.Number(object.computed_score) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: EventVEIDScoreRejectedAttestation): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.proposedScore !== 0) {
      obj.proposed_score = Math.round(message.proposedScore);
    }
    if (message.computedScore !== 0) {
      obj.computed_score = Math.round(message.computedScore);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventVEIDScoreRejectedAttestation>): EventVEIDScoreRejectedAttestation {
    const message = createBaseEventVEIDScoreRejectedAttestation();
    message.scopeId = object.scopeId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.proposedScore = object.proposedScore ?? 0;
    message.computedScore = object.computedScore ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseEventConsensusVerificationFailed(): EventConsensusVerificationFailed {
  return { scopeId: "", proposedScore: 0, computedScore: 0, scoreDifference: 0, reason: "" };
}

export const EventConsensusVerificationFailed: MessageFns<
  EventConsensusVerificationFailed,
  "virtengine.enclave.v1.EventConsensusVerificationFailed"
> = {
  $type: "virtengine.enclave.v1.EventConsensusVerificationFailed" as const,

  encode(message: EventConsensusVerificationFailed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.proposedScore !== 0) {
      writer.uint32(16).uint32(message.proposedScore);
    }
    if (message.computedScore !== 0) {
      writer.uint32(24).uint32(message.computedScore);
    }
    if (message.scoreDifference !== 0) {
      writer.uint32(32).int32(message.scoreDifference);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventConsensusVerificationFailed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventConsensusVerificationFailed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.proposedScore = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.computedScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scoreDifference = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventConsensusVerificationFailed {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      proposedScore: isSet(object.proposed_score) ? globalThis.Number(object.proposed_score) : 0,
      computedScore: isSet(object.computed_score) ? globalThis.Number(object.computed_score) : 0,
      scoreDifference: isSet(object.score_difference) ? globalThis.Number(object.score_difference) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: EventConsensusVerificationFailed): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.proposedScore !== 0) {
      obj.proposed_score = Math.round(message.proposedScore);
    }
    if (message.computedScore !== 0) {
      obj.computed_score = Math.round(message.computedScore);
    }
    if (message.scoreDifference !== 0) {
      obj.score_difference = Math.round(message.scoreDifference);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventConsensusVerificationFailed>): EventConsensusVerificationFailed {
    const message = createBaseEventConsensusVerificationFailed();
    message.scopeId = object.scopeId ?? "";
    message.proposedScore = object.proposedScore ?? 0;
    message.computedScore = object.computedScore ?? 0;
    message.scoreDifference = object.scoreDifference ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
