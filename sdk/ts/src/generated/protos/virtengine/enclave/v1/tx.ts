import { bytesFromBase64, base64FromBytes, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/enclave/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Params, TEEType, tEETypeFromJSON, tEETypeToJSON } from "./types.ts";

/** MsgRegisterEnclaveIdentity registers a new enclave identity for a validator */
export interface MsgRegisterEnclaveIdentity {
  /** ValidatorAddress is the validator operator address (sender must be the validator operator) */
  validatorAddress: string;
  /** TEEType is the type of TEE */
  teeType: TEEType;
  /** MeasurementHash is the enclave measurement hash */
  measurementHash: Uint8Array;
  /** SignerHash is the signer measurement (MRSIGNER) */
  signerHash: Uint8Array;
  /** EncryptionPubKey is the enclave's public key for encryption */
  encryptionPubKey: Uint8Array;
  /** SigningPubKey is the enclave's public key for signing */
  signingPubKey: Uint8Array;
  /** AttestationQuote is the raw attestation quote */
  attestationQuote: Uint8Array;
  /** AttestationChain is the certificate chain */
  attestationChain: Uint8Array[];
  /** ISVProdID is the product ID */
  isvProdId: number;
  /** ISVSVN is the security version number */
  isvSvn: number;
  /** QuoteVersion is the quote format version */
  quoteVersion: number;
}

/** MsgRegisterEnclaveIdentityResponse is the response for MsgRegisterEnclaveIdentity */
export interface MsgRegisterEnclaveIdentityResponse {
  /** KeyFingerprint is the fingerprint of the registered key */
  keyFingerprint: string;
  /** ExpiryHeight is the block height when the identity expires */
  expiryHeight: Long;
}

/** MsgRotateEnclaveIdentity initiates a key rotation for a validator's enclave */
export interface MsgRotateEnclaveIdentity {
  /** ValidatorAddress is the validator operator address */
  validatorAddress: string;
  /** NewEncryptionPubKey is the new enclave encryption public key */
  newEncryptionPubKey: Uint8Array;
  /** NewSigningPubKey is the new enclave signing public key */
  newSigningPubKey: Uint8Array;
  /** NewAttestationQuote is the new attestation quote */
  newAttestationQuote: Uint8Array;
  /** NewAttestationChain is the new certificate chain */
  newAttestationChain: Uint8Array[];
  /** NewMeasurementHash is the new measurement hash (if enclave was upgraded) */
  newMeasurementHash: Uint8Array;
  /** NewISVSVN is the new security version */
  newIsvSvn: number;
  /** OverlapBlocks is the number of blocks for which both keys are valid */
  overlapBlocks: Long;
}

/** MsgRotateEnclaveIdentityResponse is the response for MsgRotateEnclaveIdentity */
export interface MsgRotateEnclaveIdentityResponse {
  /** NewKeyFingerprint is the fingerprint of the new key */
  newKeyFingerprint: string;
  /** OverlapStartHeight is when both keys become valid */
  overlapStartHeight: Long;
  /** OverlapEndHeight is when the old key becomes invalid */
  overlapEndHeight: Long;
}

/** MsgProposeMeasurement proposes a new enclave measurement for the allowlist */
export interface MsgProposeMeasurement {
  /** Authority is the governance authority address */
  authority: string;
  /** MeasurementHash is the enclave measurement hash to add */
  measurementHash: Uint8Array;
  /** TEEType is the TEE type this measurement is for */
  teeType: TEEType;
  /** Description is a human-readable description */
  description: string;
  /** MinISVSVN is the minimum required security version */
  minIsvSvn: number;
  /** ExpiryBlocks is the number of blocks until expiry (0 for no expiry) */
  expiryBlocks: Long;
}

/** MsgProposeMeasurementResponse is the response for MsgProposeMeasurement */
export interface MsgProposeMeasurementResponse {
  /** MeasurementHash is the hash of the added measurement (hex-encoded) */
  measurementHash: string;
}

/** MsgRevokeMeasurement revokes an enclave measurement from the allowlist */
export interface MsgRevokeMeasurement {
  /** Authority is the governance authority address */
  authority: string;
  /** MeasurementHash is the enclave measurement hash to revoke */
  measurementHash: Uint8Array;
  /** Reason is the reason for revocation */
  reason: string;
}

/** MsgRevokeMeasurementResponse is the response for MsgRevokeMeasurement */
export interface MsgRevokeMeasurementResponse {
}

/** MsgUpdateParams is the message for updating module parameters */
export interface MsgUpdateParams {
  /** Authority is the address that controls the module (x/gov module account) */
  authority: string;
  /** Params are the new module parameters */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgRegisterEnclaveIdentity(): MsgRegisterEnclaveIdentity {
  return {
    validatorAddress: "",
    teeType: 0,
    measurementHash: new Uint8Array(0),
    signerHash: new Uint8Array(0),
    encryptionPubKey: new Uint8Array(0),
    signingPubKey: new Uint8Array(0),
    attestationQuote: new Uint8Array(0),
    attestationChain: [],
    isvProdId: 0,
    isvSvn: 0,
    quoteVersion: 0,
  };
}

export const MsgRegisterEnclaveIdentity: MessageFns<
  MsgRegisterEnclaveIdentity,
  "virtengine.enclave.v1.MsgRegisterEnclaveIdentity"
> = {
  $type: "virtengine.enclave.v1.MsgRegisterEnclaveIdentity" as const,

  encode(message: MsgRegisterEnclaveIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.teeType !== 0) {
      writer.uint32(16).int32(message.teeType);
    }
    if (message.measurementHash.length !== 0) {
      writer.uint32(26).bytes(message.measurementHash);
    }
    if (message.signerHash.length !== 0) {
      writer.uint32(34).bytes(message.signerHash);
    }
    if (message.encryptionPubKey.length !== 0) {
      writer.uint32(42).bytes(message.encryptionPubKey);
    }
    if (message.signingPubKey.length !== 0) {
      writer.uint32(50).bytes(message.signingPubKey);
    }
    if (message.attestationQuote.length !== 0) {
      writer.uint32(58).bytes(message.attestationQuote);
    }
    for (const v of message.attestationChain) {
      writer.uint32(66).bytes(v!);
    }
    if (message.isvProdId !== 0) {
      writer.uint32(72).uint32(message.isvProdId);
    }
    if (message.isvSvn !== 0) {
      writer.uint32(80).uint32(message.isvSvn);
    }
    if (message.quoteVersion !== 0) {
      writer.uint32(88).uint32(message.quoteVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterEnclaveIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterEnclaveIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.teeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signerHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.encryptionPubKey = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.signingPubKey = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.attestationQuote = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attestationChain.push(reader.bytes());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.isvProdId = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isvSvn = reader.uint32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.quoteVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterEnclaveIdentity {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      teeType: isSet(object.tee_type) ? tEETypeFromJSON(object.tee_type) : 0,
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      signerHash: isSet(object.signer_hash) ? bytesFromBase64(object.signer_hash) : new Uint8Array(0),
      encryptionPubKey: isSet(object.encryption_pub_key)
        ? bytesFromBase64(object.encryption_pub_key)
        : new Uint8Array(0),
      signingPubKey: isSet(object.signing_pub_key) ? bytesFromBase64(object.signing_pub_key) : new Uint8Array(0),
      attestationQuote: isSet(object.attestation_quote) ? bytesFromBase64(object.attestation_quote) : new Uint8Array(0),
      attestationChain: globalThis.Array.isArray(object?.attestation_chain)
        ? object.attestation_chain.map((e: any) => bytesFromBase64(e))
        : [],
      isvProdId: isSet(object.isv_prod_id) ? globalThis.Number(object.isv_prod_id) : 0,
      isvSvn: isSet(object.isv_svn) ? globalThis.Number(object.isv_svn) : 0,
      quoteVersion: isSet(object.quote_version) ? globalThis.Number(object.quote_version) : 0,
    };
  },

  toJSON(message: MsgRegisterEnclaveIdentity): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.teeType !== 0) {
      obj.tee_type = tEETypeToJSON(message.teeType);
    }
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (message.signerHash.length !== 0) {
      obj.signer_hash = base64FromBytes(message.signerHash);
    }
    if (message.encryptionPubKey.length !== 0) {
      obj.encryption_pub_key = base64FromBytes(message.encryptionPubKey);
    }
    if (message.signingPubKey.length !== 0) {
      obj.signing_pub_key = base64FromBytes(message.signingPubKey);
    }
    if (message.attestationQuote.length !== 0) {
      obj.attestation_quote = base64FromBytes(message.attestationQuote);
    }
    if (message.attestationChain?.length) {
      obj.attestation_chain = message.attestationChain.map((e) => base64FromBytes(e));
    }
    if (message.isvProdId !== 0) {
      obj.isv_prod_id = Math.round(message.isvProdId);
    }
    if (message.isvSvn !== 0) {
      obj.isv_svn = Math.round(message.isvSvn);
    }
    if (message.quoteVersion !== 0) {
      obj.quote_version = Math.round(message.quoteVersion);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterEnclaveIdentity>): MsgRegisterEnclaveIdentity {
    const message = createBaseMsgRegisterEnclaveIdentity();
    message.validatorAddress = object.validatorAddress ?? "";
    message.teeType = object.teeType ?? 0;
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.signerHash = object.signerHash ?? new Uint8Array(0);
    message.encryptionPubKey = object.encryptionPubKey ?? new Uint8Array(0);
    message.signingPubKey = object.signingPubKey ?? new Uint8Array(0);
    message.attestationQuote = object.attestationQuote ?? new Uint8Array(0);
    message.attestationChain = object.attestationChain?.map((e) => e) || [];
    message.isvProdId = object.isvProdId ?? 0;
    message.isvSvn = object.isvSvn ?? 0;
    message.quoteVersion = object.quoteVersion ?? 0;
    return message;
  },
};

function createBaseMsgRegisterEnclaveIdentityResponse(): MsgRegisterEnclaveIdentityResponse {
  return { keyFingerprint: "", expiryHeight: Long.ZERO };
}

export const MsgRegisterEnclaveIdentityResponse: MessageFns<
  MsgRegisterEnclaveIdentityResponse,
  "virtengine.enclave.v1.MsgRegisterEnclaveIdentityResponse"
> = {
  $type: "virtengine.enclave.v1.MsgRegisterEnclaveIdentityResponse" as const,

  encode(message: MsgRegisterEnclaveIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyFingerprint !== "") {
      writer.uint32(10).string(message.keyFingerprint);
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiryHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterEnclaveIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterEnclaveIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.keyFingerprint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiryHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterEnclaveIdentityResponse {
    return {
      keyFingerprint: isSet(object.key_fingerprint) ? globalThis.String(object.key_fingerprint) : "",
      expiryHeight: isSet(object.expiry_height) ? Long.fromValue(object.expiry_height) : Long.ZERO,
    };
  },

  toJSON(message: MsgRegisterEnclaveIdentityResponse): unknown {
    const obj: any = {};
    if (message.keyFingerprint !== "") {
      obj.key_fingerprint = message.keyFingerprint;
    }
    if (!message.expiryHeight.equals(Long.ZERO)) {
      obj.expiry_height = (message.expiryHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterEnclaveIdentityResponse>): MsgRegisterEnclaveIdentityResponse {
    const message = createBaseMsgRegisterEnclaveIdentityResponse();
    message.keyFingerprint = object.keyFingerprint ?? "";
    message.expiryHeight = (object.expiryHeight !== undefined && object.expiryHeight !== null)
      ? Long.fromValue(object.expiryHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgRotateEnclaveIdentity(): MsgRotateEnclaveIdentity {
  return {
    validatorAddress: "",
    newEncryptionPubKey: new Uint8Array(0),
    newSigningPubKey: new Uint8Array(0),
    newAttestationQuote: new Uint8Array(0),
    newAttestationChain: [],
    newMeasurementHash: new Uint8Array(0),
    newIsvSvn: 0,
    overlapBlocks: Long.ZERO,
  };
}

export const MsgRotateEnclaveIdentity: MessageFns<
  MsgRotateEnclaveIdentity,
  "virtengine.enclave.v1.MsgRotateEnclaveIdentity"
> = {
  $type: "virtengine.enclave.v1.MsgRotateEnclaveIdentity" as const,

  encode(message: MsgRotateEnclaveIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.newEncryptionPubKey.length !== 0) {
      writer.uint32(18).bytes(message.newEncryptionPubKey);
    }
    if (message.newSigningPubKey.length !== 0) {
      writer.uint32(26).bytes(message.newSigningPubKey);
    }
    if (message.newAttestationQuote.length !== 0) {
      writer.uint32(34).bytes(message.newAttestationQuote);
    }
    for (const v of message.newAttestationChain) {
      writer.uint32(42).bytes(v!);
    }
    if (message.newMeasurementHash.length !== 0) {
      writer.uint32(50).bytes(message.newMeasurementHash);
    }
    if (message.newIsvSvn !== 0) {
      writer.uint32(56).uint32(message.newIsvSvn);
    }
    if (!message.overlapBlocks.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.overlapBlocks.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRotateEnclaveIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRotateEnclaveIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newEncryptionPubKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newSigningPubKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newAttestationQuote = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newAttestationChain.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newMeasurementHash = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.newIsvSvn = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.overlapBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRotateEnclaveIdentity {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      newEncryptionPubKey: isSet(object.new_encryption_pub_key)
        ? bytesFromBase64(object.new_encryption_pub_key)
        : new Uint8Array(0),
      newSigningPubKey: isSet(object.new_signing_pub_key)
        ? bytesFromBase64(object.new_signing_pub_key)
        : new Uint8Array(0),
      newAttestationQuote: isSet(object.new_attestation_quote)
        ? bytesFromBase64(object.new_attestation_quote)
        : new Uint8Array(0),
      newAttestationChain: globalThis.Array.isArray(object?.new_attestation_chain)
        ? object.new_attestation_chain.map((e: any) => bytesFromBase64(e))
        : [],
      newMeasurementHash: isSet(object.new_measurement_hash)
        ? bytesFromBase64(object.new_measurement_hash)
        : new Uint8Array(0),
      newIsvSvn: isSet(object.new_isv_svn) ? globalThis.Number(object.new_isv_svn) : 0,
      overlapBlocks: isSet(object.overlap_blocks) ? Long.fromValue(object.overlap_blocks) : Long.ZERO,
    };
  },

  toJSON(message: MsgRotateEnclaveIdentity): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.newEncryptionPubKey.length !== 0) {
      obj.new_encryption_pub_key = base64FromBytes(message.newEncryptionPubKey);
    }
    if (message.newSigningPubKey.length !== 0) {
      obj.new_signing_pub_key = base64FromBytes(message.newSigningPubKey);
    }
    if (message.newAttestationQuote.length !== 0) {
      obj.new_attestation_quote = base64FromBytes(message.newAttestationQuote);
    }
    if (message.newAttestationChain?.length) {
      obj.new_attestation_chain = message.newAttestationChain.map((e) => base64FromBytes(e));
    }
    if (message.newMeasurementHash.length !== 0) {
      obj.new_measurement_hash = base64FromBytes(message.newMeasurementHash);
    }
    if (message.newIsvSvn !== 0) {
      obj.new_isv_svn = Math.round(message.newIsvSvn);
    }
    if (!message.overlapBlocks.equals(Long.ZERO)) {
      obj.overlap_blocks = (message.overlapBlocks || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRotateEnclaveIdentity>): MsgRotateEnclaveIdentity {
    const message = createBaseMsgRotateEnclaveIdentity();
    message.validatorAddress = object.validatorAddress ?? "";
    message.newEncryptionPubKey = object.newEncryptionPubKey ?? new Uint8Array(0);
    message.newSigningPubKey = object.newSigningPubKey ?? new Uint8Array(0);
    message.newAttestationQuote = object.newAttestationQuote ?? new Uint8Array(0);
    message.newAttestationChain = object.newAttestationChain?.map((e) => e) || [];
    message.newMeasurementHash = object.newMeasurementHash ?? new Uint8Array(0);
    message.newIsvSvn = object.newIsvSvn ?? 0;
    message.overlapBlocks = (object.overlapBlocks !== undefined && object.overlapBlocks !== null)
      ? Long.fromValue(object.overlapBlocks)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgRotateEnclaveIdentityResponse(): MsgRotateEnclaveIdentityResponse {
  return { newKeyFingerprint: "", overlapStartHeight: Long.ZERO, overlapEndHeight: Long.ZERO };
}

export const MsgRotateEnclaveIdentityResponse: MessageFns<
  MsgRotateEnclaveIdentityResponse,
  "virtengine.enclave.v1.MsgRotateEnclaveIdentityResponse"
> = {
  $type: "virtengine.enclave.v1.MsgRotateEnclaveIdentityResponse" as const,

  encode(message: MsgRotateEnclaveIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newKeyFingerprint !== "") {
      writer.uint32(10).string(message.newKeyFingerprint);
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.overlapStartHeight.toString());
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.overlapEndHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRotateEnclaveIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRotateEnclaveIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newKeyFingerprint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.overlapStartHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.overlapEndHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRotateEnclaveIdentityResponse {
    return {
      newKeyFingerprint: isSet(object.new_key_fingerprint) ? globalThis.String(object.new_key_fingerprint) : "",
      overlapStartHeight: isSet(object.overlap_start_height) ? Long.fromValue(object.overlap_start_height) : Long.ZERO,
      overlapEndHeight: isSet(object.overlap_end_height) ? Long.fromValue(object.overlap_end_height) : Long.ZERO,
    };
  },

  toJSON(message: MsgRotateEnclaveIdentityResponse): unknown {
    const obj: any = {};
    if (message.newKeyFingerprint !== "") {
      obj.new_key_fingerprint = message.newKeyFingerprint;
    }
    if (!message.overlapStartHeight.equals(Long.ZERO)) {
      obj.overlap_start_height = (message.overlapStartHeight || Long.ZERO).toString();
    }
    if (!message.overlapEndHeight.equals(Long.ZERO)) {
      obj.overlap_end_height = (message.overlapEndHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRotateEnclaveIdentityResponse>): MsgRotateEnclaveIdentityResponse {
    const message = createBaseMsgRotateEnclaveIdentityResponse();
    message.newKeyFingerprint = object.newKeyFingerprint ?? "";
    message.overlapStartHeight = (object.overlapStartHeight !== undefined && object.overlapStartHeight !== null)
      ? Long.fromValue(object.overlapStartHeight)
      : Long.ZERO;
    message.overlapEndHeight = (object.overlapEndHeight !== undefined && object.overlapEndHeight !== null)
      ? Long.fromValue(object.overlapEndHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgProposeMeasurement(): MsgProposeMeasurement {
  return {
    authority: "",
    measurementHash: new Uint8Array(0),
    teeType: 0,
    description: "",
    minIsvSvn: 0,
    expiryBlocks: Long.ZERO,
  };
}

export const MsgProposeMeasurement: MessageFns<MsgProposeMeasurement, "virtengine.enclave.v1.MsgProposeMeasurement"> = {
  $type: "virtengine.enclave.v1.MsgProposeMeasurement" as const,

  encode(message: MsgProposeMeasurement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.measurementHash.length !== 0) {
      writer.uint32(18).bytes(message.measurementHash);
    }
    if (message.teeType !== 0) {
      writer.uint32(24).int32(message.teeType);
    }
    if (message.description !== "") {
      writer.uint32(34).string(message.description);
    }
    if (message.minIsvSvn !== 0) {
      writer.uint32(40).uint32(message.minIsvSvn);
    }
    if (!message.expiryBlocks.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.expiryBlocks.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposeMeasurement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeMeasurement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.minIsvSvn = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiryBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeMeasurement {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      teeType: isSet(object.tee_type) ? tEETypeFromJSON(object.tee_type) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      minIsvSvn: isSet(object.min_isv_svn) ? globalThis.Number(object.min_isv_svn) : 0,
      expiryBlocks: isSet(object.expiry_blocks) ? Long.fromValue(object.expiry_blocks) : Long.ZERO,
    };
  },

  toJSON(message: MsgProposeMeasurement): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (message.teeType !== 0) {
      obj.tee_type = tEETypeToJSON(message.teeType);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.minIsvSvn !== 0) {
      obj.min_isv_svn = Math.round(message.minIsvSvn);
    }
    if (!message.expiryBlocks.equals(Long.ZERO)) {
      obj.expiry_blocks = (message.expiryBlocks || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgProposeMeasurement>): MsgProposeMeasurement {
    const message = createBaseMsgProposeMeasurement();
    message.authority = object.authority ?? "";
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.teeType = object.teeType ?? 0;
    message.description = object.description ?? "";
    message.minIsvSvn = object.minIsvSvn ?? 0;
    message.expiryBlocks = (object.expiryBlocks !== undefined && object.expiryBlocks !== null)
      ? Long.fromValue(object.expiryBlocks)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgProposeMeasurementResponse(): MsgProposeMeasurementResponse {
  return { measurementHash: "" };
}

export const MsgProposeMeasurementResponse: MessageFns<
  MsgProposeMeasurementResponse,
  "virtengine.enclave.v1.MsgProposeMeasurementResponse"
> = {
  $type: "virtengine.enclave.v1.MsgProposeMeasurementResponse" as const,

  encode(message: MsgProposeMeasurementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.measurementHash !== "") {
      writer.uint32(10).string(message.measurementHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposeMeasurementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeMeasurementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.measurementHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeMeasurementResponse {
    return { measurementHash: isSet(object.measurement_hash) ? globalThis.String(object.measurement_hash) : "" };
  },

  toJSON(message: MsgProposeMeasurementResponse): unknown {
    const obj: any = {};
    if (message.measurementHash !== "") {
      obj.measurement_hash = message.measurementHash;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgProposeMeasurementResponse>): MsgProposeMeasurementResponse {
    const message = createBaseMsgProposeMeasurementResponse();
    message.measurementHash = object.measurementHash ?? "";
    return message;
  },
};

function createBaseMsgRevokeMeasurement(): MsgRevokeMeasurement {
  return { authority: "", measurementHash: new Uint8Array(0), reason: "" };
}

export const MsgRevokeMeasurement: MessageFns<MsgRevokeMeasurement, "virtengine.enclave.v1.MsgRevokeMeasurement"> = {
  $type: "virtengine.enclave.v1.MsgRevokeMeasurement" as const,

  encode(message: MsgRevokeMeasurement, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.measurementHash.length !== 0) {
      writer.uint32(18).bytes(message.measurementHash);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeMeasurement {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeMeasurement();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.measurementHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeMeasurement {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      measurementHash: isSet(object.measurement_hash) ? bytesFromBase64(object.measurement_hash) : new Uint8Array(0),
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgRevokeMeasurement): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.measurementHash.length !== 0) {
      obj.measurement_hash = base64FromBytes(message.measurementHash);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeMeasurement>): MsgRevokeMeasurement {
    const message = createBaseMsgRevokeMeasurement();
    message.authority = object.authority ?? "";
    message.measurementHash = object.measurementHash ?? new Uint8Array(0);
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgRevokeMeasurementResponse(): MsgRevokeMeasurementResponse {
  return {};
}

export const MsgRevokeMeasurementResponse: MessageFns<
  MsgRevokeMeasurementResponse,
  "virtengine.enclave.v1.MsgRevokeMeasurementResponse"
> = {
  $type: "virtengine.enclave.v1.MsgRevokeMeasurementResponse" as const,

  encode(_: MsgRevokeMeasurementResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeMeasurementResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeMeasurementResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeMeasurementResponse {
    return {};
  },

  toJSON(_: MsgRevokeMeasurementResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgRevokeMeasurementResponse>): MsgRevokeMeasurementResponse {
    const message = createBaseMsgRevokeMeasurementResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams, "virtengine.enclave.v1.MsgUpdateParams"> = {
  $type: "virtengine.enclave.v1.MsgUpdateParams" as const,

  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<
  MsgUpdateParamsResponse,
  "virtengine.enclave.v1.MsgUpdateParamsResponse"
> = {
  $type: "virtengine.enclave.v1.MsgUpdateParamsResponse" as const,

  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
