import { bytesFromBase64, base64FromBytes, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/query.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination.ts";
import { AppealParams, AppealRecord } from "./appeal.ts";
import { ComplianceParams, ComplianceProvider, ComplianceRecord } from "./compliance.ts";
import { MLModelInfo, ModelParams, ModelVersionHistory, ModelVersionState, ValidatorModelReport } from "./model.ts";
import {
  AccountStatus,
  accountStatusFromJSON,
  accountStatusToJSON,
  ApprovedClient,
  BorderlineParams,
  ConsentSettings,
  IdentityRecord,
  IdentityScope,
  IdentityScore,
  IdentityTier,
  identityTierFromJSON,
  identityTierToJSON,
  Params,
  ScopeType,
  scopeTypeFromJSON,
  scopeTypeToJSON,
  VerificationStatus,
  verificationStatusFromJSON,
  verificationStatusToJSON,
  WalletStatus,
  walletStatusFromJSON,
  walletStatusToJSON,
} from "./types.ts";

/** QueryIdentityRequest is the request for the Identity query */
export interface QueryIdentityRequest {
  /** AccountAddress is the account to query */
  accountAddress: string;
}

/** QueryIdentityResponse is the response for the Identity query */
export interface QueryIdentityResponse {
  /** Identity is the identity record */
  identity:
    | IdentityRecord
    | undefined;
  /** Found indicates if the identity was found */
  found: boolean;
}

/** QueryIdentityRecordRequest is the request for the IdentityRecord query */
export interface QueryIdentityRecordRequest {
  /** AccountAddress is the account to query */
  accountAddress: string;
}

/** QueryIdentityRecordResponse is the response for the IdentityRecord query */
export interface QueryIdentityRecordResponse {
  /** Record is the identity record */
  record: IdentityRecord | undefined;
}

/** QueryScopeRequest is the request for the Scope query */
export interface QueryScopeRequest {
  /** AccountAddress is the account that owns the scope */
  accountAddress: string;
  /** ScopeID is the scope to query */
  scopeId: string;
}

/** QueryScopeResponse is the response for the Scope query */
export interface QueryScopeResponse {
  /** Scope is the identity scope */
  scope:
    | IdentityScope
    | undefined;
  /** Found indicates if the scope was found */
  found: boolean;
}

/** QueryScopesRequest is the request for the Scopes query */
export interface QueryScopesRequest {
  /** AccountAddress is the account to query scopes for */
  accountAddress: string;
  /** ScopeType is an optional filter by scope type */
  scopeType: ScopeType;
  /** StatusFilter is an optional filter by verification status */
  statusFilter: VerificationStatus;
  /** Pagination is the pagination options */
  pagination: PageRequest | undefined;
}

/** QueryScopesResponse is the response for the Scopes query */
export interface QueryScopesResponse {
  /** Scopes is the list of identity scopes */
  scopes: IdentityScope[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryScopesByTypeRequest is the request for the ScopesByType query */
export interface QueryScopesByTypeRequest {
  /** AccountAddress is the account to query scopes for */
  accountAddress: string;
  /** ScopeType is the type of scopes to filter by */
  scopeType: ScopeType;
}

/** QueryScopesByTypeResponse is the response for the ScopesByType query */
export interface QueryScopesByTypeResponse {
  /** Scopes is the list of identity scopes of the specified type */
  scopes: IdentityScope[];
}

/** QueryIdentityScoreRequest is the request for the IdentityScore query */
export interface QueryIdentityScoreRequest {
  /** AccountAddress is the account to query the score for */
  accountAddress: string;
}

/** QueryIdentityScoreResponse is the response for the IdentityScore query */
export interface QueryIdentityScoreResponse {
  /** Score is the identity score details */
  score:
    | IdentityScore
    | undefined;
  /** Found indicates if a score was found for the account */
  found: boolean;
}

/** QueryIdentityStatusRequest is the request for the IdentityStatus query */
export interface QueryIdentityStatusRequest {
  /** AccountAddress is the account to query the status for */
  accountAddress: string;
}

/** QueryIdentityStatusResponse is the response for the IdentityStatus query */
export interface QueryIdentityStatusResponse {
  /** AccountAddress is the queried address */
  accountAddress: string;
  /** Status is the current verification status */
  status: AccountStatus;
  /** Tier is the current identity tier */
  tier: IdentityTier;
  /** Score is the current score */
  score: number;
  /** ModelVersion is the ML model version used */
  modelVersion: string;
  /** LastUpdatedAt is when the status was last updated (Unix timestamp) */
  lastUpdatedAt: Long;
  /** Found indicates if the account exists */
  found: boolean;
}

/** QueryIdentityWalletRequest is the request for the IdentityWallet query */
export interface QueryIdentityWalletRequest {
  /** AccountAddress is the account to query the wallet for */
  accountAddress: string;
}

/** PublicWalletInfo contains non-sensitive wallet information */
export interface PublicWalletInfo {
  /** WalletID is the wallet identifier */
  walletId: string;
  /** AccountAddress is the owner's address */
  accountAddress: string;
  /** Status is the wallet status */
  status: WalletStatus;
  /** Score is the current identity score */
  score: number;
  /** Tier is the current identity tier */
  tier: IdentityTier;
  /** ScopeCount is the number of scopes in the wallet */
  scopeCount: number;
  /** VerifiedScopeCount is the number of verified scopes */
  verifiedScopeCount: number;
  /** CreatedAt is when the wallet was created (Unix timestamp) */
  createdAt: Long;
  /** LastUpdatedAt is when the wallet was last updated (Unix timestamp) */
  lastUpdatedAt: Long;
}

/** QueryIdentityWalletResponse is the response for the IdentityWallet query */
export interface QueryIdentityWalletResponse {
  /** Wallet contains non-sensitive wallet information */
  wallet:
    | PublicWalletInfo
    | undefined;
  /** Found indicates if the wallet was found */
  found: boolean;
}

/** WalletScopeInfo represents non-sensitive scope information in a wallet */
export interface WalletScopeInfo {
  /** ScopeID is the scope identifier */
  scopeId: string;
  /** ScopeType indicates what kind of identity data this scope contains */
  scopeType: ScopeType;
  /** Status is the current verification status */
  status: VerificationStatus;
  /** AddedAt is when the scope was added (Unix timestamp) */
  addedAt: Long;
  /** VerifiedAt is when the scope was verified (Unix timestamp) */
  verifiedAt: Long;
  /** ExpiresAt is when the verification expires (Unix timestamp) */
  expiresAt: Long;
  /** ConsentGranted indicates if consent is granted for this scope */
  consentGranted: boolean;
}

/** QueryWalletScopesRequest is the request for the WalletScopes query */
export interface QueryWalletScopesRequest {
  /** AccountAddress is the account to query scopes for */
  accountAddress: string;
  /** ScopeType is an optional filter by scope type */
  scopeType: ScopeType;
  /** StatusFilter is an optional filter by verification status */
  statusFilter: VerificationStatus;
  /** ActiveOnly filters to only active scopes */
  activeOnly: boolean;
}

/** QueryWalletScopesResponse is the response for the WalletScopes query */
export interface QueryWalletScopesResponse {
  /** Scopes contains non-sensitive scope information */
  scopes: WalletScopeInfo[];
  /** TotalCount is the total number of scopes in the wallet */
  totalCount: number;
  /** ActiveCount is the number of active scopes */
  activeCount: number;
}

/** QueryConsentSettingsRequest is the request for the ConsentSettings query */
export interface QueryConsentSettingsRequest {
  /** AccountAddress is the account to query consent for */
  accountAddress: string;
  /** ScopeID is an optional filter for specific scope consent */
  scopeId: string;
}

/** PublicConsentInfo represents non-sensitive consent information */
export interface PublicConsentInfo {
  /** ScopeID is the scope identifier */
  scopeId: string;
  /** Granted indicates if consent is granted */
  granted: boolean;
  /** IsActive indicates if consent is currently active */
  isActive: boolean;
  /** Purpose is the consent purpose */
  purpose: string;
  /** ExpiresAt is when consent expires (Unix timestamp) */
  expiresAt: Long;
}

/** QueryConsentSettingsResponse is the response for the ConsentSettings query */
export interface QueryConsentSettingsResponse {
  /** GlobalSettings contains global consent settings */
  globalSettings:
    | ConsentSettings
    | undefined;
  /** ScopeConsents contains per-scope consent info */
  scopeConsents: PublicConsentInfo[];
  /** ConsentVersion is the current consent version */
  consentVersion: number;
  /** LastUpdatedAt is when consent was last updated (Unix timestamp) */
  lastUpdatedAt: Long;
}

/** PublicVerificationHistoryEntry represents non-sensitive verification history */
export interface PublicVerificationHistoryEntry {
  /** EntryID is the entry identifier */
  entryId: string;
  /** Timestamp is when this verification occurred (Unix timestamp) */
  timestamp: Long;
  /** BlockHeight is the block height */
  blockHeight: Long;
  /** PreviousScore is the score before verification */
  previousScore: number;
  /** NewScore is the score after verification */
  newScore: number;
  /** PreviousStatus is the status before verification */
  previousStatus: AccountStatus;
  /** NewStatus is the status after verification */
  newStatus: AccountStatus;
  /** ScopeCount is the number of scopes evaluated */
  scopeCount: number;
  /** ModelVersion is the model version used */
  modelVersion: string;
}

/** QueryVerificationHistoryRequest is the request for the VerificationHistory query */
export interface QueryVerificationHistoryRequest {
  /** AccountAddress is the account to query history for */
  accountAddress: string;
  /** Limit is the maximum number of entries to return */
  limit: number;
  /** Offset is the number of entries to skip */
  offset: number;
}

/** QueryVerificationHistoryResponse is the response for the VerificationHistory query */
export interface QueryVerificationHistoryResponse {
  /** Entries contains verification history entries */
  entries: PublicVerificationHistoryEntry[];
  /** TotalCount is the total number of entries */
  totalCount: number;
}

/** QueryApprovedClientsRequest is the request for the ApprovedClients query */
export interface QueryApprovedClientsRequest {
  /** ActiveOnly filters to only active clients */
  activeOnly: boolean;
  /** Pagination is the pagination options */
  pagination: PageRequest | undefined;
}

/** QueryApprovedClientsResponse is the response for the ApprovedClients query */
export interface QueryApprovedClientsResponse {
  /** Clients is the list of approved clients */
  clients: ApprovedClient[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryParamsRequest is the request for the Params query */
export interface QueryParamsRequest {
}

/** QueryParamsResponse is the response for the Params query */
export interface QueryParamsResponse {
  /** Params are the module parameters */
  params: Params | undefined;
}

/** QueryBorderlineParamsRequest is the request for the BorderlineParams query */
export interface QueryBorderlineParamsRequest {
}

/** QueryBorderlineParamsResponse is the response for the BorderlineParams query */
export interface QueryBorderlineParamsResponse {
  /** Params are the borderline parameters */
  params: BorderlineParams | undefined;
}

/** PublicDerivedFeaturesInfo contains non-sensitive derived features metadata */
export interface PublicDerivedFeaturesInfo {
  /** HasFaceEmbedding indicates if face embedding hash exists */
  hasFaceEmbedding: boolean;
  /** HasBiometric indicates if biometric hash exists */
  hasBiometric: boolean;
  /** HasLivenessProof indicates if liveness proof hash exists */
  hasLivenessProof: boolean;
  /** DocFieldKeys lists which document fields have hashes */
  docFieldKeys: string[];
  /** LastComputedAt is when features were last computed (Unix timestamp) */
  lastComputedAt: Long;
  /** ModelVersion is the model version used */
  modelVersion: string;
  /** FeatureVersion is the schema version */
  featureVersion: number;
}

/** QueryDerivedFeaturesRequest is the request for the DerivedFeatures query */
export interface QueryDerivedFeaturesRequest {
  /** AccountAddress is the account to query features for */
  accountAddress: string;
}

/** QueryDerivedFeaturesResponse is the response for the DerivedFeatures query */
export interface QueryDerivedFeaturesResponse {
  /** Features contains non-sensitive derived features information */
  features:
    | PublicDerivedFeaturesInfo
    | undefined;
  /** Found indicates if features were found */
  found: boolean;
}

/**
 * QueryDerivedFeatureHashesRequest is the request for the DerivedFeatureHashes query
 * This is used for verification matching by authorized parties
 */
export interface QueryDerivedFeatureHashesRequest {
  /** AccountAddress is the account to query hashes for */
  accountAddress: string;
  /** Requester is the address requesting the hashes */
  requester: string;
  /** Purpose describes why the hashes are being requested */
  purpose: string;
}

/**
 * QueryDerivedFeatureHashesResponse is the response for the DerivedFeatureHashes query
 * Only returned if consent allows sharing
 */
export interface QueryDerivedFeatureHashesResponse {
  /** Allowed indicates if the request was allowed based on consent */
  allowed: boolean;
  /** DenialReason is set if Allowed is false */
  denialReason: string;
  /** FaceEmbeddingHash is the face embedding hash (if consented) */
  faceEmbeddingHash: Uint8Array;
  /** DocFieldHashes are document field hashes (if consented) */
  docFieldHashes: { [key: string]: Uint8Array };
  /** BiometricHash is the biometric hash (if consented) */
  biometricHash: Uint8Array;
  /** ModelVersion is the model version used */
  modelVersion: string;
}

export interface QueryDerivedFeatureHashesResponse_DocFieldHashesEntry {
  key: string;
  value: Uint8Array;
}

/** QueryAppealRequest is the request for the Appeal query */
export interface QueryAppealRequest {
  /** AppealID is the appeal to query */
  appealId: string;
}

/** QueryAppealResponse is the response for the Appeal query */
export interface QueryAppealResponse {
  /** Appeal is the appeal record */
  appeal:
    | AppealRecord
    | undefined;
  /** Found indicates if the appeal was found */
  found: boolean;
}

/** QueryAppealsRequest is the request for the Appeals query */
export interface QueryAppealsRequest {
  /** AccountAddress is the account to query appeals for */
  accountAddress: string;
  /** Pagination is optional pagination parameters */
  pagination: PageRequest | undefined;
}

/** QueryAppealsResponse is the response for the Appeals query */
export interface QueryAppealsResponse {
  /** Appeals is the list of appeal records */
  appeals: AppealRecord[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryAppealsByScopeRequest is the request for the AppealsByScope query */
export interface QueryAppealsByScopeRequest {
  /** ScopeID is the scope to query appeals for */
  scopeId: string;
  /** Pagination is optional pagination parameters */
  pagination: PageRequest | undefined;
}

/** QueryAppealsByScopeResponse is the response for the AppealsByScope query */
export interface QueryAppealsByScopeResponse {
  /** Appeals is the list of appeal records */
  appeals: AppealRecord[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryAppealParamsRequest is the request for the AppealParams query */
export interface QueryAppealParamsRequest {
}

/** QueryAppealParamsResponse is the response for the AppealParams query */
export interface QueryAppealParamsResponse {
  /** Params are the appeal parameters */
  params: AppealParams | undefined;
}

/** QueryComplianceStatusRequest is the request for the ComplianceStatus query */
export interface QueryComplianceStatusRequest {
  /** AccountAddress is the account to query compliance for */
  accountAddress: string;
}

/** QueryComplianceStatusResponse is the response for the ComplianceStatus query */
export interface QueryComplianceStatusResponse {
  /** Record is the compliance record */
  record:
    | ComplianceRecord
    | undefined;
  /** Found indicates if the record was found */
  found: boolean;
}

/** QueryComplianceProviderRequest is the request for the ComplianceProvider query */
export interface QueryComplianceProviderRequest {
  /** ProviderID is the provider to query */
  providerId: string;
}

/** QueryComplianceProviderResponse is the response for the ComplianceProvider query */
export interface QueryComplianceProviderResponse {
  /** Provider is the compliance provider */
  provider:
    | ComplianceProvider
    | undefined;
  /** Found indicates if the provider was found */
  found: boolean;
}

/** QueryComplianceProvidersRequest is the request for the ComplianceProviders query */
export interface QueryComplianceProvidersRequest {
  /** ActiveOnly filters to only return active providers */
  activeOnly: boolean;
  /** Pagination is optional pagination parameters */
  pagination: PageRequest | undefined;
}

/** QueryComplianceProvidersResponse is the response for the ComplianceProviders query */
export interface QueryComplianceProvidersResponse {
  /** Providers is the list of compliance providers */
  providers: ComplianceProvider[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryComplianceParamsRequest is the request for the ComplianceParams query */
export interface QueryComplianceParamsRequest {
}

/** QueryComplianceParamsResponse is the response for the ComplianceParams query */
export interface QueryComplianceParamsResponse {
  /** Params are the compliance parameters */
  params: ComplianceParams | undefined;
}

/** QueryModelVersionRequest is the request for the ModelVersion query */
export interface QueryModelVersionRequest {
  /** ModelType is the type of model to query */
  modelType: string;
}

/** QueryModelVersionResponse is the response for the ModelVersion query */
export interface QueryModelVersionResponse {
  /** ModelInfo is the model information */
  modelInfo:
    | MLModelInfo
    | undefined;
  /** Found indicates if the model was found */
  found: boolean;
}

/** QueryActiveModelsRequest is the request for the ActiveModels query */
export interface QueryActiveModelsRequest {
}

/** QueryActiveModelsResponse is the response for the ActiveModels query */
export interface QueryActiveModelsResponse {
  /** State is the current model version state */
  state:
    | ModelVersionState
    | undefined;
  /** Models is the list of active ML models */
  models: MLModelInfo[];
}

/** QueryModelHistoryRequest is the request for the ModelHistory query */
export interface QueryModelHistoryRequest {
  /** ModelType is the type of model to query history for */
  modelType: string;
  /** Pagination is optional pagination parameters */
  pagination: PageRequest | undefined;
}

/** QueryModelHistoryResponse is the response for the ModelHistory query */
export interface QueryModelHistoryResponse {
  /** History is the list of model version changes */
  history: ModelVersionHistory[];
  /** Pagination is the pagination response */
  pagination: PageResponse | undefined;
}

/** QueryValidatorModelSyncRequest is the request for the ValidatorModelSync query */
export interface QueryValidatorModelSyncRequest {
  /** ValidatorAddress is the validator to query */
  validatorAddress: string;
}

/** QueryValidatorModelSyncResponse is the response for the ValidatorModelSync query */
export interface QueryValidatorModelSyncResponse {
  /** Report is the validator's model version report */
  report:
    | ValidatorModelReport
    | undefined;
  /** IsSynced indicates if the validator is synced with consensus */
  isSynced: boolean;
}

/** QueryModelParamsRequest is the request for the ModelParams query */
export interface QueryModelParamsRequest {
}

/** QueryModelParamsResponse is the response for the ModelParams query */
export interface QueryModelParamsResponse {
  /** Params are the model management parameters */
  params: ModelParams | undefined;
}

function createBaseQueryIdentityRequest(): QueryIdentityRequest {
  return { accountAddress: "" };
}

export const QueryIdentityRequest: MessageFns<QueryIdentityRequest, "virtengine.veid.v1.QueryIdentityRequest"> = {
  $type: "virtengine.veid.v1.QueryIdentityRequest" as const,

  encode(message: QueryIdentityRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryIdentityRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityRequest>): QueryIdentityRequest {
    const message = createBaseQueryIdentityRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryIdentityResponse(): QueryIdentityResponse {
  return { identity: undefined, found: false };
}

export const QueryIdentityResponse: MessageFns<QueryIdentityResponse, "virtengine.veid.v1.QueryIdentityResponse"> = {
  $type: "virtengine.veid.v1.QueryIdentityResponse" as const,

  encode(message: QueryIdentityResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.identity !== undefined) {
      IdentityRecord.encode(message.identity, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identity = IdentityRecord.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityResponse {
    return {
      identity: isSet(object.identity) ? IdentityRecord.fromJSON(object.identity) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryIdentityResponse): unknown {
    const obj: any = {};
    if (message.identity !== undefined) {
      obj.identity = IdentityRecord.toJSON(message.identity);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityResponse>): QueryIdentityResponse {
    const message = createBaseQueryIdentityResponse();
    message.identity = (object.identity !== undefined && object.identity !== null)
      ? IdentityRecord.fromPartial(object.identity)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryIdentityRecordRequest(): QueryIdentityRecordRequest {
  return { accountAddress: "" };
}

export const QueryIdentityRecordRequest: MessageFns<
  QueryIdentityRecordRequest,
  "virtengine.veid.v1.QueryIdentityRecordRequest"
> = {
  $type: "virtengine.veid.v1.QueryIdentityRecordRequest" as const,

  encode(message: QueryIdentityRecordRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityRecordRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityRecordRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityRecordRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryIdentityRecordRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityRecordRequest>): QueryIdentityRecordRequest {
    const message = createBaseQueryIdentityRecordRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryIdentityRecordResponse(): QueryIdentityRecordResponse {
  return { record: undefined };
}

export const QueryIdentityRecordResponse: MessageFns<
  QueryIdentityRecordResponse,
  "virtengine.veid.v1.QueryIdentityRecordResponse"
> = {
  $type: "virtengine.veid.v1.QueryIdentityRecordResponse" as const,

  encode(message: QueryIdentityRecordResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      IdentityRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityRecordResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityRecordResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.record = IdentityRecord.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityRecordResponse {
    return { record: isSet(object.record) ? IdentityRecord.fromJSON(object.record) : undefined };
  },

  toJSON(message: QueryIdentityRecordResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = IdentityRecord.toJSON(message.record);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityRecordResponse>): QueryIdentityRecordResponse {
    const message = createBaseQueryIdentityRecordResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? IdentityRecord.fromPartial(object.record)
      : undefined;
    return message;
  },
};

function createBaseQueryScopeRequest(): QueryScopeRequest {
  return { accountAddress: "", scopeId: "" };
}

export const QueryScopeRequest: MessageFns<QueryScopeRequest, "virtengine.veid.v1.QueryScopeRequest"> = {
  $type: "virtengine.veid.v1.QueryScopeRequest" as const,

  encode(message: QueryScopeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopeRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
    };
  },

  toJSON(message: QueryScopeRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopeRequest>): QueryScopeRequest {
    const message = createBaseQueryScopeRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeId = object.scopeId ?? "";
    return message;
  },
};

function createBaseQueryScopeResponse(): QueryScopeResponse {
  return { scope: undefined, found: false };
}

export const QueryScopeResponse: MessageFns<QueryScopeResponse, "virtengine.veid.v1.QueryScopeResponse"> = {
  $type: "virtengine.veid.v1.QueryScopeResponse" as const,

  encode(message: QueryScopeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scope !== undefined) {
      IdentityScope.encode(message.scope, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scope = IdentityScope.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopeResponse {
    return {
      scope: isSet(object.scope) ? IdentityScope.fromJSON(object.scope) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryScopeResponse): unknown {
    const obj: any = {};
    if (message.scope !== undefined) {
      obj.scope = IdentityScope.toJSON(message.scope);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopeResponse>): QueryScopeResponse {
    const message = createBaseQueryScopeResponse();
    message.scope = (object.scope !== undefined && object.scope !== null)
      ? IdentityScope.fromPartial(object.scope)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryScopesRequest(): QueryScopesRequest {
  return { accountAddress: "", scopeType: 0, statusFilter: 0, pagination: undefined };
}

export const QueryScopesRequest: MessageFns<QueryScopesRequest, "virtengine.veid.v1.QueryScopesRequest"> = {
  $type: "virtengine.veid.v1.QueryScopesRequest" as const,

  encode(message: QueryScopesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.statusFilter !== 0) {
      writer.uint32(24).int32(message.statusFilter);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statusFilter = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopesRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      statusFilter: isSet(object.status_filter) ? verificationStatusFromJSON(object.status_filter) : 0,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryScopesRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.statusFilter !== 0) {
      obj.status_filter = verificationStatusToJSON(message.statusFilter);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopesRequest>): QueryScopesRequest {
    const message = createBaseQueryScopesRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.statusFilter = object.statusFilter ?? 0;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryScopesResponse(): QueryScopesResponse {
  return { scopes: [], pagination: undefined };
}

export const QueryScopesResponse: MessageFns<QueryScopesResponse, "virtengine.veid.v1.QueryScopesResponse"> = {
  $type: "virtengine.veid.v1.QueryScopesResponse" as const,

  encode(message: QueryScopesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scopes) {
      IdentityScope.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopes.push(IdentityScope.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopesResponse {
    return {
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => IdentityScope.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryScopesResponse): unknown {
    const obj: any = {};
    if (message.scopes?.length) {
      obj.scopes = message.scopes.map((e) => IdentityScope.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopesResponse>): QueryScopesResponse {
    const message = createBaseQueryScopesResponse();
    message.scopes = object.scopes?.map((e) => IdentityScope.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryScopesByTypeRequest(): QueryScopesByTypeRequest {
  return { accountAddress: "", scopeType: 0 };
}

export const QueryScopesByTypeRequest: MessageFns<
  QueryScopesByTypeRequest,
  "virtengine.veid.v1.QueryScopesByTypeRequest"
> = {
  $type: "virtengine.veid.v1.QueryScopesByTypeRequest" as const,

  encode(message: QueryScopesByTypeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopesByTypeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopesByTypeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopesByTypeRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
    };
  },

  toJSON(message: QueryScopesByTypeRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopesByTypeRequest>): QueryScopesByTypeRequest {
    const message = createBaseQueryScopesByTypeRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeType = object.scopeType ?? 0;
    return message;
  },
};

function createBaseQueryScopesByTypeResponse(): QueryScopesByTypeResponse {
  return { scopes: [] };
}

export const QueryScopesByTypeResponse: MessageFns<
  QueryScopesByTypeResponse,
  "virtengine.veid.v1.QueryScopesByTypeResponse"
> = {
  $type: "virtengine.veid.v1.QueryScopesByTypeResponse" as const,

  encode(message: QueryScopesByTypeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scopes) {
      IdentityScope.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryScopesByTypeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryScopesByTypeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopes.push(IdentityScope.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryScopesByTypeResponse {
    return {
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => IdentityScope.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryScopesByTypeResponse): unknown {
    const obj: any = {};
    if (message.scopes?.length) {
      obj.scopes = message.scopes.map((e) => IdentityScope.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryScopesByTypeResponse>): QueryScopesByTypeResponse {
    const message = createBaseQueryScopesByTypeResponse();
    message.scopes = object.scopes?.map((e) => IdentityScope.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryIdentityScoreRequest(): QueryIdentityScoreRequest {
  return { accountAddress: "" };
}

export const QueryIdentityScoreRequest: MessageFns<
  QueryIdentityScoreRequest,
  "virtengine.veid.v1.QueryIdentityScoreRequest"
> = {
  $type: "virtengine.veid.v1.QueryIdentityScoreRequest" as const,

  encode(message: QueryIdentityScoreRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityScoreRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityScoreRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityScoreRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryIdentityScoreRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityScoreRequest>): QueryIdentityScoreRequest {
    const message = createBaseQueryIdentityScoreRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryIdentityScoreResponse(): QueryIdentityScoreResponse {
  return { score: undefined, found: false };
}

export const QueryIdentityScoreResponse: MessageFns<
  QueryIdentityScoreResponse,
  "virtengine.veid.v1.QueryIdentityScoreResponse"
> = {
  $type: "virtengine.veid.v1.QueryIdentityScoreResponse" as const,

  encode(message: QueryIdentityScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.score !== undefined) {
      IdentityScore.encode(message.score, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.score = IdentityScore.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityScoreResponse {
    return {
      score: isSet(object.score) ? IdentityScore.fromJSON(object.score) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryIdentityScoreResponse): unknown {
    const obj: any = {};
    if (message.score !== undefined) {
      obj.score = IdentityScore.toJSON(message.score);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityScoreResponse>): QueryIdentityScoreResponse {
    const message = createBaseQueryIdentityScoreResponse();
    message.score = (object.score !== undefined && object.score !== null)
      ? IdentityScore.fromPartial(object.score)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryIdentityStatusRequest(): QueryIdentityStatusRequest {
  return { accountAddress: "" };
}

export const QueryIdentityStatusRequest: MessageFns<
  QueryIdentityStatusRequest,
  "virtengine.veid.v1.QueryIdentityStatusRequest"
> = {
  $type: "virtengine.veid.v1.QueryIdentityStatusRequest" as const,

  encode(message: QueryIdentityStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityStatusRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryIdentityStatusRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityStatusRequest>): QueryIdentityStatusRequest {
    const message = createBaseQueryIdentityStatusRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryIdentityStatusResponse(): QueryIdentityStatusResponse {
  return { accountAddress: "", status: 0, tier: 0, score: 0, modelVersion: "", lastUpdatedAt: Long.ZERO, found: false };
}

export const QueryIdentityStatusResponse: MessageFns<
  QueryIdentityStatusResponse,
  "virtengine.veid.v1.QueryIdentityStatusResponse"
> = {
  $type: "virtengine.veid.v1.QueryIdentityStatusResponse" as const,

  encode(message: QueryIdentityStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.tier !== 0) {
      writer.uint32(24).int32(message.tier);
    }
    if (message.score !== 0) {
      writer.uint32(32).uint32(message.score);
    }
    if (message.modelVersion !== "") {
      writer.uint32(42).string(message.modelVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastUpdatedAt.toString());
    }
    if (message.found !== false) {
      writer.uint32(56).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastUpdatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityStatusResponse {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      status: isSet(object.status) ? accountStatusFromJSON(object.status) : 0,
      tier: isSet(object.tier) ? identityTierFromJSON(object.tier) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
      lastUpdatedAt: isSet(object.last_updated_at) ? Long.fromValue(object.last_updated_at) : Long.ZERO,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryIdentityStatusResponse): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.status !== 0) {
      obj.status = accountStatusToJSON(message.status);
    }
    if (message.tier !== 0) {
      obj.tier = identityTierToJSON(message.tier);
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      obj.last_updated_at = (message.lastUpdatedAt || Long.ZERO).toString();
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityStatusResponse>): QueryIdentityStatusResponse {
    const message = createBaseQueryIdentityStatusResponse();
    message.accountAddress = object.accountAddress ?? "";
    message.status = object.status ?? 0;
    message.tier = object.tier ?? 0;
    message.score = object.score ?? 0;
    message.modelVersion = object.modelVersion ?? "";
    message.lastUpdatedAt = (object.lastUpdatedAt !== undefined && object.lastUpdatedAt !== null)
      ? Long.fromValue(object.lastUpdatedAt)
      : Long.ZERO;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryIdentityWalletRequest(): QueryIdentityWalletRequest {
  return { accountAddress: "" };
}

export const QueryIdentityWalletRequest: MessageFns<
  QueryIdentityWalletRequest,
  "virtengine.veid.v1.QueryIdentityWalletRequest"
> = {
  $type: "virtengine.veid.v1.QueryIdentityWalletRequest" as const,

  encode(message: QueryIdentityWalletRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityWalletRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityWalletRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityWalletRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryIdentityWalletRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityWalletRequest>): QueryIdentityWalletRequest {
    const message = createBaseQueryIdentityWalletRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBasePublicWalletInfo(): PublicWalletInfo {
  return {
    walletId: "",
    accountAddress: "",
    status: 0,
    score: 0,
    tier: 0,
    scopeCount: 0,
    verifiedScopeCount: 0,
    createdAt: Long.ZERO,
    lastUpdatedAt: Long.ZERO,
  };
}

export const PublicWalletInfo: MessageFns<PublicWalletInfo, "virtengine.veid.v1.PublicWalletInfo"> = {
  $type: "virtengine.veid.v1.PublicWalletInfo" as const,

  encode(message: PublicWalletInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== "") {
      writer.uint32(10).string(message.walletId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.score !== 0) {
      writer.uint32(32).uint32(message.score);
    }
    if (message.tier !== 0) {
      writer.uint32(40).int32(message.tier);
    }
    if (message.scopeCount !== 0) {
      writer.uint32(48).int32(message.scopeCount);
    }
    if (message.verifiedScopeCount !== 0) {
      writer.uint32(56).int32(message.verifiedScopeCount);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.createdAt.toString());
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.lastUpdatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicWalletInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicWalletInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scopeCount = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.verifiedScopeCount = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.lastUpdatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicWalletInfo {
    return {
      walletId: isSet(object.wallet_id) ? globalThis.String(object.wallet_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      status: isSet(object.status) ? walletStatusFromJSON(object.status) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      tier: isSet(object.tier) ? identityTierFromJSON(object.tier) : 0,
      scopeCount: isSet(object.scope_count) ? globalThis.Number(object.scope_count) : 0,
      verifiedScopeCount: isSet(object.verified_scope_count) ? globalThis.Number(object.verified_scope_count) : 0,
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      lastUpdatedAt: isSet(object.last_updated_at) ? Long.fromValue(object.last_updated_at) : Long.ZERO,
    };
  },

  toJSON(message: PublicWalletInfo): unknown {
    const obj: any = {};
    if (message.walletId !== "") {
      obj.wallet_id = message.walletId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.status !== 0) {
      obj.status = walletStatusToJSON(message.status);
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.tier !== 0) {
      obj.tier = identityTierToJSON(message.tier);
    }
    if (message.scopeCount !== 0) {
      obj.scope_count = Math.round(message.scopeCount);
    }
    if (message.verifiedScopeCount !== 0) {
      obj.verified_scope_count = Math.round(message.verifiedScopeCount);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      obj.last_updated_at = (message.lastUpdatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<PublicWalletInfo>): PublicWalletInfo {
    const message = createBasePublicWalletInfo();
    message.walletId = object.walletId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.status = object.status ?? 0;
    message.score = object.score ?? 0;
    message.tier = object.tier ?? 0;
    message.scopeCount = object.scopeCount ?? 0;
    message.verifiedScopeCount = object.verifiedScopeCount ?? 0;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.lastUpdatedAt = (object.lastUpdatedAt !== undefined && object.lastUpdatedAt !== null)
      ? Long.fromValue(object.lastUpdatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseQueryIdentityWalletResponse(): QueryIdentityWalletResponse {
  return { wallet: undefined, found: false };
}

export const QueryIdentityWalletResponse: MessageFns<
  QueryIdentityWalletResponse,
  "virtengine.veid.v1.QueryIdentityWalletResponse"
> = {
  $type: "virtengine.veid.v1.QueryIdentityWalletResponse" as const,

  encode(message: QueryIdentityWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.wallet !== undefined) {
      PublicWalletInfo.encode(message.wallet, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryIdentityWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryIdentityWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.wallet = PublicWalletInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryIdentityWalletResponse {
    return {
      wallet: isSet(object.wallet) ? PublicWalletInfo.fromJSON(object.wallet) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryIdentityWalletResponse): unknown {
    const obj: any = {};
    if (message.wallet !== undefined) {
      obj.wallet = PublicWalletInfo.toJSON(message.wallet);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryIdentityWalletResponse>): QueryIdentityWalletResponse {
    const message = createBaseQueryIdentityWalletResponse();
    message.wallet = (object.wallet !== undefined && object.wallet !== null)
      ? PublicWalletInfo.fromPartial(object.wallet)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseWalletScopeInfo(): WalletScopeInfo {
  return {
    scopeId: "",
    scopeType: 0,
    status: 0,
    addedAt: Long.ZERO,
    verifiedAt: Long.ZERO,
    expiresAt: Long.ZERO,
    consentGranted: false,
  };
}

export const WalletScopeInfo: MessageFns<WalletScopeInfo, "virtengine.veid.v1.WalletScopeInfo"> = {
  $type: "virtengine.veid.v1.WalletScopeInfo" as const,

  encode(message: WalletScopeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.addedAt.toString());
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.verifiedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.expiresAt.toString());
    }
    if (message.consentGranted !== false) {
      writer.uint32(56).bool(message.consentGranted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WalletScopeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWalletScopeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.addedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.verifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.consentGranted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WalletScopeInfo {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      status: isSet(object.status) ? verificationStatusFromJSON(object.status) : 0,
      addedAt: isSet(object.added_at) ? Long.fromValue(object.added_at) : Long.ZERO,
      verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      consentGranted: isSet(object.consent_granted) ? globalThis.Boolean(object.consent_granted) : false,
    };
  },

  toJSON(message: WalletScopeInfo): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.status !== 0) {
      obj.status = verificationStatusToJSON(message.status);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      obj.added_at = (message.addedAt || Long.ZERO).toString();
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.consentGranted !== false) {
      obj.consent_granted = message.consentGranted;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<WalletScopeInfo>): WalletScopeInfo {
    const message = createBaseWalletScopeInfo();
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.status = object.status ?? 0;
    message.addedAt = (object.addedAt !== undefined && object.addedAt !== null)
      ? Long.fromValue(object.addedAt)
      : Long.ZERO;
    message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
      ? Long.fromValue(object.verifiedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.consentGranted = object.consentGranted ?? false;
    return message;
  },
};

function createBaseQueryWalletScopesRequest(): QueryWalletScopesRequest {
  return { accountAddress: "", scopeType: 0, statusFilter: 0, activeOnly: false };
}

export const QueryWalletScopesRequest: MessageFns<
  QueryWalletScopesRequest,
  "virtengine.veid.v1.QueryWalletScopesRequest"
> = {
  $type: "virtengine.veid.v1.QueryWalletScopesRequest" as const,

  encode(message: QueryWalletScopesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.statusFilter !== 0) {
      writer.uint32(24).int32(message.statusFilter);
    }
    if (message.activeOnly !== false) {
      writer.uint32(32).bool(message.activeOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryWalletScopesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWalletScopesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.statusFilter = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryWalletScopesRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      statusFilter: isSet(object.status_filter) ? verificationStatusFromJSON(object.status_filter) : 0,
      activeOnly: isSet(object.active_only) ? globalThis.Boolean(object.active_only) : false,
    };
  },

  toJSON(message: QueryWalletScopesRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.statusFilter !== 0) {
      obj.status_filter = verificationStatusToJSON(message.statusFilter);
    }
    if (message.activeOnly !== false) {
      obj.active_only = message.activeOnly;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryWalletScopesRequest>): QueryWalletScopesRequest {
    const message = createBaseQueryWalletScopesRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.statusFilter = object.statusFilter ?? 0;
    message.activeOnly = object.activeOnly ?? false;
    return message;
  },
};

function createBaseQueryWalletScopesResponse(): QueryWalletScopesResponse {
  return { scopes: [], totalCount: 0, activeCount: 0 };
}

export const QueryWalletScopesResponse: MessageFns<
  QueryWalletScopesResponse,
  "virtengine.veid.v1.QueryWalletScopesResponse"
> = {
  $type: "virtengine.veid.v1.QueryWalletScopesResponse" as const,

  encode(message: QueryWalletScopesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.scopes) {
      WalletScopeInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    if (message.activeCount !== 0) {
      writer.uint32(24).int32(message.activeCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryWalletScopesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryWalletScopesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopes.push(WalletScopeInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.activeCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryWalletScopesResponse {
    return {
      scopes: globalThis.Array.isArray(object?.scopes)
        ? object.scopes.map((e: any) => WalletScopeInfo.fromJSON(e))
        : [],
      totalCount: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
      activeCount: isSet(object.active_count) ? globalThis.Number(object.active_count) : 0,
    };
  },

  toJSON(message: QueryWalletScopesResponse): unknown {
    const obj: any = {};
    if (message.scopes?.length) {
      obj.scopes = message.scopes.map((e) => WalletScopeInfo.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    if (message.activeCount !== 0) {
      obj.active_count = Math.round(message.activeCount);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryWalletScopesResponse>): QueryWalletScopesResponse {
    const message = createBaseQueryWalletScopesResponse();
    message.scopes = object.scopes?.map((e) => WalletScopeInfo.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    message.activeCount = object.activeCount ?? 0;
    return message;
  },
};

function createBaseQueryConsentSettingsRequest(): QueryConsentSettingsRequest {
  return { accountAddress: "", scopeId: "" };
}

export const QueryConsentSettingsRequest: MessageFns<
  QueryConsentSettingsRequest,
  "virtengine.veid.v1.QueryConsentSettingsRequest"
> = {
  $type: "virtengine.veid.v1.QueryConsentSettingsRequest" as const,

  encode(message: QueryConsentSettingsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsentSettingsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsentSettingsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsentSettingsRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
    };
  },

  toJSON(message: QueryConsentSettingsRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryConsentSettingsRequest>): QueryConsentSettingsRequest {
    const message = createBaseQueryConsentSettingsRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeId = object.scopeId ?? "";
    return message;
  },
};

function createBasePublicConsentInfo(): PublicConsentInfo {
  return { scopeId: "", granted: false, isActive: false, purpose: "", expiresAt: Long.ZERO };
}

export const PublicConsentInfo: MessageFns<PublicConsentInfo, "virtengine.veid.v1.PublicConsentInfo"> = {
  $type: "virtengine.veid.v1.PublicConsentInfo" as const,

  encode(message: PublicConsentInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.granted !== false) {
      writer.uint32(16).bool(message.granted);
    }
    if (message.isActive !== false) {
      writer.uint32(24).bool(message.isActive);
    }
    if (message.purpose !== "") {
      writer.uint32(34).string(message.purpose);
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicConsentInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicConsentInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.granted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purpose = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicConsentInfo {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      granted: isSet(object.granted) ? globalThis.Boolean(object.granted) : false,
      isActive: isSet(object.is_active) ? globalThis.Boolean(object.is_active) : false,
      purpose: isSet(object.purpose) ? globalThis.String(object.purpose) : "",
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
    };
  },

  toJSON(message: PublicConsentInfo): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.granted !== false) {
      obj.granted = message.granted;
    }
    if (message.isActive !== false) {
      obj.is_active = message.isActive;
    }
    if (message.purpose !== "") {
      obj.purpose = message.purpose;
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<PublicConsentInfo>): PublicConsentInfo {
    const message = createBasePublicConsentInfo();
    message.scopeId = object.scopeId ?? "";
    message.granted = object.granted ?? false;
    message.isActive = object.isActive ?? false;
    message.purpose = object.purpose ?? "";
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseQueryConsentSettingsResponse(): QueryConsentSettingsResponse {
  return { globalSettings: undefined, scopeConsents: [], consentVersion: 0, lastUpdatedAt: Long.ZERO };
}

export const QueryConsentSettingsResponse: MessageFns<
  QueryConsentSettingsResponse,
  "virtengine.veid.v1.QueryConsentSettingsResponse"
> = {
  $type: "virtengine.veid.v1.QueryConsentSettingsResponse" as const,

  encode(message: QueryConsentSettingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.globalSettings !== undefined) {
      ConsentSettings.encode(message.globalSettings, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopeConsents) {
      PublicConsentInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.consentVersion !== 0) {
      writer.uint32(24).uint32(message.consentVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastUpdatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryConsentSettingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryConsentSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.globalSettings = ConsentSettings.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeConsents.push(PublicConsentInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.consentVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastUpdatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryConsentSettingsResponse {
    return {
      globalSettings: isSet(object.global_settings) ? ConsentSettings.fromJSON(object.global_settings) : undefined,
      scopeConsents: globalThis.Array.isArray(object?.scope_consents)
        ? object.scope_consents.map((e: any) => PublicConsentInfo.fromJSON(e))
        : [],
      consentVersion: isSet(object.consent_version) ? globalThis.Number(object.consent_version) : 0,
      lastUpdatedAt: isSet(object.last_updated_at) ? Long.fromValue(object.last_updated_at) : Long.ZERO,
    };
  },

  toJSON(message: QueryConsentSettingsResponse): unknown {
    const obj: any = {};
    if (message.globalSettings !== undefined) {
      obj.global_settings = ConsentSettings.toJSON(message.globalSettings);
    }
    if (message.scopeConsents?.length) {
      obj.scope_consents = message.scopeConsents.map((e) => PublicConsentInfo.toJSON(e));
    }
    if (message.consentVersion !== 0) {
      obj.consent_version = Math.round(message.consentVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      obj.last_updated_at = (message.lastUpdatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryConsentSettingsResponse>): QueryConsentSettingsResponse {
    const message = createBaseQueryConsentSettingsResponse();
    message.globalSettings = (object.globalSettings !== undefined && object.globalSettings !== null)
      ? ConsentSettings.fromPartial(object.globalSettings)
      : undefined;
    message.scopeConsents = object.scopeConsents?.map((e) => PublicConsentInfo.fromPartial(e)) || [];
    message.consentVersion = object.consentVersion ?? 0;
    message.lastUpdatedAt = (object.lastUpdatedAt !== undefined && object.lastUpdatedAt !== null)
      ? Long.fromValue(object.lastUpdatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBasePublicVerificationHistoryEntry(): PublicVerificationHistoryEntry {
  return {
    entryId: "",
    timestamp: Long.ZERO,
    blockHeight: Long.ZERO,
    previousScore: 0,
    newScore: 0,
    previousStatus: 0,
    newStatus: 0,
    scopeCount: 0,
    modelVersion: "",
  };
}

export const PublicVerificationHistoryEntry: MessageFns<
  PublicVerificationHistoryEntry,
  "virtengine.veid.v1.PublicVerificationHistoryEntry"
> = {
  $type: "virtengine.veid.v1.PublicVerificationHistoryEntry" as const,

  encode(message: PublicVerificationHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.timestamp.toString());
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.blockHeight.toString());
    }
    if (message.previousScore !== 0) {
      writer.uint32(32).uint32(message.previousScore);
    }
    if (message.newScore !== 0) {
      writer.uint32(40).uint32(message.newScore);
    }
    if (message.previousStatus !== 0) {
      writer.uint32(48).int32(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(56).int32(message.newStatus);
    }
    if (message.scopeCount !== 0) {
      writer.uint32(64).int32(message.scopeCount);
    }
    if (message.modelVersion !== "") {
      writer.uint32(74).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicVerificationHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicVerificationHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.previousScore = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.newScore = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.previousStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.scopeCount = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicVerificationHistoryEntry {
    return {
      entryId: isSet(object.entry_id) ? globalThis.String(object.entry_id) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      previousScore: isSet(object.previous_score) ? globalThis.Number(object.previous_score) : 0,
      newScore: isSet(object.new_score) ? globalThis.Number(object.new_score) : 0,
      previousStatus: isSet(object.previous_status) ? accountStatusFromJSON(object.previous_status) : 0,
      newStatus: isSet(object.new_status) ? accountStatusFromJSON(object.new_status) : 0,
      scopeCount: isSet(object.scope_count) ? globalThis.Number(object.scope_count) : 0,
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
    };
  },

  toJSON(message: PublicVerificationHistoryEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entry_id = message.entryId;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.previousScore !== 0) {
      obj.previous_score = Math.round(message.previousScore);
    }
    if (message.newScore !== 0) {
      obj.new_score = Math.round(message.newScore);
    }
    if (message.previousStatus !== 0) {
      obj.previous_status = accountStatusToJSON(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      obj.new_status = accountStatusToJSON(message.newStatus);
    }
    if (message.scopeCount !== 0) {
      obj.scope_count = Math.round(message.scopeCount);
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<PublicVerificationHistoryEntry>): PublicVerificationHistoryEntry {
    const message = createBasePublicVerificationHistoryEntry();
    message.entryId = object.entryId ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.previousScore = object.previousScore ?? 0;
    message.newScore = object.newScore ?? 0;
    message.previousStatus = object.previousStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.scopeCount = object.scopeCount ?? 0;
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseQueryVerificationHistoryRequest(): QueryVerificationHistoryRequest {
  return { accountAddress: "", limit: 0, offset: 0 };
}

export const QueryVerificationHistoryRequest: MessageFns<
  QueryVerificationHistoryRequest,
  "virtengine.veid.v1.QueryVerificationHistoryRequest"
> = {
  $type: "virtengine.veid.v1.QueryVerificationHistoryRequest" as const,

  encode(message: QueryVerificationHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.limit !== 0) {
      writer.uint32(16).uint32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(24).uint32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVerificationHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.limit = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.offset = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationHistoryRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: QueryVerificationHistoryRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryVerificationHistoryRequest>): QueryVerificationHistoryRequest {
    const message = createBaseQueryVerificationHistoryRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseQueryVerificationHistoryResponse(): QueryVerificationHistoryResponse {
  return { entries: [], totalCount: 0 };
}

export const QueryVerificationHistoryResponse: MessageFns<
  QueryVerificationHistoryResponse,
  "virtengine.veid.v1.QueryVerificationHistoryResponse"
> = {
  $type: "virtengine.veid.v1.QueryVerificationHistoryResponse" as const,

  encode(message: QueryVerificationHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.entries) {
      PublicVerificationHistoryEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalCount !== 0) {
      writer.uint32(16).int32(message.totalCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryVerificationHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryVerificationHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entries.push(PublicVerificationHistoryEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryVerificationHistoryResponse {
    return {
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => PublicVerificationHistoryEntry.fromJSON(e))
        : [],
      totalCount: isSet(object.total_count) ? globalThis.Number(object.total_count) : 0,
    };
  },

  toJSON(message: QueryVerificationHistoryResponse): unknown {
    const obj: any = {};
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => PublicVerificationHistoryEntry.toJSON(e));
    }
    if (message.totalCount !== 0) {
      obj.total_count = Math.round(message.totalCount);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryVerificationHistoryResponse>): QueryVerificationHistoryResponse {
    const message = createBaseQueryVerificationHistoryResponse();
    message.entries = object.entries?.map((e) => PublicVerificationHistoryEntry.fromPartial(e)) || [];
    message.totalCount = object.totalCount ?? 0;
    return message;
  },
};

function createBaseQueryApprovedClientsRequest(): QueryApprovedClientsRequest {
  return { activeOnly: false, pagination: undefined };
}

export const QueryApprovedClientsRequest: MessageFns<
  QueryApprovedClientsRequest,
  "virtengine.veid.v1.QueryApprovedClientsRequest"
> = {
  $type: "virtengine.veid.v1.QueryApprovedClientsRequest" as const,

  encode(message: QueryApprovedClientsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeOnly !== false) {
      writer.uint32(8).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApprovedClientsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApprovedClientsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApprovedClientsRequest {
    return {
      activeOnly: isSet(object.active_only) ? globalThis.Boolean(object.active_only) : false,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryApprovedClientsRequest): unknown {
    const obj: any = {};
    if (message.activeOnly !== false) {
      obj.active_only = message.activeOnly;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryApprovedClientsRequest>): QueryApprovedClientsRequest {
    const message = createBaseQueryApprovedClientsRequest();
    message.activeOnly = object.activeOnly ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryApprovedClientsResponse(): QueryApprovedClientsResponse {
  return { clients: [], pagination: undefined };
}

export const QueryApprovedClientsResponse: MessageFns<
  QueryApprovedClientsResponse,
  "virtengine.veid.v1.QueryApprovedClientsResponse"
> = {
  $type: "virtengine.veid.v1.QueryApprovedClientsResponse" as const,

  encode(message: QueryApprovedClientsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.clients) {
      ApprovedClient.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryApprovedClientsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryApprovedClientsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clients.push(ApprovedClient.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryApprovedClientsResponse {
    return {
      clients: globalThis.Array.isArray(object?.clients)
        ? object.clients.map((e: any) => ApprovedClient.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryApprovedClientsResponse): unknown {
    const obj: any = {};
    if (message.clients?.length) {
      obj.clients = message.clients.map((e) => ApprovedClient.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryApprovedClientsResponse>): QueryApprovedClientsResponse {
    const message = createBaseQueryApprovedClientsResponse();
    message.clients = object.clients?.map((e) => ApprovedClient.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryParamsRequest(): QueryParamsRequest {
  return {};
}

export const QueryParamsRequest: MessageFns<QueryParamsRequest, "virtengine.veid.v1.QueryParamsRequest"> = {
  $type: "virtengine.veid.v1.QueryParamsRequest" as const,

  encode(_: QueryParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryParamsRequest {
    return {};
  },

  toJSON(_: QueryParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryParamsRequest>): QueryParamsRequest {
    const message = createBaseQueryParamsRequest();
    return message;
  },
};

function createBaseQueryParamsResponse(): QueryParamsResponse {
  return { params: undefined };
}

export const QueryParamsResponse: MessageFns<QueryParamsResponse, "virtengine.veid.v1.QueryParamsResponse"> = {
  $type: "virtengine.veid.v1.QueryParamsResponse" as const,

  encode(message: QueryParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryParamsResponse {
    return { params: isSet(object.params) ? Params.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryParamsResponse>): QueryParamsResponse {
    const message = createBaseQueryParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryBorderlineParamsRequest(): QueryBorderlineParamsRequest {
  return {};
}

export const QueryBorderlineParamsRequest: MessageFns<
  QueryBorderlineParamsRequest,
  "virtengine.veid.v1.QueryBorderlineParamsRequest"
> = {
  $type: "virtengine.veid.v1.QueryBorderlineParamsRequest" as const,

  encode(_: QueryBorderlineParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBorderlineParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBorderlineParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryBorderlineParamsRequest {
    return {};
  },

  toJSON(_: QueryBorderlineParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryBorderlineParamsRequest>): QueryBorderlineParamsRequest {
    const message = createBaseQueryBorderlineParamsRequest();
    return message;
  },
};

function createBaseQueryBorderlineParamsResponse(): QueryBorderlineParamsResponse {
  return { params: undefined };
}

export const QueryBorderlineParamsResponse: MessageFns<
  QueryBorderlineParamsResponse,
  "virtengine.veid.v1.QueryBorderlineParamsResponse"
> = {
  $type: "virtengine.veid.v1.QueryBorderlineParamsResponse" as const,

  encode(message: QueryBorderlineParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      BorderlineParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryBorderlineParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryBorderlineParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = BorderlineParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryBorderlineParamsResponse {
    return { params: isSet(object.params) ? BorderlineParams.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryBorderlineParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = BorderlineParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryBorderlineParamsResponse>): QueryBorderlineParamsResponse {
    const message = createBaseQueryBorderlineParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? BorderlineParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBasePublicDerivedFeaturesInfo(): PublicDerivedFeaturesInfo {
  return {
    hasFaceEmbedding: false,
    hasBiometric: false,
    hasLivenessProof: false,
    docFieldKeys: [],
    lastComputedAt: Long.ZERO,
    modelVersion: "",
    featureVersion: 0,
  };
}

export const PublicDerivedFeaturesInfo: MessageFns<
  PublicDerivedFeaturesInfo,
  "virtengine.veid.v1.PublicDerivedFeaturesInfo"
> = {
  $type: "virtengine.veid.v1.PublicDerivedFeaturesInfo" as const,

  encode(message: PublicDerivedFeaturesInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hasFaceEmbedding !== false) {
      writer.uint32(8).bool(message.hasFaceEmbedding);
    }
    if (message.hasBiometric !== false) {
      writer.uint32(16).bool(message.hasBiometric);
    }
    if (message.hasLivenessProof !== false) {
      writer.uint32(24).bool(message.hasLivenessProof);
    }
    for (const v of message.docFieldKeys) {
      writer.uint32(34).string(v!);
    }
    if (!message.lastComputedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.lastComputedAt.toString());
    }
    if (message.modelVersion !== "") {
      writer.uint32(50).string(message.modelVersion);
    }
    if (message.featureVersion !== 0) {
      writer.uint32(56).uint32(message.featureVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PublicDerivedFeaturesInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePublicDerivedFeaturesInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.hasFaceEmbedding = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.hasBiometric = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hasLivenessProof = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.docFieldKeys.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastComputedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.featureVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PublicDerivedFeaturesInfo {
    return {
      hasFaceEmbedding: isSet(object.has_face_embedding) ? globalThis.Boolean(object.has_face_embedding) : false,
      hasBiometric: isSet(object.has_biometric) ? globalThis.Boolean(object.has_biometric) : false,
      hasLivenessProof: isSet(object.has_liveness_proof) ? globalThis.Boolean(object.has_liveness_proof) : false,
      docFieldKeys: globalThis.Array.isArray(object?.doc_field_keys)
        ? object.doc_field_keys.map((e: any) => globalThis.String(e))
        : [],
      lastComputedAt: isSet(object.last_computed_at) ? Long.fromValue(object.last_computed_at) : Long.ZERO,
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
      featureVersion: isSet(object.feature_version) ? globalThis.Number(object.feature_version) : 0,
    };
  },

  toJSON(message: PublicDerivedFeaturesInfo): unknown {
    const obj: any = {};
    if (message.hasFaceEmbedding !== false) {
      obj.has_face_embedding = message.hasFaceEmbedding;
    }
    if (message.hasBiometric !== false) {
      obj.has_biometric = message.hasBiometric;
    }
    if (message.hasLivenessProof !== false) {
      obj.has_liveness_proof = message.hasLivenessProof;
    }
    if (message.docFieldKeys?.length) {
      obj.doc_field_keys = message.docFieldKeys;
    }
    if (!message.lastComputedAt.equals(Long.ZERO)) {
      obj.last_computed_at = (message.lastComputedAt || Long.ZERO).toString();
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    if (message.featureVersion !== 0) {
      obj.feature_version = Math.round(message.featureVersion);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<PublicDerivedFeaturesInfo>): PublicDerivedFeaturesInfo {
    const message = createBasePublicDerivedFeaturesInfo();
    message.hasFaceEmbedding = object.hasFaceEmbedding ?? false;
    message.hasBiometric = object.hasBiometric ?? false;
    message.hasLivenessProof = object.hasLivenessProof ?? false;
    message.docFieldKeys = object.docFieldKeys?.map((e) => e) || [];
    message.lastComputedAt = (object.lastComputedAt !== undefined && object.lastComputedAt !== null)
      ? Long.fromValue(object.lastComputedAt)
      : Long.ZERO;
    message.modelVersion = object.modelVersion ?? "";
    message.featureVersion = object.featureVersion ?? 0;
    return message;
  },
};

function createBaseQueryDerivedFeaturesRequest(): QueryDerivedFeaturesRequest {
  return { accountAddress: "" };
}

export const QueryDerivedFeaturesRequest: MessageFns<
  QueryDerivedFeaturesRequest,
  "virtengine.veid.v1.QueryDerivedFeaturesRequest"
> = {
  $type: "virtengine.veid.v1.QueryDerivedFeaturesRequest" as const,

  encode(message: QueryDerivedFeaturesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDerivedFeaturesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivedFeaturesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDerivedFeaturesRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryDerivedFeaturesRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryDerivedFeaturesRequest>): QueryDerivedFeaturesRequest {
    const message = createBaseQueryDerivedFeaturesRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryDerivedFeaturesResponse(): QueryDerivedFeaturesResponse {
  return { features: undefined, found: false };
}

export const QueryDerivedFeaturesResponse: MessageFns<
  QueryDerivedFeaturesResponse,
  "virtengine.veid.v1.QueryDerivedFeaturesResponse"
> = {
  $type: "virtengine.veid.v1.QueryDerivedFeaturesResponse" as const,

  encode(message: QueryDerivedFeaturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.features !== undefined) {
      PublicDerivedFeaturesInfo.encode(message.features, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDerivedFeaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivedFeaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.features = PublicDerivedFeaturesInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDerivedFeaturesResponse {
    return {
      features: isSet(object.features) ? PublicDerivedFeaturesInfo.fromJSON(object.features) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryDerivedFeaturesResponse): unknown {
    const obj: any = {};
    if (message.features !== undefined) {
      obj.features = PublicDerivedFeaturesInfo.toJSON(message.features);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryDerivedFeaturesResponse>): QueryDerivedFeaturesResponse {
    const message = createBaseQueryDerivedFeaturesResponse();
    message.features = (object.features !== undefined && object.features !== null)
      ? PublicDerivedFeaturesInfo.fromPartial(object.features)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryDerivedFeatureHashesRequest(): QueryDerivedFeatureHashesRequest {
  return { accountAddress: "", requester: "", purpose: "" };
}

export const QueryDerivedFeatureHashesRequest: MessageFns<
  QueryDerivedFeatureHashesRequest,
  "virtengine.veid.v1.QueryDerivedFeatureHashesRequest"
> = {
  $type: "virtengine.veid.v1.QueryDerivedFeatureHashesRequest" as const,

  encode(message: QueryDerivedFeatureHashesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.requester !== "") {
      writer.uint32(18).string(message.requester);
    }
    if (message.purpose !== "") {
      writer.uint32(26).string(message.purpose);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDerivedFeatureHashesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivedFeatureHashesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requester = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.purpose = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDerivedFeatureHashesRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      requester: isSet(object.requester) ? globalThis.String(object.requester) : "",
      purpose: isSet(object.purpose) ? globalThis.String(object.purpose) : "",
    };
  },

  toJSON(message: QueryDerivedFeatureHashesRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.requester !== "") {
      obj.requester = message.requester;
    }
    if (message.purpose !== "") {
      obj.purpose = message.purpose;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryDerivedFeatureHashesRequest>): QueryDerivedFeatureHashesRequest {
    const message = createBaseQueryDerivedFeatureHashesRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.requester = object.requester ?? "";
    message.purpose = object.purpose ?? "";
    return message;
  },
};

function createBaseQueryDerivedFeatureHashesResponse(): QueryDerivedFeatureHashesResponse {
  return {
    allowed: false,
    denialReason: "",
    faceEmbeddingHash: new Uint8Array(0),
    docFieldHashes: {},
    biometricHash: new Uint8Array(0),
    modelVersion: "",
  };
}

export const QueryDerivedFeatureHashesResponse: MessageFns<
  QueryDerivedFeatureHashesResponse,
  "virtengine.veid.v1.QueryDerivedFeatureHashesResponse"
> = {
  $type: "virtengine.veid.v1.QueryDerivedFeatureHashesResponse" as const,

  encode(message: QueryDerivedFeatureHashesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allowed !== false) {
      writer.uint32(8).bool(message.allowed);
    }
    if (message.denialReason !== "") {
      writer.uint32(18).string(message.denialReason);
    }
    if (message.faceEmbeddingHash.length !== 0) {
      writer.uint32(26).bytes(message.faceEmbeddingHash);
    }
    Object.entries(message.docFieldHashes).forEach(([key, value]) => {
      QueryDerivedFeatureHashesResponse_DocFieldHashesEntry.encode({ key: key as any, value }, writer.uint32(34).fork())
        .join();
    });
    if (message.biometricHash.length !== 0) {
      writer.uint32(42).bytes(message.biometricHash);
    }
    if (message.modelVersion !== "") {
      writer.uint32(50).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDerivedFeatureHashesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivedFeatureHashesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.allowed = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denialReason = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faceEmbeddingHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = QueryDerivedFeatureHashesResponse_DocFieldHashesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.docFieldHashes[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.biometricHash = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDerivedFeatureHashesResponse {
    return {
      allowed: isSet(object.allowed) ? globalThis.Boolean(object.allowed) : false,
      denialReason: isSet(object.denial_reason) ? globalThis.String(object.denial_reason) : "",
      faceEmbeddingHash: isSet(object.face_embedding_hash)
        ? bytesFromBase64(object.face_embedding_hash)
        : new Uint8Array(0),
      docFieldHashes: isObject(object.doc_field_hashes)
        ? Object.entries(object.doc_field_hashes).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      biometricHash: isSet(object.biometric_hash) ? bytesFromBase64(object.biometric_hash) : new Uint8Array(0),
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
    };
  },

  toJSON(message: QueryDerivedFeatureHashesResponse): unknown {
    const obj: any = {};
    if (message.allowed !== false) {
      obj.allowed = message.allowed;
    }
    if (message.denialReason !== "") {
      obj.denial_reason = message.denialReason;
    }
    if (message.faceEmbeddingHash.length !== 0) {
      obj.face_embedding_hash = base64FromBytes(message.faceEmbeddingHash);
    }
    if (message.docFieldHashes) {
      const entries = Object.entries(message.docFieldHashes);
      if (entries.length > 0) {
        obj.doc_field_hashes = {};
        entries.forEach(([k, v]) => {
          obj.doc_field_hashes[k] = base64FromBytes(v);
        });
      }
    }
    if (message.biometricHash.length !== 0) {
      obj.biometric_hash = base64FromBytes(message.biometricHash);
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryDerivedFeatureHashesResponse>): QueryDerivedFeatureHashesResponse {
    const message = createBaseQueryDerivedFeatureHashesResponse();
    message.allowed = object.allowed ?? false;
    message.denialReason = object.denialReason ?? "";
    message.faceEmbeddingHash = object.faceEmbeddingHash ?? new Uint8Array(0);
    message.docFieldHashes = Object.entries(object.docFieldHashes ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.biometricHash = object.biometricHash ?? new Uint8Array(0);
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseQueryDerivedFeatureHashesResponse_DocFieldHashesEntry(): QueryDerivedFeatureHashesResponse_DocFieldHashesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const QueryDerivedFeatureHashesResponse_DocFieldHashesEntry: MessageFns<
  QueryDerivedFeatureHashesResponse_DocFieldHashesEntry,
  "virtengine.veid.v1.QueryDerivedFeatureHashesResponse.DocFieldHashesEntry"
> = {
  $type: "virtengine.veid.v1.QueryDerivedFeatureHashesResponse.DocFieldHashesEntry" as const,

  encode(
    message: QueryDerivedFeatureHashesResponse_DocFieldHashesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryDerivedFeatureHashesResponse_DocFieldHashesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryDerivedFeatureHashesResponse_DocFieldHashesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryDerivedFeatureHashesResponse_DocFieldHashesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: QueryDerivedFeatureHashesResponse_DocFieldHashesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  fromPartial(
    object: DeepPartial<QueryDerivedFeatureHashesResponse_DocFieldHashesEntry>,
  ): QueryDerivedFeatureHashesResponse_DocFieldHashesEntry {
    const message = createBaseQueryDerivedFeatureHashesResponse_DocFieldHashesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseQueryAppealRequest(): QueryAppealRequest {
  return { appealId: "" };
}

export const QueryAppealRequest: MessageFns<QueryAppealRequest, "virtengine.veid.v1.QueryAppealRequest"> = {
  $type: "virtengine.veid.v1.QueryAppealRequest" as const,

  encode(message: QueryAppealRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealRequest {
    return { appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "" };
  },

  toJSON(message: QueryAppealRequest): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealRequest>): QueryAppealRequest {
    const message = createBaseQueryAppealRequest();
    message.appealId = object.appealId ?? "";
    return message;
  },
};

function createBaseQueryAppealResponse(): QueryAppealResponse {
  return { appeal: undefined, found: false };
}

export const QueryAppealResponse: MessageFns<QueryAppealResponse, "virtengine.veid.v1.QueryAppealResponse"> = {
  $type: "virtengine.veid.v1.QueryAppealResponse" as const,

  encode(message: QueryAppealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appeal !== undefined) {
      AppealRecord.encode(message.appeal, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appeal = AppealRecord.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealResponse {
    return {
      appeal: isSet(object.appeal) ? AppealRecord.fromJSON(object.appeal) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryAppealResponse): unknown {
    const obj: any = {};
    if (message.appeal !== undefined) {
      obj.appeal = AppealRecord.toJSON(message.appeal);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealResponse>): QueryAppealResponse {
    const message = createBaseQueryAppealResponse();
    message.appeal = (object.appeal !== undefined && object.appeal !== null)
      ? AppealRecord.fromPartial(object.appeal)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryAppealsRequest(): QueryAppealsRequest {
  return { accountAddress: "", pagination: undefined };
}

export const QueryAppealsRequest: MessageFns<QueryAppealsRequest, "virtengine.veid.v1.QueryAppealsRequest"> = {
  $type: "virtengine.veid.v1.QueryAppealsRequest" as const,

  encode(message: QueryAppealsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealsRequest {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAppealsRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealsRequest>): QueryAppealsRequest {
    const message = createBaseQueryAppealsRequest();
    message.accountAddress = object.accountAddress ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAppealsResponse(): QueryAppealsResponse {
  return { appeals: [], pagination: undefined };
}

export const QueryAppealsResponse: MessageFns<QueryAppealsResponse, "virtengine.veid.v1.QueryAppealsResponse"> = {
  $type: "virtengine.veid.v1.QueryAppealsResponse" as const,

  encode(message: QueryAppealsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.appeals) {
      AppealRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appeals.push(AppealRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealsResponse {
    return {
      appeals: globalThis.Array.isArray(object?.appeals)
        ? object.appeals.map((e: any) => AppealRecord.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAppealsResponse): unknown {
    const obj: any = {};
    if (message.appeals?.length) {
      obj.appeals = message.appeals.map((e) => AppealRecord.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealsResponse>): QueryAppealsResponse {
    const message = createBaseQueryAppealsResponse();
    message.appeals = object.appeals?.map((e) => AppealRecord.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAppealsByScopeRequest(): QueryAppealsByScopeRequest {
  return { scopeId: "", pagination: undefined };
}

export const QueryAppealsByScopeRequest: MessageFns<
  QueryAppealsByScopeRequest,
  "virtengine.veid.v1.QueryAppealsByScopeRequest"
> = {
  $type: "virtengine.veid.v1.QueryAppealsByScopeRequest" as const,

  encode(message: QueryAppealsByScopeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealsByScopeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealsByScopeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealsByScopeRequest {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAppealsByScopeRequest): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealsByScopeRequest>): QueryAppealsByScopeRequest {
    const message = createBaseQueryAppealsByScopeRequest();
    message.scopeId = object.scopeId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAppealsByScopeResponse(): QueryAppealsByScopeResponse {
  return { appeals: [], pagination: undefined };
}

export const QueryAppealsByScopeResponse: MessageFns<
  QueryAppealsByScopeResponse,
  "virtengine.veid.v1.QueryAppealsByScopeResponse"
> = {
  $type: "virtengine.veid.v1.QueryAppealsByScopeResponse" as const,

  encode(message: QueryAppealsByScopeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.appeals) {
      AppealRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealsByScopeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealsByScopeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appeals.push(AppealRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealsByScopeResponse {
    return {
      appeals: globalThis.Array.isArray(object?.appeals)
        ? object.appeals.map((e: any) => AppealRecord.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryAppealsByScopeResponse): unknown {
    const obj: any = {};
    if (message.appeals?.length) {
      obj.appeals = message.appeals.map((e) => AppealRecord.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealsByScopeResponse>): QueryAppealsByScopeResponse {
    const message = createBaseQueryAppealsByScopeResponse();
    message.appeals = object.appeals?.map((e) => AppealRecord.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryAppealParamsRequest(): QueryAppealParamsRequest {
  return {};
}

export const QueryAppealParamsRequest: MessageFns<
  QueryAppealParamsRequest,
  "virtengine.veid.v1.QueryAppealParamsRequest"
> = {
  $type: "virtengine.veid.v1.QueryAppealParamsRequest" as const,

  encode(_: QueryAppealParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryAppealParamsRequest {
    return {};
  },

  toJSON(_: QueryAppealParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryAppealParamsRequest>): QueryAppealParamsRequest {
    const message = createBaseQueryAppealParamsRequest();
    return message;
  },
};

function createBaseQueryAppealParamsResponse(): QueryAppealParamsResponse {
  return { params: undefined };
}

export const QueryAppealParamsResponse: MessageFns<
  QueryAppealParamsResponse,
  "virtengine.veid.v1.QueryAppealParamsResponse"
> = {
  $type: "virtengine.veid.v1.QueryAppealParamsResponse" as const,

  encode(message: QueryAppealParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      AppealParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryAppealParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryAppealParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = AppealParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryAppealParamsResponse {
    return { params: isSet(object.params) ? AppealParams.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryAppealParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = AppealParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryAppealParamsResponse>): QueryAppealParamsResponse {
    const message = createBaseQueryAppealParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? AppealParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryComplianceStatusRequest(): QueryComplianceStatusRequest {
  return { accountAddress: "" };
}

export const QueryComplianceStatusRequest: MessageFns<
  QueryComplianceStatusRequest,
  "virtengine.veid.v1.QueryComplianceStatusRequest"
> = {
  $type: "virtengine.veid.v1.QueryComplianceStatusRequest" as const,

  encode(message: QueryComplianceStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceStatusRequest {
    return { accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "" };
  },

  toJSON(message: QueryComplianceStatusRequest): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceStatusRequest>): QueryComplianceStatusRequest {
    const message = createBaseQueryComplianceStatusRequest();
    message.accountAddress = object.accountAddress ?? "";
    return message;
  },
};

function createBaseQueryComplianceStatusResponse(): QueryComplianceStatusResponse {
  return { record: undefined, found: false };
}

export const QueryComplianceStatusResponse: MessageFns<
  QueryComplianceStatusResponse,
  "virtengine.veid.v1.QueryComplianceStatusResponse"
> = {
  $type: "virtengine.veid.v1.QueryComplianceStatusResponse" as const,

  encode(message: QueryComplianceStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.record !== undefined) {
      ComplianceRecord.encode(message.record, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.record = ComplianceRecord.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceStatusResponse {
    return {
      record: isSet(object.record) ? ComplianceRecord.fromJSON(object.record) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryComplianceStatusResponse): unknown {
    const obj: any = {};
    if (message.record !== undefined) {
      obj.record = ComplianceRecord.toJSON(message.record);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceStatusResponse>): QueryComplianceStatusResponse {
    const message = createBaseQueryComplianceStatusResponse();
    message.record = (object.record !== undefined && object.record !== null)
      ? ComplianceRecord.fromPartial(object.record)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryComplianceProviderRequest(): QueryComplianceProviderRequest {
  return { providerId: "" };
}

export const QueryComplianceProviderRequest: MessageFns<
  QueryComplianceProviderRequest,
  "virtengine.veid.v1.QueryComplianceProviderRequest"
> = {
  $type: "virtengine.veid.v1.QueryComplianceProviderRequest" as const,

  encode(message: QueryComplianceProviderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceProviderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceProviderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceProviderRequest {
    return { providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "" };
  },

  toJSON(message: QueryComplianceProviderRequest): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceProviderRequest>): QueryComplianceProviderRequest {
    const message = createBaseQueryComplianceProviderRequest();
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseQueryComplianceProviderResponse(): QueryComplianceProviderResponse {
  return { provider: undefined, found: false };
}

export const QueryComplianceProviderResponse: MessageFns<
  QueryComplianceProviderResponse,
  "virtengine.veid.v1.QueryComplianceProviderResponse"
> = {
  $type: "virtengine.veid.v1.QueryComplianceProviderResponse" as const,

  encode(message: QueryComplianceProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.provider !== undefined) {
      ComplianceProvider.encode(message.provider, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.provider = ComplianceProvider.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceProviderResponse {
    return {
      provider: isSet(object.provider) ? ComplianceProvider.fromJSON(object.provider) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryComplianceProviderResponse): unknown {
    const obj: any = {};
    if (message.provider !== undefined) {
      obj.provider = ComplianceProvider.toJSON(message.provider);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceProviderResponse>): QueryComplianceProviderResponse {
    const message = createBaseQueryComplianceProviderResponse();
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? ComplianceProvider.fromPartial(object.provider)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryComplianceProvidersRequest(): QueryComplianceProvidersRequest {
  return { activeOnly: false, pagination: undefined };
}

export const QueryComplianceProvidersRequest: MessageFns<
  QueryComplianceProvidersRequest,
  "virtengine.veid.v1.QueryComplianceProvidersRequest"
> = {
  $type: "virtengine.veid.v1.QueryComplianceProvidersRequest" as const,

  encode(message: QueryComplianceProvidersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.activeOnly !== false) {
      writer.uint32(8).bool(message.activeOnly);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceProvidersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceProvidersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activeOnly = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceProvidersRequest {
    return {
      activeOnly: isSet(object.active_only) ? globalThis.Boolean(object.active_only) : false,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryComplianceProvidersRequest): unknown {
    const obj: any = {};
    if (message.activeOnly !== false) {
      obj.active_only = message.activeOnly;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceProvidersRequest>): QueryComplianceProvidersRequest {
    const message = createBaseQueryComplianceProvidersRequest();
    message.activeOnly = object.activeOnly ?? false;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryComplianceProvidersResponse(): QueryComplianceProvidersResponse {
  return { providers: [], pagination: undefined };
}

export const QueryComplianceProvidersResponse: MessageFns<
  QueryComplianceProvidersResponse,
  "virtengine.veid.v1.QueryComplianceProvidersResponse"
> = {
  $type: "virtengine.veid.v1.QueryComplianceProvidersResponse" as const,

  encode(message: QueryComplianceProvidersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.providers) {
      ComplianceProvider.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceProvidersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceProvidersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providers.push(ComplianceProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceProvidersResponse {
    return {
      providers: globalThis.Array.isArray(object?.providers)
        ? object.providers.map((e: any) => ComplianceProvider.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryComplianceProvidersResponse): unknown {
    const obj: any = {};
    if (message.providers?.length) {
      obj.providers = message.providers.map((e) => ComplianceProvider.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceProvidersResponse>): QueryComplianceProvidersResponse {
    const message = createBaseQueryComplianceProvidersResponse();
    message.providers = object.providers?.map((e) => ComplianceProvider.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryComplianceParamsRequest(): QueryComplianceParamsRequest {
  return {};
}

export const QueryComplianceParamsRequest: MessageFns<
  QueryComplianceParamsRequest,
  "virtengine.veid.v1.QueryComplianceParamsRequest"
> = {
  $type: "virtengine.veid.v1.QueryComplianceParamsRequest" as const,

  encode(_: QueryComplianceParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryComplianceParamsRequest {
    return {};
  },

  toJSON(_: QueryComplianceParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryComplianceParamsRequest>): QueryComplianceParamsRequest {
    const message = createBaseQueryComplianceParamsRequest();
    return message;
  },
};

function createBaseQueryComplianceParamsResponse(): QueryComplianceParamsResponse {
  return { params: undefined };
}

export const QueryComplianceParamsResponse: MessageFns<
  QueryComplianceParamsResponse,
  "virtengine.veid.v1.QueryComplianceParamsResponse"
> = {
  $type: "virtengine.veid.v1.QueryComplianceParamsResponse" as const,

  encode(message: QueryComplianceParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      ComplianceParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryComplianceParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryComplianceParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = ComplianceParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryComplianceParamsResponse {
    return { params: isSet(object.params) ? ComplianceParams.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryComplianceParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = ComplianceParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryComplianceParamsResponse>): QueryComplianceParamsResponse {
    const message = createBaseQueryComplianceParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? ComplianceParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseQueryModelVersionRequest(): QueryModelVersionRequest {
  return { modelType: "" };
}

export const QueryModelVersionRequest: MessageFns<
  QueryModelVersionRequest,
  "virtengine.veid.v1.QueryModelVersionRequest"
> = {
  $type: "virtengine.veid.v1.QueryModelVersionRequest" as const,

  encode(message: QueryModelVersionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelType !== "") {
      writer.uint32(10).string(message.modelType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelVersionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelVersionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryModelVersionRequest {
    return { modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "" };
  },

  toJSON(message: QueryModelVersionRequest): unknown {
    const obj: any = {};
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryModelVersionRequest>): QueryModelVersionRequest {
    const message = createBaseQueryModelVersionRequest();
    message.modelType = object.modelType ?? "";
    return message;
  },
};

function createBaseQueryModelVersionResponse(): QueryModelVersionResponse {
  return { modelInfo: undefined, found: false };
}

export const QueryModelVersionResponse: MessageFns<
  QueryModelVersionResponse,
  "virtengine.veid.v1.QueryModelVersionResponse"
> = {
  $type: "virtengine.veid.v1.QueryModelVersionResponse" as const,

  encode(message: QueryModelVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelInfo !== undefined) {
      MLModelInfo.encode(message.modelInfo, writer.uint32(10).fork()).join();
    }
    if (message.found !== false) {
      writer.uint32(16).bool(message.found);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelInfo = MLModelInfo.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.found = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryModelVersionResponse {
    return {
      modelInfo: isSet(object.model_info) ? MLModelInfo.fromJSON(object.model_info) : undefined,
      found: isSet(object.found) ? globalThis.Boolean(object.found) : false,
    };
  },

  toJSON(message: QueryModelVersionResponse): unknown {
    const obj: any = {};
    if (message.modelInfo !== undefined) {
      obj.model_info = MLModelInfo.toJSON(message.modelInfo);
    }
    if (message.found !== false) {
      obj.found = message.found;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryModelVersionResponse>): QueryModelVersionResponse {
    const message = createBaseQueryModelVersionResponse();
    message.modelInfo = (object.modelInfo !== undefined && object.modelInfo !== null)
      ? MLModelInfo.fromPartial(object.modelInfo)
      : undefined;
    message.found = object.found ?? false;
    return message;
  },
};

function createBaseQueryActiveModelsRequest(): QueryActiveModelsRequest {
  return {};
}

export const QueryActiveModelsRequest: MessageFns<
  QueryActiveModelsRequest,
  "virtengine.veid.v1.QueryActiveModelsRequest"
> = {
  $type: "virtengine.veid.v1.QueryActiveModelsRequest" as const,

  encode(_: QueryActiveModelsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveModelsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveModelsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryActiveModelsRequest {
    return {};
  },

  toJSON(_: QueryActiveModelsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryActiveModelsRequest>): QueryActiveModelsRequest {
    const message = createBaseQueryActiveModelsRequest();
    return message;
  },
};

function createBaseQueryActiveModelsResponse(): QueryActiveModelsResponse {
  return { state: undefined, models: [] };
}

export const QueryActiveModelsResponse: MessageFns<
  QueryActiveModelsResponse,
  "virtengine.veid.v1.QueryActiveModelsResponse"
> = {
  $type: "virtengine.veid.v1.QueryActiveModelsResponse" as const,

  encode(message: QueryActiveModelsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== undefined) {
      ModelVersionState.encode(message.state, writer.uint32(10).fork()).join();
    }
    for (const v of message.models) {
      MLModelInfo.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryActiveModelsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryActiveModelsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.state = ModelVersionState.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.models.push(MLModelInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryActiveModelsResponse {
    return {
      state: isSet(object.state) ? ModelVersionState.fromJSON(object.state) : undefined,
      models: globalThis.Array.isArray(object?.models) ? object.models.map((e: any) => MLModelInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: QueryActiveModelsResponse): unknown {
    const obj: any = {};
    if (message.state !== undefined) {
      obj.state = ModelVersionState.toJSON(message.state);
    }
    if (message.models?.length) {
      obj.models = message.models.map((e) => MLModelInfo.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryActiveModelsResponse>): QueryActiveModelsResponse {
    const message = createBaseQueryActiveModelsResponse();
    message.state = (object.state !== undefined && object.state !== null)
      ? ModelVersionState.fromPartial(object.state)
      : undefined;
    message.models = object.models?.map((e) => MLModelInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseQueryModelHistoryRequest(): QueryModelHistoryRequest {
  return { modelType: "", pagination: undefined };
}

export const QueryModelHistoryRequest: MessageFns<
  QueryModelHistoryRequest,
  "virtengine.veid.v1.QueryModelHistoryRequest"
> = {
  $type: "virtengine.veid.v1.QueryModelHistoryRequest" as const,

  encode(message: QueryModelHistoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelType !== "") {
      writer.uint32(10).string(message.modelType);
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelHistoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelHistoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryModelHistoryRequest {
    return {
      modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "",
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryModelHistoryRequest): unknown {
    const obj: any = {};
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryModelHistoryRequest>): QueryModelHistoryRequest {
    const message = createBaseQueryModelHistoryRequest();
    message.modelType = object.modelType ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryModelHistoryResponse(): QueryModelHistoryResponse {
  return { history: [], pagination: undefined };
}

export const QueryModelHistoryResponse: MessageFns<
  QueryModelHistoryResponse,
  "virtengine.veid.v1.QueryModelHistoryResponse"
> = {
  $type: "virtengine.veid.v1.QueryModelHistoryResponse" as const,

  encode(message: QueryModelHistoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.history) {
      ModelVersionHistory.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelHistoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelHistoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.history.push(ModelVersionHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryModelHistoryResponse {
    return {
      history: globalThis.Array.isArray(object?.history)
        ? object.history.map((e: any) => ModelVersionHistory.fromJSON(e))
        : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryModelHistoryResponse): unknown {
    const obj: any = {};
    if (message.history?.length) {
      obj.history = message.history.map((e) => ModelVersionHistory.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryModelHistoryResponse>): QueryModelHistoryResponse {
    const message = createBaseQueryModelHistoryResponse();
    message.history = object.history?.map((e) => ModelVersionHistory.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryValidatorModelSyncRequest(): QueryValidatorModelSyncRequest {
  return { validatorAddress: "" };
}

export const QueryValidatorModelSyncRequest: MessageFns<
  QueryValidatorModelSyncRequest,
  "virtengine.veid.v1.QueryValidatorModelSyncRequest"
> = {
  $type: "virtengine.veid.v1.QueryValidatorModelSyncRequest" as const,

  encode(message: QueryValidatorModelSyncRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorModelSyncRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorModelSyncRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorModelSyncRequest {
    return { validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "" };
  },

  toJSON(message: QueryValidatorModelSyncRequest): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryValidatorModelSyncRequest>): QueryValidatorModelSyncRequest {
    const message = createBaseQueryValidatorModelSyncRequest();
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseQueryValidatorModelSyncResponse(): QueryValidatorModelSyncResponse {
  return { report: undefined, isSynced: false };
}

export const QueryValidatorModelSyncResponse: MessageFns<
  QueryValidatorModelSyncResponse,
  "virtengine.veid.v1.QueryValidatorModelSyncResponse"
> = {
  $type: "virtengine.veid.v1.QueryValidatorModelSyncResponse" as const,

  encode(message: QueryValidatorModelSyncResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.report !== undefined) {
      ValidatorModelReport.encode(message.report, writer.uint32(10).fork()).join();
    }
    if (message.isSynced !== false) {
      writer.uint32(16).bool(message.isSynced);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryValidatorModelSyncResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryValidatorModelSyncResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.report = ValidatorModelReport.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryValidatorModelSyncResponse {
    return {
      report: isSet(object.report) ? ValidatorModelReport.fromJSON(object.report) : undefined,
      isSynced: isSet(object.is_synced) ? globalThis.Boolean(object.is_synced) : false,
    };
  },

  toJSON(message: QueryValidatorModelSyncResponse): unknown {
    const obj: any = {};
    if (message.report !== undefined) {
      obj.report = ValidatorModelReport.toJSON(message.report);
    }
    if (message.isSynced !== false) {
      obj.is_synced = message.isSynced;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryValidatorModelSyncResponse>): QueryValidatorModelSyncResponse {
    const message = createBaseQueryValidatorModelSyncResponse();
    message.report = (object.report !== undefined && object.report !== null)
      ? ValidatorModelReport.fromPartial(object.report)
      : undefined;
    message.isSynced = object.isSynced ?? false;
    return message;
  },
};

function createBaseQueryModelParamsRequest(): QueryModelParamsRequest {
  return {};
}

export const QueryModelParamsRequest: MessageFns<
  QueryModelParamsRequest,
  "virtengine.veid.v1.QueryModelParamsRequest"
> = {
  $type: "virtengine.veid.v1.QueryModelParamsRequest" as const,

  encode(_: QueryModelParamsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelParamsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelParamsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): QueryModelParamsRequest {
    return {};
  },

  toJSON(_: QueryModelParamsRequest): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<QueryModelParamsRequest>): QueryModelParamsRequest {
    const message = createBaseQueryModelParamsRequest();
    return message;
  },
};

function createBaseQueryModelParamsResponse(): QueryModelParamsResponse {
  return { params: undefined };
}

export const QueryModelParamsResponse: MessageFns<
  QueryModelParamsResponse,
  "virtengine.veid.v1.QueryModelParamsResponse"
> = {
  $type: "virtengine.veid.v1.QueryModelParamsResponse" as const,

  encode(message: QueryModelParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.params !== undefined) {
      ModelParams.encode(message.params, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryModelParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryModelParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.params = ModelParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryModelParamsResponse {
    return { params: isSet(object.params) ? ModelParams.fromJSON(object.params) : undefined };
  },

  toJSON(message: QueryModelParamsResponse): unknown {
    const obj: any = {};
    if (message.params !== undefined) {
      obj.params = ModelParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<QueryModelParamsResponse>): QueryModelParamsResponse {
    const message = createBaseQueryModelParamsResponse();
    message.params = (object.params !== undefined && object.params !== null)
      ? ModelParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
