import { bytesFromBase64, base64FromBytes, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** ScopeType represents the type of identity scope */
export enum ScopeType {
  /** SCOPE_TYPE_UNSPECIFIED - SCOPE_TYPE_UNSPECIFIED represents an unspecified scope type */
  SCOPE_TYPE_UNSPECIFIED = 0,
  /** SCOPE_TYPE_ID_DOCUMENT - SCOPE_TYPE_ID_DOCUMENT represents government-issued ID documents */
  SCOPE_TYPE_ID_DOCUMENT = 1,
  /** SCOPE_TYPE_SELFIE - SCOPE_TYPE_SELFIE represents a selfie photo for face verification */
  SCOPE_TYPE_SELFIE = 2,
  /** SCOPE_TYPE_FACE_VIDEO - SCOPE_TYPE_FACE_VIDEO represents a video for liveness detection */
  SCOPE_TYPE_FACE_VIDEO = 3,
  /** SCOPE_TYPE_BIOMETRIC - SCOPE_TYPE_BIOMETRIC represents biometric data (fingerprint, voice, etc.) */
  SCOPE_TYPE_BIOMETRIC = 4,
  /** SCOPE_TYPE_SSO_METADATA - SCOPE_TYPE_SSO_METADATA represents SSO provider metadata pointers */
  SCOPE_TYPE_SSO_METADATA = 5,
  /** SCOPE_TYPE_EMAIL_PROOF - SCOPE_TYPE_EMAIL_PROOF represents email verification proof */
  SCOPE_TYPE_EMAIL_PROOF = 6,
  /** SCOPE_TYPE_SMS_PROOF - SCOPE_TYPE_SMS_PROOF represents SMS/phone verification proof */
  SCOPE_TYPE_SMS_PROOF = 7,
  /** SCOPE_TYPE_DOMAIN_VERIFY - SCOPE_TYPE_DOMAIN_VERIFY represents domain ownership verification */
  SCOPE_TYPE_DOMAIN_VERIFY = 8,
  /** SCOPE_TYPE_AD_SSO - SCOPE_TYPE_AD_SSO represents Active Directory SSO verification */
  SCOPE_TYPE_AD_SSO = 9,
  UNRECOGNIZED = -1,
}

export function scopeTypeFromJSON(object: any): ScopeType {
  switch (object) {
    case 0:
    case "SCOPE_TYPE_UNSPECIFIED":
      return ScopeType.SCOPE_TYPE_UNSPECIFIED;
    case 1:
    case "SCOPE_TYPE_ID_DOCUMENT":
      return ScopeType.SCOPE_TYPE_ID_DOCUMENT;
    case 2:
    case "SCOPE_TYPE_SELFIE":
      return ScopeType.SCOPE_TYPE_SELFIE;
    case 3:
    case "SCOPE_TYPE_FACE_VIDEO":
      return ScopeType.SCOPE_TYPE_FACE_VIDEO;
    case 4:
    case "SCOPE_TYPE_BIOMETRIC":
      return ScopeType.SCOPE_TYPE_BIOMETRIC;
    case 5:
    case "SCOPE_TYPE_SSO_METADATA":
      return ScopeType.SCOPE_TYPE_SSO_METADATA;
    case 6:
    case "SCOPE_TYPE_EMAIL_PROOF":
      return ScopeType.SCOPE_TYPE_EMAIL_PROOF;
    case 7:
    case "SCOPE_TYPE_SMS_PROOF":
      return ScopeType.SCOPE_TYPE_SMS_PROOF;
    case 8:
    case "SCOPE_TYPE_DOMAIN_VERIFY":
      return ScopeType.SCOPE_TYPE_DOMAIN_VERIFY;
    case 9:
    case "SCOPE_TYPE_AD_SSO":
      return ScopeType.SCOPE_TYPE_AD_SSO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScopeType.UNRECOGNIZED;
  }
}

export function scopeTypeToJSON(object: ScopeType): string {
  switch (object) {
    case ScopeType.SCOPE_TYPE_UNSPECIFIED:
      return "SCOPE_TYPE_UNSPECIFIED";
    case ScopeType.SCOPE_TYPE_ID_DOCUMENT:
      return "SCOPE_TYPE_ID_DOCUMENT";
    case ScopeType.SCOPE_TYPE_SELFIE:
      return "SCOPE_TYPE_SELFIE";
    case ScopeType.SCOPE_TYPE_FACE_VIDEO:
      return "SCOPE_TYPE_FACE_VIDEO";
    case ScopeType.SCOPE_TYPE_BIOMETRIC:
      return "SCOPE_TYPE_BIOMETRIC";
    case ScopeType.SCOPE_TYPE_SSO_METADATA:
      return "SCOPE_TYPE_SSO_METADATA";
    case ScopeType.SCOPE_TYPE_EMAIL_PROOF:
      return "SCOPE_TYPE_EMAIL_PROOF";
    case ScopeType.SCOPE_TYPE_SMS_PROOF:
      return "SCOPE_TYPE_SMS_PROOF";
    case ScopeType.SCOPE_TYPE_DOMAIN_VERIFY:
      return "SCOPE_TYPE_DOMAIN_VERIFY";
    case ScopeType.SCOPE_TYPE_AD_SSO:
      return "SCOPE_TYPE_AD_SSO";
    case ScopeType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** VerificationStatus represents the verification state of an identity scope */
export enum VerificationStatus {
  /** VERIFICATION_STATUS_UNKNOWN - VERIFICATION_STATUS_UNKNOWN indicates an uninitialized or unknown status */
  VERIFICATION_STATUS_UNKNOWN = 0,
  /** VERIFICATION_STATUS_PENDING - VERIFICATION_STATUS_PENDING indicates the scope is awaiting verification */
  VERIFICATION_STATUS_PENDING = 1,
  /** VERIFICATION_STATUS_IN_PROGRESS - VERIFICATION_STATUS_IN_PROGRESS indicates verification is actively being processed */
  VERIFICATION_STATUS_IN_PROGRESS = 2,
  /** VERIFICATION_STATUS_VERIFIED - VERIFICATION_STATUS_VERIFIED indicates the scope has been successfully verified */
  VERIFICATION_STATUS_VERIFIED = 3,
  /** VERIFICATION_STATUS_REJECTED - VERIFICATION_STATUS_REJECTED indicates the scope failed verification */
  VERIFICATION_STATUS_REJECTED = 4,
  /** VERIFICATION_STATUS_EXPIRED - VERIFICATION_STATUS_EXPIRED indicates the verification has expired */
  VERIFICATION_STATUS_EXPIRED = 5,
  /** VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR - VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR indicates borderline score requires MFA */
  VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR = 6,
  /** VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING - VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING indicates MFA challenge is in progress */
  VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING = 7,
  UNRECOGNIZED = -1,
}

export function verificationStatusFromJSON(object: any): VerificationStatus {
  switch (object) {
    case 0:
    case "VERIFICATION_STATUS_UNKNOWN":
      return VerificationStatus.VERIFICATION_STATUS_UNKNOWN;
    case 1:
    case "VERIFICATION_STATUS_PENDING":
      return VerificationStatus.VERIFICATION_STATUS_PENDING;
    case 2:
    case "VERIFICATION_STATUS_IN_PROGRESS":
      return VerificationStatus.VERIFICATION_STATUS_IN_PROGRESS;
    case 3:
    case "VERIFICATION_STATUS_VERIFIED":
      return VerificationStatus.VERIFICATION_STATUS_VERIFIED;
    case 4:
    case "VERIFICATION_STATUS_REJECTED":
      return VerificationStatus.VERIFICATION_STATUS_REJECTED;
    case 5:
    case "VERIFICATION_STATUS_EXPIRED":
      return VerificationStatus.VERIFICATION_STATUS_EXPIRED;
    case 6:
    case "VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR":
      return VerificationStatus.VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR;
    case 7:
    case "VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING":
      return VerificationStatus.VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return VerificationStatus.UNRECOGNIZED;
  }
}

export function verificationStatusToJSON(object: VerificationStatus): string {
  switch (object) {
    case VerificationStatus.VERIFICATION_STATUS_UNKNOWN:
      return "VERIFICATION_STATUS_UNKNOWN";
    case VerificationStatus.VERIFICATION_STATUS_PENDING:
      return "VERIFICATION_STATUS_PENDING";
    case VerificationStatus.VERIFICATION_STATUS_IN_PROGRESS:
      return "VERIFICATION_STATUS_IN_PROGRESS";
    case VerificationStatus.VERIFICATION_STATUS_VERIFIED:
      return "VERIFICATION_STATUS_VERIFIED";
    case VerificationStatus.VERIFICATION_STATUS_REJECTED:
      return "VERIFICATION_STATUS_REJECTED";
    case VerificationStatus.VERIFICATION_STATUS_EXPIRED:
      return "VERIFICATION_STATUS_EXPIRED";
    case VerificationStatus.VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR:
      return "VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR";
    case VerificationStatus.VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING:
      return "VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING";
    case VerificationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** IdentityTier represents the verification tier of an identity */
export enum IdentityTier {
  /** IDENTITY_TIER_UNVERIFIED - IDENTITY_TIER_UNVERIFIED is the initial state with no verification */
  IDENTITY_TIER_UNVERIFIED = 0,
  /** IDENTITY_TIER_BASIC - IDENTITY_TIER_BASIC is for minimally verified identities (score 50-69) */
  IDENTITY_TIER_BASIC = 1,
  /** IDENTITY_TIER_STANDARD - IDENTITY_TIER_STANDARD is for standard verified identities (score 70-84) */
  IDENTITY_TIER_STANDARD = 2,
  /** IDENTITY_TIER_PREMIUM - IDENTITY_TIER_PREMIUM is for premium verified identities (score 85-100) */
  IDENTITY_TIER_PREMIUM = 3,
  UNRECOGNIZED = -1,
}

export function identityTierFromJSON(object: any): IdentityTier {
  switch (object) {
    case 0:
    case "IDENTITY_TIER_UNVERIFIED":
      return IdentityTier.IDENTITY_TIER_UNVERIFIED;
    case 1:
    case "IDENTITY_TIER_BASIC":
      return IdentityTier.IDENTITY_TIER_BASIC;
    case 2:
    case "IDENTITY_TIER_STANDARD":
      return IdentityTier.IDENTITY_TIER_STANDARD;
    case 3:
    case "IDENTITY_TIER_PREMIUM":
      return IdentityTier.IDENTITY_TIER_PREMIUM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return IdentityTier.UNRECOGNIZED;
  }
}

export function identityTierToJSON(object: IdentityTier): string {
  switch (object) {
    case IdentityTier.IDENTITY_TIER_UNVERIFIED:
      return "IDENTITY_TIER_UNVERIFIED";
    case IdentityTier.IDENTITY_TIER_BASIC:
      return "IDENTITY_TIER_BASIC";
    case IdentityTier.IDENTITY_TIER_STANDARD:
      return "IDENTITY_TIER_STANDARD";
    case IdentityTier.IDENTITY_TIER_PREMIUM:
      return "IDENTITY_TIER_PREMIUM";
    case IdentityTier.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AccountStatus represents the overall account verification status */
export enum AccountStatus {
  /** ACCOUNT_STATUS_UNKNOWN - ACCOUNT_STATUS_UNKNOWN indicates an uninitialized status */
  ACCOUNT_STATUS_UNKNOWN = 0,
  /** ACCOUNT_STATUS_PENDING - ACCOUNT_STATUS_PENDING indicates verification is in progress */
  ACCOUNT_STATUS_PENDING = 1,
  /** ACCOUNT_STATUS_IN_PROGRESS - ACCOUNT_STATUS_IN_PROGRESS indicates active ML scoring */
  ACCOUNT_STATUS_IN_PROGRESS = 2,
  /** ACCOUNT_STATUS_VERIFIED - ACCOUNT_STATUS_VERIFIED indicates account is verified */
  ACCOUNT_STATUS_VERIFIED = 3,
  /** ACCOUNT_STATUS_REJECTED - ACCOUNT_STATUS_REJECTED indicates verification was rejected */
  ACCOUNT_STATUS_REJECTED = 4,
  /** ACCOUNT_STATUS_EXPIRED - ACCOUNT_STATUS_EXPIRED indicates verification has expired */
  ACCOUNT_STATUS_EXPIRED = 5,
  /** ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR - ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR indicates additional verification needed */
  ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR = 6,
  UNRECOGNIZED = -1,
}

export function accountStatusFromJSON(object: any): AccountStatus {
  switch (object) {
    case 0:
    case "ACCOUNT_STATUS_UNKNOWN":
      return AccountStatus.ACCOUNT_STATUS_UNKNOWN;
    case 1:
    case "ACCOUNT_STATUS_PENDING":
      return AccountStatus.ACCOUNT_STATUS_PENDING;
    case 2:
    case "ACCOUNT_STATUS_IN_PROGRESS":
      return AccountStatus.ACCOUNT_STATUS_IN_PROGRESS;
    case 3:
    case "ACCOUNT_STATUS_VERIFIED":
      return AccountStatus.ACCOUNT_STATUS_VERIFIED;
    case 4:
    case "ACCOUNT_STATUS_REJECTED":
      return AccountStatus.ACCOUNT_STATUS_REJECTED;
    case 5:
    case "ACCOUNT_STATUS_EXPIRED":
      return AccountStatus.ACCOUNT_STATUS_EXPIRED;
    case 6:
    case "ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR":
      return AccountStatus.ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AccountStatus.UNRECOGNIZED;
  }
}

export function accountStatusToJSON(object: AccountStatus): string {
  switch (object) {
    case AccountStatus.ACCOUNT_STATUS_UNKNOWN:
      return "ACCOUNT_STATUS_UNKNOWN";
    case AccountStatus.ACCOUNT_STATUS_PENDING:
      return "ACCOUNT_STATUS_PENDING";
    case AccountStatus.ACCOUNT_STATUS_IN_PROGRESS:
      return "ACCOUNT_STATUS_IN_PROGRESS";
    case AccountStatus.ACCOUNT_STATUS_VERIFIED:
      return "ACCOUNT_STATUS_VERIFIED";
    case AccountStatus.ACCOUNT_STATUS_REJECTED:
      return "ACCOUNT_STATUS_REJECTED";
    case AccountStatus.ACCOUNT_STATUS_EXPIRED:
      return "ACCOUNT_STATUS_EXPIRED";
    case AccountStatus.ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR:
      return "ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR";
    case AccountStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** WalletStatus represents the overall status of an identity wallet */
export enum WalletStatus {
  /** WALLET_STATUS_UNSPECIFIED - WALLET_STATUS_UNSPECIFIED indicates an unspecified status */
  WALLET_STATUS_UNSPECIFIED = 0,
  /** WALLET_STATUS_ACTIVE - WALLET_STATUS_ACTIVE indicates the wallet is active and usable */
  WALLET_STATUS_ACTIVE = 1,
  /** WALLET_STATUS_SUSPENDED - WALLET_STATUS_SUSPENDED indicates the wallet is temporarily suspended */
  WALLET_STATUS_SUSPENDED = 2,
  /** WALLET_STATUS_REVOKED - WALLET_STATUS_REVOKED indicates the wallet has been revoked */
  WALLET_STATUS_REVOKED = 3,
  /** WALLET_STATUS_EXPIRED - WALLET_STATUS_EXPIRED indicates the wallet verification has expired */
  WALLET_STATUS_EXPIRED = 4,
  UNRECOGNIZED = -1,
}

export function walletStatusFromJSON(object: any): WalletStatus {
  switch (object) {
    case 0:
    case "WALLET_STATUS_UNSPECIFIED":
      return WalletStatus.WALLET_STATUS_UNSPECIFIED;
    case 1:
    case "WALLET_STATUS_ACTIVE":
      return WalletStatus.WALLET_STATUS_ACTIVE;
    case 2:
    case "WALLET_STATUS_SUSPENDED":
      return WalletStatus.WALLET_STATUS_SUSPENDED;
    case 3:
    case "WALLET_STATUS_REVOKED":
      return WalletStatus.WALLET_STATUS_REVOKED;
    case 4:
    case "WALLET_STATUS_EXPIRED":
      return WalletStatus.WALLET_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WalletStatus.UNRECOGNIZED;
  }
}

export function walletStatusToJSON(object: WalletStatus): string {
  switch (object) {
    case WalletStatus.WALLET_STATUS_UNSPECIFIED:
      return "WALLET_STATUS_UNSPECIFIED";
    case WalletStatus.WALLET_STATUS_ACTIVE:
      return "WALLET_STATUS_ACTIVE";
    case WalletStatus.WALLET_STATUS_SUSPENDED:
      return "WALLET_STATUS_SUSPENDED";
    case WalletStatus.WALLET_STATUS_REVOKED:
      return "WALLET_STATUS_REVOKED";
    case WalletStatus.WALLET_STATUS_EXPIRED:
      return "WALLET_STATUS_EXPIRED";
    case WalletStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ScopeRefStatus represents the status of a scope reference within a wallet */
export enum ScopeRefStatus {
  /** SCOPE_REF_STATUS_UNSPECIFIED - SCOPE_REF_STATUS_UNSPECIFIED indicates an unspecified status */
  SCOPE_REF_STATUS_UNSPECIFIED = 0,
  /** SCOPE_REF_STATUS_ACTIVE - SCOPE_REF_STATUS_ACTIVE indicates the scope reference is active */
  SCOPE_REF_STATUS_ACTIVE = 1,
  /** SCOPE_REF_STATUS_REVOKED - SCOPE_REF_STATUS_REVOKED indicates the scope reference has been revoked */
  SCOPE_REF_STATUS_REVOKED = 2,
  /** SCOPE_REF_STATUS_EXPIRED - SCOPE_REF_STATUS_EXPIRED indicates the scope reference has expired */
  SCOPE_REF_STATUS_EXPIRED = 3,
  /** SCOPE_REF_STATUS_PENDING - SCOPE_REF_STATUS_PENDING indicates the scope is pending verification */
  SCOPE_REF_STATUS_PENDING = 4,
  UNRECOGNIZED = -1,
}

export function scopeRefStatusFromJSON(object: any): ScopeRefStatus {
  switch (object) {
    case 0:
    case "SCOPE_REF_STATUS_UNSPECIFIED":
      return ScopeRefStatus.SCOPE_REF_STATUS_UNSPECIFIED;
    case 1:
    case "SCOPE_REF_STATUS_ACTIVE":
      return ScopeRefStatus.SCOPE_REF_STATUS_ACTIVE;
    case 2:
    case "SCOPE_REF_STATUS_REVOKED":
      return ScopeRefStatus.SCOPE_REF_STATUS_REVOKED;
    case 3:
    case "SCOPE_REF_STATUS_EXPIRED":
      return ScopeRefStatus.SCOPE_REF_STATUS_EXPIRED;
    case 4:
    case "SCOPE_REF_STATUS_PENDING":
      return ScopeRefStatus.SCOPE_REF_STATUS_PENDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScopeRefStatus.UNRECOGNIZED;
  }
}

export function scopeRefStatusToJSON(object: ScopeRefStatus): string {
  switch (object) {
    case ScopeRefStatus.SCOPE_REF_STATUS_UNSPECIFIED:
      return "SCOPE_REF_STATUS_UNSPECIFIED";
    case ScopeRefStatus.SCOPE_REF_STATUS_ACTIVE:
      return "SCOPE_REF_STATUS_ACTIVE";
    case ScopeRefStatus.SCOPE_REF_STATUS_REVOKED:
      return "SCOPE_REF_STATUS_REVOKED";
    case ScopeRefStatus.SCOPE_REF_STATUS_EXPIRED:
      return "SCOPE_REF_STATUS_EXPIRED";
    case ScopeRefStatus.SCOPE_REF_STATUS_PENDING:
      return "SCOPE_REF_STATUS_PENDING";
    case ScopeRefStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * EncryptedPayloadEnvelope is the canonical encrypted payload structure
 * for all sensitive fields stored on-chain.
 */
export interface EncryptedPayloadEnvelope {
  /** Version is the envelope format version for future compatibility */
  version: number;
  /** AlgorithmID identifies the encryption algorithm used */
  algorithmId: string;
  /** AlgorithmVersion is the version of the algorithm used */
  algorithmVersion: number;
  /** RecipientKeyIDs are the fingerprints of intended recipients' public keys */
  recipientKeyIds: string[];
  /** RecipientPublicKeys are the public keys for intended recipients */
  recipientPublicKeys: Uint8Array[];
  /** EncryptedKeys contains the data encryption key encrypted for each recipient */
  encryptedKeys: Uint8Array[];
  /** Nonce is the initialization vector / nonce for encryption */
  nonce: Uint8Array;
  /** Ciphertext is the encrypted payload data */
  ciphertext: Uint8Array;
  /** SenderSignature is the signature over the envelope contents */
  senderSignature: Uint8Array;
  /** SenderPubKey is the sender's public key for signature verification */
  senderPubKey: Uint8Array;
  /** Metadata contains optional public or encrypted metadata */
  metadata: { [key: string]: string };
}

export interface EncryptedPayloadEnvelope_MetadataEntry {
  key: string;
  value: string;
}

/** UploadMetadata contains metadata about an identity scope upload */
export interface UploadMetadata {
  /** Salt is a per-upload unique salt for cryptographic binding */
  salt: Uint8Array;
  /** SaltHash is the SHA256 hash of the salt */
  saltHash: Uint8Array;
  /** DeviceFingerprint is a hash/identifier of the device used for upload */
  deviceFingerprint: string;
  /** ClientID is the identifier of the approved client */
  clientId: string;
  /** ClientSignature is the cryptographic signature from the approved client */
  clientSignature: Uint8Array;
  /** UserSignature is the cryptographic signature from the user's account */
  userSignature: Uint8Array;
  /** PayloadHash is the SHA256 hash of the encrypted payload */
  payloadHash: Uint8Array;
  /** UploadNonce is a unique nonce for this upload session */
  uploadNonce: Uint8Array;
  /** CaptureTimestamp is when the data was captured (Unix timestamp) */
  captureTimestamp: Long;
  /** GeoHint is an optional geographic hint (coarse location) */
  geoHint: string;
}

/** ScopeRef is a lightweight reference to an identity scope */
export interface ScopeRef {
  /** ScopeID is the unique identifier for the scope */
  scopeId: string;
  /** ScopeType indicates what kind of identity data this scope contains */
  scopeType: ScopeType;
  /** Status is the current verification status */
  status: VerificationStatus;
  /** UploadedAt is when the scope was uploaded (Unix timestamp) */
  uploadedAt: Long;
  /** VerifiedAt is when the scope was verified (Unix timestamp) */
  verifiedAt: Long;
  /** ExpiresAt is when the verification expires (Unix timestamp) */
  expiresAt: Long;
}

/** IdentityScope represents a single piece of identity information */
export interface IdentityScope {
  /** ScopeID is the unique identifier for this scope */
  scopeId: string;
  /** ScopeType indicates what kind of identity data this scope contains */
  scopeType: ScopeType;
  /** Version is the schema version for this scope */
  version: number;
  /** EncryptedPayload contains the encrypted identity data */
  encryptedPayload:
    | EncryptedPayloadEnvelope
    | undefined;
  /** UploadMetadata contains metadata about the upload */
  uploadMetadata:
    | UploadMetadata
    | undefined;
  /** Status is the current verification status */
  status: VerificationStatus;
  /** UploadedAt is when this scope was uploaded (Unix timestamp) */
  uploadedAt: Long;
  /** VerifiedAt is when this scope was verified (Unix timestamp) */
  verifiedAt: Long;
  /** ExpiresAt is when the verification expires (Unix timestamp) */
  expiresAt: Long;
  /** OwnerAddress is the blockchain address that owns this scope */
  ownerAddress: string;
}

/** IdentityRecord represents a user's complete identity record on-chain */
export interface IdentityRecord {
  /** AccountAddress is the blockchain address that owns this identity */
  accountAddress: string;
  /** ScopeRefs are lightweight references to the scopes owned by this identity */
  scopeRefs: ScopeRef[];
  /** CurrentScore is the current identity score (0-100) */
  currentScore: number;
  /** ScoreVersion is the ML model version used to compute the current score */
  scoreVersion: string;
  /** LastVerifiedAt is when the identity was last verified (Unix timestamp) */
  lastVerifiedAt: Long;
  /** CreatedAt is when this identity record was created (Unix timestamp) */
  createdAt: Long;
  /** UpdatedAt is when this identity record was last updated (Unix timestamp) */
  updatedAt: Long;
  /** Tier is the current identity tier based on score */
  tier: IdentityTier;
  /** Flags contains any flags on this identity */
  flags: string[];
  /** Locked indicates if the identity is locked */
  locked: boolean;
  /** LockedReason is the reason for locking */
  lockedReason: string;
}

/** IdentityScore represents the current identity score for an account */
export interface IdentityScore {
  /** AccountAddress is the blockchain address this score belongs to */
  accountAddress: string;
  /** Score is the current identity score (0-100) */
  score: number;
  /** Status is the current account verification status */
  status: AccountStatus;
  /** Tier is the identity tier based on score */
  tier: IdentityTier;
  /** ModelVersion is the ML model version used */
  modelVersion: string;
  /** LastUpdatedAt is when the score was last updated (Unix timestamp) */
  lastUpdatedAt: Long;
  /** BlockHeight is the block height when score was computed */
  blockHeight: Long;
}

/** ConsentSettings represents consent configuration for an identity wallet */
export interface ConsentSettings {
  /** ShareWithProviders allows providers to access non-sensitive identity metadata */
  shareWithProviders: boolean;
  /** ShareForVerification allows the identity to be used for verification requests */
  shareForVerification: boolean;
  /** AllowReVerification allows the identity to be re-verified without explicit request */
  allowReVerification: boolean;
  /** AllowDerivedFeatureSharing allows sharing of derived feature hashes */
  allowDerivedFeatureSharing: boolean;
  /** ConsentVersion tracks consent settings version for audit */
  consentVersion: number;
  /** LastUpdatedAt is when consent was last updated (Unix timestamp) */
  lastUpdatedAt: Long;
}

/** GlobalConsentUpdate represents an update to global consent settings */
export interface GlobalConsentUpdate {
  /** ShareWithProviders update */
  shareWithProviders: boolean;
  /** ShareForVerification update */
  shareForVerification: boolean;
  /** AllowReVerification update */
  allowReVerification: boolean;
  /** AllowDerivedFeatureSharing update */
  allowDerivedFeatureSharing: boolean;
}

/** BorderlineParams contains parameters for borderline score handling */
export interface BorderlineParams {
  /** LowerThreshold is the lower threshold for borderline scores */
  lowerThreshold: number;
  /** UpperThreshold is the upper threshold for borderline scores */
  upperThreshold: number;
  /** MfaTimeoutBlocks is how long MFA challenge is valid */
  mfaTimeoutBlocks: Long;
  /** RequiredFactors is the number of MFA factors required */
  requiredFactors: number;
}

/** ApprovedClient represents an approved client application */
export interface ApprovedClient {
  /** ClientID is the unique identifier for the client */
  clientId: string;
  /** Name is the human-readable name of the client */
  name: string;
  /** PublicKey is the client's public key for signature verification */
  publicKey: Uint8Array;
  /** Active indicates if the client is currently active */
  active: boolean;
  /** CreatedAt is when the client was registered (Unix timestamp) */
  createdAt: Long;
  /** DeactivatedAt is when the client was deactivated (Unix timestamp) */
  deactivatedAt: Long;
}

/** Params defines the parameters for the veid module */
export interface Params {
  /** MaxScopesPerAccount is the maximum number of scopes per account */
  maxScopesPerAccount: number;
  /** MaxScopesPerType is the maximum number of scopes per type per account */
  maxScopesPerType: number;
  /** SaltMinBytes is the minimum salt size in bytes */
  saltMinBytes: number;
  /** SaltMaxBytes is the maximum salt size in bytes */
  saltMaxBytes: number;
  /** RequireClientSignature determines if client signatures are mandatory */
  requireClientSignature: boolean;
  /** RequireUserSignature determines if user signatures are mandatory */
  requireUserSignature: boolean;
  /** VerificationExpiryDays is how long a verification is valid (in days) */
  verificationExpiryDays: number;
}

/**
 * DerivedFeatures contains hashes of derived features from identity scopes.
 * These are used for verification matching without revealing the underlying data.
 * All hashes are SHA-256 (32 bytes) for consistency.
 */
export interface DerivedFeatures {
  /**
   * FaceEmbeddingHash is the SHA-256 hash of the face embedding vector.
   * The actual embedding is stored encrypted; this hash allows matching.
   */
  faceEmbeddingHash: Uint8Array;
  /**
   * DocFieldHashes contains hashes of extracted document fields.
   * Keys are field names: "name_hash", "dob_hash", "doc_number_hash", etc.
   */
  docFieldHashes: { [key: string]: Uint8Array };
  /** BiometricHash is the hash of biometric data (fingerprint, voice, etc.) */
  biometricHash: Uint8Array;
  /** LivenessProofHash is the hash of liveness detection proof */
  livenessProofHash: Uint8Array;
  /** LastComputedAt is when these features were last computed (Unix timestamp) */
  lastComputedAt: Long;
  /** ModelVersion is the ML model version used to compute these features */
  modelVersion: string;
  /** ComputedBy is the validator address that computed these features */
  computedBy: string;
  /** BlockHeight is the block height when features were computed */
  blockHeight: Long;
  /** FeatureVersion tracks the derived features schema version */
  featureVersion: number;
}

export interface DerivedFeatures_DocFieldHashesEntry {
  key: string;
  value: Uint8Array;
}

/**
 * ScopeReference represents a reference to an encrypted scope within a wallet.
 * This is a more detailed reference than ScopeRef, containing wallet-specific metadata.
 */
export interface ScopeReference {
  /** ScopeID is the unique identifier of the scope */
  scopeId: string;
  /** ScopeType indicates what kind of identity data this scope contains */
  scopeType: ScopeType;
  /**
   * EnvelopeHash is the SHA-256 hash of the encrypted envelope.
   * This allows verification without exposing the encrypted content.
   */
  envelopeHash: Uint8Array;
  /** AddedAt is when this scope was added to the wallet (Unix timestamp) */
  addedAt: Long;
  /** Status is the current status of this scope reference */
  status: ScopeRefStatus;
  /** ConsentGranted indicates if consent has been granted for this scope */
  consentGranted: boolean;
  /** RevocationReason is the reason for revocation (if revoked) */
  revocationReason: string;
  /** RevokedAt is when this scope was revoked (Unix timestamp, 0 if not revoked) */
  revokedAt: Long;
  /** ExpiresAt is when this scope reference expires (Unix timestamp, 0 for no expiry) */
  expiresAt: Long;
}

/**
 * ScopeConsent represents consent configuration for a specific scope.
 * This tracks per-scope consent settings within a wallet.
 */
export interface ScopeConsent {
  /** ScopeID is the identifier of the scope this consent applies to */
  scopeId: string;
  /** Granted indicates if consent is currently granted */
  granted: boolean;
  /** GrantedAt is when consent was granted (Unix timestamp, 0 if never granted) */
  grantedAt: Long;
  /** RevokedAt is when consent was revoked (Unix timestamp, 0 if not revoked) */
  revokedAt: Long;
  /** ExpiresAt is when this consent expires (Unix timestamp, 0 for no expiration) */
  expiresAt: Long;
  /** Purpose describes the purpose for which consent was granted */
  purpose: string;
  /**
   * GrantedToProviders lists specific providers consent was granted to.
   * Empty means consent is general (not provider-specific).
   */
  grantedToProviders: string[];
  /** Restrictions contains any restrictions on this consent */
  restrictions: string[];
}

/**
 * VerificationHistoryEntry represents a single verification event in the wallet's history.
 * This tracks score and status changes over time for audit purposes.
 */
export interface VerificationHistoryEntry {
  /** EntryID is a unique identifier for this history entry */
  entryId: string;
  /** Timestamp is when this verification occurred (Unix timestamp) */
  timestamp: Long;
  /** BlockHeight is the block height when this was recorded */
  blockHeight: Long;
  /** PreviousScore is the score before this verification */
  previousScore: number;
  /** NewScore is the score after this verification */
  newScore: number;
  /** PreviousStatus is the status before this verification */
  previousStatus: AccountStatus;
  /** NewStatus is the status after this verification */
  newStatus: AccountStatus;
  /** ScopesEvaluated lists the scope IDs that were evaluated */
  scopesEvaluated: string[];
  /** ModelVersion is the ML model version used for this verification */
  modelVersion: string;
  /** ValidatorAddress is the address of the validator that performed this verification */
  validatorAddress: string;
  /** Reason is an optional reason/description for this verification */
  reason: string;
}

/**
 * IdentityWallet represents a user-controlled identity container.
 * This is the first-class on-chain identity primitive that references
 * encrypted scopes and derived features, bound to the user's account key(s).
 */
export interface IdentityWallet {
  /**
   * WalletID is the unique identifier for this wallet.
   * Typically derived from the account address.
   */
  walletId: string;
  /** AccountAddress is the blockchain address bound to this wallet */
  accountAddress: string;
  /** CreatedAt is when this wallet was created (Unix timestamp) */
  createdAt: Long;
  /** UpdatedAt is when this wallet was last updated (Unix timestamp) */
  updatedAt: Long;
  /** Status is the current status of the wallet */
  status: WalletStatus;
  /**
   * ScopeRefs are references to encrypted scope envelopes.
   * These are opaque references - the actual encrypted data is stored separately.
   */
  scopeRefs: ScopeReference[];
  /** DerivedFeatures contains hashes of derived features for verification matching */
  derivedFeatures:
    | DerivedFeatures
    | undefined;
  /** CurrentScore is the current identity verification score (0-100) */
  currentScore: number;
  /** ScoreStatus is the current verification status */
  scoreStatus: AccountStatus;
  /** VerificationHistory contains the history of verification events */
  verificationHistory: VerificationHistoryEntry[];
  /** ConsentSettings contains the consent configuration for this wallet */
  consentSettings:
    | ConsentSettings
    | undefined;
  /** ScopeConsents contains per-scope consent settings (key is scopeID) */
  scopeConsents: { [key: string]: ScopeConsent };
  /**
   * BindingSignature is the user's signature over (WalletID + AccountAddress).
   * This cryptographically binds the wallet to the user's account.
   */
  bindingSignature: Uint8Array;
  /**
   * BindingPubKey is the public key used to create the binding signature.
   * This is captured at wallet creation and updated on key rotation.
   */
  bindingPubKey: Uint8Array;
  /** LastBindingAt is when the wallet was last bound/rebound (Unix timestamp) */
  lastBindingAt: Long;
  /** Tier is the current identity tier based on score */
  tier: IdentityTier;
  /** Metadata contains additional wallet metadata */
  metadata: { [key: string]: string };
}

export interface IdentityWallet_ScopeConsentsEntry {
  key: string;
  value: ScopeConsent | undefined;
}

export interface IdentityWallet_MetadataEntry {
  key: string;
  value: string;
}

function createBaseEncryptedPayloadEnvelope(): EncryptedPayloadEnvelope {
  return {
    version: 0,
    algorithmId: "",
    algorithmVersion: 0,
    recipientKeyIds: [],
    recipientPublicKeys: [],
    encryptedKeys: [],
    nonce: new Uint8Array(0),
    ciphertext: new Uint8Array(0),
    senderSignature: new Uint8Array(0),
    senderPubKey: new Uint8Array(0),
    metadata: {},
  };
}

export const EncryptedPayloadEnvelope: MessageFns<
  EncryptedPayloadEnvelope,
  "virtengine.veid.v1.EncryptedPayloadEnvelope"
> = {
  $type: "virtengine.veid.v1.EncryptedPayloadEnvelope" as const,

  encode(message: EncryptedPayloadEnvelope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.version !== 0) {
      writer.uint32(8).uint32(message.version);
    }
    if (message.algorithmId !== "") {
      writer.uint32(18).string(message.algorithmId);
    }
    if (message.algorithmVersion !== 0) {
      writer.uint32(24).uint32(message.algorithmVersion);
    }
    for (const v of message.recipientKeyIds) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.recipientPublicKeys) {
      writer.uint32(42).bytes(v!);
    }
    for (const v of message.encryptedKeys) {
      writer.uint32(50).bytes(v!);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(58).bytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(66).bytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      writer.uint32(74).bytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      writer.uint32(82).bytes(message.senderPubKey);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EncryptedPayloadEnvelope_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedPayloadEnvelope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedPayloadEnvelope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.algorithmId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.algorithmVersion = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recipientKeyIds.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.recipientPublicKeys.push(reader.bytes());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.encryptedKeys.push(reader.bytes());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.senderSignature = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.senderPubKey = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = EncryptedPayloadEnvelope_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedPayloadEnvelope {
    return {
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      algorithmId: isSet(object.algorithm_id) ? globalThis.String(object.algorithm_id) : "",
      algorithmVersion: isSet(object.algorithm_version) ? globalThis.Number(object.algorithm_version) : 0,
      recipientKeyIds: globalThis.Array.isArray(object?.recipient_key_ids)
        ? object.recipient_key_ids.map((e: any) => globalThis.String(e))
        : [],
      recipientPublicKeys: globalThis.Array.isArray(object?.recipient_public_keys)
        ? object.recipient_public_keys.map((e: any) => bytesFromBase64(e))
        : [],
      encryptedKeys: globalThis.Array.isArray(object?.encrypted_keys)
        ? object.encrypted_keys.map((e: any) => bytesFromBase64(e))
        : [],
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      senderSignature: isSet(object.sender_signature) ? bytesFromBase64(object.sender_signature) : new Uint8Array(0),
      senderPubKey: isSet(object.sender_pub_key) ? bytesFromBase64(object.sender_pub_key) : new Uint8Array(0),
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: EncryptedPayloadEnvelope): unknown {
    const obj: any = {};
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.algorithmId !== "") {
      obj.algorithm_id = message.algorithmId;
    }
    if (message.algorithmVersion !== 0) {
      obj.algorithm_version = Math.round(message.algorithmVersion);
    }
    if (message.recipientKeyIds?.length) {
      obj.recipient_key_ids = message.recipientKeyIds;
    }
    if (message.recipientPublicKeys?.length) {
      obj.recipient_public_keys = message.recipientPublicKeys.map((e) => base64FromBytes(e));
    }
    if (message.encryptedKeys?.length) {
      obj.encrypted_keys = message.encryptedKeys.map((e) => base64FromBytes(e));
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      obj.sender_signature = base64FromBytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      obj.sender_pub_key = base64FromBytes(message.senderPubKey);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EncryptedPayloadEnvelope>): EncryptedPayloadEnvelope {
    const message = createBaseEncryptedPayloadEnvelope();
    message.version = object.version ?? 0;
    message.algorithmId = object.algorithmId ?? "";
    message.algorithmVersion = object.algorithmVersion ?? 0;
    message.recipientKeyIds = object.recipientKeyIds?.map((e) => e) || [];
    message.recipientPublicKeys = object.recipientPublicKeys?.map((e) => e) || [];
    message.encryptedKeys = object.encryptedKeys?.map((e) => e) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.senderSignature = object.senderSignature ?? new Uint8Array(0);
    message.senderPubKey = object.senderPubKey ?? new Uint8Array(0);
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseEncryptedPayloadEnvelope_MetadataEntry(): EncryptedPayloadEnvelope_MetadataEntry {
  return { key: "", value: "" };
}

export const EncryptedPayloadEnvelope_MetadataEntry: MessageFns<
  EncryptedPayloadEnvelope_MetadataEntry,
  "virtengine.veid.v1.EncryptedPayloadEnvelope.MetadataEntry"
> = {
  $type: "virtengine.veid.v1.EncryptedPayloadEnvelope.MetadataEntry" as const,

  encode(message: EncryptedPayloadEnvelope_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedPayloadEnvelope_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedPayloadEnvelope_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedPayloadEnvelope_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EncryptedPayloadEnvelope_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EncryptedPayloadEnvelope_MetadataEntry>): EncryptedPayloadEnvelope_MetadataEntry {
    const message = createBaseEncryptedPayloadEnvelope_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUploadMetadata(): UploadMetadata {
  return {
    salt: new Uint8Array(0),
    saltHash: new Uint8Array(0),
    deviceFingerprint: "",
    clientId: "",
    clientSignature: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    payloadHash: new Uint8Array(0),
    uploadNonce: new Uint8Array(0),
    captureTimestamp: Long.ZERO,
    geoHint: "",
  };
}

export const UploadMetadata: MessageFns<UploadMetadata, "virtengine.veid.v1.UploadMetadata"> = {
  $type: "virtengine.veid.v1.UploadMetadata" as const,

  encode(message: UploadMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.salt.length !== 0) {
      writer.uint32(10).bytes(message.salt);
    }
    if (message.saltHash.length !== 0) {
      writer.uint32(18).bytes(message.saltHash);
    }
    if (message.deviceFingerprint !== "") {
      writer.uint32(26).string(message.deviceFingerprint);
    }
    if (message.clientId !== "") {
      writer.uint32(34).string(message.clientId);
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(42).bytes(message.clientSignature);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(50).bytes(message.userSignature);
    }
    if (message.payloadHash.length !== 0) {
      writer.uint32(58).bytes(message.payloadHash);
    }
    if (message.uploadNonce.length !== 0) {
      writer.uint32(66).bytes(message.uploadNonce);
    }
    if (!message.captureTimestamp.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.captureTimestamp.toString());
    }
    if (message.geoHint !== "") {
      writer.uint32(82).string(message.geoHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UploadMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUploadMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.salt = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.saltHash = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.deviceFingerprint = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.payloadHash = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.uploadNonce = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.captureTimestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.geoHint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UploadMetadata {
    return {
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0),
      saltHash: isSet(object.salt_hash) ? bytesFromBase64(object.salt_hash) : new Uint8Array(0),
      deviceFingerprint: isSet(object.device_fingerprint) ? globalThis.String(object.device_fingerprint) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      clientSignature: isSet(object.client_signature) ? bytesFromBase64(object.client_signature) : new Uint8Array(0),
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
      payloadHash: isSet(object.payload_hash) ? bytesFromBase64(object.payload_hash) : new Uint8Array(0),
      uploadNonce: isSet(object.upload_nonce) ? bytesFromBase64(object.upload_nonce) : new Uint8Array(0),
      captureTimestamp: isSet(object.capture_timestamp) ? Long.fromValue(object.capture_timestamp) : Long.ZERO,
      geoHint: isSet(object.geo_hint) ? globalThis.String(object.geo_hint) : "",
    };
  },

  toJSON(message: UploadMetadata): unknown {
    const obj: any = {};
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    if (message.saltHash.length !== 0) {
      obj.salt_hash = base64FromBytes(message.saltHash);
    }
    if (message.deviceFingerprint !== "") {
      obj.device_fingerprint = message.deviceFingerprint;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.clientSignature.length !== 0) {
      obj.client_signature = base64FromBytes(message.clientSignature);
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    if (message.payloadHash.length !== 0) {
      obj.payload_hash = base64FromBytes(message.payloadHash);
    }
    if (message.uploadNonce.length !== 0) {
      obj.upload_nonce = base64FromBytes(message.uploadNonce);
    }
    if (!message.captureTimestamp.equals(Long.ZERO)) {
      obj.capture_timestamp = (message.captureTimestamp || Long.ZERO).toString();
    }
    if (message.geoHint !== "") {
      obj.geo_hint = message.geoHint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<UploadMetadata>): UploadMetadata {
    const message = createBaseUploadMetadata();
    message.salt = object.salt ?? new Uint8Array(0);
    message.saltHash = object.saltHash ?? new Uint8Array(0);
    message.deviceFingerprint = object.deviceFingerprint ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.payloadHash = object.payloadHash ?? new Uint8Array(0);
    message.uploadNonce = object.uploadNonce ?? new Uint8Array(0);
    message.captureTimestamp = (object.captureTimestamp !== undefined && object.captureTimestamp !== null)
      ? Long.fromValue(object.captureTimestamp)
      : Long.ZERO;
    message.geoHint = object.geoHint ?? "";
    return message;
  },
};

function createBaseScopeRef(): ScopeRef {
  return { scopeId: "", scopeType: 0, status: 0, uploadedAt: Long.ZERO, verifiedAt: Long.ZERO, expiresAt: Long.ZERO };
}

export const ScopeRef: MessageFns<ScopeRef, "virtengine.veid.v1.ScopeRef"> = {
  $type: "virtengine.veid.v1.ScopeRef" as const,

  encode(message: ScopeRef, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.uploadedAt.toString());
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.verifiedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeRef {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeRef();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.uploadedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.verifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeRef {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      status: isSet(object.status) ? verificationStatusFromJSON(object.status) : 0,
      uploadedAt: isSet(object.uploaded_at) ? Long.fromValue(object.uploaded_at) : Long.ZERO,
      verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
    };
  },

  toJSON(message: ScopeRef): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.status !== 0) {
      obj.status = verificationStatusToJSON(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      obj.uploaded_at = (message.uploadedAt || Long.ZERO).toString();
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ScopeRef>): ScopeRef {
    const message = createBaseScopeRef();
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.status = object.status ?? 0;
    message.uploadedAt = (object.uploadedAt !== undefined && object.uploadedAt !== null)
      ? Long.fromValue(object.uploadedAt)
      : Long.ZERO;
    message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
      ? Long.fromValue(object.verifiedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseIdentityScope(): IdentityScope {
  return {
    scopeId: "",
    scopeType: 0,
    version: 0,
    encryptedPayload: undefined,
    uploadMetadata: undefined,
    status: 0,
    uploadedAt: Long.ZERO,
    verifiedAt: Long.ZERO,
    expiresAt: Long.ZERO,
    ownerAddress: "",
  };
}

export const IdentityScope: MessageFns<IdentityScope, "virtengine.veid.v1.IdentityScope"> = {
  $type: "virtengine.veid.v1.IdentityScope" as const,

  encode(message: IdentityScope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint32(message.version);
    }
    if (message.encryptedPayload !== undefined) {
      EncryptedPayloadEnvelope.encode(message.encryptedPayload, writer.uint32(34).fork()).join();
    }
    if (message.uploadMetadata !== undefined) {
      UploadMetadata.encode(message.uploadMetadata, writer.uint32(42).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.uploadedAt.toString());
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.verifiedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.expiresAt.toString());
    }
    if (message.ownerAddress !== "") {
      writer.uint32(82).string(message.ownerAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityScope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.version = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encryptedPayload = EncryptedPayloadEnvelope.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.uploadMetadata = UploadMetadata.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.uploadedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.verifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.ownerAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityScope {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      encryptedPayload: isSet(object.encrypted_payload)
        ? EncryptedPayloadEnvelope.fromJSON(object.encrypted_payload)
        : undefined,
      uploadMetadata: isSet(object.upload_metadata) ? UploadMetadata.fromJSON(object.upload_metadata) : undefined,
      status: isSet(object.status) ? verificationStatusFromJSON(object.status) : 0,
      uploadedAt: isSet(object.uploaded_at) ? Long.fromValue(object.uploaded_at) : Long.ZERO,
      verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      ownerAddress: isSet(object.owner_address) ? globalThis.String(object.owner_address) : "",
    };
  },

  toJSON(message: IdentityScope): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.encryptedPayload !== undefined) {
      obj.encrypted_payload = EncryptedPayloadEnvelope.toJSON(message.encryptedPayload);
    }
    if (message.uploadMetadata !== undefined) {
      obj.upload_metadata = UploadMetadata.toJSON(message.uploadMetadata);
    }
    if (message.status !== 0) {
      obj.status = verificationStatusToJSON(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      obj.uploaded_at = (message.uploadedAt || Long.ZERO).toString();
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.ownerAddress !== "") {
      obj.owner_address = message.ownerAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityScope>): IdentityScope {
    const message = createBaseIdentityScope();
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.version = object.version ?? 0;
    message.encryptedPayload = (object.encryptedPayload !== undefined && object.encryptedPayload !== null)
      ? EncryptedPayloadEnvelope.fromPartial(object.encryptedPayload)
      : undefined;
    message.uploadMetadata = (object.uploadMetadata !== undefined && object.uploadMetadata !== null)
      ? UploadMetadata.fromPartial(object.uploadMetadata)
      : undefined;
    message.status = object.status ?? 0;
    message.uploadedAt = (object.uploadedAt !== undefined && object.uploadedAt !== null)
      ? Long.fromValue(object.uploadedAt)
      : Long.ZERO;
    message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
      ? Long.fromValue(object.verifiedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.ownerAddress = object.ownerAddress ?? "";
    return message;
  },
};

function createBaseIdentityRecord(): IdentityRecord {
  return {
    accountAddress: "",
    scopeRefs: [],
    currentScore: 0,
    scoreVersion: "",
    lastVerifiedAt: Long.ZERO,
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
    tier: 0,
    flags: [],
    locked: false,
    lockedReason: "",
  };
}

export const IdentityRecord: MessageFns<IdentityRecord, "virtengine.veid.v1.IdentityRecord"> = {
  $type: "virtengine.veid.v1.IdentityRecord" as const,

  encode(message: IdentityRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    for (const v of message.scopeRefs) {
      ScopeRef.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.currentScore !== 0) {
      writer.uint32(24).uint32(message.currentScore);
    }
    if (message.scoreVersion !== "") {
      writer.uint32(34).string(message.scoreVersion);
    }
    if (!message.lastVerifiedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.lastVerifiedAt.toString());
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.updatedAt.toString());
    }
    if (message.tier !== 0) {
      writer.uint32(64).int32(message.tier);
    }
    for (const v of message.flags) {
      writer.uint32(74).string(v!);
    }
    if (message.locked !== false) {
      writer.uint32(80).bool(message.locked);
    }
    if (message.lockedReason !== "") {
      writer.uint32(90).string(message.lockedReason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeRefs.push(ScopeRef.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.currentScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scoreVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastVerifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.flags.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.locked = reader.bool();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.lockedReason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityRecord {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeRefs: globalThis.Array.isArray(object?.scope_refs)
        ? object.scope_refs.map((e: any) => ScopeRef.fromJSON(e))
        : [],
      currentScore: isSet(object.current_score) ? globalThis.Number(object.current_score) : 0,
      scoreVersion: isSet(object.score_version) ? globalThis.String(object.score_version) : "",
      lastVerifiedAt: isSet(object.last_verified_at) ? Long.fromValue(object.last_verified_at) : Long.ZERO,
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
      tier: isSet(object.tier) ? identityTierFromJSON(object.tier) : 0,
      flags: globalThis.Array.isArray(object?.flags) ? object.flags.map((e: any) => globalThis.String(e)) : [],
      locked: isSet(object.locked) ? globalThis.Boolean(object.locked) : false,
      lockedReason: isSet(object.locked_reason) ? globalThis.String(object.locked_reason) : "",
    };
  },

  toJSON(message: IdentityRecord): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeRefs?.length) {
      obj.scope_refs = message.scopeRefs.map((e) => ScopeRef.toJSON(e));
    }
    if (message.currentScore !== 0) {
      obj.current_score = Math.round(message.currentScore);
    }
    if (message.scoreVersion !== "") {
      obj.score_version = message.scoreVersion;
    }
    if (!message.lastVerifiedAt.equals(Long.ZERO)) {
      obj.last_verified_at = (message.lastVerifiedAt || Long.ZERO).toString();
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    if (message.tier !== 0) {
      obj.tier = identityTierToJSON(message.tier);
    }
    if (message.flags?.length) {
      obj.flags = message.flags;
    }
    if (message.locked !== false) {
      obj.locked = message.locked;
    }
    if (message.lockedReason !== "") {
      obj.locked_reason = message.lockedReason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityRecord>): IdentityRecord {
    const message = createBaseIdentityRecord();
    message.accountAddress = object.accountAddress ?? "";
    message.scopeRefs = object.scopeRefs?.map((e) => ScopeRef.fromPartial(e)) || [];
    message.currentScore = object.currentScore ?? 0;
    message.scoreVersion = object.scoreVersion ?? "";
    message.lastVerifiedAt = (object.lastVerifiedAt !== undefined && object.lastVerifiedAt !== null)
      ? Long.fromValue(object.lastVerifiedAt)
      : Long.ZERO;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.tier = object.tier ?? 0;
    message.flags = object.flags?.map((e) => e) || [];
    message.locked = object.locked ?? false;
    message.lockedReason = object.lockedReason ?? "";
    return message;
  },
};

function createBaseIdentityScore(): IdentityScore {
  return {
    accountAddress: "",
    score: 0,
    status: 0,
    tier: 0,
    modelVersion: "",
    lastUpdatedAt: Long.ZERO,
    blockHeight: Long.ZERO,
  };
}

export const IdentityScore: MessageFns<IdentityScore, "virtengine.veid.v1.IdentityScore"> = {
  $type: "virtengine.veid.v1.IdentityScore" as const,

  encode(message: IdentityScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.score !== 0) {
      writer.uint32(16).uint32(message.score);
    }
    if (message.status !== 0) {
      writer.uint32(24).int32(message.status);
    }
    if (message.tier !== 0) {
      writer.uint32(32).int32(message.tier);
    }
    if (message.modelVersion !== "") {
      writer.uint32(42).string(message.modelVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastUpdatedAt.toString());
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.blockHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastUpdatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityScore {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      status: isSet(object.status) ? accountStatusFromJSON(object.status) : 0,
      tier: isSet(object.tier) ? identityTierFromJSON(object.tier) : 0,
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
      lastUpdatedAt: isSet(object.last_updated_at) ? Long.fromValue(object.last_updated_at) : Long.ZERO,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
    };
  },

  toJSON(message: IdentityScore): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.status !== 0) {
      obj.status = accountStatusToJSON(message.status);
    }
    if (message.tier !== 0) {
      obj.tier = identityTierToJSON(message.tier);
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      obj.last_updated_at = (message.lastUpdatedAt || Long.ZERO).toString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityScore>): IdentityScore {
    const message = createBaseIdentityScore();
    message.accountAddress = object.accountAddress ?? "";
    message.score = object.score ?? 0;
    message.status = object.status ?? 0;
    message.tier = object.tier ?? 0;
    message.modelVersion = object.modelVersion ?? "";
    message.lastUpdatedAt = (object.lastUpdatedAt !== undefined && object.lastUpdatedAt !== null)
      ? Long.fromValue(object.lastUpdatedAt)
      : Long.ZERO;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseConsentSettings(): ConsentSettings {
  return {
    shareWithProviders: false,
    shareForVerification: false,
    allowReVerification: false,
    allowDerivedFeatureSharing: false,
    consentVersion: 0,
    lastUpdatedAt: Long.ZERO,
  };
}

export const ConsentSettings: MessageFns<ConsentSettings, "virtengine.veid.v1.ConsentSettings"> = {
  $type: "virtengine.veid.v1.ConsentSettings" as const,

  encode(message: ConsentSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shareWithProviders !== false) {
      writer.uint32(8).bool(message.shareWithProviders);
    }
    if (message.shareForVerification !== false) {
      writer.uint32(16).bool(message.shareForVerification);
    }
    if (message.allowReVerification !== false) {
      writer.uint32(24).bool(message.allowReVerification);
    }
    if (message.allowDerivedFeatureSharing !== false) {
      writer.uint32(32).bool(message.allowDerivedFeatureSharing);
    }
    if (message.consentVersion !== 0) {
      writer.uint32(40).uint32(message.consentVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastUpdatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsentSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsentSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shareWithProviders = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.shareForVerification = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowReVerification = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowDerivedFeatureSharing = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.consentVersion = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastUpdatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsentSettings {
    return {
      shareWithProviders: isSet(object.share_with_providers) ? globalThis.Boolean(object.share_with_providers) : false,
      shareForVerification: isSet(object.share_for_verification)
        ? globalThis.Boolean(object.share_for_verification)
        : false,
      allowReVerification: isSet(object.allow_re_verification)
        ? globalThis.Boolean(object.allow_re_verification)
        : false,
      allowDerivedFeatureSharing: isSet(object.allow_derived_feature_sharing)
        ? globalThis.Boolean(object.allow_derived_feature_sharing)
        : false,
      consentVersion: isSet(object.consent_version) ? globalThis.Number(object.consent_version) : 0,
      lastUpdatedAt: isSet(object.last_updated_at) ? Long.fromValue(object.last_updated_at) : Long.ZERO,
    };
  },

  toJSON(message: ConsentSettings): unknown {
    const obj: any = {};
    if (message.shareWithProviders !== false) {
      obj.share_with_providers = message.shareWithProviders;
    }
    if (message.shareForVerification !== false) {
      obj.share_for_verification = message.shareForVerification;
    }
    if (message.allowReVerification !== false) {
      obj.allow_re_verification = message.allowReVerification;
    }
    if (message.allowDerivedFeatureSharing !== false) {
      obj.allow_derived_feature_sharing = message.allowDerivedFeatureSharing;
    }
    if (message.consentVersion !== 0) {
      obj.consent_version = Math.round(message.consentVersion);
    }
    if (!message.lastUpdatedAt.equals(Long.ZERO)) {
      obj.last_updated_at = (message.lastUpdatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ConsentSettings>): ConsentSettings {
    const message = createBaseConsentSettings();
    message.shareWithProviders = object.shareWithProviders ?? false;
    message.shareForVerification = object.shareForVerification ?? false;
    message.allowReVerification = object.allowReVerification ?? false;
    message.allowDerivedFeatureSharing = object.allowDerivedFeatureSharing ?? false;
    message.consentVersion = object.consentVersion ?? 0;
    message.lastUpdatedAt = (object.lastUpdatedAt !== undefined && object.lastUpdatedAt !== null)
      ? Long.fromValue(object.lastUpdatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseGlobalConsentUpdate(): GlobalConsentUpdate {
  return {
    shareWithProviders: false,
    shareForVerification: false,
    allowReVerification: false,
    allowDerivedFeatureSharing: false,
  };
}

export const GlobalConsentUpdate: MessageFns<GlobalConsentUpdate, "virtengine.veid.v1.GlobalConsentUpdate"> = {
  $type: "virtengine.veid.v1.GlobalConsentUpdate" as const,

  encode(message: GlobalConsentUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.shareWithProviders !== false) {
      writer.uint32(8).bool(message.shareWithProviders);
    }
    if (message.shareForVerification !== false) {
      writer.uint32(16).bool(message.shareForVerification);
    }
    if (message.allowReVerification !== false) {
      writer.uint32(24).bool(message.allowReVerification);
    }
    if (message.allowDerivedFeatureSharing !== false) {
      writer.uint32(32).bool(message.allowDerivedFeatureSharing);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GlobalConsentUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGlobalConsentUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.shareWithProviders = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.shareForVerification = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowReVerification = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.allowDerivedFeatureSharing = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GlobalConsentUpdate {
    return {
      shareWithProviders: isSet(object.share_with_providers) ? globalThis.Boolean(object.share_with_providers) : false,
      shareForVerification: isSet(object.share_for_verification)
        ? globalThis.Boolean(object.share_for_verification)
        : false,
      allowReVerification: isSet(object.allow_re_verification)
        ? globalThis.Boolean(object.allow_re_verification)
        : false,
      allowDerivedFeatureSharing: isSet(object.allow_derived_feature_sharing)
        ? globalThis.Boolean(object.allow_derived_feature_sharing)
        : false,
    };
  },

  toJSON(message: GlobalConsentUpdate): unknown {
    const obj: any = {};
    if (message.shareWithProviders !== false) {
      obj.share_with_providers = message.shareWithProviders;
    }
    if (message.shareForVerification !== false) {
      obj.share_for_verification = message.shareForVerification;
    }
    if (message.allowReVerification !== false) {
      obj.allow_re_verification = message.allowReVerification;
    }
    if (message.allowDerivedFeatureSharing !== false) {
      obj.allow_derived_feature_sharing = message.allowDerivedFeatureSharing;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<GlobalConsentUpdate>): GlobalConsentUpdate {
    const message = createBaseGlobalConsentUpdate();
    message.shareWithProviders = object.shareWithProviders ?? false;
    message.shareForVerification = object.shareForVerification ?? false;
    message.allowReVerification = object.allowReVerification ?? false;
    message.allowDerivedFeatureSharing = object.allowDerivedFeatureSharing ?? false;
    return message;
  },
};

function createBaseBorderlineParams(): BorderlineParams {
  return { lowerThreshold: 0, upperThreshold: 0, mfaTimeoutBlocks: Long.ZERO, requiredFactors: 0 };
}

export const BorderlineParams: MessageFns<BorderlineParams, "virtengine.veid.v1.BorderlineParams"> = {
  $type: "virtengine.veid.v1.BorderlineParams" as const,

  encode(message: BorderlineParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lowerThreshold !== 0) {
      writer.uint32(8).uint32(message.lowerThreshold);
    }
    if (message.upperThreshold !== 0) {
      writer.uint32(16).uint32(message.upperThreshold);
    }
    if (!message.mfaTimeoutBlocks.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.mfaTimeoutBlocks.toString());
    }
    if (message.requiredFactors !== 0) {
      writer.uint32(32).uint32(message.requiredFactors);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BorderlineParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBorderlineParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lowerThreshold = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.upperThreshold = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.mfaTimeoutBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requiredFactors = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BorderlineParams {
    return {
      lowerThreshold: isSet(object.lower_threshold) ? globalThis.Number(object.lower_threshold) : 0,
      upperThreshold: isSet(object.upper_threshold) ? globalThis.Number(object.upper_threshold) : 0,
      mfaTimeoutBlocks: isSet(object.mfa_timeout_blocks) ? Long.fromValue(object.mfa_timeout_blocks) : Long.ZERO,
      requiredFactors: isSet(object.required_factors) ? globalThis.Number(object.required_factors) : 0,
    };
  },

  toJSON(message: BorderlineParams): unknown {
    const obj: any = {};
    if (message.lowerThreshold !== 0) {
      obj.lower_threshold = Math.round(message.lowerThreshold);
    }
    if (message.upperThreshold !== 0) {
      obj.upper_threshold = Math.round(message.upperThreshold);
    }
    if (!message.mfaTimeoutBlocks.equals(Long.ZERO)) {
      obj.mfa_timeout_blocks = (message.mfaTimeoutBlocks || Long.ZERO).toString();
    }
    if (message.requiredFactors !== 0) {
      obj.required_factors = Math.round(message.requiredFactors);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<BorderlineParams>): BorderlineParams {
    const message = createBaseBorderlineParams();
    message.lowerThreshold = object.lowerThreshold ?? 0;
    message.upperThreshold = object.upperThreshold ?? 0;
    message.mfaTimeoutBlocks = (object.mfaTimeoutBlocks !== undefined && object.mfaTimeoutBlocks !== null)
      ? Long.fromValue(object.mfaTimeoutBlocks)
      : Long.ZERO;
    message.requiredFactors = object.requiredFactors ?? 0;
    return message;
  },
};

function createBaseApprovedClient(): ApprovedClient {
  return {
    clientId: "",
    name: "",
    publicKey: new Uint8Array(0),
    active: false,
    createdAt: Long.ZERO,
    deactivatedAt: Long.ZERO,
  };
}

export const ApprovedClient: MessageFns<ApprovedClient, "virtengine.veid.v1.ApprovedClient"> = {
  $type: "virtengine.veid.v1.ApprovedClient" as const,

  encode(message: ApprovedClient, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.clientId !== "") {
      writer.uint32(10).string(message.clientId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(26).bytes(message.publicKey);
    }
    if (message.active !== false) {
      writer.uint32(32).bool(message.active);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.createdAt.toString());
    }
    if (!message.deactivatedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.deactivatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ApprovedClient {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseApprovedClient();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.deactivatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ApprovedClient {
    return {
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      publicKey: isSet(object.public_key) ? bytesFromBase64(object.public_key) : new Uint8Array(0),
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      deactivatedAt: isSet(object.deactivated_at) ? Long.fromValue(object.deactivated_at) : Long.ZERO,
    };
  },

  toJSON(message: ApprovedClient): unknown {
    const obj: any = {};
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.publicKey.length !== 0) {
      obj.public_key = base64FromBytes(message.publicKey);
    }
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.deactivatedAt.equals(Long.ZERO)) {
      obj.deactivated_at = (message.deactivatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ApprovedClient>): ApprovedClient {
    const message = createBaseApprovedClient();
    message.clientId = object.clientId ?? "";
    message.name = object.name ?? "";
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.active = object.active ?? false;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.deactivatedAt = (object.deactivatedAt !== undefined && object.deactivatedAt !== null)
      ? Long.fromValue(object.deactivatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseParams(): Params {
  return {
    maxScopesPerAccount: 0,
    maxScopesPerType: 0,
    saltMinBytes: 0,
    saltMaxBytes: 0,
    requireClientSignature: false,
    requireUserSignature: false,
    verificationExpiryDays: 0,
  };
}

export const Params: MessageFns<Params, "virtengine.veid.v1.Params"> = {
  $type: "virtengine.veid.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.maxScopesPerAccount !== 0) {
      writer.uint32(8).uint32(message.maxScopesPerAccount);
    }
    if (message.maxScopesPerType !== 0) {
      writer.uint32(16).uint32(message.maxScopesPerType);
    }
    if (message.saltMinBytes !== 0) {
      writer.uint32(24).uint32(message.saltMinBytes);
    }
    if (message.saltMaxBytes !== 0) {
      writer.uint32(32).uint32(message.saltMaxBytes);
    }
    if (message.requireClientSignature !== false) {
      writer.uint32(40).bool(message.requireClientSignature);
    }
    if (message.requireUserSignature !== false) {
      writer.uint32(48).bool(message.requireUserSignature);
    }
    if (message.verificationExpiryDays !== 0) {
      writer.uint32(56).uint32(message.verificationExpiryDays);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.maxScopesPerAccount = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxScopesPerType = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.saltMinBytes = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.saltMaxBytes = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.requireClientSignature = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.requireUserSignature = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.verificationExpiryDays = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      maxScopesPerAccount: isSet(object.max_scopes_per_account) ? globalThis.Number(object.max_scopes_per_account) : 0,
      maxScopesPerType: isSet(object.max_scopes_per_type) ? globalThis.Number(object.max_scopes_per_type) : 0,
      saltMinBytes: isSet(object.salt_min_bytes) ? globalThis.Number(object.salt_min_bytes) : 0,
      saltMaxBytes: isSet(object.salt_max_bytes) ? globalThis.Number(object.salt_max_bytes) : 0,
      requireClientSignature: isSet(object.require_client_signature)
        ? globalThis.Boolean(object.require_client_signature)
        : false,
      requireUserSignature: isSet(object.require_user_signature)
        ? globalThis.Boolean(object.require_user_signature)
        : false,
      verificationExpiryDays: isSet(object.verification_expiry_days)
        ? globalThis.Number(object.verification_expiry_days)
        : 0,
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (message.maxScopesPerAccount !== 0) {
      obj.max_scopes_per_account = Math.round(message.maxScopesPerAccount);
    }
    if (message.maxScopesPerType !== 0) {
      obj.max_scopes_per_type = Math.round(message.maxScopesPerType);
    }
    if (message.saltMinBytes !== 0) {
      obj.salt_min_bytes = Math.round(message.saltMinBytes);
    }
    if (message.saltMaxBytes !== 0) {
      obj.salt_max_bytes = Math.round(message.saltMaxBytes);
    }
    if (message.requireClientSignature !== false) {
      obj.require_client_signature = message.requireClientSignature;
    }
    if (message.requireUserSignature !== false) {
      obj.require_user_signature = message.requireUserSignature;
    }
    if (message.verificationExpiryDays !== 0) {
      obj.verification_expiry_days = Math.round(message.verificationExpiryDays);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.maxScopesPerAccount = object.maxScopesPerAccount ?? 0;
    message.maxScopesPerType = object.maxScopesPerType ?? 0;
    message.saltMinBytes = object.saltMinBytes ?? 0;
    message.saltMaxBytes = object.saltMaxBytes ?? 0;
    message.requireClientSignature = object.requireClientSignature ?? false;
    message.requireUserSignature = object.requireUserSignature ?? false;
    message.verificationExpiryDays = object.verificationExpiryDays ?? 0;
    return message;
  },
};

function createBaseDerivedFeatures(): DerivedFeatures {
  return {
    faceEmbeddingHash: new Uint8Array(0),
    docFieldHashes: {},
    biometricHash: new Uint8Array(0),
    livenessProofHash: new Uint8Array(0),
    lastComputedAt: Long.ZERO,
    modelVersion: "",
    computedBy: "",
    blockHeight: Long.ZERO,
    featureVersion: 0,
  };
}

export const DerivedFeatures: MessageFns<DerivedFeatures, "virtengine.veid.v1.DerivedFeatures"> = {
  $type: "virtengine.veid.v1.DerivedFeatures" as const,

  encode(message: DerivedFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.faceEmbeddingHash.length !== 0) {
      writer.uint32(10).bytes(message.faceEmbeddingHash);
    }
    Object.entries(message.docFieldHashes).forEach(([key, value]) => {
      DerivedFeatures_DocFieldHashesEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (message.biometricHash.length !== 0) {
      writer.uint32(26).bytes(message.biometricHash);
    }
    if (message.livenessProofHash.length !== 0) {
      writer.uint32(34).bytes(message.livenessProofHash);
    }
    if (!message.lastComputedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.lastComputedAt.toString());
    }
    if (message.modelVersion !== "") {
      writer.uint32(50).string(message.modelVersion);
    }
    if (message.computedBy !== "") {
      writer.uint32(58).string(message.computedBy);
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.blockHeight.toString());
    }
    if (message.featureVersion !== 0) {
      writer.uint32(72).uint32(message.featureVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DerivedFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivedFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.faceEmbeddingHash = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = DerivedFeatures_DocFieldHashesEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.docFieldHashes[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.biometricHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.livenessProofHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastComputedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.computedBy = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.featureVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DerivedFeatures {
    return {
      faceEmbeddingHash: isSet(object.face_embedding_hash)
        ? bytesFromBase64(object.face_embedding_hash)
        : new Uint8Array(0),
      docFieldHashes: isObject(object.doc_field_hashes)
        ? Object.entries(object.doc_field_hashes).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      biometricHash: isSet(object.biometric_hash) ? bytesFromBase64(object.biometric_hash) : new Uint8Array(0),
      livenessProofHash: isSet(object.liveness_proof_hash)
        ? bytesFromBase64(object.liveness_proof_hash)
        : new Uint8Array(0),
      lastComputedAt: isSet(object.last_computed_at) ? Long.fromValue(object.last_computed_at) : Long.ZERO,
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
      computedBy: isSet(object.computed_by) ? globalThis.String(object.computed_by) : "",
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      featureVersion: isSet(object.feature_version) ? globalThis.Number(object.feature_version) : 0,
    };
  },

  toJSON(message: DerivedFeatures): unknown {
    const obj: any = {};
    if (message.faceEmbeddingHash.length !== 0) {
      obj.face_embedding_hash = base64FromBytes(message.faceEmbeddingHash);
    }
    if (message.docFieldHashes) {
      const entries = Object.entries(message.docFieldHashes);
      if (entries.length > 0) {
        obj.doc_field_hashes = {};
        entries.forEach(([k, v]) => {
          obj.doc_field_hashes[k] = base64FromBytes(v);
        });
      }
    }
    if (message.biometricHash.length !== 0) {
      obj.biometric_hash = base64FromBytes(message.biometricHash);
    }
    if (message.livenessProofHash.length !== 0) {
      obj.liveness_proof_hash = base64FromBytes(message.livenessProofHash);
    }
    if (!message.lastComputedAt.equals(Long.ZERO)) {
      obj.last_computed_at = (message.lastComputedAt || Long.ZERO).toString();
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    if (message.computedBy !== "") {
      obj.computed_by = message.computedBy;
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.featureVersion !== 0) {
      obj.feature_version = Math.round(message.featureVersion);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DerivedFeatures>): DerivedFeatures {
    const message = createBaseDerivedFeatures();
    message.faceEmbeddingHash = object.faceEmbeddingHash ?? new Uint8Array(0);
    message.docFieldHashes = Object.entries(object.docFieldHashes ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.biometricHash = object.biometricHash ?? new Uint8Array(0);
    message.livenessProofHash = object.livenessProofHash ?? new Uint8Array(0);
    message.lastComputedAt = (object.lastComputedAt !== undefined && object.lastComputedAt !== null)
      ? Long.fromValue(object.lastComputedAt)
      : Long.ZERO;
    message.modelVersion = object.modelVersion ?? "";
    message.computedBy = object.computedBy ?? "";
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.featureVersion = object.featureVersion ?? 0;
    return message;
  },
};

function createBaseDerivedFeatures_DocFieldHashesEntry(): DerivedFeatures_DocFieldHashesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const DerivedFeatures_DocFieldHashesEntry: MessageFns<
  DerivedFeatures_DocFieldHashesEntry,
  "virtengine.veid.v1.DerivedFeatures.DocFieldHashesEntry"
> = {
  $type: "virtengine.veid.v1.DerivedFeatures.DocFieldHashesEntry" as const,

  encode(message: DerivedFeatures_DocFieldHashesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DerivedFeatures_DocFieldHashesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDerivedFeatures_DocFieldHashesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DerivedFeatures_DocFieldHashesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: DerivedFeatures_DocFieldHashesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DerivedFeatures_DocFieldHashesEntry>): DerivedFeatures_DocFieldHashesEntry {
    const message = createBaseDerivedFeatures_DocFieldHashesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseScopeReference(): ScopeReference {
  return {
    scopeId: "",
    scopeType: 0,
    envelopeHash: new Uint8Array(0),
    addedAt: Long.ZERO,
    status: 0,
    consentGranted: false,
    revocationReason: "",
    revokedAt: Long.ZERO,
    expiresAt: Long.ZERO,
  };
}

export const ScopeReference: MessageFns<ScopeReference, "virtengine.veid.v1.ScopeReference"> = {
  $type: "virtengine.veid.v1.ScopeReference" as const,

  encode(message: ScopeReference, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(16).int32(message.scopeType);
    }
    if (message.envelopeHash.length !== 0) {
      writer.uint32(26).bytes(message.envelopeHash);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.addedAt.toString());
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    if (message.consentGranted !== false) {
      writer.uint32(48).bool(message.consentGranted);
    }
    if (message.revocationReason !== "") {
      writer.uint32(58).string(message.revocationReason);
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.revokedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeReference {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeReference();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.envelopeHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.addedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.consentGranted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.revocationReason = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeReference {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      envelopeHash: isSet(object.envelope_hash) ? bytesFromBase64(object.envelope_hash) : new Uint8Array(0),
      addedAt: isSet(object.added_at) ? Long.fromValue(object.added_at) : Long.ZERO,
      status: isSet(object.status) ? scopeRefStatusFromJSON(object.status) : 0,
      consentGranted: isSet(object.consent_granted) ? globalThis.Boolean(object.consent_granted) : false,
      revocationReason: isSet(object.revocation_reason) ? globalThis.String(object.revocation_reason) : "",
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
    };
  },

  toJSON(message: ScopeReference): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.envelopeHash.length !== 0) {
      obj.envelope_hash = base64FromBytes(message.envelopeHash);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      obj.added_at = (message.addedAt || Long.ZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = scopeRefStatusToJSON(message.status);
    }
    if (message.consentGranted !== false) {
      obj.consent_granted = message.consentGranted;
    }
    if (message.revocationReason !== "") {
      obj.revocation_reason = message.revocationReason;
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ScopeReference>): ScopeReference {
    const message = createBaseScopeReference();
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.envelopeHash = object.envelopeHash ?? new Uint8Array(0);
    message.addedAt = (object.addedAt !== undefined && object.addedAt !== null)
      ? Long.fromValue(object.addedAt)
      : Long.ZERO;
    message.status = object.status ?? 0;
    message.consentGranted = object.consentGranted ?? false;
    message.revocationReason = object.revocationReason ?? "";
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseScopeConsent(): ScopeConsent {
  return {
    scopeId: "",
    granted: false,
    grantedAt: Long.ZERO,
    revokedAt: Long.ZERO,
    expiresAt: Long.ZERO,
    purpose: "",
    grantedToProviders: [],
    restrictions: [],
  };
}

export const ScopeConsent: MessageFns<ScopeConsent, "virtengine.veid.v1.ScopeConsent"> = {
  $type: "virtengine.veid.v1.ScopeConsent" as const,

  encode(message: ScopeConsent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.granted !== false) {
      writer.uint32(16).bool(message.granted);
    }
    if (!message.grantedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.grantedAt.toString());
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.revokedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expiresAt.toString());
    }
    if (message.purpose !== "") {
      writer.uint32(50).string(message.purpose);
    }
    for (const v of message.grantedToProviders) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.restrictions) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScopeConsent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScopeConsent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.granted = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.grantedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.purpose = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.grantedToProviders.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.restrictions.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScopeConsent {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      granted: isSet(object.granted) ? globalThis.Boolean(object.granted) : false,
      grantedAt: isSet(object.granted_at) ? Long.fromValue(object.granted_at) : Long.ZERO,
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      purpose: isSet(object.purpose) ? globalThis.String(object.purpose) : "",
      grantedToProviders: globalThis.Array.isArray(object?.granted_to_providers)
        ? object.granted_to_providers.map((e: any) => globalThis.String(e))
        : [],
      restrictions: globalThis.Array.isArray(object?.restrictions)
        ? object.restrictions.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ScopeConsent): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.granted !== false) {
      obj.granted = message.granted;
    }
    if (!message.grantedAt.equals(Long.ZERO)) {
      obj.granted_at = (message.grantedAt || Long.ZERO).toString();
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.purpose !== "") {
      obj.purpose = message.purpose;
    }
    if (message.grantedToProviders?.length) {
      obj.granted_to_providers = message.grantedToProviders;
    }
    if (message.restrictions?.length) {
      obj.restrictions = message.restrictions;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ScopeConsent>): ScopeConsent {
    const message = createBaseScopeConsent();
    message.scopeId = object.scopeId ?? "";
    message.granted = object.granted ?? false;
    message.grantedAt = (object.grantedAt !== undefined && object.grantedAt !== null)
      ? Long.fromValue(object.grantedAt)
      : Long.ZERO;
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.purpose = object.purpose ?? "";
    message.grantedToProviders = object.grantedToProviders?.map((e) => e) || [];
    message.restrictions = object.restrictions?.map((e) => e) || [];
    return message;
  },
};

function createBaseVerificationHistoryEntry(): VerificationHistoryEntry {
  return {
    entryId: "",
    timestamp: Long.ZERO,
    blockHeight: Long.ZERO,
    previousScore: 0,
    newScore: 0,
    previousStatus: 0,
    newStatus: 0,
    scopesEvaluated: [],
    modelVersion: "",
    validatorAddress: "",
    reason: "",
  };
}

export const VerificationHistoryEntry: MessageFns<
  VerificationHistoryEntry,
  "virtengine.veid.v1.VerificationHistoryEntry"
> = {
  $type: "virtengine.veid.v1.VerificationHistoryEntry" as const,

  encode(message: VerificationHistoryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entryId !== "") {
      writer.uint32(10).string(message.entryId);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.timestamp.toString());
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.blockHeight.toString());
    }
    if (message.previousScore !== 0) {
      writer.uint32(32).uint32(message.previousScore);
    }
    if (message.newScore !== 0) {
      writer.uint32(40).uint32(message.newScore);
    }
    if (message.previousStatus !== 0) {
      writer.uint32(48).int32(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(56).int32(message.newStatus);
    }
    for (const v of message.scopesEvaluated) {
      writer.uint32(66).string(v!);
    }
    if (message.modelVersion !== "") {
      writer.uint32(74).string(message.modelVersion);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(82).string(message.validatorAddress);
    }
    if (message.reason !== "") {
      writer.uint32(90).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): VerificationHistoryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVerificationHistoryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entryId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.previousScore = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.newScore = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.previousStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.scopesEvaluated.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): VerificationHistoryEntry {
    return {
      entryId: isSet(object.entry_id) ? globalThis.String(object.entry_id) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      previousScore: isSet(object.previous_score) ? globalThis.Number(object.previous_score) : 0,
      newScore: isSet(object.new_score) ? globalThis.Number(object.new_score) : 0,
      previousStatus: isSet(object.previous_status) ? accountStatusFromJSON(object.previous_status) : 0,
      newStatus: isSet(object.new_status) ? accountStatusFromJSON(object.new_status) : 0,
      scopesEvaluated: globalThis.Array.isArray(object?.scopes_evaluated)
        ? object.scopes_evaluated.map((e: any) => globalThis.String(e))
        : [],
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: VerificationHistoryEntry): unknown {
    const obj: any = {};
    if (message.entryId !== "") {
      obj.entry_id = message.entryId;
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.previousScore !== 0) {
      obj.previous_score = Math.round(message.previousScore);
    }
    if (message.newScore !== 0) {
      obj.new_score = Math.round(message.newScore);
    }
    if (message.previousStatus !== 0) {
      obj.previous_status = accountStatusToJSON(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      obj.new_status = accountStatusToJSON(message.newStatus);
    }
    if (message.scopesEvaluated?.length) {
      obj.scopes_evaluated = message.scopesEvaluated;
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<VerificationHistoryEntry>): VerificationHistoryEntry {
    const message = createBaseVerificationHistoryEntry();
    message.entryId = object.entryId ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.previousScore = object.previousScore ?? 0;
    message.newScore = object.newScore ?? 0;
    message.previousStatus = object.previousStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.scopesEvaluated = object.scopesEvaluated?.map((e) => e) || [];
    message.modelVersion = object.modelVersion ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseIdentityWallet(): IdentityWallet {
  return {
    walletId: "",
    accountAddress: "",
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
    status: 0,
    scopeRefs: [],
    derivedFeatures: undefined,
    currentScore: 0,
    scoreStatus: 0,
    verificationHistory: [],
    consentSettings: undefined,
    scopeConsents: {},
    bindingSignature: new Uint8Array(0),
    bindingPubKey: new Uint8Array(0),
    lastBindingAt: Long.ZERO,
    tier: 0,
    metadata: {},
  };
}

export const IdentityWallet: MessageFns<IdentityWallet, "virtengine.veid.v1.IdentityWallet"> = {
  $type: "virtengine.veid.v1.IdentityWallet" as const,

  encode(message: IdentityWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== "") {
      writer.uint32(10).string(message.walletId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.updatedAt.toString());
    }
    if (message.status !== 0) {
      writer.uint32(40).int32(message.status);
    }
    for (const v of message.scopeRefs) {
      ScopeReference.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.derivedFeatures !== undefined) {
      DerivedFeatures.encode(message.derivedFeatures, writer.uint32(58).fork()).join();
    }
    if (message.currentScore !== 0) {
      writer.uint32(64).uint32(message.currentScore);
    }
    if (message.scoreStatus !== 0) {
      writer.uint32(72).int32(message.scoreStatus);
    }
    for (const v of message.verificationHistory) {
      VerificationHistoryEntry.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.consentSettings !== undefined) {
      ConsentSettings.encode(message.consentSettings, writer.uint32(90).fork()).join();
    }
    Object.entries(message.scopeConsents).forEach(([key, value]) => {
      IdentityWallet_ScopeConsentsEntry.encode({ key: key as any, value }, writer.uint32(98).fork()).join();
    });
    if (message.bindingSignature.length !== 0) {
      writer.uint32(106).bytes(message.bindingSignature);
    }
    if (message.bindingPubKey.length !== 0) {
      writer.uint32(114).bytes(message.bindingPubKey);
    }
    if (!message.lastBindingAt.equals(Long.ZERO)) {
      writer.uint32(120).int64(message.lastBindingAt.toString());
    }
    if (message.tier !== 0) {
      writer.uint32(128).int32(message.tier);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      IdentityWallet_MetadataEntry.encode({ key: key as any, value }, writer.uint32(138).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.scopeRefs.push(ScopeReference.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.derivedFeatures = DerivedFeatures.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.currentScore = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.scoreStatus = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.verificationHistory.push(VerificationHistoryEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.consentSettings = ConsentSettings.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          const entry12 = IdentityWallet_ScopeConsentsEntry.decode(reader, reader.uint32());
          if (entry12.value !== undefined) {
            message.scopeConsents[entry12.key] = entry12.value;
          }
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.bindingSignature = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.bindingPubKey = reader.bytes();
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.lastBindingAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.tier = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          const entry17 = IdentityWallet_MetadataEntry.decode(reader, reader.uint32());
          if (entry17.value !== undefined) {
            message.metadata[entry17.key] = entry17.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityWallet {
    return {
      walletId: isSet(object.wallet_id) ? globalThis.String(object.wallet_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
      status: isSet(object.status) ? walletStatusFromJSON(object.status) : 0,
      scopeRefs: globalThis.Array.isArray(object?.scope_refs)
        ? object.scope_refs.map((e: any) => ScopeReference.fromJSON(e))
        : [],
      derivedFeatures: isSet(object.derived_features) ? DerivedFeatures.fromJSON(object.derived_features) : undefined,
      currentScore: isSet(object.current_score) ? globalThis.Number(object.current_score) : 0,
      scoreStatus: isSet(object.score_status) ? accountStatusFromJSON(object.score_status) : 0,
      verificationHistory: globalThis.Array.isArray(object?.verification_history)
        ? object.verification_history.map((e: any) => VerificationHistoryEntry.fromJSON(e))
        : [],
      consentSettings: isSet(object.consent_settings) ? ConsentSettings.fromJSON(object.consent_settings) : undefined,
      scopeConsents: isObject(object.scope_consents)
        ? Object.entries(object.scope_consents).reduce<{ [key: string]: ScopeConsent }>((acc, [key, value]) => {
          acc[key] = ScopeConsent.fromJSON(value);
          return acc;
        }, {})
        : {},
      bindingSignature: isSet(object.binding_signature) ? bytesFromBase64(object.binding_signature) : new Uint8Array(0),
      bindingPubKey: isSet(object.binding_pub_key) ? bytesFromBase64(object.binding_pub_key) : new Uint8Array(0),
      lastBindingAt: isSet(object.last_binding_at) ? Long.fromValue(object.last_binding_at) : Long.ZERO,
      tier: isSet(object.tier) ? identityTierFromJSON(object.tier) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: IdentityWallet): unknown {
    const obj: any = {};
    if (message.walletId !== "") {
      obj.wallet_id = message.walletId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = walletStatusToJSON(message.status);
    }
    if (message.scopeRefs?.length) {
      obj.scope_refs = message.scopeRefs.map((e) => ScopeReference.toJSON(e));
    }
    if (message.derivedFeatures !== undefined) {
      obj.derived_features = DerivedFeatures.toJSON(message.derivedFeatures);
    }
    if (message.currentScore !== 0) {
      obj.current_score = Math.round(message.currentScore);
    }
    if (message.scoreStatus !== 0) {
      obj.score_status = accountStatusToJSON(message.scoreStatus);
    }
    if (message.verificationHistory?.length) {
      obj.verification_history = message.verificationHistory.map((e) => VerificationHistoryEntry.toJSON(e));
    }
    if (message.consentSettings !== undefined) {
      obj.consent_settings = ConsentSettings.toJSON(message.consentSettings);
    }
    if (message.scopeConsents) {
      const entries = Object.entries(message.scopeConsents);
      if (entries.length > 0) {
        obj.scope_consents = {};
        entries.forEach(([k, v]) => {
          obj.scope_consents[k] = ScopeConsent.toJSON(v);
        });
      }
    }
    if (message.bindingSignature.length !== 0) {
      obj.binding_signature = base64FromBytes(message.bindingSignature);
    }
    if (message.bindingPubKey.length !== 0) {
      obj.binding_pub_key = base64FromBytes(message.bindingPubKey);
    }
    if (!message.lastBindingAt.equals(Long.ZERO)) {
      obj.last_binding_at = (message.lastBindingAt || Long.ZERO).toString();
    }
    if (message.tier !== 0) {
      obj.tier = identityTierToJSON(message.tier);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityWallet>): IdentityWallet {
    const message = createBaseIdentityWallet();
    message.walletId = object.walletId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.status = object.status ?? 0;
    message.scopeRefs = object.scopeRefs?.map((e) => ScopeReference.fromPartial(e)) || [];
    message.derivedFeatures = (object.derivedFeatures !== undefined && object.derivedFeatures !== null)
      ? DerivedFeatures.fromPartial(object.derivedFeatures)
      : undefined;
    message.currentScore = object.currentScore ?? 0;
    message.scoreStatus = object.scoreStatus ?? 0;
    message.verificationHistory = object.verificationHistory?.map((e) => VerificationHistoryEntry.fromPartial(e)) || [];
    message.consentSettings = (object.consentSettings !== undefined && object.consentSettings !== null)
      ? ConsentSettings.fromPartial(object.consentSettings)
      : undefined;
    message.scopeConsents = Object.entries(object.scopeConsents ?? {}).reduce<{ [key: string]: ScopeConsent }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScopeConsent.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    message.bindingSignature = object.bindingSignature ?? new Uint8Array(0);
    message.bindingPubKey = object.bindingPubKey ?? new Uint8Array(0);
    message.lastBindingAt = (object.lastBindingAt !== undefined && object.lastBindingAt !== null)
      ? Long.fromValue(object.lastBindingAt)
      : Long.ZERO;
    message.tier = object.tier ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseIdentityWallet_ScopeConsentsEntry(): IdentityWallet_ScopeConsentsEntry {
  return { key: "", value: undefined };
}

export const IdentityWallet_ScopeConsentsEntry: MessageFns<
  IdentityWallet_ScopeConsentsEntry,
  "virtengine.veid.v1.IdentityWallet.ScopeConsentsEntry"
> = {
  $type: "virtengine.veid.v1.IdentityWallet.ScopeConsentsEntry" as const,

  encode(message: IdentityWallet_ScopeConsentsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScopeConsent.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityWallet_ScopeConsentsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityWallet_ScopeConsentsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = ScopeConsent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityWallet_ScopeConsentsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScopeConsent.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: IdentityWallet_ScopeConsentsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScopeConsent.toJSON(message.value);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityWallet_ScopeConsentsEntry>): IdentityWallet_ScopeConsentsEntry {
    const message = createBaseIdentityWallet_ScopeConsentsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ScopeConsent.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseIdentityWallet_MetadataEntry(): IdentityWallet_MetadataEntry {
  return { key: "", value: "" };
}

export const IdentityWallet_MetadataEntry: MessageFns<
  IdentityWallet_MetadataEntry,
  "virtengine.veid.v1.IdentityWallet.MetadataEntry"
> = {
  $type: "virtengine.veid.v1.IdentityWallet.MetadataEntry" as const,

  encode(message: IdentityWallet_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IdentityWallet_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIdentityWallet_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IdentityWallet_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: IdentityWallet_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<IdentityWallet_MetadataEntry>): IdentityWallet_MetadataEntry {
    const message = createBaseIdentityWallet_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
