import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/appeal.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** AppealStatus represents the current state of an appeal */
export enum AppealStatus {
  /** APPEAL_STATUS_UNSPECIFIED - APPEAL_STATUS_UNSPECIFIED is the default unspecified status */
  APPEAL_STATUS_UNSPECIFIED = 0,
  /** APPEAL_STATUS_PENDING - APPEAL_STATUS_PENDING indicates the appeal has been submitted and awaits review */
  APPEAL_STATUS_PENDING = 1,
  /** APPEAL_STATUS_REVIEWING - APPEAL_STATUS_REVIEWING indicates an arbitrator has claimed the appeal for review */
  APPEAL_STATUS_REVIEWING = 2,
  /** APPEAL_STATUS_APPROVED - APPEAL_STATUS_APPROVED indicates the appeal was approved */
  APPEAL_STATUS_APPROVED = 3,
  /** APPEAL_STATUS_REJECTED - APPEAL_STATUS_REJECTED indicates the appeal was rejected */
  APPEAL_STATUS_REJECTED = 4,
  /** APPEAL_STATUS_WITHDRAWN - APPEAL_STATUS_WITHDRAWN indicates the submitter withdrew their appeal */
  APPEAL_STATUS_WITHDRAWN = 5,
  /** APPEAL_STATUS_EXPIRED - APPEAL_STATUS_EXPIRED indicates the appeal expired without resolution */
  APPEAL_STATUS_EXPIRED = 6,
  UNRECOGNIZED = -1,
}

export function appealStatusFromJSON(object: any): AppealStatus {
  switch (object) {
    case 0:
    case "APPEAL_STATUS_UNSPECIFIED":
      return AppealStatus.APPEAL_STATUS_UNSPECIFIED;
    case 1:
    case "APPEAL_STATUS_PENDING":
      return AppealStatus.APPEAL_STATUS_PENDING;
    case 2:
    case "APPEAL_STATUS_REVIEWING":
      return AppealStatus.APPEAL_STATUS_REVIEWING;
    case 3:
    case "APPEAL_STATUS_APPROVED":
      return AppealStatus.APPEAL_STATUS_APPROVED;
    case 4:
    case "APPEAL_STATUS_REJECTED":
      return AppealStatus.APPEAL_STATUS_REJECTED;
    case 5:
    case "APPEAL_STATUS_WITHDRAWN":
      return AppealStatus.APPEAL_STATUS_WITHDRAWN;
    case 6:
    case "APPEAL_STATUS_EXPIRED":
      return AppealStatus.APPEAL_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AppealStatus.UNRECOGNIZED;
  }
}

export function appealStatusToJSON(object: AppealStatus): string {
  switch (object) {
    case AppealStatus.APPEAL_STATUS_UNSPECIFIED:
      return "APPEAL_STATUS_UNSPECIFIED";
    case AppealStatus.APPEAL_STATUS_PENDING:
      return "APPEAL_STATUS_PENDING";
    case AppealStatus.APPEAL_STATUS_REVIEWING:
      return "APPEAL_STATUS_REVIEWING";
    case AppealStatus.APPEAL_STATUS_APPROVED:
      return "APPEAL_STATUS_APPROVED";
    case AppealStatus.APPEAL_STATUS_REJECTED:
      return "APPEAL_STATUS_REJECTED";
    case AppealStatus.APPEAL_STATUS_WITHDRAWN:
      return "APPEAL_STATUS_WITHDRAWN";
    case AppealStatus.APPEAL_STATUS_EXPIRED:
      return "APPEAL_STATUS_EXPIRED";
    case AppealStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AppealRecord tracks an appeal against a verification decision */
export interface AppealRecord {
  /** AppealID is the unique identifier for this appeal */
  appealId: string;
  /** AccountAddress is the address of the account filing the appeal */
  accountAddress: string;
  /** ScopeID is the scope whose verification decision is being appealed */
  scopeId: string;
  /** OriginalStatus is the verification status that prompted the appeal */
  originalStatus: string;
  /** OriginalScore is the verification score at the time of appeal */
  originalScore: number;
  /** AppealReason is the user's explanation for why they are appealing */
  appealReason: string;
  /** EvidenceHashes are hashes of supporting evidence documents */
  evidenceHashes: string[];
  /** SubmittedAt is the block height when the appeal was submitted */
  submittedAt: Long;
  /** SubmittedAtTime is the Unix timestamp when the appeal was submitted */
  submittedAtTime: Long;
  /** Status is the current status of the appeal */
  status: AppealStatus;
  /** ReviewerAddress is the address of the arbitrator reviewing the appeal */
  reviewerAddress: string;
  /** ClaimedAt is the block height when the appeal was claimed for review */
  claimedAt: Long;
  /** ReviewedAt is the block height when the appeal was resolved */
  reviewedAt: Long;
  /** ReviewedAtTime is the Unix timestamp when the appeal was resolved */
  reviewedAtTime: Long;
  /** ResolutionReason is the arbitrator's explanation for the decision */
  resolutionReason: string;
  /** ScoreAdjustment is the adjustment to the verification score */
  scoreAdjustment: number;
  /** AppealNumber tracks which appeal this is for the scope (1st, 2nd, 3rd) */
  appealNumber: number;
}

/** AppealParams defines the parameters for the appeal system */
export interface AppealParams {
  /** AppealWindowBlocks is how long after rejection can user appeal */
  appealWindowBlocks: Long;
  /** MaxAppealsPerScope is the maximum appeals allowed per scope */
  maxAppealsPerScope: number;
  /** MinAppealReasonLength is the minimum characters for appeal reason */
  minAppealReasonLength: number;
  /** ReviewTimeoutBlocks is how long an appeal can stay in reviewing status */
  reviewTimeoutBlocks: Long;
  /** Enabled indicates whether the appeal system is active */
  enabled: boolean;
  /** RequireEscrowDeposit indicates whether appeals require a deposit */
  requireEscrowDeposit: boolean;
  /** EscrowDepositAmount is the deposit amount required (in base units) */
  escrowDepositAmount: Long;
}

/** AppealSummary provides a summary of appeals for an account */
export interface AppealSummary {
  /** TotalAppeals is the total number of appeals */
  totalAppeals: number;
  /** PendingAppeals is the number of pending appeals */
  pendingAppeals: number;
  /** ApprovedAppeals is the number of approved appeals */
  approvedAppeals: number;
  /** RejectedAppeals is the number of rejected appeals */
  rejectedAppeals: number;
  /** WithdrawnAppeals is the number of withdrawn appeals */
  withdrawnAppeals: number;
}

/** MsgSubmitAppeal is the message to submit an appeal against a verification decision */
export interface MsgSubmitAppeal {
  /** Submitter is the account address submitting the appeal (must own the scope) */
  submitter: string;
  /** ScopeID is the scope whose verification decision is being appealed */
  scopeId: string;
  /** Reason is the explanation for why the submitter is appealing */
  reason: string;
  /** EvidenceHashes are hashes of supporting evidence documents */
  evidenceHashes: string[];
}

/** MsgSubmitAppealResponse is the response for MsgSubmitAppeal */
export interface MsgSubmitAppealResponse {
  /** AppealID is the unique identifier for the created appeal */
  appealId: string;
  /** Status is the initial status of the appeal */
  status: AppealStatus;
  /** AppealNumber is which appeal this is for the scope */
  appealNumber: number;
  /** SubmittedAt is the block height when submitted */
  submittedAt: Long;
}

/** MsgClaimAppeal is the message for an arbitrator to claim an appeal for review */
export interface MsgClaimAppeal {
  /** Reviewer is the arbitrator claiming the appeal */
  reviewer: string;
  /** AppealID is the appeal being claimed */
  appealId: string;
}

/** MsgClaimAppealResponse is the response for MsgClaimAppeal */
export interface MsgClaimAppealResponse {
  /** AppealID is the claimed appeal ID */
  appealId: string;
  /** ClaimedAt is the block height when claimed */
  claimedAt: Long;
}

/** MsgResolveAppeal is the message to resolve an appeal */
export interface MsgResolveAppeal {
  /** Resolver is the arbitrator resolving the appeal */
  resolver: string;
  /** AppealID is the appeal being resolved */
  appealId: string;
  /** Resolution is the resolution status (approved or rejected) */
  resolution: AppealStatus;
  /** Reason is the explanation for the resolution decision */
  reason: string;
  /** ScoreAdjustment is the adjustment to the verification score */
  scoreAdjustment: number;
}

/** MsgResolveAppealResponse is the response for MsgResolveAppeal */
export interface MsgResolveAppealResponse {
  /** AppealID is the resolved appeal ID */
  appealId: string;
  /** Resolution is the final resolution status */
  resolution: AppealStatus;
  /** ResolvedAt is the block height when resolved */
  resolvedAt: Long;
}

/** MsgWithdrawAppeal allows the submitter to withdraw their appeal */
export interface MsgWithdrawAppeal {
  /** Submitter is the original appeal submitter */
  submitter: string;
  /** AppealID is the appeal to withdraw */
  appealId: string;
}

/** MsgWithdrawAppealResponse is the response for MsgWithdrawAppeal */
export interface MsgWithdrawAppealResponse {
  /** AppealID is the withdrawn appeal ID */
  appealId: string;
  /** WithdrawnAt is the block height when withdrawn */
  withdrawnAt: Long;
}

function createBaseAppealRecord(): AppealRecord {
  return {
    appealId: "",
    accountAddress: "",
    scopeId: "",
    originalStatus: "",
    originalScore: 0,
    appealReason: "",
    evidenceHashes: [],
    submittedAt: Long.ZERO,
    submittedAtTime: Long.ZERO,
    status: 0,
    reviewerAddress: "",
    claimedAt: Long.ZERO,
    reviewedAt: Long.ZERO,
    reviewedAtTime: Long.ZERO,
    resolutionReason: "",
    scoreAdjustment: 0,
    appealNumber: 0,
  };
}

export const AppealRecord: MessageFns<AppealRecord, "virtengine.veid.v1.AppealRecord"> = {
  $type: "virtengine.veid.v1.AppealRecord" as const,

  encode(message: AppealRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.scopeId !== "") {
      writer.uint32(26).string(message.scopeId);
    }
    if (message.originalStatus !== "") {
      writer.uint32(34).string(message.originalStatus);
    }
    if (message.originalScore !== 0) {
      writer.uint32(40).uint32(message.originalScore);
    }
    if (message.appealReason !== "") {
      writer.uint32(50).string(message.appealReason);
    }
    for (const v of message.evidenceHashes) {
      writer.uint32(58).string(v!);
    }
    if (!message.submittedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.submittedAt.toString());
    }
    if (!message.submittedAtTime.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.submittedAtTime.toString());
    }
    if (message.status !== 0) {
      writer.uint32(80).int32(message.status);
    }
    if (message.reviewerAddress !== "") {
      writer.uint32(90).string(message.reviewerAddress);
    }
    if (!message.claimedAt.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.claimedAt.toString());
    }
    if (!message.reviewedAt.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.reviewedAt.toString());
    }
    if (!message.reviewedAtTime.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.reviewedAtTime.toString());
    }
    if (message.resolutionReason !== "") {
      writer.uint32(122).string(message.resolutionReason);
    }
    if (message.scoreAdjustment !== 0) {
      writer.uint32(128).int32(message.scoreAdjustment);
    }
    if (message.appealNumber !== 0) {
      writer.uint32(136).uint32(message.appealNumber);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppealRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppealRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originalStatus = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.originalScore = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.appealReason = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.evidenceHashes.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.submittedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.submittedAtTime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.reviewerAddress = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.claimedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.reviewedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.reviewedAtTime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.resolutionReason = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.scoreAdjustment = reader.int32();
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.appealNumber = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppealRecord {
    return {
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      originalStatus: isSet(object.original_status) ? globalThis.String(object.original_status) : "",
      originalScore: isSet(object.original_score) ? globalThis.Number(object.original_score) : 0,
      appealReason: isSet(object.appeal_reason) ? globalThis.String(object.appeal_reason) : "",
      evidenceHashes: globalThis.Array.isArray(object?.evidence_hashes)
        ? object.evidence_hashes.map((e: any) => globalThis.String(e))
        : [],
      submittedAt: isSet(object.submitted_at) ? Long.fromValue(object.submitted_at) : Long.ZERO,
      submittedAtTime: isSet(object.submitted_at_time) ? Long.fromValue(object.submitted_at_time) : Long.ZERO,
      status: isSet(object.status) ? appealStatusFromJSON(object.status) : 0,
      reviewerAddress: isSet(object.reviewer_address) ? globalThis.String(object.reviewer_address) : "",
      claimedAt: isSet(object.claimed_at) ? Long.fromValue(object.claimed_at) : Long.ZERO,
      reviewedAt: isSet(object.reviewed_at) ? Long.fromValue(object.reviewed_at) : Long.ZERO,
      reviewedAtTime: isSet(object.reviewed_at_time) ? Long.fromValue(object.reviewed_at_time) : Long.ZERO,
      resolutionReason: isSet(object.resolution_reason) ? globalThis.String(object.resolution_reason) : "",
      scoreAdjustment: isSet(object.score_adjustment) ? globalThis.Number(object.score_adjustment) : 0,
      appealNumber: isSet(object.appeal_number) ? globalThis.Number(object.appeal_number) : 0,
    };
  },

  toJSON(message: AppealRecord): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.originalStatus !== "") {
      obj.original_status = message.originalStatus;
    }
    if (message.originalScore !== 0) {
      obj.original_score = Math.round(message.originalScore);
    }
    if (message.appealReason !== "") {
      obj.appeal_reason = message.appealReason;
    }
    if (message.evidenceHashes?.length) {
      obj.evidence_hashes = message.evidenceHashes;
    }
    if (!message.submittedAt.equals(Long.ZERO)) {
      obj.submitted_at = (message.submittedAt || Long.ZERO).toString();
    }
    if (!message.submittedAtTime.equals(Long.ZERO)) {
      obj.submitted_at_time = (message.submittedAtTime || Long.ZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = appealStatusToJSON(message.status);
    }
    if (message.reviewerAddress !== "") {
      obj.reviewer_address = message.reviewerAddress;
    }
    if (!message.claimedAt.equals(Long.ZERO)) {
      obj.claimed_at = (message.claimedAt || Long.ZERO).toString();
    }
    if (!message.reviewedAt.equals(Long.ZERO)) {
      obj.reviewed_at = (message.reviewedAt || Long.ZERO).toString();
    }
    if (!message.reviewedAtTime.equals(Long.ZERO)) {
      obj.reviewed_at_time = (message.reviewedAtTime || Long.ZERO).toString();
    }
    if (message.resolutionReason !== "") {
      obj.resolution_reason = message.resolutionReason;
    }
    if (message.scoreAdjustment !== 0) {
      obj.score_adjustment = Math.round(message.scoreAdjustment);
    }
    if (message.appealNumber !== 0) {
      obj.appeal_number = Math.round(message.appealNumber);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AppealRecord>): AppealRecord {
    const message = createBaseAppealRecord();
    message.appealId = object.appealId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.scopeId = object.scopeId ?? "";
    message.originalStatus = object.originalStatus ?? "";
    message.originalScore = object.originalScore ?? 0;
    message.appealReason = object.appealReason ?? "";
    message.evidenceHashes = object.evidenceHashes?.map((e) => e) || [];
    message.submittedAt = (object.submittedAt !== undefined && object.submittedAt !== null)
      ? Long.fromValue(object.submittedAt)
      : Long.ZERO;
    message.submittedAtTime = (object.submittedAtTime !== undefined && object.submittedAtTime !== null)
      ? Long.fromValue(object.submittedAtTime)
      : Long.ZERO;
    message.status = object.status ?? 0;
    message.reviewerAddress = object.reviewerAddress ?? "";
    message.claimedAt = (object.claimedAt !== undefined && object.claimedAt !== null)
      ? Long.fromValue(object.claimedAt)
      : Long.ZERO;
    message.reviewedAt = (object.reviewedAt !== undefined && object.reviewedAt !== null)
      ? Long.fromValue(object.reviewedAt)
      : Long.ZERO;
    message.reviewedAtTime = (object.reviewedAtTime !== undefined && object.reviewedAtTime !== null)
      ? Long.fromValue(object.reviewedAtTime)
      : Long.ZERO;
    message.resolutionReason = object.resolutionReason ?? "";
    message.scoreAdjustment = object.scoreAdjustment ?? 0;
    message.appealNumber = object.appealNumber ?? 0;
    return message;
  },
};

function createBaseAppealParams(): AppealParams {
  return {
    appealWindowBlocks: Long.ZERO,
    maxAppealsPerScope: 0,
    minAppealReasonLength: 0,
    reviewTimeoutBlocks: Long.ZERO,
    enabled: false,
    requireEscrowDeposit: false,
    escrowDepositAmount: Long.ZERO,
  };
}

export const AppealParams: MessageFns<AppealParams, "virtengine.veid.v1.AppealParams"> = {
  $type: "virtengine.veid.v1.AppealParams" as const,

  encode(message: AppealParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.appealWindowBlocks.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.appealWindowBlocks.toString());
    }
    if (message.maxAppealsPerScope !== 0) {
      writer.uint32(16).uint32(message.maxAppealsPerScope);
    }
    if (message.minAppealReasonLength !== 0) {
      writer.uint32(24).uint32(message.minAppealReasonLength);
    }
    if (!message.reviewTimeoutBlocks.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.reviewTimeoutBlocks.toString());
    }
    if (message.enabled !== false) {
      writer.uint32(40).bool(message.enabled);
    }
    if (message.requireEscrowDeposit !== false) {
      writer.uint32(48).bool(message.requireEscrowDeposit);
    }
    if (!message.escrowDepositAmount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.escrowDepositAmount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppealParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppealParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.appealWindowBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxAppealsPerScope = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minAppealReasonLength = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.reviewTimeoutBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.requireEscrowDeposit = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.escrowDepositAmount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppealParams {
    return {
      appealWindowBlocks: isSet(object.appeal_window_blocks) ? Long.fromValue(object.appeal_window_blocks) : Long.ZERO,
      maxAppealsPerScope: isSet(object.max_appeals_per_scope) ? globalThis.Number(object.max_appeals_per_scope) : 0,
      minAppealReasonLength: isSet(object.min_appeal_reason_length)
        ? globalThis.Number(object.min_appeal_reason_length)
        : 0,
      reviewTimeoutBlocks: isSet(object.review_timeout_blocks)
        ? Long.fromValue(object.review_timeout_blocks)
        : Long.ZERO,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      requireEscrowDeposit: isSet(object.require_escrow_deposit)
        ? globalThis.Boolean(object.require_escrow_deposit)
        : false,
      escrowDepositAmount: isSet(object.escrow_deposit_amount)
        ? Long.fromValue(object.escrow_deposit_amount)
        : Long.ZERO,
    };
  },

  toJSON(message: AppealParams): unknown {
    const obj: any = {};
    if (!message.appealWindowBlocks.equals(Long.ZERO)) {
      obj.appeal_window_blocks = (message.appealWindowBlocks || Long.ZERO).toString();
    }
    if (message.maxAppealsPerScope !== 0) {
      obj.max_appeals_per_scope = Math.round(message.maxAppealsPerScope);
    }
    if (message.minAppealReasonLength !== 0) {
      obj.min_appeal_reason_length = Math.round(message.minAppealReasonLength);
    }
    if (!message.reviewTimeoutBlocks.equals(Long.ZERO)) {
      obj.review_timeout_blocks = (message.reviewTimeoutBlocks || Long.ZERO).toString();
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.requireEscrowDeposit !== false) {
      obj.require_escrow_deposit = message.requireEscrowDeposit;
    }
    if (!message.escrowDepositAmount.equals(Long.ZERO)) {
      obj.escrow_deposit_amount = (message.escrowDepositAmount || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AppealParams>): AppealParams {
    const message = createBaseAppealParams();
    message.appealWindowBlocks = (object.appealWindowBlocks !== undefined && object.appealWindowBlocks !== null)
      ? Long.fromValue(object.appealWindowBlocks)
      : Long.ZERO;
    message.maxAppealsPerScope = object.maxAppealsPerScope ?? 0;
    message.minAppealReasonLength = object.minAppealReasonLength ?? 0;
    message.reviewTimeoutBlocks = (object.reviewTimeoutBlocks !== undefined && object.reviewTimeoutBlocks !== null)
      ? Long.fromValue(object.reviewTimeoutBlocks)
      : Long.ZERO;
    message.enabled = object.enabled ?? false;
    message.requireEscrowDeposit = object.requireEscrowDeposit ?? false;
    message.escrowDepositAmount = (object.escrowDepositAmount !== undefined && object.escrowDepositAmount !== null)
      ? Long.fromValue(object.escrowDepositAmount)
      : Long.ZERO;
    return message;
  },
};

function createBaseAppealSummary(): AppealSummary {
  return { totalAppeals: 0, pendingAppeals: 0, approvedAppeals: 0, rejectedAppeals: 0, withdrawnAppeals: 0 };
}

export const AppealSummary: MessageFns<AppealSummary, "virtengine.veid.v1.AppealSummary"> = {
  $type: "virtengine.veid.v1.AppealSummary" as const,

  encode(message: AppealSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalAppeals !== 0) {
      writer.uint32(8).uint32(message.totalAppeals);
    }
    if (message.pendingAppeals !== 0) {
      writer.uint32(16).uint32(message.pendingAppeals);
    }
    if (message.approvedAppeals !== 0) {
      writer.uint32(24).uint32(message.approvedAppeals);
    }
    if (message.rejectedAppeals !== 0) {
      writer.uint32(32).uint32(message.rejectedAppeals);
    }
    if (message.withdrawnAppeals !== 0) {
      writer.uint32(40).uint32(message.withdrawnAppeals);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppealSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppealSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.totalAppeals = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.pendingAppeals = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.approvedAppeals = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.rejectedAppeals = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.withdrawnAppeals = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppealSummary {
    return {
      totalAppeals: isSet(object.total_appeals) ? globalThis.Number(object.total_appeals) : 0,
      pendingAppeals: isSet(object.pending_appeals) ? globalThis.Number(object.pending_appeals) : 0,
      approvedAppeals: isSet(object.approved_appeals) ? globalThis.Number(object.approved_appeals) : 0,
      rejectedAppeals: isSet(object.rejected_appeals) ? globalThis.Number(object.rejected_appeals) : 0,
      withdrawnAppeals: isSet(object.withdrawn_appeals) ? globalThis.Number(object.withdrawn_appeals) : 0,
    };
  },

  toJSON(message: AppealSummary): unknown {
    const obj: any = {};
    if (message.totalAppeals !== 0) {
      obj.total_appeals = Math.round(message.totalAppeals);
    }
    if (message.pendingAppeals !== 0) {
      obj.pending_appeals = Math.round(message.pendingAppeals);
    }
    if (message.approvedAppeals !== 0) {
      obj.approved_appeals = Math.round(message.approvedAppeals);
    }
    if (message.rejectedAppeals !== 0) {
      obj.rejected_appeals = Math.round(message.rejectedAppeals);
    }
    if (message.withdrawnAppeals !== 0) {
      obj.withdrawn_appeals = Math.round(message.withdrawnAppeals);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AppealSummary>): AppealSummary {
    const message = createBaseAppealSummary();
    message.totalAppeals = object.totalAppeals ?? 0;
    message.pendingAppeals = object.pendingAppeals ?? 0;
    message.approvedAppeals = object.approvedAppeals ?? 0;
    message.rejectedAppeals = object.rejectedAppeals ?? 0;
    message.withdrawnAppeals = object.withdrawnAppeals ?? 0;
    return message;
  },
};

function createBaseMsgSubmitAppeal(): MsgSubmitAppeal {
  return { submitter: "", scopeId: "", reason: "", evidenceHashes: [] };
}

export const MsgSubmitAppeal: MessageFns<MsgSubmitAppeal, "virtengine.veid.v1.MsgSubmitAppeal"> = {
  $type: "virtengine.veid.v1.MsgSubmitAppeal" as const,

  encode(message: MsgSubmitAppeal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submitter !== "") {
      writer.uint32(10).string(message.submitter);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    for (const v of message.evidenceHashes) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitAppeal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitAppeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.evidenceHashes.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitAppeal {
    return {
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      evidenceHashes: globalThis.Array.isArray(object?.evidence_hashes)
        ? object.evidence_hashes.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgSubmitAppeal): unknown {
    const obj: any = {};
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.evidenceHashes?.length) {
      obj.evidence_hashes = message.evidenceHashes;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitAppeal>): MsgSubmitAppeal {
    const message = createBaseMsgSubmitAppeal();
    message.submitter = object.submitter ?? "";
    message.scopeId = object.scopeId ?? "";
    message.reason = object.reason ?? "";
    message.evidenceHashes = object.evidenceHashes?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgSubmitAppealResponse(): MsgSubmitAppealResponse {
  return { appealId: "", status: 0, appealNumber: 0, submittedAt: Long.ZERO };
}

export const MsgSubmitAppealResponse: MessageFns<
  MsgSubmitAppealResponse,
  "virtengine.veid.v1.MsgSubmitAppealResponse"
> = {
  $type: "virtengine.veid.v1.MsgSubmitAppealResponse" as const,

  encode(message: MsgSubmitAppealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.appealNumber !== 0) {
      writer.uint32(24).uint32(message.appealNumber);
    }
    if (!message.submittedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.submittedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitAppealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitAppealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.appealNumber = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.submittedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitAppealResponse {
    return {
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      status: isSet(object.status) ? appealStatusFromJSON(object.status) : 0,
      appealNumber: isSet(object.appeal_number) ? globalThis.Number(object.appeal_number) : 0,
      submittedAt: isSet(object.submitted_at) ? Long.fromValue(object.submitted_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgSubmitAppealResponse): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (message.status !== 0) {
      obj.status = appealStatusToJSON(message.status);
    }
    if (message.appealNumber !== 0) {
      obj.appeal_number = Math.round(message.appealNumber);
    }
    if (!message.submittedAt.equals(Long.ZERO)) {
      obj.submitted_at = (message.submittedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitAppealResponse>): MsgSubmitAppealResponse {
    const message = createBaseMsgSubmitAppealResponse();
    message.appealId = object.appealId ?? "";
    message.status = object.status ?? 0;
    message.appealNumber = object.appealNumber ?? 0;
    message.submittedAt = (object.submittedAt !== undefined && object.submittedAt !== null)
      ? Long.fromValue(object.submittedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgClaimAppeal(): MsgClaimAppeal {
  return { reviewer: "", appealId: "" };
}

export const MsgClaimAppeal: MessageFns<MsgClaimAppeal, "virtengine.veid.v1.MsgClaimAppeal"> = {
  $type: "virtengine.veid.v1.MsgClaimAppeal" as const,

  encode(message: MsgClaimAppeal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reviewer !== "") {
      writer.uint32(10).string(message.reviewer);
    }
    if (message.appealId !== "") {
      writer.uint32(18).string(message.appealId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimAppeal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimAppeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reviewer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimAppeal {
    return {
      reviewer: isSet(object.reviewer) ? globalThis.String(object.reviewer) : "",
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
    };
  },

  toJSON(message: MsgClaimAppeal): unknown {
    const obj: any = {};
    if (message.reviewer !== "") {
      obj.reviewer = message.reviewer;
    }
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgClaimAppeal>): MsgClaimAppeal {
    const message = createBaseMsgClaimAppeal();
    message.reviewer = object.reviewer ?? "";
    message.appealId = object.appealId ?? "";
    return message;
  },
};

function createBaseMsgClaimAppealResponse(): MsgClaimAppealResponse {
  return { appealId: "", claimedAt: Long.ZERO };
}

export const MsgClaimAppealResponse: MessageFns<MsgClaimAppealResponse, "virtengine.veid.v1.MsgClaimAppealResponse"> = {
  $type: "virtengine.veid.v1.MsgClaimAppealResponse" as const,

  encode(message: MsgClaimAppealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    if (!message.claimedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.claimedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgClaimAppealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgClaimAppealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.claimedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgClaimAppealResponse {
    return {
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      claimedAt: isSet(object.claimed_at) ? Long.fromValue(object.claimed_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgClaimAppealResponse): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (!message.claimedAt.equals(Long.ZERO)) {
      obj.claimed_at = (message.claimedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgClaimAppealResponse>): MsgClaimAppealResponse {
    const message = createBaseMsgClaimAppealResponse();
    message.appealId = object.appealId ?? "";
    message.claimedAt = (object.claimedAt !== undefined && object.claimedAt !== null)
      ? Long.fromValue(object.claimedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgResolveAppeal(): MsgResolveAppeal {
  return { resolver: "", appealId: "", resolution: 0, reason: "", scoreAdjustment: 0 };
}

export const MsgResolveAppeal: MessageFns<MsgResolveAppeal, "virtengine.veid.v1.MsgResolveAppeal"> = {
  $type: "virtengine.veid.v1.MsgResolveAppeal" as const,

  encode(message: MsgResolveAppeal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.resolver !== "") {
      writer.uint32(10).string(message.resolver);
    }
    if (message.appealId !== "") {
      writer.uint32(18).string(message.appealId);
    }
    if (message.resolution !== 0) {
      writer.uint32(24).int32(message.resolution);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (message.scoreAdjustment !== 0) {
      writer.uint32(40).int32(message.scoreAdjustment);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveAppeal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveAppeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.resolver = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resolution = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scoreAdjustment = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResolveAppeal {
    return {
      resolver: isSet(object.resolver) ? globalThis.String(object.resolver) : "",
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      resolution: isSet(object.resolution) ? appealStatusFromJSON(object.resolution) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      scoreAdjustment: isSet(object.score_adjustment) ? globalThis.Number(object.score_adjustment) : 0,
    };
  },

  toJSON(message: MsgResolveAppeal): unknown {
    const obj: any = {};
    if (message.resolver !== "") {
      obj.resolver = message.resolver;
    }
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (message.resolution !== 0) {
      obj.resolution = appealStatusToJSON(message.resolution);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.scoreAdjustment !== 0) {
      obj.score_adjustment = Math.round(message.scoreAdjustment);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgResolveAppeal>): MsgResolveAppeal {
    const message = createBaseMsgResolveAppeal();
    message.resolver = object.resolver ?? "";
    message.appealId = object.appealId ?? "";
    message.resolution = object.resolution ?? 0;
    message.reason = object.reason ?? "";
    message.scoreAdjustment = object.scoreAdjustment ?? 0;
    return message;
  },
};

function createBaseMsgResolveAppealResponse(): MsgResolveAppealResponse {
  return { appealId: "", resolution: 0, resolvedAt: Long.ZERO };
}

export const MsgResolveAppealResponse: MessageFns<
  MsgResolveAppealResponse,
  "virtengine.veid.v1.MsgResolveAppealResponse"
> = {
  $type: "virtengine.veid.v1.MsgResolveAppealResponse" as const,

  encode(message: MsgResolveAppealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    if (message.resolution !== 0) {
      writer.uint32(16).int32(message.resolution);
    }
    if (!message.resolvedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.resolvedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgResolveAppealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgResolveAppealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.resolution = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.resolvedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgResolveAppealResponse {
    return {
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      resolution: isSet(object.resolution) ? appealStatusFromJSON(object.resolution) : 0,
      resolvedAt: isSet(object.resolved_at) ? Long.fromValue(object.resolved_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgResolveAppealResponse): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (message.resolution !== 0) {
      obj.resolution = appealStatusToJSON(message.resolution);
    }
    if (!message.resolvedAt.equals(Long.ZERO)) {
      obj.resolved_at = (message.resolvedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgResolveAppealResponse>): MsgResolveAppealResponse {
    const message = createBaseMsgResolveAppealResponse();
    message.appealId = object.appealId ?? "";
    message.resolution = object.resolution ?? 0;
    message.resolvedAt = (object.resolvedAt !== undefined && object.resolvedAt !== null)
      ? Long.fromValue(object.resolvedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgWithdrawAppeal(): MsgWithdrawAppeal {
  return { submitter: "", appealId: "" };
}

export const MsgWithdrawAppeal: MessageFns<MsgWithdrawAppeal, "virtengine.veid.v1.MsgWithdrawAppeal"> = {
  $type: "virtengine.veid.v1.MsgWithdrawAppeal" as const,

  encode(message: MsgWithdrawAppeal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.submitter !== "") {
      writer.uint32(10).string(message.submitter);
    }
    if (message.appealId !== "") {
      writer.uint32(18).string(message.appealId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawAppeal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawAppeal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.submitter = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawAppeal {
    return {
      submitter: isSet(object.submitter) ? globalThis.String(object.submitter) : "",
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
    };
  },

  toJSON(message: MsgWithdrawAppeal): unknown {
    const obj: any = {};
    if (message.submitter !== "") {
      obj.submitter = message.submitter;
    }
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgWithdrawAppeal>): MsgWithdrawAppeal {
    const message = createBaseMsgWithdrawAppeal();
    message.submitter = object.submitter ?? "";
    message.appealId = object.appealId ?? "";
    return message;
  },
};

function createBaseMsgWithdrawAppealResponse(): MsgWithdrawAppealResponse {
  return { appealId: "", withdrawnAt: Long.ZERO };
}

export const MsgWithdrawAppealResponse: MessageFns<
  MsgWithdrawAppealResponse,
  "virtengine.veid.v1.MsgWithdrawAppealResponse"
> = {
  $type: "virtengine.veid.v1.MsgWithdrawAppealResponse" as const,

  encode(message: MsgWithdrawAppealResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.appealId !== "") {
      writer.uint32(10).string(message.appealId);
    }
    if (!message.withdrawnAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.withdrawnAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgWithdrawAppealResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgWithdrawAppealResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.appealId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.withdrawnAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgWithdrawAppealResponse {
    return {
      appealId: isSet(object.appeal_id) ? globalThis.String(object.appeal_id) : "",
      withdrawnAt: isSet(object.withdrawn_at) ? Long.fromValue(object.withdrawn_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgWithdrawAppealResponse): unknown {
    const obj: any = {};
    if (message.appealId !== "") {
      obj.appeal_id = message.appealId;
    }
    if (!message.withdrawnAt.equals(Long.ZERO)) {
      obj.withdrawn_at = (message.withdrawnAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgWithdrawAppealResponse>): MsgWithdrawAppealResponse {
    const message = createBaseMsgWithdrawAppealResponse();
    message.appealId = object.appealId ?? "";
    message.withdrawnAt = (object.withdrawnAt !== undefined && object.withdrawnAt !== null)
      ? Long.fromValue(object.withdrawnAt)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
