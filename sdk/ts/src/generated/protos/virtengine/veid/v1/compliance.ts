import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/compliance.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** ComplianceStatus represents the compliance state of an identity */
export enum ComplianceStatus {
  /** COMPLIANCE_STATUS_UNKNOWN - COMPLIANCE_STATUS_UNKNOWN indicates no compliance check has been performed */
  COMPLIANCE_STATUS_UNKNOWN = 0,
  /** COMPLIANCE_STATUS_PENDING - COMPLIANCE_STATUS_PENDING indicates compliance check is in progress */
  COMPLIANCE_STATUS_PENDING = 1,
  /** COMPLIANCE_STATUS_CLEARED - COMPLIANCE_STATUS_CLEARED indicates identity passed all compliance checks */
  COMPLIANCE_STATUS_CLEARED = 2,
  /** COMPLIANCE_STATUS_FLAGGED - COMPLIANCE_STATUS_FLAGGED indicates identity has been flagged for review */
  COMPLIANCE_STATUS_FLAGGED = 3,
  /** COMPLIANCE_STATUS_BLOCKED - COMPLIANCE_STATUS_BLOCKED indicates identity is blocked from transactions */
  COMPLIANCE_STATUS_BLOCKED = 4,
  /** COMPLIANCE_STATUS_EXPIRED - COMPLIANCE_STATUS_EXPIRED indicates compliance check has expired */
  COMPLIANCE_STATUS_EXPIRED = 5,
  UNRECOGNIZED = -1,
}

export function complianceStatusFromJSON(object: any): ComplianceStatus {
  switch (object) {
    case 0:
    case "COMPLIANCE_STATUS_UNKNOWN":
      return ComplianceStatus.COMPLIANCE_STATUS_UNKNOWN;
    case 1:
    case "COMPLIANCE_STATUS_PENDING":
      return ComplianceStatus.COMPLIANCE_STATUS_PENDING;
    case 2:
    case "COMPLIANCE_STATUS_CLEARED":
      return ComplianceStatus.COMPLIANCE_STATUS_CLEARED;
    case 3:
    case "COMPLIANCE_STATUS_FLAGGED":
      return ComplianceStatus.COMPLIANCE_STATUS_FLAGGED;
    case 4:
    case "COMPLIANCE_STATUS_BLOCKED":
      return ComplianceStatus.COMPLIANCE_STATUS_BLOCKED;
    case 5:
    case "COMPLIANCE_STATUS_EXPIRED":
      return ComplianceStatus.COMPLIANCE_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComplianceStatus.UNRECOGNIZED;
  }
}

export function complianceStatusToJSON(object: ComplianceStatus): string {
  switch (object) {
    case ComplianceStatus.COMPLIANCE_STATUS_UNKNOWN:
      return "COMPLIANCE_STATUS_UNKNOWN";
    case ComplianceStatus.COMPLIANCE_STATUS_PENDING:
      return "COMPLIANCE_STATUS_PENDING";
    case ComplianceStatus.COMPLIANCE_STATUS_CLEARED:
      return "COMPLIANCE_STATUS_CLEARED";
    case ComplianceStatus.COMPLIANCE_STATUS_FLAGGED:
      return "COMPLIANCE_STATUS_FLAGGED";
    case ComplianceStatus.COMPLIANCE_STATUS_BLOCKED:
      return "COMPLIANCE_STATUS_BLOCKED";
    case ComplianceStatus.COMPLIANCE_STATUS_EXPIRED:
      return "COMPLIANCE_STATUS_EXPIRED";
    case ComplianceStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ComplianceCheckType defines what type of compliance check */
export enum ComplianceCheckType {
  /** COMPLIANCE_CHECK_SANCTION_LIST - COMPLIANCE_CHECK_SANCTION_LIST checks against global sanction lists */
  COMPLIANCE_CHECK_SANCTION_LIST = 0,
  /** COMPLIANCE_CHECK_PEP - COMPLIANCE_CHECK_PEP checks for Politically Exposed Person status */
  COMPLIANCE_CHECK_PEP = 1,
  /** COMPLIANCE_CHECK_ADVERSE_MEDIA - COMPLIANCE_CHECK_ADVERSE_MEDIA checks for negative news coverage */
  COMPLIANCE_CHECK_ADVERSE_MEDIA = 2,
  /** COMPLIANCE_CHECK_GEOGRAPHIC - COMPLIANCE_CHECK_GEOGRAPHIC checks geographic restrictions */
  COMPLIANCE_CHECK_GEOGRAPHIC = 3,
  /** COMPLIANCE_CHECK_WATCHLIST - COMPLIANCE_CHECK_WATCHLIST checks against custom watchlists */
  COMPLIANCE_CHECK_WATCHLIST = 4,
  /** COMPLIANCE_CHECK_DOCUMENT_VERIFICATION - COMPLIANCE_CHECK_DOCUMENT_VERIFICATION verifies identity documents */
  COMPLIANCE_CHECK_DOCUMENT_VERIFICATION = 5,
  /** COMPLIANCE_CHECK_AML_RISK - COMPLIANCE_CHECK_AML_RISK assesses anti-money laundering risk */
  COMPLIANCE_CHECK_AML_RISK = 6,
  UNRECOGNIZED = -1,
}

export function complianceCheckTypeFromJSON(object: any): ComplianceCheckType {
  switch (object) {
    case 0:
    case "COMPLIANCE_CHECK_SANCTION_LIST":
      return ComplianceCheckType.COMPLIANCE_CHECK_SANCTION_LIST;
    case 1:
    case "COMPLIANCE_CHECK_PEP":
      return ComplianceCheckType.COMPLIANCE_CHECK_PEP;
    case 2:
    case "COMPLIANCE_CHECK_ADVERSE_MEDIA":
      return ComplianceCheckType.COMPLIANCE_CHECK_ADVERSE_MEDIA;
    case 3:
    case "COMPLIANCE_CHECK_GEOGRAPHIC":
      return ComplianceCheckType.COMPLIANCE_CHECK_GEOGRAPHIC;
    case 4:
    case "COMPLIANCE_CHECK_WATCHLIST":
      return ComplianceCheckType.COMPLIANCE_CHECK_WATCHLIST;
    case 5:
    case "COMPLIANCE_CHECK_DOCUMENT_VERIFICATION":
      return ComplianceCheckType.COMPLIANCE_CHECK_DOCUMENT_VERIFICATION;
    case 6:
    case "COMPLIANCE_CHECK_AML_RISK":
      return ComplianceCheckType.COMPLIANCE_CHECK_AML_RISK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ComplianceCheckType.UNRECOGNIZED;
  }
}

export function complianceCheckTypeToJSON(object: ComplianceCheckType): string {
  switch (object) {
    case ComplianceCheckType.COMPLIANCE_CHECK_SANCTION_LIST:
      return "COMPLIANCE_CHECK_SANCTION_LIST";
    case ComplianceCheckType.COMPLIANCE_CHECK_PEP:
      return "COMPLIANCE_CHECK_PEP";
    case ComplianceCheckType.COMPLIANCE_CHECK_ADVERSE_MEDIA:
      return "COMPLIANCE_CHECK_ADVERSE_MEDIA";
    case ComplianceCheckType.COMPLIANCE_CHECK_GEOGRAPHIC:
      return "COMPLIANCE_CHECK_GEOGRAPHIC";
    case ComplianceCheckType.COMPLIANCE_CHECK_WATCHLIST:
      return "COMPLIANCE_CHECK_WATCHLIST";
    case ComplianceCheckType.COMPLIANCE_CHECK_DOCUMENT_VERIFICATION:
      return "COMPLIANCE_CHECK_DOCUMENT_VERIFICATION";
    case ComplianceCheckType.COMPLIANCE_CHECK_AML_RISK:
      return "COMPLIANCE_CHECK_AML_RISK";
    case ComplianceCheckType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ComplianceCheckResult stores result of a single compliance check */
export interface ComplianceCheckResult {
  /** CheckType indicates what kind of check was performed */
  checkType: ComplianceCheckType;
  /** Passed indicates whether the check passed */
  passed: boolean;
  /** Details provides additional context about the check result */
  details: string;
  /** MatchScore indicates confidence of any matches found (0-100) */
  matchScore: number;
  /** CheckedAt is the Unix timestamp when the check was performed */
  checkedAt: Long;
  /** ProviderID identifies the compliance provider that performed the check */
  providerId: string;
  /** ReferenceID is the provider's reference for this check */
  referenceId: string;
}

/** ComplianceAttestation is a validator attestation of compliance status */
export interface ComplianceAttestation {
  /** ValidatorAddress is the address of the attesting validator */
  validatorAddress: string;
  /** AttestedAt is the Unix timestamp when attestation was made */
  attestedAt: Long;
  /** ExpiresAt is the Unix timestamp when this attestation expires */
  expiresAt: Long;
  /** AttestationType describes what is being attested */
  attestationType: string;
  /** AttestationHash is a hash of the attestation data for verification */
  attestationHash: string;
}

/** ComplianceRecord stores the complete compliance status for an identity */
export interface ComplianceRecord {
  /** AccountAddress is the blockchain address of the identity */
  accountAddress: string;
  /** Status is the overall compliance status */
  status: ComplianceStatus;
  /** CheckResults contains results of individual compliance checks */
  checkResults: ComplianceCheckResult[];
  /** LastCheckedAt is the Unix timestamp of the last compliance check */
  lastCheckedAt: Long;
  /** ExpiresAt is the Unix timestamp when the compliance record expires */
  expiresAt: Long;
  /** RiskScore is the overall risk score (0-100, lower is better) */
  riskScore: number;
  /** RestrictedRegions lists regions where this identity is restricted */
  restrictedRegions: string[];
  /** Attestations contains validator attestations of compliance */
  attestations: ComplianceAttestation[];
  /** CreatedAt is when this record was first created */
  createdAt: Long;
  /** UpdatedAt is when this record was last updated */
  updatedAt: Long;
  /** Notes contains any additional notes about the compliance status */
  notes: string;
}

/** ComplianceParams configures the compliance module behavior */
export interface ComplianceParams {
  /** RequireSanctionCheck indicates if sanction list check is mandatory */
  requireSanctionCheck: boolean;
  /** RequirePEPCheck indicates if PEP check is mandatory */
  requirePepCheck: boolean;
  /** CheckExpiryBlocks is how long compliance checks remain valid */
  checkExpiryBlocks: Long;
  /** RiskScoreThreshold is the maximum allowed risk score (0-100) */
  riskScoreThreshold: number;
  /** RestrictedCountries is list of ISO country codes that are restricted */
  restrictedCountries: string[];
  /** MinAttestationsRequired is minimum validator attestations needed */
  minAttestationsRequired: number;
  /** EnableAutoExpiry enables automatic expiration of compliance records */
  enableAutoExpiry: boolean;
  /** RequireDocumentVerification indicates if document verification is mandatory */
  requireDocumentVerification: boolean;
}

/** ComplianceProvider represents an authorized external compliance provider */
export interface ComplianceProvider {
  /** ProviderID is the unique identifier for this provider */
  providerId: string;
  /** Name is the human-readable name of the provider */
  name: string;
  /** ProviderAddress is the blockchain address authorized to submit checks */
  providerAddress: string;
  /** SupportedCheckTypes lists which check types this provider can perform */
  supportedCheckTypes: ComplianceCheckType[];
  /** IsActive indicates if this provider is currently active */
  isActive: boolean;
  /** RegisteredAt is when this provider was registered */
  registeredAt: Long;
  /** LastActiveAt is when this provider last submitted a check */
  lastActiveAt: Long;
}

/** MsgSubmitComplianceCheck submits external compliance check results */
export interface MsgSubmitComplianceCheck {
  /** ProviderAddress is the address of the compliance provider */
  providerAddress: string;
  /** TargetAddress is the address being checked */
  targetAddress: string;
  /** CheckResults contains the compliance check results */
  checkResults: ComplianceCheckResult[];
  /** ProviderID is the ID of the compliance provider */
  providerId: string;
}

/** MsgSubmitComplianceCheckResponse is the response for MsgSubmitComplianceCheck */
export interface MsgSubmitComplianceCheckResponse {
  /** Status is the updated compliance status */
  status: ComplianceStatus;
  /** RiskScore is the updated risk score */
  riskScore: number;
}

/** MsgAttestCompliance allows validators to attest compliance status */
export interface MsgAttestCompliance {
  /** ValidatorAddress is the address of the attesting validator */
  validatorAddress: string;
  /** TargetAddress is the address being attested */
  targetAddress: string;
  /** AttestationType describes what is being attested */
  attestationType: string;
  /** ExpiryBlocks is how long until this attestation expires (in blocks) */
  expiryBlocks: Long;
}

/** MsgAttestComplianceResponse is the response for MsgAttestCompliance */
export interface MsgAttestComplianceResponse {
  /** AttestedAt is the block height when attested */
  attestedAt: Long;
  /** ExpiresAt is when the attestation expires */
  expiresAt: Long;
}

/** MsgUpdateComplianceParams updates compliance configuration (gov only) */
export interface MsgUpdateComplianceParams {
  /** Authority is the address that is authorized to update params (x/gov) */
  authority: string;
  /** Params are the new compliance parameters */
  params: ComplianceParams | undefined;
}

/** MsgUpdateComplianceParamsResponse is the response for MsgUpdateComplianceParams */
export interface MsgUpdateComplianceParamsResponse {
}

/** MsgRegisterComplianceProvider registers a new compliance provider */
export interface MsgRegisterComplianceProvider {
  /** Authority is the address that is authorized to register providers (x/gov) */
  authority: string;
  /** Provider is the compliance provider to register */
  provider: ComplianceProvider | undefined;
}

/** MsgRegisterComplianceProviderResponse is the response for MsgRegisterComplianceProvider */
export interface MsgRegisterComplianceProviderResponse {
  /** ProviderID is the registered provider's ID */
  providerId: string;
}

/** MsgDeactivateComplianceProvider deactivates a compliance provider */
export interface MsgDeactivateComplianceProvider {
  /** Authority is the address that is authorized to deactivate providers (x/gov) */
  authority: string;
  /** ProviderID is the ID of the provider to deactivate */
  providerId: string;
  /** Reason is the reason for deactivation */
  reason: string;
}

/** MsgDeactivateComplianceProviderResponse is the response for MsgDeactivateComplianceProvider */
export interface MsgDeactivateComplianceProviderResponse {
}

function createBaseComplianceCheckResult(): ComplianceCheckResult {
  return {
    checkType: 0,
    passed: false,
    details: "",
    matchScore: 0,
    checkedAt: Long.ZERO,
    providerId: "",
    referenceId: "",
  };
}

export const ComplianceCheckResult: MessageFns<ComplianceCheckResult, "virtengine.veid.v1.ComplianceCheckResult"> = {
  $type: "virtengine.veid.v1.ComplianceCheckResult" as const,

  encode(message: ComplianceCheckResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkType !== 0) {
      writer.uint32(8).int32(message.checkType);
    }
    if (message.passed !== false) {
      writer.uint32(16).bool(message.passed);
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    if (message.matchScore !== 0) {
      writer.uint32(32).int32(message.matchScore);
    }
    if (!message.checkedAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.checkedAt.toString());
    }
    if (message.providerId !== "") {
      writer.uint32(50).string(message.providerId);
    }
    if (message.referenceId !== "") {
      writer.uint32(58).string(message.referenceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceCheckResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceCheckResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.checkType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.passed = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.matchScore = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.checkedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.referenceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceCheckResult {
    return {
      checkType: isSet(object.check_type) ? complianceCheckTypeFromJSON(object.check_type) : 0,
      passed: isSet(object.passed) ? globalThis.Boolean(object.passed) : false,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      matchScore: isSet(object.match_score) ? globalThis.Number(object.match_score) : 0,
      checkedAt: isSet(object.checked_at) ? Long.fromValue(object.checked_at) : Long.ZERO,
      providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "",
      referenceId: isSet(object.reference_id) ? globalThis.String(object.reference_id) : "",
    };
  },

  toJSON(message: ComplianceCheckResult): unknown {
    const obj: any = {};
    if (message.checkType !== 0) {
      obj.check_type = complianceCheckTypeToJSON(message.checkType);
    }
    if (message.passed !== false) {
      obj.passed = message.passed;
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.matchScore !== 0) {
      obj.match_score = Math.round(message.matchScore);
    }
    if (!message.checkedAt.equals(Long.ZERO)) {
      obj.checked_at = (message.checkedAt || Long.ZERO).toString();
    }
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    if (message.referenceId !== "") {
      obj.reference_id = message.referenceId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ComplianceCheckResult>): ComplianceCheckResult {
    const message = createBaseComplianceCheckResult();
    message.checkType = object.checkType ?? 0;
    message.passed = object.passed ?? false;
    message.details = object.details ?? "";
    message.matchScore = object.matchScore ?? 0;
    message.checkedAt = (object.checkedAt !== undefined && object.checkedAt !== null)
      ? Long.fromValue(object.checkedAt)
      : Long.ZERO;
    message.providerId = object.providerId ?? "";
    message.referenceId = object.referenceId ?? "";
    return message;
  },
};

function createBaseComplianceAttestation(): ComplianceAttestation {
  return {
    validatorAddress: "",
    attestedAt: Long.ZERO,
    expiresAt: Long.ZERO,
    attestationType: "",
    attestationHash: "",
  };
}

export const ComplianceAttestation: MessageFns<ComplianceAttestation, "virtengine.veid.v1.ComplianceAttestation"> = {
  $type: "virtengine.veid.v1.ComplianceAttestation" as const,

  encode(message: ComplianceAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (!message.attestedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.attestedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.expiresAt.toString());
    }
    if (message.attestationType !== "") {
      writer.uint32(34).string(message.attestationType);
    }
    if (message.attestationHash !== "") {
      writer.uint32(42).string(message.attestationHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.attestedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.attestationType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attestationHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceAttestation {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      attestedAt: isSet(object.attested_at) ? Long.fromValue(object.attested_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      attestationType: isSet(object.attestation_type) ? globalThis.String(object.attestation_type) : "",
      attestationHash: isSet(object.attestation_hash) ? globalThis.String(object.attestation_hash) : "",
    };
  },

  toJSON(message: ComplianceAttestation): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.attestedAt.equals(Long.ZERO)) {
      obj.attested_at = (message.attestedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.attestationType !== "") {
      obj.attestation_type = message.attestationType;
    }
    if (message.attestationHash !== "") {
      obj.attestation_hash = message.attestationHash;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ComplianceAttestation>): ComplianceAttestation {
    const message = createBaseComplianceAttestation();
    message.validatorAddress = object.validatorAddress ?? "";
    message.attestedAt = (object.attestedAt !== undefined && object.attestedAt !== null)
      ? Long.fromValue(object.attestedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.attestationType = object.attestationType ?? "";
    message.attestationHash = object.attestationHash ?? "";
    return message;
  },
};

function createBaseComplianceRecord(): ComplianceRecord {
  return {
    accountAddress: "",
    status: 0,
    checkResults: [],
    lastCheckedAt: Long.ZERO,
    expiresAt: Long.ZERO,
    riskScore: 0,
    restrictedRegions: [],
    attestations: [],
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
    notes: "",
  };
}

export const ComplianceRecord: MessageFns<ComplianceRecord, "virtengine.veid.v1.ComplianceRecord"> = {
  $type: "virtengine.veid.v1.ComplianceRecord" as const,

  encode(message: ComplianceRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    for (const v of message.checkResults) {
      ComplianceCheckResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (!message.lastCheckedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastCheckedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expiresAt.toString());
    }
    if (message.riskScore !== 0) {
      writer.uint32(48).int32(message.riskScore);
    }
    for (const v of message.restrictedRegions) {
      writer.uint32(58).string(v!);
    }
    for (const v of message.attestations) {
      ComplianceAttestation.encode(v!, writer.uint32(66).fork()).join();
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.updatedAt.toString());
    }
    if (message.notes !== "") {
      writer.uint32(90).string(message.notes);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkResults.push(ComplianceCheckResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastCheckedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.riskScore = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.restrictedRegions.push(reader.string());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.attestations.push(ComplianceAttestation.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.notes = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceRecord {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      status: isSet(object.status) ? complianceStatusFromJSON(object.status) : 0,
      checkResults: globalThis.Array.isArray(object?.check_results)
        ? object.check_results.map((e: any) => ComplianceCheckResult.fromJSON(e))
        : [],
      lastCheckedAt: isSet(object.last_checked_at) ? Long.fromValue(object.last_checked_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      riskScore: isSet(object.risk_score) ? globalThis.Number(object.risk_score) : 0,
      restrictedRegions: globalThis.Array.isArray(object?.restricted_regions)
        ? object.restricted_regions.map((e: any) => globalThis.String(e))
        : [],
      attestations: globalThis.Array.isArray(object?.attestations)
        ? object.attestations.map((e: any) => ComplianceAttestation.fromJSON(e))
        : [],
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
      notes: isSet(object.notes) ? globalThis.String(object.notes) : "",
    };
  },

  toJSON(message: ComplianceRecord): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.status !== 0) {
      obj.status = complianceStatusToJSON(message.status);
    }
    if (message.checkResults?.length) {
      obj.check_results = message.checkResults.map((e) => ComplianceCheckResult.toJSON(e));
    }
    if (!message.lastCheckedAt.equals(Long.ZERO)) {
      obj.last_checked_at = (message.lastCheckedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.riskScore !== 0) {
      obj.risk_score = Math.round(message.riskScore);
    }
    if (message.restrictedRegions?.length) {
      obj.restricted_regions = message.restrictedRegions;
    }
    if (message.attestations?.length) {
      obj.attestations = message.attestations.map((e) => ComplianceAttestation.toJSON(e));
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    if (message.notes !== "") {
      obj.notes = message.notes;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ComplianceRecord>): ComplianceRecord {
    const message = createBaseComplianceRecord();
    message.accountAddress = object.accountAddress ?? "";
    message.status = object.status ?? 0;
    message.checkResults = object.checkResults?.map((e) => ComplianceCheckResult.fromPartial(e)) || [];
    message.lastCheckedAt = (object.lastCheckedAt !== undefined && object.lastCheckedAt !== null)
      ? Long.fromValue(object.lastCheckedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.riskScore = object.riskScore ?? 0;
    message.restrictedRegions = object.restrictedRegions?.map((e) => e) || [];
    message.attestations = object.attestations?.map((e) => ComplianceAttestation.fromPartial(e)) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.notes = object.notes ?? "";
    return message;
  },
};

function createBaseComplianceParams(): ComplianceParams {
  return {
    requireSanctionCheck: false,
    requirePepCheck: false,
    checkExpiryBlocks: Long.ZERO,
    riskScoreThreshold: 0,
    restrictedCountries: [],
    minAttestationsRequired: 0,
    enableAutoExpiry: false,
    requireDocumentVerification: false,
  };
}

export const ComplianceParams: MessageFns<ComplianceParams, "virtengine.veid.v1.ComplianceParams"> = {
  $type: "virtengine.veid.v1.ComplianceParams" as const,

  encode(message: ComplianceParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requireSanctionCheck !== false) {
      writer.uint32(8).bool(message.requireSanctionCheck);
    }
    if (message.requirePepCheck !== false) {
      writer.uint32(16).bool(message.requirePepCheck);
    }
    if (!message.checkExpiryBlocks.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.checkExpiryBlocks.toString());
    }
    if (message.riskScoreThreshold !== 0) {
      writer.uint32(32).int32(message.riskScoreThreshold);
    }
    for (const v of message.restrictedCountries) {
      writer.uint32(42).string(v!);
    }
    if (message.minAttestationsRequired !== 0) {
      writer.uint32(48).int32(message.minAttestationsRequired);
    }
    if (message.enableAutoExpiry !== false) {
      writer.uint32(56).bool(message.enableAutoExpiry);
    }
    if (message.requireDocumentVerification !== false) {
      writer.uint32(64).bool(message.requireDocumentVerification);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requireSanctionCheck = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.requirePepCheck = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.checkExpiryBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.riskScoreThreshold = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.restrictedCountries.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.minAttestationsRequired = reader.int32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.enableAutoExpiry = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.requireDocumentVerification = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceParams {
    return {
      requireSanctionCheck: isSet(object.require_sanction_check)
        ? globalThis.Boolean(object.require_sanction_check)
        : false,
      requirePepCheck: isSet(object.require_pep_check) ? globalThis.Boolean(object.require_pep_check) : false,
      checkExpiryBlocks: isSet(object.check_expiry_blocks) ? Long.fromValue(object.check_expiry_blocks) : Long.ZERO,
      riskScoreThreshold: isSet(object.risk_score_threshold) ? globalThis.Number(object.risk_score_threshold) : 0,
      restrictedCountries: globalThis.Array.isArray(object?.restricted_countries)
        ? object.restricted_countries.map((e: any) => globalThis.String(e))
        : [],
      minAttestationsRequired: isSet(object.min_attestations_required)
        ? globalThis.Number(object.min_attestations_required)
        : 0,
      enableAutoExpiry: isSet(object.enable_auto_expiry) ? globalThis.Boolean(object.enable_auto_expiry) : false,
      requireDocumentVerification: isSet(object.require_document_verification)
        ? globalThis.Boolean(object.require_document_verification)
        : false,
    };
  },

  toJSON(message: ComplianceParams): unknown {
    const obj: any = {};
    if (message.requireSanctionCheck !== false) {
      obj.require_sanction_check = message.requireSanctionCheck;
    }
    if (message.requirePepCheck !== false) {
      obj.require_pep_check = message.requirePepCheck;
    }
    if (!message.checkExpiryBlocks.equals(Long.ZERO)) {
      obj.check_expiry_blocks = (message.checkExpiryBlocks || Long.ZERO).toString();
    }
    if (message.riskScoreThreshold !== 0) {
      obj.risk_score_threshold = Math.round(message.riskScoreThreshold);
    }
    if (message.restrictedCountries?.length) {
      obj.restricted_countries = message.restrictedCountries;
    }
    if (message.minAttestationsRequired !== 0) {
      obj.min_attestations_required = Math.round(message.minAttestationsRequired);
    }
    if (message.enableAutoExpiry !== false) {
      obj.enable_auto_expiry = message.enableAutoExpiry;
    }
    if (message.requireDocumentVerification !== false) {
      obj.require_document_verification = message.requireDocumentVerification;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ComplianceParams>): ComplianceParams {
    const message = createBaseComplianceParams();
    message.requireSanctionCheck = object.requireSanctionCheck ?? false;
    message.requirePepCheck = object.requirePepCheck ?? false;
    message.checkExpiryBlocks = (object.checkExpiryBlocks !== undefined && object.checkExpiryBlocks !== null)
      ? Long.fromValue(object.checkExpiryBlocks)
      : Long.ZERO;
    message.riskScoreThreshold = object.riskScoreThreshold ?? 0;
    message.restrictedCountries = object.restrictedCountries?.map((e) => e) || [];
    message.minAttestationsRequired = object.minAttestationsRequired ?? 0;
    message.enableAutoExpiry = object.enableAutoExpiry ?? false;
    message.requireDocumentVerification = object.requireDocumentVerification ?? false;
    return message;
  },
};

function createBaseComplianceProvider(): ComplianceProvider {
  return {
    providerId: "",
    name: "",
    providerAddress: "",
    supportedCheckTypes: [],
    isActive: false,
    registeredAt: Long.ZERO,
    lastActiveAt: Long.ZERO,
  };
}

export const ComplianceProvider: MessageFns<ComplianceProvider, "virtengine.veid.v1.ComplianceProvider"> = {
  $type: "virtengine.veid.v1.ComplianceProvider" as const,

  encode(message: ComplianceProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.providerAddress !== "") {
      writer.uint32(26).string(message.providerAddress);
    }
    for (const v of message.supportedCheckTypes) {
      writer.uint32(32).int32(v!);
    }
    if (message.isActive !== false) {
      writer.uint32(40).bool(message.isActive);
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.registeredAt.toString());
    }
    if (!message.lastActiveAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.lastActiveAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ComplianceProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseComplianceProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.supportedCheckTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.supportedCheckTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isActive = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.lastActiveAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ComplianceProvider {
    return {
      providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      supportedCheckTypes: globalThis.Array.isArray(object?.supported_check_types)
        ? object.supported_check_types.map((e: any) => complianceCheckTypeFromJSON(e))
        : [],
      isActive: isSet(object.is_active) ? globalThis.Boolean(object.is_active) : false,
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
      lastActiveAt: isSet(object.last_active_at) ? Long.fromValue(object.last_active_at) : Long.ZERO,
    };
  },

  toJSON(message: ComplianceProvider): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.supportedCheckTypes?.length) {
      obj.supported_check_types = message.supportedCheckTypes.map((e) => complianceCheckTypeToJSON(e));
    }
    if (message.isActive !== false) {
      obj.is_active = message.isActive;
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    if (!message.lastActiveAt.equals(Long.ZERO)) {
      obj.last_active_at = (message.lastActiveAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ComplianceProvider>): ComplianceProvider {
    const message = createBaseComplianceProvider();
    message.providerId = object.providerId ?? "";
    message.name = object.name ?? "";
    message.providerAddress = object.providerAddress ?? "";
    message.supportedCheckTypes = object.supportedCheckTypes?.map((e) => e) || [];
    message.isActive = object.isActive ?? false;
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    message.lastActiveAt = (object.lastActiveAt !== undefined && object.lastActiveAt !== null)
      ? Long.fromValue(object.lastActiveAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgSubmitComplianceCheck(): MsgSubmitComplianceCheck {
  return { providerAddress: "", targetAddress: "", checkResults: [], providerId: "" };
}

export const MsgSubmitComplianceCheck: MessageFns<
  MsgSubmitComplianceCheck,
  "virtengine.veid.v1.MsgSubmitComplianceCheck"
> = {
  $type: "virtengine.veid.v1.MsgSubmitComplianceCheck" as const,

  encode(message: MsgSubmitComplianceCheck, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerAddress !== "") {
      writer.uint32(10).string(message.providerAddress);
    }
    if (message.targetAddress !== "") {
      writer.uint32(18).string(message.targetAddress);
    }
    for (const v of message.checkResults) {
      ComplianceCheckResult.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.providerId !== "") {
      writer.uint32(34).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitComplianceCheck {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitComplianceCheck();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.checkResults.push(ComplianceCheckResult.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitComplianceCheck {
    return {
      providerAddress: isSet(object.provider_address) ? globalThis.String(object.provider_address) : "",
      targetAddress: isSet(object.target_address) ? globalThis.String(object.target_address) : "",
      checkResults: globalThis.Array.isArray(object?.check_results)
        ? object.check_results.map((e: any) => ComplianceCheckResult.fromJSON(e))
        : [],
      providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "",
    };
  },

  toJSON(message: MsgSubmitComplianceCheck): unknown {
    const obj: any = {};
    if (message.providerAddress !== "") {
      obj.provider_address = message.providerAddress;
    }
    if (message.targetAddress !== "") {
      obj.target_address = message.targetAddress;
    }
    if (message.checkResults?.length) {
      obj.check_results = message.checkResults.map((e) => ComplianceCheckResult.toJSON(e));
    }
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitComplianceCheck>): MsgSubmitComplianceCheck {
    const message = createBaseMsgSubmitComplianceCheck();
    message.providerAddress = object.providerAddress ?? "";
    message.targetAddress = object.targetAddress ?? "";
    message.checkResults = object.checkResults?.map((e) => ComplianceCheckResult.fromPartial(e)) || [];
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseMsgSubmitComplianceCheckResponse(): MsgSubmitComplianceCheckResponse {
  return { status: 0, riskScore: 0 };
}

export const MsgSubmitComplianceCheckResponse: MessageFns<
  MsgSubmitComplianceCheckResponse,
  "virtengine.veid.v1.MsgSubmitComplianceCheckResponse"
> = {
  $type: "virtengine.veid.v1.MsgSubmitComplianceCheckResponse" as const,

  encode(message: MsgSubmitComplianceCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.riskScore !== 0) {
      writer.uint32(16).int32(message.riskScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSubmitComplianceCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSubmitComplianceCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.riskScore = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSubmitComplianceCheckResponse {
    return {
      status: isSet(object.status) ? complianceStatusFromJSON(object.status) : 0,
      riskScore: isSet(object.risk_score) ? globalThis.Number(object.risk_score) : 0,
    };
  },

  toJSON(message: MsgSubmitComplianceCheckResponse): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = complianceStatusToJSON(message.status);
    }
    if (message.riskScore !== 0) {
      obj.risk_score = Math.round(message.riskScore);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSubmitComplianceCheckResponse>): MsgSubmitComplianceCheckResponse {
    const message = createBaseMsgSubmitComplianceCheckResponse();
    message.status = object.status ?? 0;
    message.riskScore = object.riskScore ?? 0;
    return message;
  },
};

function createBaseMsgAttestCompliance(): MsgAttestCompliance {
  return { validatorAddress: "", targetAddress: "", attestationType: "", expiryBlocks: Long.ZERO };
}

export const MsgAttestCompliance: MessageFns<MsgAttestCompliance, "virtengine.veid.v1.MsgAttestCompliance"> = {
  $type: "virtengine.veid.v1.MsgAttestCompliance" as const,

  encode(message: MsgAttestCompliance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.targetAddress !== "") {
      writer.uint32(18).string(message.targetAddress);
    }
    if (message.attestationType !== "") {
      writer.uint32(26).string(message.attestationType);
    }
    if (!message.expiryBlocks.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.expiryBlocks.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAttestCompliance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAttestCompliance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.targetAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attestationType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.expiryBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAttestCompliance {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      targetAddress: isSet(object.target_address) ? globalThis.String(object.target_address) : "",
      attestationType: isSet(object.attestation_type) ? globalThis.String(object.attestation_type) : "",
      expiryBlocks: isSet(object.expiry_blocks) ? Long.fromValue(object.expiry_blocks) : Long.ZERO,
    };
  },

  toJSON(message: MsgAttestCompliance): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.targetAddress !== "") {
      obj.target_address = message.targetAddress;
    }
    if (message.attestationType !== "") {
      obj.attestation_type = message.attestationType;
    }
    if (!message.expiryBlocks.equals(Long.ZERO)) {
      obj.expiry_blocks = (message.expiryBlocks || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgAttestCompliance>): MsgAttestCompliance {
    const message = createBaseMsgAttestCompliance();
    message.validatorAddress = object.validatorAddress ?? "";
    message.targetAddress = object.targetAddress ?? "";
    message.attestationType = object.attestationType ?? "";
    message.expiryBlocks = (object.expiryBlocks !== undefined && object.expiryBlocks !== null)
      ? Long.fromValue(object.expiryBlocks)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgAttestComplianceResponse(): MsgAttestComplianceResponse {
  return { attestedAt: Long.ZERO, expiresAt: Long.ZERO };
}

export const MsgAttestComplianceResponse: MessageFns<
  MsgAttestComplianceResponse,
  "virtengine.veid.v1.MsgAttestComplianceResponse"
> = {
  $type: "virtengine.veid.v1.MsgAttestComplianceResponse" as const,

  encode(message: MsgAttestComplianceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.attestedAt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.attestedAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAttestComplianceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAttestComplianceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.attestedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAttestComplianceResponse {
    return {
      attestedAt: isSet(object.attested_at) ? Long.fromValue(object.attested_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgAttestComplianceResponse): unknown {
    const obj: any = {};
    if (!message.attestedAt.equals(Long.ZERO)) {
      obj.attested_at = (message.attestedAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgAttestComplianceResponse>): MsgAttestComplianceResponse {
    const message = createBaseMsgAttestComplianceResponse();
    message.attestedAt = (object.attestedAt !== undefined && object.attestedAt !== null)
      ? Long.fromValue(object.attestedAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgUpdateComplianceParams(): MsgUpdateComplianceParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateComplianceParams: MessageFns<
  MsgUpdateComplianceParams,
  "virtengine.veid.v1.MsgUpdateComplianceParams"
> = {
  $type: "virtengine.veid.v1.MsgUpdateComplianceParams" as const,

  encode(message: MsgUpdateComplianceParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      ComplianceParams.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateComplianceParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateComplianceParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = ComplianceParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateComplianceParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? ComplianceParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateComplianceParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = ComplianceParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateComplianceParams>): MsgUpdateComplianceParams {
    const message = createBaseMsgUpdateComplianceParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? ComplianceParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateComplianceParamsResponse(): MsgUpdateComplianceParamsResponse {
  return {};
}

export const MsgUpdateComplianceParamsResponse: MessageFns<
  MsgUpdateComplianceParamsResponse,
  "virtengine.veid.v1.MsgUpdateComplianceParamsResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateComplianceParamsResponse" as const,

  encode(_: MsgUpdateComplianceParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateComplianceParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateComplianceParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateComplianceParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateComplianceParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateComplianceParamsResponse>): MsgUpdateComplianceParamsResponse {
    const message = createBaseMsgUpdateComplianceParamsResponse();
    return message;
  },
};

function createBaseMsgRegisterComplianceProvider(): MsgRegisterComplianceProvider {
  return { authority: "", provider: undefined };
}

export const MsgRegisterComplianceProvider: MessageFns<
  MsgRegisterComplianceProvider,
  "virtengine.veid.v1.MsgRegisterComplianceProvider"
> = {
  $type: "virtengine.veid.v1.MsgRegisterComplianceProvider" as const,

  encode(message: MsgRegisterComplianceProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.provider !== undefined) {
      ComplianceProvider.encode(message.provider, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterComplianceProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterComplianceProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.provider = ComplianceProvider.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterComplianceProvider {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      provider: isSet(object.provider) ? ComplianceProvider.fromJSON(object.provider) : undefined,
    };
  },

  toJSON(message: MsgRegisterComplianceProvider): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.provider !== undefined) {
      obj.provider = ComplianceProvider.toJSON(message.provider);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterComplianceProvider>): MsgRegisterComplianceProvider {
    const message = createBaseMsgRegisterComplianceProvider();
    message.authority = object.authority ?? "";
    message.provider = (object.provider !== undefined && object.provider !== null)
      ? ComplianceProvider.fromPartial(object.provider)
      : undefined;
    return message;
  },
};

function createBaseMsgRegisterComplianceProviderResponse(): MsgRegisterComplianceProviderResponse {
  return { providerId: "" };
}

export const MsgRegisterComplianceProviderResponse: MessageFns<
  MsgRegisterComplianceProviderResponse,
  "virtengine.veid.v1.MsgRegisterComplianceProviderResponse"
> = {
  $type: "virtengine.veid.v1.MsgRegisterComplianceProviderResponse" as const,

  encode(message: MsgRegisterComplianceProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.providerId !== "") {
      writer.uint32(10).string(message.providerId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterComplianceProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterComplianceProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterComplianceProviderResponse {
    return { providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "" };
  },

  toJSON(message: MsgRegisterComplianceProviderResponse): unknown {
    const obj: any = {};
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterComplianceProviderResponse>): MsgRegisterComplianceProviderResponse {
    const message = createBaseMsgRegisterComplianceProviderResponse();
    message.providerId = object.providerId ?? "";
    return message;
  },
};

function createBaseMsgDeactivateComplianceProvider(): MsgDeactivateComplianceProvider {
  return { authority: "", providerId: "", reason: "" };
}

export const MsgDeactivateComplianceProvider: MessageFns<
  MsgDeactivateComplianceProvider,
  "virtengine.veid.v1.MsgDeactivateComplianceProvider"
> = {
  $type: "virtengine.veid.v1.MsgDeactivateComplianceProvider" as const,

  encode(message: MsgDeactivateComplianceProvider, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.providerId !== "") {
      writer.uint32(18).string(message.providerId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateComplianceProvider {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateComplianceProvider();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeactivateComplianceProvider {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      providerId: isSet(object.provider_id) ? globalThis.String(object.provider_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgDeactivateComplianceProvider): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.providerId !== "") {
      obj.provider_id = message.providerId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgDeactivateComplianceProvider>): MsgDeactivateComplianceProvider {
    const message = createBaseMsgDeactivateComplianceProvider();
    message.authority = object.authority ?? "";
    message.providerId = object.providerId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgDeactivateComplianceProviderResponse(): MsgDeactivateComplianceProviderResponse {
  return {};
}

export const MsgDeactivateComplianceProviderResponse: MessageFns<
  MsgDeactivateComplianceProviderResponse,
  "virtengine.veid.v1.MsgDeactivateComplianceProviderResponse"
> = {
  $type: "virtengine.veid.v1.MsgDeactivateComplianceProviderResponse" as const,

  encode(_: MsgDeactivateComplianceProviderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeactivateComplianceProviderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeactivateComplianceProviderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeactivateComplianceProviderResponse {
    return {};
  },

  toJSON(_: MsgDeactivateComplianceProviderResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgDeactivateComplianceProviderResponse>): MsgDeactivateComplianceProviderResponse {
    const message = createBaseMsgDeactivateComplianceProviderResponse();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
