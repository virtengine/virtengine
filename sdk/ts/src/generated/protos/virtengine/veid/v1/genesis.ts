import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/genesis.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { AppealParams, AppealRecord } from "./appeal.ts";
import { ComplianceParams, ComplianceProvider, ComplianceRecord } from "./compliance.ts";
import {
  MLModelInfo,
  ModelParams,
  ModelUpdateProposal,
  ModelVersionHistory,
  ModelVersionState,
  ValidatorModelReport,
} from "./model.ts";
import { ApprovedClient, BorderlineParams, IdentityRecord, IdentityScope, IdentityScore, Params } from "./types.ts";

/** GenesisState defines the veid module's genesis state */
export interface GenesisState {
  /** IdentityRecords are the initial identity records */
  identityRecords: IdentityRecord[];
  /** Scopes are the initial identity scopes */
  scopes: IdentityScope[];
  /** ApprovedClients are the initially approved clients */
  approvedClients: ApprovedClient[];
  /** Params are the module parameters */
  params:
    | Params
    | undefined;
  /** Scores are the initial identity scores */
  scores: IdentityScore[];
  /** BorderlineParams are the borderline fallback parameters */
  borderlineParams:
    | BorderlineParams
    | undefined;
  /** AppealRecords are the initial appeal records */
  appealRecords: AppealRecord[];
  /** AppealParams are the appeal system parameters */
  appealParams:
    | AppealParams
    | undefined;
  /** ComplianceRecords are the initial compliance records */
  complianceRecords: ComplianceRecord[];
  /** ComplianceProviders are the registered compliance providers */
  complianceProviders: ComplianceProvider[];
  /** ComplianceParams are the compliance configuration parameters */
  complianceParams:
    | ComplianceParams
    | undefined;
  /** MLModels are the registered ML models */
  mlModels: MLModelInfo[];
  /** ModelVersionState is the current active model versions */
  modelVersionState:
    | ModelVersionState
    | undefined;
  /** ModelVersionHistory is the model version change history */
  modelVersionHistory: ModelVersionHistory[];
  /** ModelParams are the model management parameters */
  modelParams:
    | ModelParams
    | undefined;
  /** PendingModelProposals are the pending model update proposals */
  pendingModelProposals: ModelUpdateProposal[];
  /** ValidatorModelReports are the validator model version reports */
  validatorModelReports: ValidatorModelReport[];
}

function createBaseGenesisState(): GenesisState {
  return {
    identityRecords: [],
    scopes: [],
    approvedClients: [],
    params: undefined,
    scores: [],
    borderlineParams: undefined,
    appealRecords: [],
    appealParams: undefined,
    complianceRecords: [],
    complianceProviders: [],
    complianceParams: undefined,
    mlModels: [],
    modelVersionState: undefined,
    modelVersionHistory: [],
    modelParams: undefined,
    pendingModelProposals: [],
    validatorModelReports: [],
  };
}

export const GenesisState: MessageFns<GenesisState, "virtengine.veid.v1.GenesisState"> = {
  $type: "virtengine.veid.v1.GenesisState" as const,

  encode(message: GenesisState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.identityRecords) {
      IdentityRecord.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.scopes) {
      IdentityScope.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.approvedClients) {
      ApprovedClient.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(34).fork()).join();
    }
    for (const v of message.scores) {
      IdentityScore.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.borderlineParams !== undefined) {
      BorderlineParams.encode(message.borderlineParams, writer.uint32(50).fork()).join();
    }
    for (const v of message.appealRecords) {
      AppealRecord.encode(v!, writer.uint32(58).fork()).join();
    }
    if (message.appealParams !== undefined) {
      AppealParams.encode(message.appealParams, writer.uint32(66).fork()).join();
    }
    for (const v of message.complianceRecords) {
      ComplianceRecord.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.complianceProviders) {
      ComplianceProvider.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.complianceParams !== undefined) {
      ComplianceParams.encode(message.complianceParams, writer.uint32(90).fork()).join();
    }
    for (const v of message.mlModels) {
      MLModelInfo.encode(v!, writer.uint32(98).fork()).join();
    }
    if (message.modelVersionState !== undefined) {
      ModelVersionState.encode(message.modelVersionState, writer.uint32(106).fork()).join();
    }
    for (const v of message.modelVersionHistory) {
      ModelVersionHistory.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.modelParams !== undefined) {
      ModelParams.encode(message.modelParams, writer.uint32(122).fork()).join();
    }
    for (const v of message.pendingModelProposals) {
      ModelUpdateProposal.encode(v!, writer.uint32(130).fork()).join();
    }
    for (const v of message.validatorModelReports) {
      ValidatorModelReport.encode(v!, writer.uint32(138).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenesisState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenesisState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.identityRecords.push(IdentityRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopes.push(IdentityScope.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.approvedClients.push(ApprovedClient.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.scores.push(IdentityScore.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.borderlineParams = BorderlineParams.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.appealRecords.push(AppealRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.appealParams = AppealParams.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.complianceRecords.push(ComplianceRecord.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.complianceProviders.push(ComplianceProvider.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.complianceParams = ComplianceParams.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.mlModels.push(MLModelInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.modelVersionState = ModelVersionState.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.modelVersionHistory.push(ModelVersionHistory.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.modelParams = ModelParams.decode(reader, reader.uint32());
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.pendingModelProposals.push(ModelUpdateProposal.decode(reader, reader.uint32()));
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.validatorModelReports.push(ValidatorModelReport.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GenesisState {
    return {
      identityRecords: globalThis.Array.isArray(object?.identity_records)
        ? object.identity_records.map((e: any) => IdentityRecord.fromJSON(e))
        : [],
      scopes: globalThis.Array.isArray(object?.scopes) ? object.scopes.map((e: any) => IdentityScope.fromJSON(e)) : [],
      approvedClients: globalThis.Array.isArray(object?.approved_clients)
        ? object.approved_clients.map((e: any) => ApprovedClient.fromJSON(e))
        : [],
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
      scores: globalThis.Array.isArray(object?.scores) ? object.scores.map((e: any) => IdentityScore.fromJSON(e)) : [],
      borderlineParams: isSet(object.borderline_params)
        ? BorderlineParams.fromJSON(object.borderline_params)
        : undefined,
      appealRecords: globalThis.Array.isArray(object?.appeal_records)
        ? object.appeal_records.map((e: any) => AppealRecord.fromJSON(e))
        : [],
      appealParams: isSet(object.appeal_params) ? AppealParams.fromJSON(object.appeal_params) : undefined,
      complianceRecords: globalThis.Array.isArray(object?.compliance_records)
        ? object.compliance_records.map((e: any) => ComplianceRecord.fromJSON(e))
        : [],
      complianceProviders: globalThis.Array.isArray(object?.compliance_providers)
        ? object.compliance_providers.map((e: any) => ComplianceProvider.fromJSON(e))
        : [],
      complianceParams: isSet(object.compliance_params)
        ? ComplianceParams.fromJSON(object.compliance_params)
        : undefined,
      mlModels: globalThis.Array.isArray(object?.ml_models)
        ? object.ml_models.map((e: any) => MLModelInfo.fromJSON(e))
        : [],
      modelVersionState: isSet(object.model_version_state)
        ? ModelVersionState.fromJSON(object.model_version_state)
        : undefined,
      modelVersionHistory: globalThis.Array.isArray(object?.model_version_history)
        ? object.model_version_history.map((e: any) => ModelVersionHistory.fromJSON(e))
        : [],
      modelParams: isSet(object.model_params) ? ModelParams.fromJSON(object.model_params) : undefined,
      pendingModelProposals: globalThis.Array.isArray(object?.pending_model_proposals)
        ? object.pending_model_proposals.map((e: any) => ModelUpdateProposal.fromJSON(e))
        : [],
      validatorModelReports: globalThis.Array.isArray(object?.validator_model_reports)
        ? object.validator_model_reports.map((e: any) => ValidatorModelReport.fromJSON(e))
        : [],
    };
  },

  toJSON(message: GenesisState): unknown {
    const obj: any = {};
    if (message.identityRecords?.length) {
      obj.identity_records = message.identityRecords.map((e) => IdentityRecord.toJSON(e));
    }
    if (message.scopes?.length) {
      obj.scopes = message.scopes.map((e) => IdentityScope.toJSON(e));
    }
    if (message.approvedClients?.length) {
      obj.approved_clients = message.approvedClients.map((e) => ApprovedClient.toJSON(e));
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    if (message.scores?.length) {
      obj.scores = message.scores.map((e) => IdentityScore.toJSON(e));
    }
    if (message.borderlineParams !== undefined) {
      obj.borderline_params = BorderlineParams.toJSON(message.borderlineParams);
    }
    if (message.appealRecords?.length) {
      obj.appeal_records = message.appealRecords.map((e) => AppealRecord.toJSON(e));
    }
    if (message.appealParams !== undefined) {
      obj.appeal_params = AppealParams.toJSON(message.appealParams);
    }
    if (message.complianceRecords?.length) {
      obj.compliance_records = message.complianceRecords.map((e) => ComplianceRecord.toJSON(e));
    }
    if (message.complianceProviders?.length) {
      obj.compliance_providers = message.complianceProviders.map((e) => ComplianceProvider.toJSON(e));
    }
    if (message.complianceParams !== undefined) {
      obj.compliance_params = ComplianceParams.toJSON(message.complianceParams);
    }
    if (message.mlModels?.length) {
      obj.ml_models = message.mlModels.map((e) => MLModelInfo.toJSON(e));
    }
    if (message.modelVersionState !== undefined) {
      obj.model_version_state = ModelVersionState.toJSON(message.modelVersionState);
    }
    if (message.modelVersionHistory?.length) {
      obj.model_version_history = message.modelVersionHistory.map((e) => ModelVersionHistory.toJSON(e));
    }
    if (message.modelParams !== undefined) {
      obj.model_params = ModelParams.toJSON(message.modelParams);
    }
    if (message.pendingModelProposals?.length) {
      obj.pending_model_proposals = message.pendingModelProposals.map((e) => ModelUpdateProposal.toJSON(e));
    }
    if (message.validatorModelReports?.length) {
      obj.validator_model_reports = message.validatorModelReports.map((e) => ValidatorModelReport.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<GenesisState>): GenesisState {
    const message = createBaseGenesisState();
    message.identityRecords = object.identityRecords?.map((e) => IdentityRecord.fromPartial(e)) || [];
    message.scopes = object.scopes?.map((e) => IdentityScope.fromPartial(e)) || [];
    message.approvedClients = object.approvedClients?.map((e) => ApprovedClient.fromPartial(e)) || [];
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    message.scores = object.scores?.map((e) => IdentityScore.fromPartial(e)) || [];
    message.borderlineParams = (object.borderlineParams !== undefined && object.borderlineParams !== null)
      ? BorderlineParams.fromPartial(object.borderlineParams)
      : undefined;
    message.appealRecords = object.appealRecords?.map((e) => AppealRecord.fromPartial(e)) || [];
    message.appealParams = (object.appealParams !== undefined && object.appealParams !== null)
      ? AppealParams.fromPartial(object.appealParams)
      : undefined;
    message.complianceRecords = object.complianceRecords?.map((e) => ComplianceRecord.fromPartial(e)) || [];
    message.complianceProviders = object.complianceProviders?.map((e) => ComplianceProvider.fromPartial(e)) || [];
    message.complianceParams = (object.complianceParams !== undefined && object.complianceParams !== null)
      ? ComplianceParams.fromPartial(object.complianceParams)
      : undefined;
    message.mlModels = object.mlModels?.map((e) => MLModelInfo.fromPartial(e)) || [];
    message.modelVersionState = (object.modelVersionState !== undefined && object.modelVersionState !== null)
      ? ModelVersionState.fromPartial(object.modelVersionState)
      : undefined;
    message.modelVersionHistory = object.modelVersionHistory?.map((e) => ModelVersionHistory.fromPartial(e)) || [];
    message.modelParams = (object.modelParams !== undefined && object.modelParams !== null)
      ? ModelParams.fromPartial(object.modelParams)
      : undefined;
    message.pendingModelProposals = object.pendingModelProposals?.map((e) => ModelUpdateProposal.fromPartial(e)) || [];
    message.validatorModelReports = object.validatorModelReports?.map((e) => ValidatorModelReport.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
