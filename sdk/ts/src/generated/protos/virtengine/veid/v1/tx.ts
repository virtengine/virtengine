import { bytesFromBase64, base64FromBytes, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import {
  BorderlineParams,
  ConsentSettings,
  EncryptedPayloadEnvelope,
  GlobalConsentUpdate,
  IdentityTier,
  identityTierFromJSON,
  identityTierToJSON,
  Params,
  ScopeType,
  scopeTypeFromJSON,
  scopeTypeToJSON,
  VerificationStatus,
  verificationStatusFromJSON,
  verificationStatusToJSON,
} from "./types.ts";

/** MsgUploadScope is the message for uploading an identity scope */
export interface MsgUploadScope {
  /** Sender is the account uploading the scope */
  sender: string;
  /** ScopeID is a unique identifier for this scope */
  scopeId: string;
  /** ScopeType indicates what kind of identity data this scope contains */
  scopeType: ScopeType;
  /** EncryptedPayload is the encrypted identity data */
  encryptedPayload:
    | EncryptedPayloadEnvelope
    | undefined;
  /** Salt is a per-upload unique salt for cryptographic binding */
  salt: Uint8Array;
  /** DeviceFingerprint is the device that captured/uploaded this data */
  deviceFingerprint: string;
  /** ClientID is the approved client that facilitated this upload */
  clientId: string;
  /** ClientSignature is the signature from the approved client */
  clientSignature: Uint8Array;
  /** UserSignature is the signature from the user authorizing this upload */
  userSignature: Uint8Array;
  /** PayloadHash is the hash of the encrypted payload for integrity */
  payloadHash: Uint8Array;
  /** CaptureTimestamp is when the data was captured (Unix timestamp) */
  captureTimestamp: Long;
  /** GeoHint is an optional coarse geographic hint */
  geoHint: string;
}

/** MsgUploadScopeResponse is the response for MsgUploadScope */
export interface MsgUploadScopeResponse {
  /** ScopeID is the ID of the uploaded scope */
  scopeId: string;
  /** Status is the initial verification status */
  status: VerificationStatus;
  /** UploadedAt is when the scope was uploaded (Unix timestamp) */
  uploadedAt: Long;
}

/** MsgRevokeScope is the message for revoking an identity scope */
export interface MsgRevokeScope {
  /** Sender is the account revoking the scope */
  sender: string;
  /** ScopeID is the unique identifier of the scope to revoke */
  scopeId: string;
  /** Reason is the reason for revocation */
  reason: string;
}

/** MsgRevokeScopeResponse is the response for MsgRevokeScope */
export interface MsgRevokeScopeResponse {
  /** ScopeID is the ID of the revoked scope */
  scopeId: string;
  /** RevokedAt is when the scope was revoked (Unix timestamp) */
  revokedAt: Long;
}

/** MsgRequestVerification is the message for requesting verification of a scope */
export interface MsgRequestVerification {
  /** Sender is the account requesting verification */
  sender: string;
  /** ScopeID is the unique identifier of the scope to verify */
  scopeId: string;
}

/** MsgRequestVerificationResponse is the response for MsgRequestVerification */
export interface MsgRequestVerificationResponse {
  /** ScopeID is the ID of the scope */
  scopeId: string;
  /** Status is the new verification status */
  status: VerificationStatus;
  /** RequestedAt is when verification was requested (Unix timestamp) */
  requestedAt: Long;
}

/** MsgUpdateVerificationStatus is the message for validators to update verification status */
export interface MsgUpdateVerificationStatus {
  /** Sender is the validator updating the status */
  sender: string;
  /** AccountAddress is the account whose scope is being updated */
  accountAddress: string;
  /** ScopeID is the unique identifier of the scope */
  scopeId: string;
  /** NewStatus is the new verification status */
  newStatus: VerificationStatus;
  /** Reason is the reason for the status update */
  reason: string;
}

/** MsgUpdateVerificationStatusResponse is the response for MsgUpdateVerificationStatus */
export interface MsgUpdateVerificationStatusResponse {
  /** ScopeID is the ID of the scope */
  scopeId: string;
  /** PreviousStatus is the previous verification status */
  previousStatus: VerificationStatus;
  /** NewStatus is the new verification status */
  newStatus: VerificationStatus;
  /** UpdatedAt is when the status was updated (Unix timestamp) */
  updatedAt: Long;
}

/** MsgUpdateScore is the message for validators to update identity score */
export interface MsgUpdateScore {
  /** Sender is the validator updating the score */
  sender: string;
  /** AccountAddress is the account whose score is being updated */
  accountAddress: string;
  /** NewScore is the new identity score (0-100) */
  newScore: number;
  /** ScoreVersion is the ML model version used */
  scoreVersion: string;
}

/** MsgUpdateScoreResponse is the response for MsgUpdateScore */
export interface MsgUpdateScoreResponse {
  /** AccountAddress is the account whose score was updated */
  accountAddress: string;
  /** PreviousScore is the previous identity score */
  previousScore: number;
  /** NewScore is the new identity score */
  newScore: number;
  /** PreviousTier is the previous identity tier */
  previousTier: IdentityTier;
  /** NewTier is the new identity tier */
  newTier: IdentityTier;
  /** UpdatedAt is when the score was updated (Unix timestamp) */
  updatedAt: Long;
}

/** MsgCreateIdentityWallet is the message for creating an identity wallet */
export interface MsgCreateIdentityWallet {
  /** Sender is the account creating the wallet */
  sender: string;
  /** BindingSignature is the signature proving ownership of the account */
  bindingSignature: Uint8Array;
  /** BindingPubKey is the public key used for the binding signature */
  bindingPubKey: Uint8Array;
  /** InitialConsent contains optional initial consent settings */
  initialConsent:
    | ConsentSettings
    | undefined;
  /** Metadata contains optional wallet metadata */
  metadata: { [key: string]: string };
}

export interface MsgCreateIdentityWallet_MetadataEntry {
  key: string;
  value: string;
}

/** MsgCreateIdentityWalletResponse is the response for MsgCreateIdentityWallet */
export interface MsgCreateIdentityWalletResponse {
  /** WalletID is the ID of the created wallet */
  walletId: string;
  /** CreatedAt is when the wallet was created (Unix timestamp) */
  createdAt: Long;
}

/** MsgAddScopeToWallet is the message for adding a scope reference to a wallet */
export interface MsgAddScopeToWallet {
  /** Sender is the account that owns the wallet */
  sender: string;
  /** ScopeID is the unique identifier of the scope to add */
  scopeId: string;
  /** ScopeType is the type of scope being added */
  scopeType: ScopeType;
  /** EnvelopeHash is the hash of the encrypted scope envelope */
  envelopeHash: Uint8Array;
  /** UserSignature authorizes adding this scope to the wallet */
  userSignature: Uint8Array;
  /** GrantConsent indicates if consent should be granted for this scope */
  grantConsent: boolean;
  /** ConsentPurpose describes the purpose for consent */
  consentPurpose: string;
  /** ConsentExpiresAt is when consent expires (Unix timestamp) */
  consentExpiresAt: Long;
}

/** MsgAddScopeToWalletResponse is the response for MsgAddScopeToWallet */
export interface MsgAddScopeToWalletResponse {
  /** ScopeID is the ID of the added scope */
  scopeId: string;
  /** AddedAt is when the scope was added (Unix timestamp) */
  addedAt: Long;
}

/** MsgRevokeScopeFromWallet is the message for revoking a scope from a wallet */
export interface MsgRevokeScopeFromWallet {
  /** Sender is the account that owns the wallet */
  sender: string;
  /** ScopeID is the unique identifier of the scope to revoke */
  scopeId: string;
  /** Reason is the reason for revocation */
  reason: string;
  /** UserSignature authorizes revoking this scope */
  userSignature: Uint8Array;
}

/** MsgRevokeScopeFromWalletResponse is the response for MsgRevokeScopeFromWallet */
export interface MsgRevokeScopeFromWalletResponse {
  /** ScopeID is the ID of the revoked scope */
  scopeId: string;
  /** RevokedAt is when the scope was revoked (Unix timestamp) */
  revokedAt: Long;
}

/** MsgUpdateConsentSettings is the message for updating consent settings */
export interface MsgUpdateConsentSettings {
  /** Sender is the account that owns the wallet */
  sender: string;
  /** ScopeID is the scope to update consent for (empty for global settings) */
  scopeId: string;
  /** GrantConsent indicates whether to grant or revoke consent */
  grantConsent: boolean;
  /** Purpose is the purpose for granting consent */
  purpose: string;
  /** ExpiresAt is when the consent should expire (Unix timestamp) */
  expiresAt: Long;
  /** GlobalSettings contains global settings updates */
  globalSettings:
    | GlobalConsentUpdate
    | undefined;
  /** UserSignature authorizes this consent update */
  userSignature: Uint8Array;
}

/** MsgUpdateConsentSettingsResponse is the response for MsgUpdateConsentSettings */
export interface MsgUpdateConsentSettingsResponse {
  /** UpdatedAt is when consent was updated (Unix timestamp) */
  updatedAt: Long;
  /** ConsentVersion is the new consent version */
  consentVersion: number;
}

/** MsgRebindWallet is the message for rebinding a wallet during key rotation */
export interface MsgRebindWallet {
  /** Sender is the account that owns the wallet */
  sender: string;
  /** NewBindingSignature is the new binding signature with the new key */
  newBindingSignature: Uint8Array;
  /** NewBindingPubKey is the new public key */
  newBindingPubKey: Uint8Array;
  /** OldSignature proves ownership of the old key */
  oldSignature: Uint8Array;
  /** MFAProof is proof of MFA for key rotation (serialized) */
  mfaProof: Uint8Array;
  /** DeviceFingerprint is the client device fingerprint */
  deviceFingerprint: string;
}

/** MsgRebindWalletResponse is the response for MsgRebindWallet */
export interface MsgRebindWalletResponse {
  /** ReboundAt is when the wallet was rebound (Unix timestamp) */
  reboundAt: Long;
}

/** MsgUpdateDerivedFeatures is the message for updating derived features */
export interface MsgUpdateDerivedFeatures {
  /** Sender is the validator submitting the update */
  sender: string;
  /** AccountAddress is the account to update features for */
  accountAddress: string;
  /** FaceEmbeddingHash is the new face embedding hash */
  faceEmbeddingHash: Uint8Array;
  /** DocFieldHashes are new document field hashes */
  docFieldHashes: { [key: string]: Uint8Array };
  /** BiometricHash is the new biometric hash */
  biometricHash: Uint8Array;
  /** LivenessProofHash is the new liveness proof hash */
  livenessProofHash: Uint8Array;
  /** ModelVersion is the ML model version used */
  modelVersion: string;
}

export interface MsgUpdateDerivedFeatures_DocFieldHashesEntry {
  key: string;
  value: Uint8Array;
}

/** MsgUpdateDerivedFeaturesResponse is the response for MsgUpdateDerivedFeatures */
export interface MsgUpdateDerivedFeaturesResponse {
  /** UpdatedAt is when the features were updated (Unix timestamp) */
  updatedAt: Long;
}

/** MsgCompleteBorderlineFallback is the message for completing a borderline fallback */
export interface MsgCompleteBorderlineFallback {
  /** Sender is the account completing the fallback */
  sender: string;
  /** ChallengeID is the MFA challenge ID that was satisfied */
  challengeId: string;
  /** FactorsSatisfied are the factor types that were successfully verified */
  factorsSatisfied: string[];
}

/** MsgCompleteBorderlineFallbackResponse is the response for MsgCompleteBorderlineFallback */
export interface MsgCompleteBorderlineFallbackResponse {
  /** FallbackID is the ID of the completed fallback */
  fallbackId: string;
  /** FinalStatus is the resulting verification status */
  finalStatus: VerificationStatus;
  /** FactorClass is the security class of the satisfied factors */
  factorClass: string;
}

/** MsgUpdateBorderlineParams is the message for updating borderline parameters */
export interface MsgUpdateBorderlineParams {
  /** Authority is the governance module account address */
  authority: string;
  /** Params are the new borderline parameters */
  params: BorderlineParams | undefined;
}

/** MsgUpdateBorderlineParamsResponse is the response for MsgUpdateBorderlineParams */
export interface MsgUpdateBorderlineParamsResponse {
}

/** MsgUpdateParams is the message for updating module parameters */
export interface MsgUpdateParams {
  /** Authority is the governance module account address */
  authority: string;
  /** Params are the new module parameters */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

function createBaseMsgUploadScope(): MsgUploadScope {
  return {
    sender: "",
    scopeId: "",
    scopeType: 0,
    encryptedPayload: undefined,
    salt: new Uint8Array(0),
    deviceFingerprint: "",
    clientId: "",
    clientSignature: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    payloadHash: new Uint8Array(0),
    captureTimestamp: Long.ZERO,
    geoHint: "",
  };
}

export const MsgUploadScope: MessageFns<MsgUploadScope, "virtengine.veid.v1.MsgUploadScope"> = {
  $type: "virtengine.veid.v1.MsgUploadScope" as const,

  encode(message: MsgUploadScope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(24).int32(message.scopeType);
    }
    if (message.encryptedPayload !== undefined) {
      EncryptedPayloadEnvelope.encode(message.encryptedPayload, writer.uint32(34).fork()).join();
    }
    if (message.salt.length !== 0) {
      writer.uint32(42).bytes(message.salt);
    }
    if (message.deviceFingerprint !== "") {
      writer.uint32(50).string(message.deviceFingerprint);
    }
    if (message.clientId !== "") {
      writer.uint32(58).string(message.clientId);
    }
    if (message.clientSignature.length !== 0) {
      writer.uint32(66).bytes(message.clientSignature);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(74).bytes(message.userSignature);
    }
    if (message.payloadHash.length !== 0) {
      writer.uint32(82).bytes(message.payloadHash);
    }
    if (!message.captureTimestamp.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.captureTimestamp.toString());
    }
    if (message.geoHint !== "") {
      writer.uint32(98).string(message.geoHint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUploadScope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUploadScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.encryptedPayload = EncryptedPayloadEnvelope.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.salt = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deviceFingerprint = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.clientId = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientSignature = reader.bytes();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.payloadHash = reader.bytes();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.captureTimestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.geoHint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUploadScope {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      encryptedPayload: isSet(object.encrypted_payload)
        ? EncryptedPayloadEnvelope.fromJSON(object.encrypted_payload)
        : undefined,
      salt: isSet(object.salt) ? bytesFromBase64(object.salt) : new Uint8Array(0),
      deviceFingerprint: isSet(object.device_fingerprint) ? globalThis.String(object.device_fingerprint) : "",
      clientId: isSet(object.client_id) ? globalThis.String(object.client_id) : "",
      clientSignature: isSet(object.client_signature) ? bytesFromBase64(object.client_signature) : new Uint8Array(0),
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
      payloadHash: isSet(object.payload_hash) ? bytesFromBase64(object.payload_hash) : new Uint8Array(0),
      captureTimestamp: isSet(object.capture_timestamp) ? Long.fromValue(object.capture_timestamp) : Long.ZERO,
      geoHint: isSet(object.geo_hint) ? globalThis.String(object.geo_hint) : "",
    };
  },

  toJSON(message: MsgUploadScope): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.encryptedPayload !== undefined) {
      obj.encrypted_payload = EncryptedPayloadEnvelope.toJSON(message.encryptedPayload);
    }
    if (message.salt.length !== 0) {
      obj.salt = base64FromBytes(message.salt);
    }
    if (message.deviceFingerprint !== "") {
      obj.device_fingerprint = message.deviceFingerprint;
    }
    if (message.clientId !== "") {
      obj.client_id = message.clientId;
    }
    if (message.clientSignature.length !== 0) {
      obj.client_signature = base64FromBytes(message.clientSignature);
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    if (message.payloadHash.length !== 0) {
      obj.payload_hash = base64FromBytes(message.payloadHash);
    }
    if (!message.captureTimestamp.equals(Long.ZERO)) {
      obj.capture_timestamp = (message.captureTimestamp || Long.ZERO).toString();
    }
    if (message.geoHint !== "") {
      obj.geo_hint = message.geoHint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUploadScope>): MsgUploadScope {
    const message = createBaseMsgUploadScope();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.encryptedPayload = (object.encryptedPayload !== undefined && object.encryptedPayload !== null)
      ? EncryptedPayloadEnvelope.fromPartial(object.encryptedPayload)
      : undefined;
    message.salt = object.salt ?? new Uint8Array(0);
    message.deviceFingerprint = object.deviceFingerprint ?? "";
    message.clientId = object.clientId ?? "";
    message.clientSignature = object.clientSignature ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.payloadHash = object.payloadHash ?? new Uint8Array(0);
    message.captureTimestamp = (object.captureTimestamp !== undefined && object.captureTimestamp !== null)
      ? Long.fromValue(object.captureTimestamp)
      : Long.ZERO;
    message.geoHint = object.geoHint ?? "";
    return message;
  },
};

function createBaseMsgUploadScopeResponse(): MsgUploadScopeResponse {
  return { scopeId: "", status: 0, uploadedAt: Long.ZERO };
}

export const MsgUploadScopeResponse: MessageFns<MsgUploadScopeResponse, "virtengine.veid.v1.MsgUploadScopeResponse"> = {
  $type: "virtengine.veid.v1.MsgUploadScopeResponse" as const,

  encode(message: MsgUploadScopeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.uploadedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUploadScopeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUploadScopeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.uploadedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUploadScopeResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      status: isSet(object.status) ? verificationStatusFromJSON(object.status) : 0,
      uploadedAt: isSet(object.uploaded_at) ? Long.fromValue(object.uploaded_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgUploadScopeResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.status !== 0) {
      obj.status = verificationStatusToJSON(message.status);
    }
    if (!message.uploadedAt.equals(Long.ZERO)) {
      obj.uploaded_at = (message.uploadedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUploadScopeResponse>): MsgUploadScopeResponse {
    const message = createBaseMsgUploadScopeResponse();
    message.scopeId = object.scopeId ?? "";
    message.status = object.status ?? 0;
    message.uploadedAt = (object.uploadedAt !== undefined && object.uploadedAt !== null)
      ? Long.fromValue(object.uploadedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgRevokeScope(): MsgRevokeScope {
  return { sender: "", scopeId: "", reason: "" };
}

export const MsgRevokeScope: MessageFns<MsgRevokeScope, "virtengine.veid.v1.MsgRevokeScope"> = {
  $type: "virtengine.veid.v1.MsgRevokeScope" as const,

  encode(message: MsgRevokeScope, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeScope {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeScope();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeScope {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgRevokeScope): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeScope>): MsgRevokeScope {
    const message = createBaseMsgRevokeScope();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgRevokeScopeResponse(): MsgRevokeScopeResponse {
  return { scopeId: "", revokedAt: Long.ZERO };
}

export const MsgRevokeScopeResponse: MessageFns<MsgRevokeScopeResponse, "virtengine.veid.v1.MsgRevokeScopeResponse"> = {
  $type: "virtengine.veid.v1.MsgRevokeScopeResponse" as const,

  encode(message: MsgRevokeScopeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.revokedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeScopeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeScopeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeScopeResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgRevokeScopeResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeScopeResponse>): MsgRevokeScopeResponse {
    const message = createBaseMsgRevokeScopeResponse();
    message.scopeId = object.scopeId ?? "";
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgRequestVerification(): MsgRequestVerification {
  return { sender: "", scopeId: "" };
}

export const MsgRequestVerification: MessageFns<MsgRequestVerification, "virtengine.veid.v1.MsgRequestVerification"> = {
  $type: "virtengine.veid.v1.MsgRequestVerification" as const,

  encode(message: MsgRequestVerification, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRequestVerification {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestVerification();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRequestVerification {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
    };
  },

  toJSON(message: MsgRequestVerification): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRequestVerification>): MsgRequestVerification {
    const message = createBaseMsgRequestVerification();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    return message;
  },
};

function createBaseMsgRequestVerificationResponse(): MsgRequestVerificationResponse {
  return { scopeId: "", status: 0, requestedAt: Long.ZERO };
}

export const MsgRequestVerificationResponse: MessageFns<
  MsgRequestVerificationResponse,
  "virtengine.veid.v1.MsgRequestVerificationResponse"
> = {
  $type: "virtengine.veid.v1.MsgRequestVerificationResponse" as const,

  encode(message: MsgRequestVerificationResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (!message.requestedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.requestedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRequestVerificationResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRequestVerificationResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.requestedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRequestVerificationResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      status: isSet(object.status) ? verificationStatusFromJSON(object.status) : 0,
      requestedAt: isSet(object.requested_at) ? Long.fromValue(object.requested_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgRequestVerificationResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.status !== 0) {
      obj.status = verificationStatusToJSON(message.status);
    }
    if (!message.requestedAt.equals(Long.ZERO)) {
      obj.requested_at = (message.requestedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRequestVerificationResponse>): MsgRequestVerificationResponse {
    const message = createBaseMsgRequestVerificationResponse();
    message.scopeId = object.scopeId ?? "";
    message.status = object.status ?? 0;
    message.requestedAt = (object.requestedAt !== undefined && object.requestedAt !== null)
      ? Long.fromValue(object.requestedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgUpdateVerificationStatus(): MsgUpdateVerificationStatus {
  return { sender: "", accountAddress: "", scopeId: "", newStatus: 0, reason: "" };
}

export const MsgUpdateVerificationStatus: MessageFns<
  MsgUpdateVerificationStatus,
  "virtengine.veid.v1.MsgUpdateVerificationStatus"
> = {
  $type: "virtengine.veid.v1.MsgUpdateVerificationStatus" as const,

  encode(message: MsgUpdateVerificationStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.scopeId !== "") {
      writer.uint32(26).string(message.scopeId);
    }
    if (message.newStatus !== 0) {
      writer.uint32(32).int32(message.newStatus);
    }
    if (message.reason !== "") {
      writer.uint32(42).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateVerificationStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateVerificationStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateVerificationStatus {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      newStatus: isSet(object.new_status) ? verificationStatusFromJSON(object.new_status) : 0,
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgUpdateVerificationStatus): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.newStatus !== 0) {
      obj.new_status = verificationStatusToJSON(message.newStatus);
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateVerificationStatus>): MsgUpdateVerificationStatus {
    const message = createBaseMsgUpdateVerificationStatus();
    message.sender = object.sender ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.scopeId = object.scopeId ?? "";
    message.newStatus = object.newStatus ?? 0;
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgUpdateVerificationStatusResponse(): MsgUpdateVerificationStatusResponse {
  return { scopeId: "", previousStatus: 0, newStatus: 0, updatedAt: Long.ZERO };
}

export const MsgUpdateVerificationStatusResponse: MessageFns<
  MsgUpdateVerificationStatusResponse,
  "virtengine.veid.v1.MsgUpdateVerificationStatusResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateVerificationStatusResponse" as const,

  encode(message: MsgUpdateVerificationStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (message.previousStatus !== 0) {
      writer.uint32(16).int32(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(24).int32(message.newStatus);
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateVerificationStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateVerificationStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.previousStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateVerificationStatusResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      previousStatus: isSet(object.previous_status) ? verificationStatusFromJSON(object.previous_status) : 0,
      newStatus: isSet(object.new_status) ? verificationStatusFromJSON(object.new_status) : 0,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgUpdateVerificationStatusResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.previousStatus !== 0) {
      obj.previous_status = verificationStatusToJSON(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      obj.new_status = verificationStatusToJSON(message.newStatus);
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateVerificationStatusResponse>): MsgUpdateVerificationStatusResponse {
    const message = createBaseMsgUpdateVerificationStatusResponse();
    message.scopeId = object.scopeId ?? "";
    message.previousStatus = object.previousStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgUpdateScore(): MsgUpdateScore {
  return { sender: "", accountAddress: "", newScore: 0, scoreVersion: "" };
}

export const MsgUpdateScore: MessageFns<MsgUpdateScore, "virtengine.veid.v1.MsgUpdateScore"> = {
  $type: "virtengine.veid.v1.MsgUpdateScore" as const,

  encode(message: MsgUpdateScore, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.newScore !== 0) {
      writer.uint32(24).uint32(message.newScore);
    }
    if (message.scoreVersion !== "") {
      writer.uint32(34).string(message.scoreVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateScore {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateScore();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.scoreVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateScore {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      newScore: isSet(object.new_score) ? globalThis.Number(object.new_score) : 0,
      scoreVersion: isSet(object.score_version) ? globalThis.String(object.score_version) : "",
    };
  },

  toJSON(message: MsgUpdateScore): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.newScore !== 0) {
      obj.new_score = Math.round(message.newScore);
    }
    if (message.scoreVersion !== "") {
      obj.score_version = message.scoreVersion;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateScore>): MsgUpdateScore {
    const message = createBaseMsgUpdateScore();
    message.sender = object.sender ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.newScore = object.newScore ?? 0;
    message.scoreVersion = object.scoreVersion ?? "";
    return message;
  },
};

function createBaseMsgUpdateScoreResponse(): MsgUpdateScoreResponse {
  return { accountAddress: "", previousScore: 0, newScore: 0, previousTier: 0, newTier: 0, updatedAt: Long.ZERO };
}

export const MsgUpdateScoreResponse: MessageFns<MsgUpdateScoreResponse, "virtengine.veid.v1.MsgUpdateScoreResponse"> = {
  $type: "virtengine.veid.v1.MsgUpdateScoreResponse" as const,

  encode(message: MsgUpdateScoreResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.previousScore !== 0) {
      writer.uint32(16).uint32(message.previousScore);
    }
    if (message.newScore !== 0) {
      writer.uint32(24).uint32(message.newScore);
    }
    if (message.previousTier !== 0) {
      writer.uint32(32).int32(message.previousTier);
    }
    if (message.newTier !== 0) {
      writer.uint32(40).int32(message.newTier);
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateScoreResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateScoreResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.previousScore = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.newScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.previousTier = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.newTier = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateScoreResponse {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      previousScore: isSet(object.previous_score) ? globalThis.Number(object.previous_score) : 0,
      newScore: isSet(object.new_score) ? globalThis.Number(object.new_score) : 0,
      previousTier: isSet(object.previous_tier) ? identityTierFromJSON(object.previous_tier) : 0,
      newTier: isSet(object.new_tier) ? identityTierFromJSON(object.new_tier) : 0,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgUpdateScoreResponse): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.previousScore !== 0) {
      obj.previous_score = Math.round(message.previousScore);
    }
    if (message.newScore !== 0) {
      obj.new_score = Math.round(message.newScore);
    }
    if (message.previousTier !== 0) {
      obj.previous_tier = identityTierToJSON(message.previousTier);
    }
    if (message.newTier !== 0) {
      obj.new_tier = identityTierToJSON(message.newTier);
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateScoreResponse>): MsgUpdateScoreResponse {
    const message = createBaseMsgUpdateScoreResponse();
    message.accountAddress = object.accountAddress ?? "";
    message.previousScore = object.previousScore ?? 0;
    message.newScore = object.newScore ?? 0;
    message.previousTier = object.previousTier ?? 0;
    message.newTier = object.newTier ?? 0;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgCreateIdentityWallet(): MsgCreateIdentityWallet {
  return {
    sender: "",
    bindingSignature: new Uint8Array(0),
    bindingPubKey: new Uint8Array(0),
    initialConsent: undefined,
    metadata: {},
  };
}

export const MsgCreateIdentityWallet: MessageFns<
  MsgCreateIdentityWallet,
  "virtengine.veid.v1.MsgCreateIdentityWallet"
> = {
  $type: "virtengine.veid.v1.MsgCreateIdentityWallet" as const,

  encode(message: MsgCreateIdentityWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.bindingSignature.length !== 0) {
      writer.uint32(18).bytes(message.bindingSignature);
    }
    if (message.bindingPubKey.length !== 0) {
      writer.uint32(26).bytes(message.bindingPubKey);
    }
    if (message.initialConsent !== undefined) {
      ConsentSettings.encode(message.initialConsent, writer.uint32(34).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      MsgCreateIdentityWallet_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateIdentityWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateIdentityWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.bindingSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bindingPubKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initialConsent = ConsentSettings.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = MsgCreateIdentityWallet_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateIdentityWallet {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      bindingSignature: isSet(object.binding_signature) ? bytesFromBase64(object.binding_signature) : new Uint8Array(0),
      bindingPubKey: isSet(object.binding_pub_key) ? bytesFromBase64(object.binding_pub_key) : new Uint8Array(0),
      initialConsent: isSet(object.initial_consent) ? ConsentSettings.fromJSON(object.initial_consent) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MsgCreateIdentityWallet): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.bindingSignature.length !== 0) {
      obj.binding_signature = base64FromBytes(message.bindingSignature);
    }
    if (message.bindingPubKey.length !== 0) {
      obj.binding_pub_key = base64FromBytes(message.bindingPubKey);
    }
    if (message.initialConsent !== undefined) {
      obj.initial_consent = ConsentSettings.toJSON(message.initialConsent);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCreateIdentityWallet>): MsgCreateIdentityWallet {
    const message = createBaseMsgCreateIdentityWallet();
    message.sender = object.sender ?? "";
    message.bindingSignature = object.bindingSignature ?? new Uint8Array(0);
    message.bindingPubKey = object.bindingPubKey ?? new Uint8Array(0);
    message.initialConsent = (object.initialConsent !== undefined && object.initialConsent !== null)
      ? ConsentSettings.fromPartial(object.initialConsent)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseMsgCreateIdentityWallet_MetadataEntry(): MsgCreateIdentityWallet_MetadataEntry {
  return { key: "", value: "" };
}

export const MsgCreateIdentityWallet_MetadataEntry: MessageFns<
  MsgCreateIdentityWallet_MetadataEntry,
  "virtengine.veid.v1.MsgCreateIdentityWallet.MetadataEntry"
> = {
  $type: "virtengine.veid.v1.MsgCreateIdentityWallet.MetadataEntry" as const,

  encode(message: MsgCreateIdentityWallet_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateIdentityWallet_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateIdentityWallet_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateIdentityWallet_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MsgCreateIdentityWallet_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCreateIdentityWallet_MetadataEntry>): MsgCreateIdentityWallet_MetadataEntry {
    const message = createBaseMsgCreateIdentityWallet_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMsgCreateIdentityWalletResponse(): MsgCreateIdentityWalletResponse {
  return { walletId: "", createdAt: Long.ZERO };
}

export const MsgCreateIdentityWalletResponse: MessageFns<
  MsgCreateIdentityWalletResponse,
  "virtengine.veid.v1.MsgCreateIdentityWalletResponse"
> = {
  $type: "virtengine.veid.v1.MsgCreateIdentityWalletResponse" as const,

  encode(message: MsgCreateIdentityWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.walletId !== "") {
      writer.uint32(10).string(message.walletId);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.createdAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCreateIdentityWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCreateIdentityWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.walletId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCreateIdentityWalletResponse {
    return {
      walletId: isSet(object.wallet_id) ? globalThis.String(object.wallet_id) : "",
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgCreateIdentityWalletResponse): unknown {
    const obj: any = {};
    if (message.walletId !== "") {
      obj.wallet_id = message.walletId;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCreateIdentityWalletResponse>): MsgCreateIdentityWalletResponse {
    const message = createBaseMsgCreateIdentityWalletResponse();
    message.walletId = object.walletId ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgAddScopeToWallet(): MsgAddScopeToWallet {
  return {
    sender: "",
    scopeId: "",
    scopeType: 0,
    envelopeHash: new Uint8Array(0),
    userSignature: new Uint8Array(0),
    grantConsent: false,
    consentPurpose: "",
    consentExpiresAt: Long.ZERO,
  };
}

export const MsgAddScopeToWallet: MessageFns<MsgAddScopeToWallet, "virtengine.veid.v1.MsgAddScopeToWallet"> = {
  $type: "virtengine.veid.v1.MsgAddScopeToWallet" as const,

  encode(message: MsgAddScopeToWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.scopeType !== 0) {
      writer.uint32(24).int32(message.scopeType);
    }
    if (message.envelopeHash.length !== 0) {
      writer.uint32(34).bytes(message.envelopeHash);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(42).bytes(message.userSignature);
    }
    if (message.grantConsent !== false) {
      writer.uint32(48).bool(message.grantConsent);
    }
    if (message.consentPurpose !== "") {
      writer.uint32(58).string(message.consentPurpose);
    }
    if (!message.consentExpiresAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.consentExpiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddScopeToWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddScopeToWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scopeType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.envelopeHash = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.grantConsent = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.consentPurpose = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.consentExpiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddScopeToWallet {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      scopeType: isSet(object.scope_type) ? scopeTypeFromJSON(object.scope_type) : 0,
      envelopeHash: isSet(object.envelope_hash) ? bytesFromBase64(object.envelope_hash) : new Uint8Array(0),
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
      grantConsent: isSet(object.grant_consent) ? globalThis.Boolean(object.grant_consent) : false,
      consentPurpose: isSet(object.consent_purpose) ? globalThis.String(object.consent_purpose) : "",
      consentExpiresAt: isSet(object.consent_expires_at) ? Long.fromValue(object.consent_expires_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgAddScopeToWallet): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.scopeType !== 0) {
      obj.scope_type = scopeTypeToJSON(message.scopeType);
    }
    if (message.envelopeHash.length !== 0) {
      obj.envelope_hash = base64FromBytes(message.envelopeHash);
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    if (message.grantConsent !== false) {
      obj.grant_consent = message.grantConsent;
    }
    if (message.consentPurpose !== "") {
      obj.consent_purpose = message.consentPurpose;
    }
    if (!message.consentExpiresAt.equals(Long.ZERO)) {
      obj.consent_expires_at = (message.consentExpiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgAddScopeToWallet>): MsgAddScopeToWallet {
    const message = createBaseMsgAddScopeToWallet();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    message.scopeType = object.scopeType ?? 0;
    message.envelopeHash = object.envelopeHash ?? new Uint8Array(0);
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    message.grantConsent = object.grantConsent ?? false;
    message.consentPurpose = object.consentPurpose ?? "";
    message.consentExpiresAt = (object.consentExpiresAt !== undefined && object.consentExpiresAt !== null)
      ? Long.fromValue(object.consentExpiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgAddScopeToWalletResponse(): MsgAddScopeToWalletResponse {
  return { scopeId: "", addedAt: Long.ZERO };
}

export const MsgAddScopeToWalletResponse: MessageFns<
  MsgAddScopeToWalletResponse,
  "virtengine.veid.v1.MsgAddScopeToWalletResponse"
> = {
  $type: "virtengine.veid.v1.MsgAddScopeToWalletResponse" as const,

  encode(message: MsgAddScopeToWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.addedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgAddScopeToWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgAddScopeToWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.addedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgAddScopeToWalletResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      addedAt: isSet(object.added_at) ? Long.fromValue(object.added_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgAddScopeToWalletResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      obj.added_at = (message.addedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgAddScopeToWalletResponse>): MsgAddScopeToWalletResponse {
    const message = createBaseMsgAddScopeToWalletResponse();
    message.scopeId = object.scopeId ?? "";
    message.addedAt = (object.addedAt !== undefined && object.addedAt !== null)
      ? Long.fromValue(object.addedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgRevokeScopeFromWallet(): MsgRevokeScopeFromWallet {
  return { sender: "", scopeId: "", reason: "", userSignature: new Uint8Array(0) };
}

export const MsgRevokeScopeFromWallet: MessageFns<
  MsgRevokeScopeFromWallet,
  "virtengine.veid.v1.MsgRevokeScopeFromWallet"
> = {
  $type: "virtengine.veid.v1.MsgRevokeScopeFromWallet" as const,

  encode(message: MsgRevokeScopeFromWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(34).bytes(message.userSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeScopeFromWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeScopeFromWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeScopeFromWallet {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgRevokeScopeFromWallet): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeScopeFromWallet>): MsgRevokeScopeFromWallet {
    const message = createBaseMsgRevokeScopeFromWallet();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    message.reason = object.reason ?? "";
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgRevokeScopeFromWalletResponse(): MsgRevokeScopeFromWalletResponse {
  return { scopeId: "", revokedAt: Long.ZERO };
}

export const MsgRevokeScopeFromWalletResponse: MessageFns<
  MsgRevokeScopeFromWalletResponse,
  "virtengine.veid.v1.MsgRevokeScopeFromWalletResponse"
> = {
  $type: "virtengine.veid.v1.MsgRevokeScopeFromWalletResponse" as const,

  encode(message: MsgRevokeScopeFromWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.scopeId !== "") {
      writer.uint32(10).string(message.scopeId);
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.revokedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeScopeFromWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeScopeFromWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeScopeFromWalletResponse {
    return {
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
    };
  },

  toJSON(message: MsgRevokeScopeFromWalletResponse): unknown {
    const obj: any = {};
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeScopeFromWalletResponse>): MsgRevokeScopeFromWalletResponse {
    const message = createBaseMsgRevokeScopeFromWalletResponse();
    message.scopeId = object.scopeId ?? "";
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgUpdateConsentSettings(): MsgUpdateConsentSettings {
  return {
    sender: "",
    scopeId: "",
    grantConsent: false,
    purpose: "",
    expiresAt: Long.ZERO,
    globalSettings: undefined,
    userSignature: new Uint8Array(0),
  };
}

export const MsgUpdateConsentSettings: MessageFns<
  MsgUpdateConsentSettings,
  "virtengine.veid.v1.MsgUpdateConsentSettings"
> = {
  $type: "virtengine.veid.v1.MsgUpdateConsentSettings" as const,

  encode(message: MsgUpdateConsentSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.scopeId !== "") {
      writer.uint32(18).string(message.scopeId);
    }
    if (message.grantConsent !== false) {
      writer.uint32(24).bool(message.grantConsent);
    }
    if (message.purpose !== "") {
      writer.uint32(34).string(message.purpose);
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expiresAt.toString());
    }
    if (message.globalSettings !== undefined) {
      GlobalConsentUpdate.encode(message.globalSettings, writer.uint32(50).fork()).join();
    }
    if (message.userSignature.length !== 0) {
      writer.uint32(58).bytes(message.userSignature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateConsentSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateConsentSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.scopeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.grantConsent = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.purpose = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.globalSettings = GlobalConsentUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.userSignature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateConsentSettings {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      scopeId: isSet(object.scope_id) ? globalThis.String(object.scope_id) : "",
      grantConsent: isSet(object.grant_consent) ? globalThis.Boolean(object.grant_consent) : false,
      purpose: isSet(object.purpose) ? globalThis.String(object.purpose) : "",
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      globalSettings: isSet(object.global_settings) ? GlobalConsentUpdate.fromJSON(object.global_settings) : undefined,
      userSignature: isSet(object.user_signature) ? bytesFromBase64(object.user_signature) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgUpdateConsentSettings): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.scopeId !== "") {
      obj.scope_id = message.scopeId;
    }
    if (message.grantConsent !== false) {
      obj.grant_consent = message.grantConsent;
    }
    if (message.purpose !== "") {
      obj.purpose = message.purpose;
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (message.globalSettings !== undefined) {
      obj.global_settings = GlobalConsentUpdate.toJSON(message.globalSettings);
    }
    if (message.userSignature.length !== 0) {
      obj.user_signature = base64FromBytes(message.userSignature);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateConsentSettings>): MsgUpdateConsentSettings {
    const message = createBaseMsgUpdateConsentSettings();
    message.sender = object.sender ?? "";
    message.scopeId = object.scopeId ?? "";
    message.grantConsent = object.grantConsent ?? false;
    message.purpose = object.purpose ?? "";
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.globalSettings = (object.globalSettings !== undefined && object.globalSettings !== null)
      ? GlobalConsentUpdate.fromPartial(object.globalSettings)
      : undefined;
    message.userSignature = object.userSignature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgUpdateConsentSettingsResponse(): MsgUpdateConsentSettingsResponse {
  return { updatedAt: Long.ZERO, consentVersion: 0 };
}

export const MsgUpdateConsentSettingsResponse: MessageFns<
  MsgUpdateConsentSettingsResponse,
  "virtengine.veid.v1.MsgUpdateConsentSettingsResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateConsentSettingsResponse" as const,

  encode(message: MsgUpdateConsentSettingsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.updatedAt.toString());
    }
    if (message.consentVersion !== 0) {
      writer.uint32(16).uint32(message.consentVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateConsentSettingsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateConsentSettingsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.consentVersion = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateConsentSettingsResponse {
    return {
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
      consentVersion: isSet(object.consent_version) ? globalThis.Number(object.consent_version) : 0,
    };
  },

  toJSON(message: MsgUpdateConsentSettingsResponse): unknown {
    const obj: any = {};
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    if (message.consentVersion !== 0) {
      obj.consent_version = Math.round(message.consentVersion);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateConsentSettingsResponse>): MsgUpdateConsentSettingsResponse {
    const message = createBaseMsgUpdateConsentSettingsResponse();
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.consentVersion = object.consentVersion ?? 0;
    return message;
  },
};

function createBaseMsgRebindWallet(): MsgRebindWallet {
  return {
    sender: "",
    newBindingSignature: new Uint8Array(0),
    newBindingPubKey: new Uint8Array(0),
    oldSignature: new Uint8Array(0),
    mfaProof: new Uint8Array(0),
    deviceFingerprint: "",
  };
}

export const MsgRebindWallet: MessageFns<MsgRebindWallet, "virtengine.veid.v1.MsgRebindWallet"> = {
  $type: "virtengine.veid.v1.MsgRebindWallet" as const,

  encode(message: MsgRebindWallet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.newBindingSignature.length !== 0) {
      writer.uint32(18).bytes(message.newBindingSignature);
    }
    if (message.newBindingPubKey.length !== 0) {
      writer.uint32(26).bytes(message.newBindingPubKey);
    }
    if (message.oldSignature.length !== 0) {
      writer.uint32(34).bytes(message.oldSignature);
    }
    if (message.mfaProof.length !== 0) {
      writer.uint32(42).bytes(message.mfaProof);
    }
    if (message.deviceFingerprint !== "") {
      writer.uint32(50).string(message.deviceFingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRebindWallet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRebindWallet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newBindingSignature = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newBindingPubKey = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.oldSignature = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mfaProof = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.deviceFingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRebindWallet {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      newBindingSignature: isSet(object.new_binding_signature)
        ? bytesFromBase64(object.new_binding_signature)
        : new Uint8Array(0),
      newBindingPubKey: isSet(object.new_binding_pub_key)
        ? bytesFromBase64(object.new_binding_pub_key)
        : new Uint8Array(0),
      oldSignature: isSet(object.old_signature) ? bytesFromBase64(object.old_signature) : new Uint8Array(0),
      mfaProof: isSet(object.mfa_proof) ? bytesFromBase64(object.mfa_proof) : new Uint8Array(0),
      deviceFingerprint: isSet(object.device_fingerprint) ? globalThis.String(object.device_fingerprint) : "",
    };
  },

  toJSON(message: MsgRebindWallet): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.newBindingSignature.length !== 0) {
      obj.new_binding_signature = base64FromBytes(message.newBindingSignature);
    }
    if (message.newBindingPubKey.length !== 0) {
      obj.new_binding_pub_key = base64FromBytes(message.newBindingPubKey);
    }
    if (message.oldSignature.length !== 0) {
      obj.old_signature = base64FromBytes(message.oldSignature);
    }
    if (message.mfaProof.length !== 0) {
      obj.mfa_proof = base64FromBytes(message.mfaProof);
    }
    if (message.deviceFingerprint !== "") {
      obj.device_fingerprint = message.deviceFingerprint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRebindWallet>): MsgRebindWallet {
    const message = createBaseMsgRebindWallet();
    message.sender = object.sender ?? "";
    message.newBindingSignature = object.newBindingSignature ?? new Uint8Array(0);
    message.newBindingPubKey = object.newBindingPubKey ?? new Uint8Array(0);
    message.oldSignature = object.oldSignature ?? new Uint8Array(0);
    message.mfaProof = object.mfaProof ?? new Uint8Array(0);
    message.deviceFingerprint = object.deviceFingerprint ?? "";
    return message;
  },
};

function createBaseMsgRebindWalletResponse(): MsgRebindWalletResponse {
  return { reboundAt: Long.ZERO };
}

export const MsgRebindWalletResponse: MessageFns<
  MsgRebindWalletResponse,
  "virtengine.veid.v1.MsgRebindWalletResponse"
> = {
  $type: "virtengine.veid.v1.MsgRebindWalletResponse" as const,

  encode(message: MsgRebindWalletResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.reboundAt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.reboundAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRebindWalletResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRebindWalletResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reboundAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRebindWalletResponse {
    return { reboundAt: isSet(object.rebound_at) ? Long.fromValue(object.rebound_at) : Long.ZERO };
  },

  toJSON(message: MsgRebindWalletResponse): unknown {
    const obj: any = {};
    if (!message.reboundAt.equals(Long.ZERO)) {
      obj.rebound_at = (message.reboundAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRebindWalletResponse>): MsgRebindWalletResponse {
    const message = createBaseMsgRebindWalletResponse();
    message.reboundAt = (object.reboundAt !== undefined && object.reboundAt !== null)
      ? Long.fromValue(object.reboundAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgUpdateDerivedFeatures(): MsgUpdateDerivedFeatures {
  return {
    sender: "",
    accountAddress: "",
    faceEmbeddingHash: new Uint8Array(0),
    docFieldHashes: {},
    biometricHash: new Uint8Array(0),
    livenessProofHash: new Uint8Array(0),
    modelVersion: "",
  };
}

export const MsgUpdateDerivedFeatures: MessageFns<
  MsgUpdateDerivedFeatures,
  "virtengine.veid.v1.MsgUpdateDerivedFeatures"
> = {
  $type: "virtengine.veid.v1.MsgUpdateDerivedFeatures" as const,

  encode(message: MsgUpdateDerivedFeatures, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.faceEmbeddingHash.length !== 0) {
      writer.uint32(26).bytes(message.faceEmbeddingHash);
    }
    Object.entries(message.docFieldHashes).forEach(([key, value]) => {
      MsgUpdateDerivedFeatures_DocFieldHashesEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.biometricHash.length !== 0) {
      writer.uint32(42).bytes(message.biometricHash);
    }
    if (message.livenessProofHash.length !== 0) {
      writer.uint32(50).bytes(message.livenessProofHash);
    }
    if (message.modelVersion !== "") {
      writer.uint32(58).string(message.modelVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateDerivedFeatures {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateDerivedFeatures();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.faceEmbeddingHash = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = MsgUpdateDerivedFeatures_DocFieldHashesEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.docFieldHashes[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.biometricHash = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.livenessProofHash = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.modelVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateDerivedFeatures {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      faceEmbeddingHash: isSet(object.face_embedding_hash)
        ? bytesFromBase64(object.face_embedding_hash)
        : new Uint8Array(0),
      docFieldHashes: isObject(object.doc_field_hashes)
        ? Object.entries(object.doc_field_hashes).reduce<{ [key: string]: Uint8Array }>((acc, [key, value]) => {
          acc[key] = bytesFromBase64(value as string);
          return acc;
        }, {})
        : {},
      biometricHash: isSet(object.biometric_hash) ? bytesFromBase64(object.biometric_hash) : new Uint8Array(0),
      livenessProofHash: isSet(object.liveness_proof_hash)
        ? bytesFromBase64(object.liveness_proof_hash)
        : new Uint8Array(0),
      modelVersion: isSet(object.model_version) ? globalThis.String(object.model_version) : "",
    };
  },

  toJSON(message: MsgUpdateDerivedFeatures): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.faceEmbeddingHash.length !== 0) {
      obj.face_embedding_hash = base64FromBytes(message.faceEmbeddingHash);
    }
    if (message.docFieldHashes) {
      const entries = Object.entries(message.docFieldHashes);
      if (entries.length > 0) {
        obj.doc_field_hashes = {};
        entries.forEach(([k, v]) => {
          obj.doc_field_hashes[k] = base64FromBytes(v);
        });
      }
    }
    if (message.biometricHash.length !== 0) {
      obj.biometric_hash = base64FromBytes(message.biometricHash);
    }
    if (message.livenessProofHash.length !== 0) {
      obj.liveness_proof_hash = base64FromBytes(message.livenessProofHash);
    }
    if (message.modelVersion !== "") {
      obj.model_version = message.modelVersion;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateDerivedFeatures>): MsgUpdateDerivedFeatures {
    const message = createBaseMsgUpdateDerivedFeatures();
    message.sender = object.sender ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.faceEmbeddingHash = object.faceEmbeddingHash ?? new Uint8Array(0);
    message.docFieldHashes = Object.entries(object.docFieldHashes ?? {}).reduce<{ [key: string]: Uint8Array }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = value;
        }
        return acc;
      },
      {},
    );
    message.biometricHash = object.biometricHash ?? new Uint8Array(0);
    message.livenessProofHash = object.livenessProofHash ?? new Uint8Array(0);
    message.modelVersion = object.modelVersion ?? "";
    return message;
  },
};

function createBaseMsgUpdateDerivedFeatures_DocFieldHashesEntry(): MsgUpdateDerivedFeatures_DocFieldHashesEntry {
  return { key: "", value: new Uint8Array(0) };
}

export const MsgUpdateDerivedFeatures_DocFieldHashesEntry: MessageFns<
  MsgUpdateDerivedFeatures_DocFieldHashesEntry,
  "virtengine.veid.v1.MsgUpdateDerivedFeatures.DocFieldHashesEntry"
> = {
  $type: "virtengine.veid.v1.MsgUpdateDerivedFeatures.DocFieldHashesEntry" as const,

  encode(
    message: MsgUpdateDerivedFeatures_DocFieldHashesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value.length !== 0) {
      writer.uint32(18).bytes(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateDerivedFeatures_DocFieldHashesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateDerivedFeatures_DocFieldHashesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateDerivedFeatures_DocFieldHashesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? bytesFromBase64(object.value) : new Uint8Array(0),
    };
  },

  toJSON(message: MsgUpdateDerivedFeatures_DocFieldHashesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value.length !== 0) {
      obj.value = base64FromBytes(message.value);
    }
    return obj;
  },

  fromPartial(
    object: DeepPartial<MsgUpdateDerivedFeatures_DocFieldHashesEntry>,
  ): MsgUpdateDerivedFeatures_DocFieldHashesEntry {
    const message = createBaseMsgUpdateDerivedFeatures_DocFieldHashesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? new Uint8Array(0);
    return message;
  },
};

function createBaseMsgUpdateDerivedFeaturesResponse(): MsgUpdateDerivedFeaturesResponse {
  return { updatedAt: Long.ZERO };
}

export const MsgUpdateDerivedFeaturesResponse: MessageFns<
  MsgUpdateDerivedFeaturesResponse,
  "virtengine.veid.v1.MsgUpdateDerivedFeaturesResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateDerivedFeaturesResponse" as const,

  encode(message: MsgUpdateDerivedFeaturesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateDerivedFeaturesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateDerivedFeaturesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateDerivedFeaturesResponse {
    return { updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO };
  },

  toJSON(message: MsgUpdateDerivedFeaturesResponse): unknown {
    const obj: any = {};
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateDerivedFeaturesResponse>): MsgUpdateDerivedFeaturesResponse {
    const message = createBaseMsgUpdateDerivedFeaturesResponse();
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgCompleteBorderlineFallback(): MsgCompleteBorderlineFallback {
  return { sender: "", challengeId: "", factorsSatisfied: [] };
}

export const MsgCompleteBorderlineFallback: MessageFns<
  MsgCompleteBorderlineFallback,
  "virtengine.veid.v1.MsgCompleteBorderlineFallback"
> = {
  $type: "virtengine.veid.v1.MsgCompleteBorderlineFallback" as const,

  encode(message: MsgCompleteBorderlineFallback, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== "") {
      writer.uint32(10).string(message.sender);
    }
    if (message.challengeId !== "") {
      writer.uint32(18).string(message.challengeId);
    }
    for (const v of message.factorsSatisfied) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteBorderlineFallback {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteBorderlineFallback();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sender = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.challengeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorsSatisfied.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCompleteBorderlineFallback {
    return {
      sender: isSet(object.sender) ? globalThis.String(object.sender) : "",
      challengeId: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "",
      factorsSatisfied: globalThis.Array.isArray(object?.factors_satisfied)
        ? object.factors_satisfied.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgCompleteBorderlineFallback): unknown {
    const obj: any = {};
    if (message.sender !== "") {
      obj.sender = message.sender;
    }
    if (message.challengeId !== "") {
      obj.challenge_id = message.challengeId;
    }
    if (message.factorsSatisfied?.length) {
      obj.factors_satisfied = message.factorsSatisfied;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCompleteBorderlineFallback>): MsgCompleteBorderlineFallback {
    const message = createBaseMsgCompleteBorderlineFallback();
    message.sender = object.sender ?? "";
    message.challengeId = object.challengeId ?? "";
    message.factorsSatisfied = object.factorsSatisfied?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgCompleteBorderlineFallbackResponse(): MsgCompleteBorderlineFallbackResponse {
  return { fallbackId: "", finalStatus: 0, factorClass: "" };
}

export const MsgCompleteBorderlineFallbackResponse: MessageFns<
  MsgCompleteBorderlineFallbackResponse,
  "virtengine.veid.v1.MsgCompleteBorderlineFallbackResponse"
> = {
  $type: "virtengine.veid.v1.MsgCompleteBorderlineFallbackResponse" as const,

  encode(message: MsgCompleteBorderlineFallbackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fallbackId !== "") {
      writer.uint32(10).string(message.fallbackId);
    }
    if (message.finalStatus !== 0) {
      writer.uint32(16).int32(message.finalStatus);
    }
    if (message.factorClass !== "") {
      writer.uint32(26).string(message.factorClass);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgCompleteBorderlineFallbackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgCompleteBorderlineFallbackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fallbackId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.finalStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorClass = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgCompleteBorderlineFallbackResponse {
    return {
      fallbackId: isSet(object.fallback_id) ? globalThis.String(object.fallback_id) : "",
      finalStatus: isSet(object.final_status) ? verificationStatusFromJSON(object.final_status) : 0,
      factorClass: isSet(object.factor_class) ? globalThis.String(object.factor_class) : "",
    };
  },

  toJSON(message: MsgCompleteBorderlineFallbackResponse): unknown {
    const obj: any = {};
    if (message.fallbackId !== "") {
      obj.fallback_id = message.fallbackId;
    }
    if (message.finalStatus !== 0) {
      obj.final_status = verificationStatusToJSON(message.finalStatus);
    }
    if (message.factorClass !== "") {
      obj.factor_class = message.factorClass;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgCompleteBorderlineFallbackResponse>): MsgCompleteBorderlineFallbackResponse {
    const message = createBaseMsgCompleteBorderlineFallbackResponse();
    message.fallbackId = object.fallbackId ?? "";
    message.finalStatus = object.finalStatus ?? 0;
    message.factorClass = object.factorClass ?? "";
    return message;
  },
};

function createBaseMsgUpdateBorderlineParams(): MsgUpdateBorderlineParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateBorderlineParams: MessageFns<
  MsgUpdateBorderlineParams,
  "virtengine.veid.v1.MsgUpdateBorderlineParams"
> = {
  $type: "virtengine.veid.v1.MsgUpdateBorderlineParams" as const,

  encode(message: MsgUpdateBorderlineParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      BorderlineParams.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBorderlineParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBorderlineParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = BorderlineParams.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateBorderlineParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? BorderlineParams.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateBorderlineParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = BorderlineParams.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateBorderlineParams>): MsgUpdateBorderlineParams {
    const message = createBaseMsgUpdateBorderlineParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? BorderlineParams.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateBorderlineParamsResponse(): MsgUpdateBorderlineParamsResponse {
  return {};
}

export const MsgUpdateBorderlineParamsResponse: MessageFns<
  MsgUpdateBorderlineParamsResponse,
  "virtengine.veid.v1.MsgUpdateBorderlineParamsResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateBorderlineParamsResponse" as const,

  encode(_: MsgUpdateBorderlineParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateBorderlineParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateBorderlineParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateBorderlineParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateBorderlineParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateBorderlineParamsResponse>): MsgUpdateBorderlineParamsResponse {
    const message = createBaseMsgUpdateBorderlineParamsResponse();
    return message;
  },
};

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams, "virtengine.veid.v1.MsgUpdateParams"> = {
  $type: "virtengine.veid.v1.MsgUpdateParams" as const,

  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<
  MsgUpdateParamsResponse,
  "virtengine.veid.v1.MsgUpdateParamsResponse"
> = {
  $type: "virtengine.veid.v1.MsgUpdateParamsResponse" as const,

  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
