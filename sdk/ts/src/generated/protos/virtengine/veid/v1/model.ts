import { isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/veid/v1/model.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** ModelType represents the type of ML model */
export enum ModelType {
  /** MODEL_TYPE_UNSPECIFIED - MODEL_TYPE_UNSPECIFIED is the default unspecified type */
  MODEL_TYPE_UNSPECIFIED = 0,
  /** MODEL_TYPE_TRUST_SCORE - MODEL_TYPE_TRUST_SCORE is the trust score calculation model */
  MODEL_TYPE_TRUST_SCORE = 1,
  /** MODEL_TYPE_FACE_VERIFICATION - MODEL_TYPE_FACE_VERIFICATION is the facial verification model */
  MODEL_TYPE_FACE_VERIFICATION = 2,
  /** MODEL_TYPE_LIVENESS - MODEL_TYPE_LIVENESS is the liveness detection model */
  MODEL_TYPE_LIVENESS = 3,
  /** MODEL_TYPE_GAN_DETECTION - MODEL_TYPE_GAN_DETECTION is the GAN-generated image detection model */
  MODEL_TYPE_GAN_DETECTION = 4,
  /** MODEL_TYPE_OCR - MODEL_TYPE_OCR is the OCR extraction model */
  MODEL_TYPE_OCR = 5,
  UNRECOGNIZED = -1,
}

export function modelTypeFromJSON(object: any): ModelType {
  switch (object) {
    case 0:
    case "MODEL_TYPE_UNSPECIFIED":
      return ModelType.MODEL_TYPE_UNSPECIFIED;
    case 1:
    case "MODEL_TYPE_TRUST_SCORE":
      return ModelType.MODEL_TYPE_TRUST_SCORE;
    case 2:
    case "MODEL_TYPE_FACE_VERIFICATION":
      return ModelType.MODEL_TYPE_FACE_VERIFICATION;
    case 3:
    case "MODEL_TYPE_LIVENESS":
      return ModelType.MODEL_TYPE_LIVENESS;
    case 4:
    case "MODEL_TYPE_GAN_DETECTION":
      return ModelType.MODEL_TYPE_GAN_DETECTION;
    case 5:
    case "MODEL_TYPE_OCR":
      return ModelType.MODEL_TYPE_OCR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelType.UNRECOGNIZED;
  }
}

export function modelTypeToJSON(object: ModelType): string {
  switch (object) {
    case ModelType.MODEL_TYPE_UNSPECIFIED:
      return "MODEL_TYPE_UNSPECIFIED";
    case ModelType.MODEL_TYPE_TRUST_SCORE:
      return "MODEL_TYPE_TRUST_SCORE";
    case ModelType.MODEL_TYPE_FACE_VERIFICATION:
      return "MODEL_TYPE_FACE_VERIFICATION";
    case ModelType.MODEL_TYPE_LIVENESS:
      return "MODEL_TYPE_LIVENESS";
    case ModelType.MODEL_TYPE_GAN_DETECTION:
      return "MODEL_TYPE_GAN_DETECTION";
    case ModelType.MODEL_TYPE_OCR:
      return "MODEL_TYPE_OCR";
    case ModelType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ModelStatus represents the lifecycle status of a model */
export enum ModelStatus {
  /** MODEL_STATUS_UNSPECIFIED - MODEL_STATUS_UNSPECIFIED is the default unspecified status */
  MODEL_STATUS_UNSPECIFIED = 0,
  /** MODEL_STATUS_PENDING - MODEL_STATUS_PENDING indicates the model is pending activation */
  MODEL_STATUS_PENDING = 1,
  /** MODEL_STATUS_ACTIVE - MODEL_STATUS_ACTIVE indicates the model is currently active */
  MODEL_STATUS_ACTIVE = 2,
  /** MODEL_STATUS_DEPRECATED - MODEL_STATUS_DEPRECATED indicates the model has been deprecated */
  MODEL_STATUS_DEPRECATED = 3,
  /** MODEL_STATUS_REVOKED - MODEL_STATUS_REVOKED indicates the model has been revoked */
  MODEL_STATUS_REVOKED = 4,
  UNRECOGNIZED = -1,
}

export function modelStatusFromJSON(object: any): ModelStatus {
  switch (object) {
    case 0:
    case "MODEL_STATUS_UNSPECIFIED":
      return ModelStatus.MODEL_STATUS_UNSPECIFIED;
    case 1:
    case "MODEL_STATUS_PENDING":
      return ModelStatus.MODEL_STATUS_PENDING;
    case 2:
    case "MODEL_STATUS_ACTIVE":
      return ModelStatus.MODEL_STATUS_ACTIVE;
    case 3:
    case "MODEL_STATUS_DEPRECATED":
      return ModelStatus.MODEL_STATUS_DEPRECATED;
    case 4:
    case "MODEL_STATUS_REVOKED":
      return ModelStatus.MODEL_STATUS_REVOKED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelStatus.UNRECOGNIZED;
  }
}

export function modelStatusToJSON(object: ModelStatus): string {
  switch (object) {
    case ModelStatus.MODEL_STATUS_UNSPECIFIED:
      return "MODEL_STATUS_UNSPECIFIED";
    case ModelStatus.MODEL_STATUS_PENDING:
      return "MODEL_STATUS_PENDING";
    case ModelStatus.MODEL_STATUS_ACTIVE:
      return "MODEL_STATUS_ACTIVE";
    case ModelStatus.MODEL_STATUS_DEPRECATED:
      return "MODEL_STATUS_DEPRECATED";
    case ModelStatus.MODEL_STATUS_REVOKED:
      return "MODEL_STATUS_REVOKED";
    case ModelStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ModelProposalStatus represents the status of a model update proposal */
export enum ModelProposalStatus {
  /** MODEL_PROPOSAL_STATUS_UNSPECIFIED - MODEL_PROPOSAL_STATUS_UNSPECIFIED is the default unspecified status */
  MODEL_PROPOSAL_STATUS_UNSPECIFIED = 0,
  /** MODEL_PROPOSAL_STATUS_PENDING - MODEL_PROPOSAL_STATUS_PENDING indicates the proposal is pending */
  MODEL_PROPOSAL_STATUS_PENDING = 1,
  /** MODEL_PROPOSAL_STATUS_APPROVED - MODEL_PROPOSAL_STATUS_APPROVED indicates the proposal was approved */
  MODEL_PROPOSAL_STATUS_APPROVED = 2,
  /** MODEL_PROPOSAL_STATUS_REJECTED - MODEL_PROPOSAL_STATUS_REJECTED indicates the proposal was rejected */
  MODEL_PROPOSAL_STATUS_REJECTED = 3,
  /** MODEL_PROPOSAL_STATUS_ACTIVATED - MODEL_PROPOSAL_STATUS_ACTIVATED indicates the model has been activated */
  MODEL_PROPOSAL_STATUS_ACTIVATED = 4,
  /** MODEL_PROPOSAL_STATUS_EXPIRED - MODEL_PROPOSAL_STATUS_EXPIRED indicates the proposal has expired */
  MODEL_PROPOSAL_STATUS_EXPIRED = 5,
  UNRECOGNIZED = -1,
}

export function modelProposalStatusFromJSON(object: any): ModelProposalStatus {
  switch (object) {
    case 0:
    case "MODEL_PROPOSAL_STATUS_UNSPECIFIED":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_UNSPECIFIED;
    case 1:
    case "MODEL_PROPOSAL_STATUS_PENDING":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_PENDING;
    case 2:
    case "MODEL_PROPOSAL_STATUS_APPROVED":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_APPROVED;
    case 3:
    case "MODEL_PROPOSAL_STATUS_REJECTED":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_REJECTED;
    case 4:
    case "MODEL_PROPOSAL_STATUS_ACTIVATED":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_ACTIVATED;
    case 5:
    case "MODEL_PROPOSAL_STATUS_EXPIRED":
      return ModelProposalStatus.MODEL_PROPOSAL_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ModelProposalStatus.UNRECOGNIZED;
  }
}

export function modelProposalStatusToJSON(object: ModelProposalStatus): string {
  switch (object) {
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_UNSPECIFIED:
      return "MODEL_PROPOSAL_STATUS_UNSPECIFIED";
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_PENDING:
      return "MODEL_PROPOSAL_STATUS_PENDING";
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_APPROVED:
      return "MODEL_PROPOSAL_STATUS_APPROVED";
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_REJECTED:
      return "MODEL_PROPOSAL_STATUS_REJECTED";
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_ACTIVATED:
      return "MODEL_PROPOSAL_STATUS_ACTIVATED";
    case ModelProposalStatus.MODEL_PROPOSAL_STATUS_EXPIRED:
      return "MODEL_PROPOSAL_STATUS_EXPIRED";
    case ModelProposalStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MLModelInfo describes a registered ML model for version tracking */
export interface MLModelInfo {
  /** ModelID is the unique identifier for this model */
  modelId: string;
  /** Name is the human-readable name of the model */
  name: string;
  /** Version is the semantic version of the model (e.g., "1.0.0") */
  version: string;
  /** ModelType is the type of model (e.g., "face_verification") */
  modelType: string;
  /** SHA256Hash is the SHA256 hash of the model binary */
  sha256Hash: string;
  /** Description is a human-readable description of the model */
  description: string;
  /** ActivatedAt is the block height when this model was activated */
  activatedAt: Long;
  /** RegisteredAt is the block height when this model was registered */
  registeredAt: Long;
  /** RegisteredBy is the address that registered this model */
  registeredBy: string;
  /** GovernanceID is the governance proposal ID that approved this model */
  governanceId: Long;
  /** Status is the current status of the model */
  status: ModelStatus;
}

/** ModelVersionState tracks the current active model versions for consensus */
export interface ModelVersionState {
  /** TrustScoreModel is the active model ID for trust scoring */
  trustScoreModel: string;
  /** FaceVerificationModel is the active model ID for face verification */
  faceVerificationModel: string;
  /** LivenessModel is the active model ID for liveness detection */
  livenessModel: string;
  /** GANDetectionModel is the active model ID for GAN detection */
  ganDetectionModel: string;
  /** OCRModel is the active model ID for OCR extraction */
  ocrModel: string;
  /** LastUpdated is the block height when state was last updated */
  lastUpdated: Long;
}

/** ModelUpdateProposal for governance-controlled model updates */
export interface ModelUpdateProposal {
  /** Title is the proposal title */
  title: string;
  /** Description is the detailed proposal description */
  description: string;
  /** ModelType is the type of model being updated */
  modelType: string;
  /** NewModelID is the ID of the new model to activate */
  newModelId: string;
  /** NewModelHash is the SHA256 hash of the new model */
  newModelHash: string;
  /** ActivationDelay is the number of blocks to wait after approval */
  activationDelay: Long;
  /** ProposedAt is the block height when proposal was submitted */
  proposedAt: Long;
  /** ProposerAddress is the address that submitted the proposal */
  proposerAddress: string;
  /** Status is the current status of the proposal */
  status: ModelProposalStatus;
  /** GovernanceID is the governance proposal ID (set when submitted to gov) */
  governanceId: Long;
  /** ActivationHeight is the block height when activation should occur */
  activationHeight: Long;
}

/** ModelVersionHistory tracks model version changes */
export interface ModelVersionHistory {
  /** HistoryID is the unique identifier for this history entry */
  historyId: string;
  /** ModelType is the type of model that was changed */
  modelType: string;
  /** OldModelID is the previous model ID (empty if first model) */
  oldModelId: string;
  /** NewModelID is the new model ID */
  newModelId: string;
  /** OldModelHash is the previous model hash */
  oldModelHash: string;
  /** NewModelHash is the new model hash */
  newModelHash: string;
  /** ChangedAt is the block height when the change occurred */
  changedAt: Long;
  /** GovernanceID is the governance proposal ID that approved this change */
  governanceId: Long;
  /** ProposerAddress is the address that proposed this change */
  proposerAddress: string;
  /** Reason is the reason for the change */
  reason: string;
}

/** ValidatorModelReport represents a validator's reported model versions */
export interface ValidatorModelReport {
  /** ValidatorAddress is the validator's operator address */
  validatorAddress: string;
  /** ModelVersions maps model type to SHA256 hash */
  modelVersions: { [key: string]: string };
  /** ReportedAt is the block height when this report was submitted */
  reportedAt: Long;
  /** LastVerified is the block height when versions were last verified */
  lastVerified: Long;
  /** IsSynced indicates if all model versions match consensus */
  isSynced: boolean;
  /** MismatchedModels lists model types with version mismatches */
  mismatchedModels: string[];
}

export interface ValidatorModelReport_ModelVersionsEntry {
  key: string;
  value: string;
}

/** ModelParams contains parameters for model management */
export interface ModelParams {
  /** RequiredModelTypes lists model types that must be registered */
  requiredModelTypes: string[];
  /** ActivationDelayBlocks is the default delay for model activation */
  activationDelayBlocks: Long;
  /** MaxModelAgeDays is the maximum age of a model before requiring update */
  maxModelAgeDays: number;
  /** AllowedRegistrars lists addresses allowed to register models */
  allowedRegistrars: string[];
  /** ValidatorSyncGracePeriod is blocks allowed for validators to sync */
  validatorSyncGracePeriod: Long;
  /** ModelUpdateQuorum is the minimum voting power for model updates */
  modelUpdateQuorum: number;
  /** EnableGovernanceUpdates enables governance-controlled updates */
  enableGovernanceUpdates: boolean;
}

/** MsgRegisterModel registers a new ML model */
export interface MsgRegisterModel {
  /** Authority is the address authorized to register models */
  authority: string;
  /** ModelInfo contains the model information */
  modelInfo: MLModelInfo | undefined;
}

/** MsgRegisterModelResponse is the response for MsgRegisterModel */
export interface MsgRegisterModelResponse {
  /** ModelID is the registered model's ID */
  modelId: string;
  /** Status is the initial model status */
  status: ModelStatus;
}

/** MsgProposeModelUpdate proposes updating active model via governance */
export interface MsgProposeModelUpdate {
  /** Proposer is the address proposing the update */
  proposer: string;
  /** Proposal contains the update proposal details */
  proposal: ModelUpdateProposal | undefined;
}

/** MsgProposeModelUpdateResponse is the response for MsgProposeModelUpdate */
export interface MsgProposeModelUpdateResponse {
  /** ProposalID is the governance proposal ID */
  proposalId: Long;
}

/** MsgReportModelVersion reports validator's model versions */
export interface MsgReportModelVersion {
  /** ValidatorAddress is the validator's operator address */
  validatorAddress: string;
  /** ModelVersions maps model type to SHA256 hash */
  modelVersions: { [key: string]: string };
}

export interface MsgReportModelVersion_ModelVersionsEntry {
  key: string;
  value: string;
}

/** MsgReportModelVersionResponse is the response for MsgReportModelVersion */
export interface MsgReportModelVersionResponse {
  /** IsSynced indicates if all models match consensus */
  isSynced: boolean;
  /** MismatchedModels lists any models that don't match */
  mismatchedModels: string[];
}

/** MsgActivateModel activates a pending model after governance approval */
export interface MsgActivateModel {
  /** Authority is the address authorized to activate models */
  authority: string;
  /** ModelType is the type of model to activate */
  modelType: string;
  /** ModelID is the ID of the model to activate */
  modelId: string;
  /** GovernanceID is the governance proposal ID */
  governanceId: Long;
}

/** MsgActivateModelResponse is the response for MsgActivateModel */
export interface MsgActivateModelResponse {
  /** ActivatedAt is the block height when activated */
  activatedAt: Long;
}

/** MsgDeprecateModel deprecates a model */
export interface MsgDeprecateModel {
  /** Authority is the address authorized to deprecate models */
  authority: string;
  /** ModelID is the ID of the model to deprecate */
  modelId: string;
  /** Reason is the reason for deprecation */
  reason: string;
}

/** MsgDeprecateModelResponse is the response for MsgDeprecateModel */
export interface MsgDeprecateModelResponse {
}

/** MsgRevokeModel revokes a model */
export interface MsgRevokeModel {
  /** Authority is the address authorized to revoke models */
  authority: string;
  /** ModelID is the ID of the model to revoke */
  modelId: string;
  /** Reason is the reason for revocation */
  reason: string;
}

/** MsgRevokeModelResponse is the response for MsgRevokeModel */
export interface MsgRevokeModelResponse {
}

function createBaseMLModelInfo(): MLModelInfo {
  return {
    modelId: "",
    name: "",
    version: "",
    modelType: "",
    sha256Hash: "",
    description: "",
    activatedAt: Long.ZERO,
    registeredAt: Long.ZERO,
    registeredBy: "",
    governanceId: Long.UZERO,
    status: 0,
  };
}

export const MLModelInfo: MessageFns<MLModelInfo, "virtengine.veid.v1.MLModelInfo"> = {
  $type: "virtengine.veid.v1.MLModelInfo" as const,

  encode(message: MLModelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelId !== "") {
      writer.uint32(10).string(message.modelId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== "") {
      writer.uint32(26).string(message.version);
    }
    if (message.modelType !== "") {
      writer.uint32(34).string(message.modelType);
    }
    if (message.sha256Hash !== "") {
      writer.uint32(42).string(message.sha256Hash);
    }
    if (message.description !== "") {
      writer.uint32(50).string(message.description);
    }
    if (!message.activatedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.activatedAt.toString());
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.registeredAt.toString());
    }
    if (message.registeredBy !== "") {
      writer.uint32(74).string(message.registeredBy);
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.governanceId.toString());
    }
    if (message.status !== 0) {
      writer.uint32(88).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MLModelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMLModelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.version = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sha256Hash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.activatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.registeredAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.registeredBy = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.governanceId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MLModelInfo {
    return {
      modelId: isSet(object.model_id) ? globalThis.String(object.model_id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.String(object.version) : "",
      modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "",
      sha256Hash: isSet(object.sha256_hash) ? globalThis.String(object.sha256_hash) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      activatedAt: isSet(object.activated_at) ? Long.fromValue(object.activated_at) : Long.ZERO,
      registeredAt: isSet(object.registered_at) ? Long.fromValue(object.registered_at) : Long.ZERO,
      registeredBy: isSet(object.registered_by) ? globalThis.String(object.registered_by) : "",
      governanceId: isSet(object.governance_id) ? Long.fromValue(object.governance_id) : Long.UZERO,
      status: isSet(object.status) ? modelStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MLModelInfo): unknown {
    const obj: any = {};
    if (message.modelId !== "") {
      obj.model_id = message.modelId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== "") {
      obj.version = message.version;
    }
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    if (message.sha256Hash !== "") {
      obj.sha256_hash = message.sha256Hash;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (!message.activatedAt.equals(Long.ZERO)) {
      obj.activated_at = (message.activatedAt || Long.ZERO).toString();
    }
    if (!message.registeredAt.equals(Long.ZERO)) {
      obj.registered_at = (message.registeredAt || Long.ZERO).toString();
    }
    if (message.registeredBy !== "") {
      obj.registered_by = message.registeredBy;
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      obj.governance_id = (message.governanceId || Long.UZERO).toString();
    }
    if (message.status !== 0) {
      obj.status = modelStatusToJSON(message.status);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MLModelInfo>): MLModelInfo {
    const message = createBaseMLModelInfo();
    message.modelId = object.modelId ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? "";
    message.modelType = object.modelType ?? "";
    message.sha256Hash = object.sha256Hash ?? "";
    message.description = object.description ?? "";
    message.activatedAt = (object.activatedAt !== undefined && object.activatedAt !== null)
      ? Long.fromValue(object.activatedAt)
      : Long.ZERO;
    message.registeredAt = (object.registeredAt !== undefined && object.registeredAt !== null)
      ? Long.fromValue(object.registeredAt)
      : Long.ZERO;
    message.registeredBy = object.registeredBy ?? "";
    message.governanceId = (object.governanceId !== undefined && object.governanceId !== null)
      ? Long.fromValue(object.governanceId)
      : Long.UZERO;
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseModelVersionState(): ModelVersionState {
  return {
    trustScoreModel: "",
    faceVerificationModel: "",
    livenessModel: "",
    ganDetectionModel: "",
    ocrModel: "",
    lastUpdated: Long.ZERO,
  };
}

export const ModelVersionState: MessageFns<ModelVersionState, "virtengine.veid.v1.ModelVersionState"> = {
  $type: "virtengine.veid.v1.ModelVersionState" as const,

  encode(message: ModelVersionState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trustScoreModel !== "") {
      writer.uint32(10).string(message.trustScoreModel);
    }
    if (message.faceVerificationModel !== "") {
      writer.uint32(18).string(message.faceVerificationModel);
    }
    if (message.livenessModel !== "") {
      writer.uint32(26).string(message.livenessModel);
    }
    if (message.ganDetectionModel !== "") {
      writer.uint32(34).string(message.ganDetectionModel);
    }
    if (message.ocrModel !== "") {
      writer.uint32(42).string(message.ocrModel);
    }
    if (!message.lastUpdated.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.lastUpdated.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trustScoreModel = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.faceVerificationModel = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.livenessModel = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ganDetectionModel = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ocrModel = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.lastUpdated = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionState {
    return {
      trustScoreModel: isSet(object.trust_score_model) ? globalThis.String(object.trust_score_model) : "",
      faceVerificationModel: isSet(object.face_verification_model)
        ? globalThis.String(object.face_verification_model)
        : "",
      livenessModel: isSet(object.liveness_model) ? globalThis.String(object.liveness_model) : "",
      ganDetectionModel: isSet(object.gan_detection_model) ? globalThis.String(object.gan_detection_model) : "",
      ocrModel: isSet(object.ocr_model) ? globalThis.String(object.ocr_model) : "",
      lastUpdated: isSet(object.last_updated) ? Long.fromValue(object.last_updated) : Long.ZERO,
    };
  },

  toJSON(message: ModelVersionState): unknown {
    const obj: any = {};
    if (message.trustScoreModel !== "") {
      obj.trust_score_model = message.trustScoreModel;
    }
    if (message.faceVerificationModel !== "") {
      obj.face_verification_model = message.faceVerificationModel;
    }
    if (message.livenessModel !== "") {
      obj.liveness_model = message.livenessModel;
    }
    if (message.ganDetectionModel !== "") {
      obj.gan_detection_model = message.ganDetectionModel;
    }
    if (message.ocrModel !== "") {
      obj.ocr_model = message.ocrModel;
    }
    if (!message.lastUpdated.equals(Long.ZERO)) {
      obj.last_updated = (message.lastUpdated || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ModelVersionState>): ModelVersionState {
    const message = createBaseModelVersionState();
    message.trustScoreModel = object.trustScoreModel ?? "";
    message.faceVerificationModel = object.faceVerificationModel ?? "";
    message.livenessModel = object.livenessModel ?? "";
    message.ganDetectionModel = object.ganDetectionModel ?? "";
    message.ocrModel = object.ocrModel ?? "";
    message.lastUpdated = (object.lastUpdated !== undefined && object.lastUpdated !== null)
      ? Long.fromValue(object.lastUpdated)
      : Long.ZERO;
    return message;
  },
};

function createBaseModelUpdateProposal(): ModelUpdateProposal {
  return {
    title: "",
    description: "",
    modelType: "",
    newModelId: "",
    newModelHash: "",
    activationDelay: Long.ZERO,
    proposedAt: Long.ZERO,
    proposerAddress: "",
    status: 0,
    governanceId: Long.UZERO,
    activationHeight: Long.ZERO,
  };
}

export const ModelUpdateProposal: MessageFns<ModelUpdateProposal, "virtengine.veid.v1.ModelUpdateProposal"> = {
  $type: "virtengine.veid.v1.ModelUpdateProposal" as const,

  encode(message: ModelUpdateProposal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.modelType !== "") {
      writer.uint32(26).string(message.modelType);
    }
    if (message.newModelId !== "") {
      writer.uint32(34).string(message.newModelId);
    }
    if (message.newModelHash !== "") {
      writer.uint32(42).string(message.newModelHash);
    }
    if (!message.activationDelay.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.activationDelay.toString());
    }
    if (!message.proposedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.proposedAt.toString());
    }
    if (message.proposerAddress !== "") {
      writer.uint32(66).string(message.proposerAddress);
    }
    if (message.status !== 0) {
      writer.uint32(72).int32(message.status);
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      writer.uint32(80).uint64(message.governanceId.toString());
    }
    if (!message.activationHeight.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.activationHeight.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelUpdateProposal {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelUpdateProposal();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newModelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newModelHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.activationDelay = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.proposedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.proposerAddress = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.governanceId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.activationHeight = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelUpdateProposal {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "",
      newModelId: isSet(object.new_model_id) ? globalThis.String(object.new_model_id) : "",
      newModelHash: isSet(object.new_model_hash) ? globalThis.String(object.new_model_hash) : "",
      activationDelay: isSet(object.activation_delay) ? Long.fromValue(object.activation_delay) : Long.ZERO,
      proposedAt: isSet(object.proposed_at) ? Long.fromValue(object.proposed_at) : Long.ZERO,
      proposerAddress: isSet(object.proposer_address) ? globalThis.String(object.proposer_address) : "",
      status: isSet(object.status) ? modelProposalStatusFromJSON(object.status) : 0,
      governanceId: isSet(object.governance_id) ? Long.fromValue(object.governance_id) : Long.UZERO,
      activationHeight: isSet(object.activation_height) ? Long.fromValue(object.activation_height) : Long.ZERO,
    };
  },

  toJSON(message: ModelUpdateProposal): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    if (message.newModelId !== "") {
      obj.new_model_id = message.newModelId;
    }
    if (message.newModelHash !== "") {
      obj.new_model_hash = message.newModelHash;
    }
    if (!message.activationDelay.equals(Long.ZERO)) {
      obj.activation_delay = (message.activationDelay || Long.ZERO).toString();
    }
    if (!message.proposedAt.equals(Long.ZERO)) {
      obj.proposed_at = (message.proposedAt || Long.ZERO).toString();
    }
    if (message.proposerAddress !== "") {
      obj.proposer_address = message.proposerAddress;
    }
    if (message.status !== 0) {
      obj.status = modelProposalStatusToJSON(message.status);
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      obj.governance_id = (message.governanceId || Long.UZERO).toString();
    }
    if (!message.activationHeight.equals(Long.ZERO)) {
      obj.activation_height = (message.activationHeight || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ModelUpdateProposal>): ModelUpdateProposal {
    const message = createBaseModelUpdateProposal();
    message.title = object.title ?? "";
    message.description = object.description ?? "";
    message.modelType = object.modelType ?? "";
    message.newModelId = object.newModelId ?? "";
    message.newModelHash = object.newModelHash ?? "";
    message.activationDelay = (object.activationDelay !== undefined && object.activationDelay !== null)
      ? Long.fromValue(object.activationDelay)
      : Long.ZERO;
    message.proposedAt = (object.proposedAt !== undefined && object.proposedAt !== null)
      ? Long.fromValue(object.proposedAt)
      : Long.ZERO;
    message.proposerAddress = object.proposerAddress ?? "";
    message.status = object.status ?? 0;
    message.governanceId = (object.governanceId !== undefined && object.governanceId !== null)
      ? Long.fromValue(object.governanceId)
      : Long.UZERO;
    message.activationHeight = (object.activationHeight !== undefined && object.activationHeight !== null)
      ? Long.fromValue(object.activationHeight)
      : Long.ZERO;
    return message;
  },
};

function createBaseModelVersionHistory(): ModelVersionHistory {
  return {
    historyId: "",
    modelType: "",
    oldModelId: "",
    newModelId: "",
    oldModelHash: "",
    newModelHash: "",
    changedAt: Long.ZERO,
    governanceId: Long.UZERO,
    proposerAddress: "",
    reason: "",
  };
}

export const ModelVersionHistory: MessageFns<ModelVersionHistory, "virtengine.veid.v1.ModelVersionHistory"> = {
  $type: "virtengine.veid.v1.ModelVersionHistory" as const,

  encode(message: ModelVersionHistory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.historyId !== "") {
      writer.uint32(10).string(message.historyId);
    }
    if (message.modelType !== "") {
      writer.uint32(18).string(message.modelType);
    }
    if (message.oldModelId !== "") {
      writer.uint32(26).string(message.oldModelId);
    }
    if (message.newModelId !== "") {
      writer.uint32(34).string(message.newModelId);
    }
    if (message.oldModelHash !== "") {
      writer.uint32(42).string(message.oldModelHash);
    }
    if (message.newModelHash !== "") {
      writer.uint32(50).string(message.newModelHash);
    }
    if (!message.changedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.changedAt.toString());
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.governanceId.toString());
    }
    if (message.proposerAddress !== "") {
      writer.uint32(74).string(message.proposerAddress);
    }
    if (message.reason !== "") {
      writer.uint32(82).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelVersionHistory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelVersionHistory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.historyId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldModelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.newModelId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.oldModelHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.newModelHash = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.changedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.governanceId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.proposerAddress = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelVersionHistory {
    return {
      historyId: isSet(object.history_id) ? globalThis.String(object.history_id) : "",
      modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "",
      oldModelId: isSet(object.old_model_id) ? globalThis.String(object.old_model_id) : "",
      newModelId: isSet(object.new_model_id) ? globalThis.String(object.new_model_id) : "",
      oldModelHash: isSet(object.old_model_hash) ? globalThis.String(object.old_model_hash) : "",
      newModelHash: isSet(object.new_model_hash) ? globalThis.String(object.new_model_hash) : "",
      changedAt: isSet(object.changed_at) ? Long.fromValue(object.changed_at) : Long.ZERO,
      governanceId: isSet(object.governance_id) ? Long.fromValue(object.governance_id) : Long.UZERO,
      proposerAddress: isSet(object.proposer_address) ? globalThis.String(object.proposer_address) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: ModelVersionHistory): unknown {
    const obj: any = {};
    if (message.historyId !== "") {
      obj.history_id = message.historyId;
    }
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    if (message.oldModelId !== "") {
      obj.old_model_id = message.oldModelId;
    }
    if (message.newModelId !== "") {
      obj.new_model_id = message.newModelId;
    }
    if (message.oldModelHash !== "") {
      obj.old_model_hash = message.oldModelHash;
    }
    if (message.newModelHash !== "") {
      obj.new_model_hash = message.newModelHash;
    }
    if (!message.changedAt.equals(Long.ZERO)) {
      obj.changed_at = (message.changedAt || Long.ZERO).toString();
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      obj.governance_id = (message.governanceId || Long.UZERO).toString();
    }
    if (message.proposerAddress !== "") {
      obj.proposer_address = message.proposerAddress;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ModelVersionHistory>): ModelVersionHistory {
    const message = createBaseModelVersionHistory();
    message.historyId = object.historyId ?? "";
    message.modelType = object.modelType ?? "";
    message.oldModelId = object.oldModelId ?? "";
    message.newModelId = object.newModelId ?? "";
    message.oldModelHash = object.oldModelHash ?? "";
    message.newModelHash = object.newModelHash ?? "";
    message.changedAt = (object.changedAt !== undefined && object.changedAt !== null)
      ? Long.fromValue(object.changedAt)
      : Long.ZERO;
    message.governanceId = (object.governanceId !== undefined && object.governanceId !== null)
      ? Long.fromValue(object.governanceId)
      : Long.UZERO;
    message.proposerAddress = object.proposerAddress ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseValidatorModelReport(): ValidatorModelReport {
  return {
    validatorAddress: "",
    modelVersions: {},
    reportedAt: Long.ZERO,
    lastVerified: Long.ZERO,
    isSynced: false,
    mismatchedModels: [],
  };
}

export const ValidatorModelReport: MessageFns<ValidatorModelReport, "virtengine.veid.v1.ValidatorModelReport"> = {
  $type: "virtengine.veid.v1.ValidatorModelReport" as const,

  encode(message: ValidatorModelReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    Object.entries(message.modelVersions).forEach(([key, value]) => {
      ValidatorModelReport_ModelVersionsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    if (!message.reportedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.reportedAt.toString());
    }
    if (!message.lastVerified.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastVerified.toString());
    }
    if (message.isSynced !== false) {
      writer.uint32(40).bool(message.isSynced);
    }
    for (const v of message.mismatchedModels) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorModelReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorModelReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ValidatorModelReport_ModelVersionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.modelVersions[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reportedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastVerified = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mismatchedModels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorModelReport {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      modelVersions: isObject(object.model_versions)
        ? Object.entries(object.model_versions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      reportedAt: isSet(object.reported_at) ? Long.fromValue(object.reported_at) : Long.ZERO,
      lastVerified: isSet(object.last_verified) ? Long.fromValue(object.last_verified) : Long.ZERO,
      isSynced: isSet(object.is_synced) ? globalThis.Boolean(object.is_synced) : false,
      mismatchedModels: globalThis.Array.isArray(object?.mismatched_models)
        ? object.mismatched_models.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ValidatorModelReport): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.modelVersions) {
      const entries = Object.entries(message.modelVersions);
      if (entries.length > 0) {
        obj.model_versions = {};
        entries.forEach(([k, v]) => {
          obj.model_versions[k] = v;
        });
      }
    }
    if (!message.reportedAt.equals(Long.ZERO)) {
      obj.reported_at = (message.reportedAt || Long.ZERO).toString();
    }
    if (!message.lastVerified.equals(Long.ZERO)) {
      obj.last_verified = (message.lastVerified || Long.ZERO).toString();
    }
    if (message.isSynced !== false) {
      obj.is_synced = message.isSynced;
    }
    if (message.mismatchedModels?.length) {
      obj.mismatched_models = message.mismatchedModels;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorModelReport>): ValidatorModelReport {
    const message = createBaseValidatorModelReport();
    message.validatorAddress = object.validatorAddress ?? "";
    message.modelVersions = Object.entries(object.modelVersions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.reportedAt = (object.reportedAt !== undefined && object.reportedAt !== null)
      ? Long.fromValue(object.reportedAt)
      : Long.ZERO;
    message.lastVerified = (object.lastVerified !== undefined && object.lastVerified !== null)
      ? Long.fromValue(object.lastVerified)
      : Long.ZERO;
    message.isSynced = object.isSynced ?? false;
    message.mismatchedModels = object.mismatchedModels?.map((e) => e) || [];
    return message;
  },
};

function createBaseValidatorModelReport_ModelVersionsEntry(): ValidatorModelReport_ModelVersionsEntry {
  return { key: "", value: "" };
}

export const ValidatorModelReport_ModelVersionsEntry: MessageFns<
  ValidatorModelReport_ModelVersionsEntry,
  "virtengine.veid.v1.ValidatorModelReport.ModelVersionsEntry"
> = {
  $type: "virtengine.veid.v1.ValidatorModelReport.ModelVersionsEntry" as const,

  encode(message: ValidatorModelReport_ModelVersionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorModelReport_ModelVersionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorModelReport_ModelVersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorModelReport_ModelVersionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ValidatorModelReport_ModelVersionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorModelReport_ModelVersionsEntry>): ValidatorModelReport_ModelVersionsEntry {
    const message = createBaseValidatorModelReport_ModelVersionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseModelParams(): ModelParams {
  return {
    requiredModelTypes: [],
    activationDelayBlocks: Long.ZERO,
    maxModelAgeDays: 0,
    allowedRegistrars: [],
    validatorSyncGracePeriod: Long.ZERO,
    modelUpdateQuorum: 0,
    enableGovernanceUpdates: false,
  };
}

export const ModelParams: MessageFns<ModelParams, "virtengine.veid.v1.ModelParams"> = {
  $type: "virtengine.veid.v1.ModelParams" as const,

  encode(message: ModelParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.requiredModelTypes) {
      writer.uint32(10).string(v!);
    }
    if (!message.activationDelayBlocks.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.activationDelayBlocks.toString());
    }
    if (message.maxModelAgeDays !== 0) {
      writer.uint32(24).int32(message.maxModelAgeDays);
    }
    for (const v of message.allowedRegistrars) {
      writer.uint32(34).string(v!);
    }
    if (!message.validatorSyncGracePeriod.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.validatorSyncGracePeriod.toString());
    }
    if (message.modelUpdateQuorum !== 0) {
      writer.uint32(48).uint32(message.modelUpdateQuorum);
    }
    if (message.enableGovernanceUpdates !== false) {
      writer.uint32(56).bool(message.enableGovernanceUpdates);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModelParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModelParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requiredModelTypes.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.activationDelayBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxModelAgeDays = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.allowedRegistrars.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validatorSyncGracePeriod = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.modelUpdateQuorum = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.enableGovernanceUpdates = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModelParams {
    return {
      requiredModelTypes: globalThis.Array.isArray(object?.required_model_types)
        ? object.required_model_types.map((e: any) => globalThis.String(e))
        : [],
      activationDelayBlocks: isSet(object.activation_delay_blocks)
        ? Long.fromValue(object.activation_delay_blocks)
        : Long.ZERO,
      maxModelAgeDays: isSet(object.max_model_age_days) ? globalThis.Number(object.max_model_age_days) : 0,
      allowedRegistrars: globalThis.Array.isArray(object?.allowed_registrars)
        ? object.allowed_registrars.map((e: any) => globalThis.String(e))
        : [],
      validatorSyncGracePeriod: isSet(object.validator_sync_grace_period)
        ? Long.fromValue(object.validator_sync_grace_period)
        : Long.ZERO,
      modelUpdateQuorum: isSet(object.model_update_quorum) ? globalThis.Number(object.model_update_quorum) : 0,
      enableGovernanceUpdates: isSet(object.enable_governance_updates)
        ? globalThis.Boolean(object.enable_governance_updates)
        : false,
    };
  },

  toJSON(message: ModelParams): unknown {
    const obj: any = {};
    if (message.requiredModelTypes?.length) {
      obj.required_model_types = message.requiredModelTypes;
    }
    if (!message.activationDelayBlocks.equals(Long.ZERO)) {
      obj.activation_delay_blocks = (message.activationDelayBlocks || Long.ZERO).toString();
    }
    if (message.maxModelAgeDays !== 0) {
      obj.max_model_age_days = Math.round(message.maxModelAgeDays);
    }
    if (message.allowedRegistrars?.length) {
      obj.allowed_registrars = message.allowedRegistrars;
    }
    if (!message.validatorSyncGracePeriod.equals(Long.ZERO)) {
      obj.validator_sync_grace_period = (message.validatorSyncGracePeriod || Long.ZERO).toString();
    }
    if (message.modelUpdateQuorum !== 0) {
      obj.model_update_quorum = Math.round(message.modelUpdateQuorum);
    }
    if (message.enableGovernanceUpdates !== false) {
      obj.enable_governance_updates = message.enableGovernanceUpdates;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ModelParams>): ModelParams {
    const message = createBaseModelParams();
    message.requiredModelTypes = object.requiredModelTypes?.map((e) => e) || [];
    message.activationDelayBlocks =
      (object.activationDelayBlocks !== undefined && object.activationDelayBlocks !== null)
        ? Long.fromValue(object.activationDelayBlocks)
        : Long.ZERO;
    message.maxModelAgeDays = object.maxModelAgeDays ?? 0;
    message.allowedRegistrars = object.allowedRegistrars?.map((e) => e) || [];
    message.validatorSyncGracePeriod =
      (object.validatorSyncGracePeriod !== undefined && object.validatorSyncGracePeriod !== null)
        ? Long.fromValue(object.validatorSyncGracePeriod)
        : Long.ZERO;
    message.modelUpdateQuorum = object.modelUpdateQuorum ?? 0;
    message.enableGovernanceUpdates = object.enableGovernanceUpdates ?? false;
    return message;
  },
};

function createBaseMsgRegisterModel(): MsgRegisterModel {
  return { authority: "", modelInfo: undefined };
}

export const MsgRegisterModel: MessageFns<MsgRegisterModel, "virtengine.veid.v1.MsgRegisterModel"> = {
  $type: "virtengine.veid.v1.MsgRegisterModel" as const,

  encode(message: MsgRegisterModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.modelInfo !== undefined) {
      MLModelInfo.encode(message.modelInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelInfo = MLModelInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterModel {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      modelInfo: isSet(object.model_info) ? MLModelInfo.fromJSON(object.model_info) : undefined,
    };
  },

  toJSON(message: MsgRegisterModel): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.modelInfo !== undefined) {
      obj.model_info = MLModelInfo.toJSON(message.modelInfo);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterModel>): MsgRegisterModel {
    const message = createBaseMsgRegisterModel();
    message.authority = object.authority ?? "";
    message.modelInfo = (object.modelInfo !== undefined && object.modelInfo !== null)
      ? MLModelInfo.fromPartial(object.modelInfo)
      : undefined;
    return message;
  },
};

function createBaseMsgRegisterModelResponse(): MsgRegisterModelResponse {
  return { modelId: "", status: 0 };
}

export const MsgRegisterModelResponse: MessageFns<
  MsgRegisterModelResponse,
  "virtengine.veid.v1.MsgRegisterModelResponse"
> = {
  $type: "virtengine.veid.v1.MsgRegisterModelResponse" as const,

  encode(message: MsgRegisterModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.modelId !== "") {
      writer.uint32(10).string(message.modelId);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRegisterModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRegisterModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRegisterModelResponse {
    return {
      modelId: isSet(object.model_id) ? globalThis.String(object.model_id) : "",
      status: isSet(object.status) ? modelStatusFromJSON(object.status) : 0,
    };
  },

  toJSON(message: MsgRegisterModelResponse): unknown {
    const obj: any = {};
    if (message.modelId !== "") {
      obj.model_id = message.modelId;
    }
    if (message.status !== 0) {
      obj.status = modelStatusToJSON(message.status);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRegisterModelResponse>): MsgRegisterModelResponse {
    const message = createBaseMsgRegisterModelResponse();
    message.modelId = object.modelId ?? "";
    message.status = object.status ?? 0;
    return message;
  },
};

function createBaseMsgProposeModelUpdate(): MsgProposeModelUpdate {
  return { proposer: "", proposal: undefined };
}

export const MsgProposeModelUpdate: MessageFns<MsgProposeModelUpdate, "virtengine.veid.v1.MsgProposeModelUpdate"> = {
  $type: "virtengine.veid.v1.MsgProposeModelUpdate" as const,

  encode(message: MsgProposeModelUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.proposer !== "") {
      writer.uint32(10).string(message.proposer);
    }
    if (message.proposal !== undefined) {
      ModelUpdateProposal.encode(message.proposal, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposeModelUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeModelUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.proposer = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.proposal = ModelUpdateProposal.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeModelUpdate {
    return {
      proposer: isSet(object.proposer) ? globalThis.String(object.proposer) : "",
      proposal: isSet(object.proposal) ? ModelUpdateProposal.fromJSON(object.proposal) : undefined,
    };
  },

  toJSON(message: MsgProposeModelUpdate): unknown {
    const obj: any = {};
    if (message.proposer !== "") {
      obj.proposer = message.proposer;
    }
    if (message.proposal !== undefined) {
      obj.proposal = ModelUpdateProposal.toJSON(message.proposal);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgProposeModelUpdate>): MsgProposeModelUpdate {
    const message = createBaseMsgProposeModelUpdate();
    message.proposer = object.proposer ?? "";
    message.proposal = (object.proposal !== undefined && object.proposal !== null)
      ? ModelUpdateProposal.fromPartial(object.proposal)
      : undefined;
    return message;
  },
};

function createBaseMsgProposeModelUpdateResponse(): MsgProposeModelUpdateResponse {
  return { proposalId: Long.UZERO };
}

export const MsgProposeModelUpdateResponse: MessageFns<
  MsgProposeModelUpdateResponse,
  "virtengine.veid.v1.MsgProposeModelUpdateResponse"
> = {
  $type: "virtengine.veid.v1.MsgProposeModelUpdateResponse" as const,

  encode(message: MsgProposeModelUpdateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.proposalId.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.proposalId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgProposeModelUpdateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgProposeModelUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.proposalId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgProposeModelUpdateResponse {
    return { proposalId: isSet(object.proposal_id) ? Long.fromValue(object.proposal_id) : Long.UZERO };
  },

  toJSON(message: MsgProposeModelUpdateResponse): unknown {
    const obj: any = {};
    if (!message.proposalId.equals(Long.UZERO)) {
      obj.proposal_id = (message.proposalId || Long.UZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgProposeModelUpdateResponse>): MsgProposeModelUpdateResponse {
    const message = createBaseMsgProposeModelUpdateResponse();
    message.proposalId = (object.proposalId !== undefined && object.proposalId !== null)
      ? Long.fromValue(object.proposalId)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgReportModelVersion(): MsgReportModelVersion {
  return { validatorAddress: "", modelVersions: {} };
}

export const MsgReportModelVersion: MessageFns<MsgReportModelVersion, "virtengine.veid.v1.MsgReportModelVersion"> = {
  $type: "virtengine.veid.v1.MsgReportModelVersion" as const,

  encode(message: MsgReportModelVersion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    Object.entries(message.modelVersions).forEach(([key, value]) => {
      MsgReportModelVersion_ModelVersionsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReportModelVersion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReportModelVersion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = MsgReportModelVersion_ModelVersionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.modelVersions[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReportModelVersion {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      modelVersions: isObject(object.model_versions)
        ? Object.entries(object.model_versions).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: MsgReportModelVersion): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.modelVersions) {
      const entries = Object.entries(message.modelVersions);
      if (entries.length > 0) {
        obj.model_versions = {};
        entries.forEach(([k, v]) => {
          obj.model_versions[k] = v;
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgReportModelVersion>): MsgReportModelVersion {
    const message = createBaseMsgReportModelVersion();
    message.validatorAddress = object.validatorAddress ?? "";
    message.modelVersions = Object.entries(object.modelVersions ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseMsgReportModelVersion_ModelVersionsEntry(): MsgReportModelVersion_ModelVersionsEntry {
  return { key: "", value: "" };
}

export const MsgReportModelVersion_ModelVersionsEntry: MessageFns<
  MsgReportModelVersion_ModelVersionsEntry,
  "virtengine.veid.v1.MsgReportModelVersion.ModelVersionsEntry"
> = {
  $type: "virtengine.veid.v1.MsgReportModelVersion.ModelVersionsEntry" as const,

  encode(message: MsgReportModelVersion_ModelVersionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReportModelVersion_ModelVersionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReportModelVersion_ModelVersionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReportModelVersion_ModelVersionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: MsgReportModelVersion_ModelVersionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgReportModelVersion_ModelVersionsEntry>): MsgReportModelVersion_ModelVersionsEntry {
    const message = createBaseMsgReportModelVersion_ModelVersionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMsgReportModelVersionResponse(): MsgReportModelVersionResponse {
  return { isSynced: false, mismatchedModels: [] };
}

export const MsgReportModelVersionResponse: MessageFns<
  MsgReportModelVersionResponse,
  "virtengine.veid.v1.MsgReportModelVersionResponse"
> = {
  $type: "virtengine.veid.v1.MsgReportModelVersionResponse" as const,

  encode(message: MsgReportModelVersionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.isSynced !== false) {
      writer.uint32(8).bool(message.isSynced);
    }
    for (const v of message.mismatchedModels) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgReportModelVersionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgReportModelVersionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.isSynced = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mismatchedModels.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgReportModelVersionResponse {
    return {
      isSynced: isSet(object.is_synced) ? globalThis.Boolean(object.is_synced) : false,
      mismatchedModels: globalThis.Array.isArray(object?.mismatched_models)
        ? object.mismatched_models.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MsgReportModelVersionResponse): unknown {
    const obj: any = {};
    if (message.isSynced !== false) {
      obj.is_synced = message.isSynced;
    }
    if (message.mismatchedModels?.length) {
      obj.mismatched_models = message.mismatchedModels;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgReportModelVersionResponse>): MsgReportModelVersionResponse {
    const message = createBaseMsgReportModelVersionResponse();
    message.isSynced = object.isSynced ?? false;
    message.mismatchedModels = object.mismatchedModels?.map((e) => e) || [];
    return message;
  },
};

function createBaseMsgActivateModel(): MsgActivateModel {
  return { authority: "", modelType: "", modelId: "", governanceId: Long.UZERO };
}

export const MsgActivateModel: MessageFns<MsgActivateModel, "virtengine.veid.v1.MsgActivateModel"> = {
  $type: "virtengine.veid.v1.MsgActivateModel" as const,

  encode(message: MsgActivateModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.modelType !== "") {
      writer.uint32(18).string(message.modelType);
    }
    if (message.modelId !== "") {
      writer.uint32(26).string(message.modelId);
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      writer.uint32(32).uint64(message.governanceId.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.governanceId = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgActivateModel {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      modelType: isSet(object.model_type) ? globalThis.String(object.model_type) : "",
      modelId: isSet(object.model_id) ? globalThis.String(object.model_id) : "",
      governanceId: isSet(object.governance_id) ? Long.fromValue(object.governance_id) : Long.UZERO,
    };
  },

  toJSON(message: MsgActivateModel): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.modelType !== "") {
      obj.model_type = message.modelType;
    }
    if (message.modelId !== "") {
      obj.model_id = message.modelId;
    }
    if (!message.governanceId.equals(Long.UZERO)) {
      obj.governance_id = (message.governanceId || Long.UZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgActivateModel>): MsgActivateModel {
    const message = createBaseMsgActivateModel();
    message.authority = object.authority ?? "";
    message.modelType = object.modelType ?? "";
    message.modelId = object.modelId ?? "";
    message.governanceId = (object.governanceId !== undefined && object.governanceId !== null)
      ? Long.fromValue(object.governanceId)
      : Long.UZERO;
    return message;
  },
};

function createBaseMsgActivateModelResponse(): MsgActivateModelResponse {
  return { activatedAt: Long.ZERO };
}

export const MsgActivateModelResponse: MessageFns<
  MsgActivateModelResponse,
  "virtengine.veid.v1.MsgActivateModelResponse"
> = {
  $type: "virtengine.veid.v1.MsgActivateModelResponse" as const,

  encode(message: MsgActivateModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.activatedAt.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.activatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgActivateModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgActivateModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.activatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgActivateModelResponse {
    return { activatedAt: isSet(object.activated_at) ? Long.fromValue(object.activated_at) : Long.ZERO };
  },

  toJSON(message: MsgActivateModelResponse): unknown {
    const obj: any = {};
    if (!message.activatedAt.equals(Long.ZERO)) {
      obj.activated_at = (message.activatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgActivateModelResponse>): MsgActivateModelResponse {
    const message = createBaseMsgActivateModelResponse();
    message.activatedAt = (object.activatedAt !== undefined && object.activatedAt !== null)
      ? Long.fromValue(object.activatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseMsgDeprecateModel(): MsgDeprecateModel {
  return { authority: "", modelId: "", reason: "" };
}

export const MsgDeprecateModel: MessageFns<MsgDeprecateModel, "virtengine.veid.v1.MsgDeprecateModel"> = {
  $type: "virtengine.veid.v1.MsgDeprecateModel" as const,

  encode(message: MsgDeprecateModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeprecateModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeprecateModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgDeprecateModel {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      modelId: isSet(object.model_id) ? globalThis.String(object.model_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgDeprecateModel): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.modelId !== "") {
      obj.model_id = message.modelId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgDeprecateModel>): MsgDeprecateModel {
    const message = createBaseMsgDeprecateModel();
    message.authority = object.authority ?? "";
    message.modelId = object.modelId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgDeprecateModelResponse(): MsgDeprecateModelResponse {
  return {};
}

export const MsgDeprecateModelResponse: MessageFns<
  MsgDeprecateModelResponse,
  "virtengine.veid.v1.MsgDeprecateModelResponse"
> = {
  $type: "virtengine.veid.v1.MsgDeprecateModelResponse" as const,

  encode(_: MsgDeprecateModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgDeprecateModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgDeprecateModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgDeprecateModelResponse {
    return {};
  },

  toJSON(_: MsgDeprecateModelResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgDeprecateModelResponse>): MsgDeprecateModelResponse {
    const message = createBaseMsgDeprecateModelResponse();
    return message;
  },
};

function createBaseMsgRevokeModel(): MsgRevokeModel {
  return { authority: "", modelId: "", reason: "" };
}

export const MsgRevokeModel: MessageFns<MsgRevokeModel, "virtengine.veid.v1.MsgRevokeModel"> = {
  $type: "virtengine.veid.v1.MsgRevokeModel" as const,

  encode(message: MsgRevokeModel, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.modelId !== "") {
      writer.uint32(18).string(message.modelId);
    }
    if (message.reason !== "") {
      writer.uint32(26).string(message.reason);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeModel {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeModel();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.modelId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRevokeModel {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      modelId: isSet(object.model_id) ? globalThis.String(object.model_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
    };
  },

  toJSON(message: MsgRevokeModel): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.modelId !== "") {
      obj.model_id = message.modelId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRevokeModel>): MsgRevokeModel {
    const message = createBaseMsgRevokeModel();
    message.authority = object.authority ?? "";
    message.modelId = object.modelId ?? "";
    message.reason = object.reason ?? "";
    return message;
  },
};

function createBaseMsgRevokeModelResponse(): MsgRevokeModelResponse {
  return {};
}

export const MsgRevokeModelResponse: MessageFns<MsgRevokeModelResponse, "virtengine.veid.v1.MsgRevokeModelResponse"> = {
  $type: "virtengine.veid.v1.MsgRevokeModelResponse" as const,

  encode(_: MsgRevokeModelResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRevokeModelResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRevokeModelResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRevokeModelResponse {
    return {};
  },

  toJSON(_: MsgRevokeModelResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgRevokeModelResponse>): MsgRevokeModelResponse {
    const message = createBaseMsgRevokeModelResponse();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
