import { toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/delegation/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** DelegationStatus represents the status of a delegation */
export enum DelegationStatus {
  /** DELEGATION_STATUS_UNSPECIFIED - DELEGATION_STATUS_UNSPECIFIED is the default/invalid status */
  DELEGATION_STATUS_UNSPECIFIED = 0,
  /** DELEGATION_STATUS_ACTIVE - DELEGATION_STATUS_ACTIVE means the delegation is active */
  DELEGATION_STATUS_ACTIVE = 1,
  /** DELEGATION_STATUS_UNBONDING - DELEGATION_STATUS_UNBONDING means the delegation is unbonding */
  DELEGATION_STATUS_UNBONDING = 2,
  UNRECOGNIZED = -1,
}

export function delegationStatusFromJSON(object: any): DelegationStatus {
  switch (object) {
    case 0:
    case "DELEGATION_STATUS_UNSPECIFIED":
      return DelegationStatus.DELEGATION_STATUS_UNSPECIFIED;
    case 1:
    case "DELEGATION_STATUS_ACTIVE":
      return DelegationStatus.DELEGATION_STATUS_ACTIVE;
    case 2:
    case "DELEGATION_STATUS_UNBONDING":
      return DelegationStatus.DELEGATION_STATUS_UNBONDING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DelegationStatus.UNRECOGNIZED;
  }
}

export function delegationStatusToJSON(object: DelegationStatus): string {
  switch (object) {
    case DelegationStatus.DELEGATION_STATUS_UNSPECIFIED:
      return "DELEGATION_STATUS_UNSPECIFIED";
    case DelegationStatus.DELEGATION_STATUS_ACTIVE:
      return "DELEGATION_STATUS_ACTIVE";
    case DelegationStatus.DELEGATION_STATUS_UNBONDING:
      return "DELEGATION_STATUS_UNBONDING";
    case DelegationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Delegation represents a delegation from a delegator to a validator */
export interface Delegation {
  /** delegator_address is the delegator's address */
  delegatorAddress: string;
  /** validator_address is the validator's address */
  validatorAddress: string;
  /** shares is the delegation shares (fixed-point, 18 decimals) */
  shares: string;
  /** initial_amount is the initial delegation amount in base units */
  initialAmount: string;
  /** created_at is when the delegation was created */
  createdAt:
    | Date
    | undefined;
  /** updated_at is when the delegation was last updated */
  updatedAt:
    | Date
    | undefined;
  /** height is the block height when delegation was created */
  height: Long;
}

/** UnbondingDelegationEntry represents a single unbonding entry */
export interface UnbondingDelegationEntry {
  /** creation_height is the height at which the unbonding was created */
  creationHeight: Long;
  /** completion_time is when the unbonding will complete */
  completionTime:
    | Date
    | undefined;
  /** initial_balance is the initial balance to undelegate */
  initialBalance: string;
  /** balance is the remaining balance to return */
  balance: string;
  /** unbonding_shares is the shares being unbonded */
  unbondingShares: string;
}

/** UnbondingDelegation represents a delegation that is unbonding */
export interface UnbondingDelegation {
  /** id is the unique unbonding delegation ID */
  id: string;
  /** delegator_address is the delegator's address */
  delegatorAddress: string;
  /** validator_address is the validator's address */
  validatorAddress: string;
  /** entries are the unbonding entries */
  entries: UnbondingDelegationEntry[];
  /** created_at is when the unbonding started */
  createdAt:
    | Date
    | undefined;
  /** height is the block height when unbonding was initiated */
  height: Long;
}

/** RedelegationEntry represents a single redelegation entry */
export interface RedelegationEntry {
  /** creation_height is the height at which the redelegation was created */
  creationHeight: Long;
  /** completion_time is when the redelegation matures */
  completionTime:
    | Date
    | undefined;
  /** initial_balance is the initial balance being redelegated */
  initialBalance: string;
  /** shares_dst is the shares received at the destination validator */
  sharesDst: string;
}

/** Redelegation represents a redelegation from one validator to another */
export interface Redelegation {
  /** id is the unique redelegation ID */
  id: string;
  /** delegator_address is the delegator's address */
  delegatorAddress: string;
  /** validator_src_address is the source validator's address */
  validatorSrcAddress: string;
  /** validator_dst_address is the destination validator's address */
  validatorDstAddress: string;
  /** entries are the redelegation entries */
  entries: RedelegationEntry[];
  /** created_at is when the redelegation started */
  createdAt:
    | Date
    | undefined;
  /** height is the block height when redelegation was initiated */
  height: Long;
}

/** ValidatorShares represents the total shares for a validator */
export interface ValidatorShares {
  /** validator_address is the validator's address */
  validatorAddress: string;
  /** total_shares is the total delegation shares (fixed-point, 18 decimals) */
  totalShares: string;
  /** total_stake is the total stake amount in base units */
  totalStake: string;
  /** updated_at is when the record was last updated */
  updatedAt: Date | undefined;
}

/** DelegatorReward represents rewards for a delegator from a specific validator */
export interface DelegatorReward {
  /** delegator_address is the delegator's address */
  delegatorAddress: string;
  /** validator_address is the validator's address */
  validatorAddress: string;
  /** epoch_number is the epoch this reward belongs to */
  epochNumber: Long;
  /** reward is the reward amount in base units */
  reward: string;
  /** shares_at_epoch is the delegator's shares at the epoch */
  sharesAtEpoch: string;
  /** validator_total_shares_at_epoch is the validator's total shares at the epoch */
  validatorTotalSharesAtEpoch: string;
  /** calculated_at is when the reward was calculated */
  calculatedAt:
    | Date
    | undefined;
  /** claimed indicates if the reward has been claimed */
  claimed: boolean;
  /** claimed_at is when the reward was claimed (optional) */
  claimedAt: Date | undefined;
}

/** Params defines the parameters for the delegation module */
export interface Params {
  /** unbonding_period is the duration for unbonding in seconds */
  unbondingPeriod: Long;
  /** max_validators_per_delegator is the maximum number of validators a delegator can delegate to */
  maxValidatorsPerDelegator: Long;
  /** min_delegation_amount is the minimum delegation amount in base units */
  minDelegationAmount: Long;
  /** max_redelegations is the maximum number of simultaneous redelegations */
  maxRedelegations: Long;
  /** validator_commission_rate is the validator commission rate in basis points (e.g., 1000 = 10%) */
  validatorCommissionRate: Long;
  /** reward_denom is the denomination for rewards */
  rewardDenom: string;
  /** stake_denom is the denomination for staking */
  stakeDenom: string;
}

function createBaseDelegation(): Delegation {
  return {
    delegatorAddress: "",
    validatorAddress: "",
    shares: "",
    initialAmount: "",
    createdAt: undefined,
    updatedAt: undefined,
    height: Long.ZERO,
  };
}

export const Delegation: MessageFns<Delegation, "virtengine.delegation.v1.Delegation"> = {
  $type: "virtengine.delegation.v1.Delegation" as const,

  encode(message: Delegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.shares !== "") {
      writer.uint32(26).string(message.shares);
    }
    if (message.initialAmount !== "") {
      writer.uint32(34).string(message.initialAmount);
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(50).fork()).join();
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.height.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Delegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.shares = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.initialAmount = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Delegation {
    return {
      delegatorAddress: isSet(object.delegator_address) ? globalThis.String(object.delegator_address) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      shares: isSet(object.shares) ? globalThis.String(object.shares) : "",
      initialAmount: isSet(object.initial_amount) ? globalThis.String(object.initial_amount) : "",
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
    };
  },

  toJSON(message: Delegation): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegator_address = message.delegatorAddress;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.shares !== "") {
      obj.shares = message.shares;
    }
    if (message.initialAmount !== "") {
      obj.initial_amount = message.initialAmount;
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Delegation>): Delegation {
    const message = createBaseDelegation();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.shares = object.shares ?? "";
    message.initialAmount = object.initialAmount ?? "";
    message.createdAt = object.createdAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    return message;
  },
};

function createBaseUnbondingDelegationEntry(): UnbondingDelegationEntry {
  return { creationHeight: Long.ZERO, completionTime: undefined, initialBalance: "", balance: "", unbondingShares: "" };
}

export const UnbondingDelegationEntry: MessageFns<
  UnbondingDelegationEntry,
  "virtengine.delegation.v1.UnbondingDelegationEntry"
> = {
  $type: "virtengine.delegation.v1.UnbondingDelegationEntry" as const,

  encode(message: UnbondingDelegationEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.creationHeight.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.creationHeight.toString());
    }
    if (message.completionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).join();
    }
    if (message.initialBalance !== "") {
      writer.uint32(26).string(message.initialBalance);
    }
    if (message.balance !== "") {
      writer.uint32(34).string(message.balance);
    }
    if (message.unbondingShares !== "") {
      writer.uint32(42).string(message.unbondingShares);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbondingDelegationEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbondingDelegationEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.creationHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.completionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initialBalance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.balance = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.unbondingShares = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbondingDelegationEntry {
    return {
      creationHeight: isSet(object.creation_height) ? Long.fromValue(object.creation_height) : Long.ZERO,
      completionTime: isSet(object.completion_time) ? fromJsonTimestamp(object.completion_time) : undefined,
      initialBalance: isSet(object.initial_balance) ? globalThis.String(object.initial_balance) : "",
      balance: isSet(object.balance) ? globalThis.String(object.balance) : "",
      unbondingShares: isSet(object.unbonding_shares) ? globalThis.String(object.unbonding_shares) : "",
    };
  },

  toJSON(message: UnbondingDelegationEntry): unknown {
    const obj: any = {};
    if (!message.creationHeight.equals(Long.ZERO)) {
      obj.creation_height = (message.creationHeight || Long.ZERO).toString();
    }
    if (message.completionTime !== undefined) {
      obj.completion_time = message.completionTime.toISOString();
    }
    if (message.initialBalance !== "") {
      obj.initial_balance = message.initialBalance;
    }
    if (message.balance !== "") {
      obj.balance = message.balance;
    }
    if (message.unbondingShares !== "") {
      obj.unbonding_shares = message.unbondingShares;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<UnbondingDelegationEntry>): UnbondingDelegationEntry {
    const message = createBaseUnbondingDelegationEntry();
    message.creationHeight = (object.creationHeight !== undefined && object.creationHeight !== null)
      ? Long.fromValue(object.creationHeight)
      : Long.ZERO;
    message.completionTime = object.completionTime ?? undefined;
    message.initialBalance = object.initialBalance ?? "";
    message.balance = object.balance ?? "";
    message.unbondingShares = object.unbondingShares ?? "";
    return message;
  },
};

function createBaseUnbondingDelegation(): UnbondingDelegation {
  return { id: "", delegatorAddress: "", validatorAddress: "", entries: [], createdAt: undefined, height: Long.ZERO };
}

export const UnbondingDelegation: MessageFns<UnbondingDelegation, "virtengine.delegation.v1.UnbondingDelegation"> = {
  $type: "virtengine.delegation.v1.UnbondingDelegation" as const,

  encode(message: UnbondingDelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.delegatorAddress !== "") {
      writer.uint32(18).string(message.delegatorAddress);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(26).string(message.validatorAddress);
    }
    for (const v of message.entries) {
      UnbondingDelegationEntry.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(42).fork()).join();
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.height.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnbondingDelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnbondingDelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.entries.push(UnbondingDelegationEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnbondingDelegation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      delegatorAddress: isSet(object.delegator_address) ? globalThis.String(object.delegator_address) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => UnbondingDelegationEntry.fromJSON(e))
        : [],
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
    };
  },

  toJSON(message: UnbondingDelegation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.delegatorAddress !== "") {
      obj.delegator_address = message.delegatorAddress;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => UnbondingDelegationEntry.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<UnbondingDelegation>): UnbondingDelegation {
    const message = createBaseUnbondingDelegation();
    message.id = object.id ?? "";
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.entries = object.entries?.map((e) => UnbondingDelegationEntry.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    return message;
  },
};

function createBaseRedelegationEntry(): RedelegationEntry {
  return { creationHeight: Long.ZERO, completionTime: undefined, initialBalance: "", sharesDst: "" };
}

export const RedelegationEntry: MessageFns<RedelegationEntry, "virtengine.delegation.v1.RedelegationEntry"> = {
  $type: "virtengine.delegation.v1.RedelegationEntry" as const,

  encode(message: RedelegationEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.creationHeight.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.creationHeight.toString());
    }
    if (message.completionTime !== undefined) {
      Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).join();
    }
    if (message.initialBalance !== "") {
      writer.uint32(26).string(message.initialBalance);
    }
    if (message.sharesDst !== "") {
      writer.uint32(34).string(message.sharesDst);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RedelegationEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedelegationEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.creationHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.completionTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.initialBalance = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sharesDst = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RedelegationEntry {
    return {
      creationHeight: isSet(object.creation_height) ? Long.fromValue(object.creation_height) : Long.ZERO,
      completionTime: isSet(object.completion_time) ? fromJsonTimestamp(object.completion_time) : undefined,
      initialBalance: isSet(object.initial_balance) ? globalThis.String(object.initial_balance) : "",
      sharesDst: isSet(object.shares_dst) ? globalThis.String(object.shares_dst) : "",
    };
  },

  toJSON(message: RedelegationEntry): unknown {
    const obj: any = {};
    if (!message.creationHeight.equals(Long.ZERO)) {
      obj.creation_height = (message.creationHeight || Long.ZERO).toString();
    }
    if (message.completionTime !== undefined) {
      obj.completion_time = message.completionTime.toISOString();
    }
    if (message.initialBalance !== "") {
      obj.initial_balance = message.initialBalance;
    }
    if (message.sharesDst !== "") {
      obj.shares_dst = message.sharesDst;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<RedelegationEntry>): RedelegationEntry {
    const message = createBaseRedelegationEntry();
    message.creationHeight = (object.creationHeight !== undefined && object.creationHeight !== null)
      ? Long.fromValue(object.creationHeight)
      : Long.ZERO;
    message.completionTime = object.completionTime ?? undefined;
    message.initialBalance = object.initialBalance ?? "";
    message.sharesDst = object.sharesDst ?? "";
    return message;
  },
};

function createBaseRedelegation(): Redelegation {
  return {
    id: "",
    delegatorAddress: "",
    validatorSrcAddress: "",
    validatorDstAddress: "",
    entries: [],
    createdAt: undefined,
    height: Long.ZERO,
  };
}

export const Redelegation: MessageFns<Redelegation, "virtengine.delegation.v1.Redelegation"> = {
  $type: "virtengine.delegation.v1.Redelegation" as const,

  encode(message: Redelegation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.delegatorAddress !== "") {
      writer.uint32(18).string(message.delegatorAddress);
    }
    if (message.validatorSrcAddress !== "") {
      writer.uint32(26).string(message.validatorSrcAddress);
    }
    if (message.validatorDstAddress !== "") {
      writer.uint32(34).string(message.validatorDstAddress);
    }
    for (const v of message.entries) {
      RedelegationEntry.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.createdAt !== undefined) {
      Timestamp.encode(toTimestamp(message.createdAt), writer.uint32(50).fork()).join();
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.height.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Redelegation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRedelegation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.validatorSrcAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.validatorDstAddress = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.entries.push(RedelegationEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Redelegation {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      delegatorAddress: isSet(object.delegator_address) ? globalThis.String(object.delegator_address) : "",
      validatorSrcAddress: isSet(object.validator_src_address) ? globalThis.String(object.validator_src_address) : "",
      validatorDstAddress: isSet(object.validator_dst_address) ? globalThis.String(object.validator_dst_address) : "",
      entries: globalThis.Array.isArray(object?.entries)
        ? object.entries.map((e: any) => RedelegationEntry.fromJSON(e))
        : [],
      createdAt: isSet(object.created_at) ? fromJsonTimestamp(object.created_at) : undefined,
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
    };
  },

  toJSON(message: Redelegation): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.delegatorAddress !== "") {
      obj.delegator_address = message.delegatorAddress;
    }
    if (message.validatorSrcAddress !== "") {
      obj.validator_src_address = message.validatorSrcAddress;
    }
    if (message.validatorDstAddress !== "") {
      obj.validator_dst_address = message.validatorDstAddress;
    }
    if (message.entries?.length) {
      obj.entries = message.entries.map((e) => RedelegationEntry.toJSON(e));
    }
    if (message.createdAt !== undefined) {
      obj.created_at = message.createdAt.toISOString();
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Redelegation>): Redelegation {
    const message = createBaseRedelegation();
    message.id = object.id ?? "";
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.validatorSrcAddress = object.validatorSrcAddress ?? "";
    message.validatorDstAddress = object.validatorDstAddress ?? "";
    message.entries = object.entries?.map((e) => RedelegationEntry.fromPartial(e)) || [];
    message.createdAt = object.createdAt ?? undefined;
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    return message;
  },
};

function createBaseValidatorShares(): ValidatorShares {
  return { validatorAddress: "", totalShares: "", totalStake: "", updatedAt: undefined };
}

export const ValidatorShares: MessageFns<ValidatorShares, "virtengine.delegation.v1.ValidatorShares"> = {
  $type: "virtengine.delegation.v1.ValidatorShares" as const,

  encode(message: ValidatorShares, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (message.totalShares !== "") {
      writer.uint32(18).string(message.totalShares);
    }
    if (message.totalStake !== "") {
      writer.uint32(26).string(message.totalStake);
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorShares {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorShares();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalShares = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalStake = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorShares {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      totalShares: isSet(object.total_shares) ? globalThis.String(object.total_shares) : "",
      totalStake: isSet(object.total_stake) ? globalThis.String(object.total_stake) : "",
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
    };
  },

  toJSON(message: ValidatorShares): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.totalShares !== "") {
      obj.total_shares = message.totalShares;
    }
    if (message.totalStake !== "") {
      obj.total_stake = message.totalStake;
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorShares>): ValidatorShares {
    const message = createBaseValidatorShares();
    message.validatorAddress = object.validatorAddress ?? "";
    message.totalShares = object.totalShares ?? "";
    message.totalStake = object.totalStake ?? "";
    message.updatedAt = object.updatedAt ?? undefined;
    return message;
  },
};

function createBaseDelegatorReward(): DelegatorReward {
  return {
    delegatorAddress: "",
    validatorAddress: "",
    epochNumber: Long.UZERO,
    reward: "",
    sharesAtEpoch: "",
    validatorTotalSharesAtEpoch: "",
    calculatedAt: undefined,
    claimed: false,
    claimedAt: undefined,
  };
}

export const DelegatorReward: MessageFns<DelegatorReward, "virtengine.delegation.v1.DelegatorReward"> = {
  $type: "virtengine.delegation.v1.DelegatorReward" as const,

  encode(message: DelegatorReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.delegatorAddress !== "") {
      writer.uint32(10).string(message.delegatorAddress);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.epochNumber.toString());
    }
    if (message.reward !== "") {
      writer.uint32(34).string(message.reward);
    }
    if (message.sharesAtEpoch !== "") {
      writer.uint32(42).string(message.sharesAtEpoch);
    }
    if (message.validatorTotalSharesAtEpoch !== "") {
      writer.uint32(50).string(message.validatorTotalSharesAtEpoch);
    }
    if (message.calculatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.calculatedAt), writer.uint32(58).fork()).join();
    }
    if (message.claimed !== false) {
      writer.uint32(64).bool(message.claimed);
    }
    if (message.claimedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.claimedAt), writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DelegatorReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDelegatorReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.delegatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.epochNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reward = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.sharesAtEpoch = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.validatorTotalSharesAtEpoch = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.calculatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.claimed = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.claimedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DelegatorReward {
    return {
      delegatorAddress: isSet(object.delegator_address) ? globalThis.String(object.delegator_address) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      epochNumber: isSet(object.epoch_number) ? Long.fromValue(object.epoch_number) : Long.UZERO,
      reward: isSet(object.reward) ? globalThis.String(object.reward) : "",
      sharesAtEpoch: isSet(object.shares_at_epoch) ? globalThis.String(object.shares_at_epoch) : "",
      validatorTotalSharesAtEpoch: isSet(object.validator_total_shares_at_epoch)
        ? globalThis.String(object.validator_total_shares_at_epoch)
        : "",
      calculatedAt: isSet(object.calculated_at) ? fromJsonTimestamp(object.calculated_at) : undefined,
      claimed: isSet(object.claimed) ? globalThis.Boolean(object.claimed) : false,
      claimedAt: isSet(object.claimed_at) ? fromJsonTimestamp(object.claimed_at) : undefined,
    };
  },

  toJSON(message: DelegatorReward): unknown {
    const obj: any = {};
    if (message.delegatorAddress !== "") {
      obj.delegator_address = message.delegatorAddress;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      obj.epoch_number = (message.epochNumber || Long.UZERO).toString();
    }
    if (message.reward !== "") {
      obj.reward = message.reward;
    }
    if (message.sharesAtEpoch !== "") {
      obj.shares_at_epoch = message.sharesAtEpoch;
    }
    if (message.validatorTotalSharesAtEpoch !== "") {
      obj.validator_total_shares_at_epoch = message.validatorTotalSharesAtEpoch;
    }
    if (message.calculatedAt !== undefined) {
      obj.calculated_at = message.calculatedAt.toISOString();
    }
    if (message.claimed !== false) {
      obj.claimed = message.claimed;
    }
    if (message.claimedAt !== undefined) {
      obj.claimed_at = message.claimedAt.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DelegatorReward>): DelegatorReward {
    const message = createBaseDelegatorReward();
    message.delegatorAddress = object.delegatorAddress ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.epochNumber = (object.epochNumber !== undefined && object.epochNumber !== null)
      ? Long.fromValue(object.epochNumber)
      : Long.UZERO;
    message.reward = object.reward ?? "";
    message.sharesAtEpoch = object.sharesAtEpoch ?? "";
    message.validatorTotalSharesAtEpoch = object.validatorTotalSharesAtEpoch ?? "";
    message.calculatedAt = object.calculatedAt ?? undefined;
    message.claimed = object.claimed ?? false;
    message.claimedAt = object.claimedAt ?? undefined;
    return message;
  },
};

function createBaseParams(): Params {
  return {
    unbondingPeriod: Long.ZERO,
    maxValidatorsPerDelegator: Long.ZERO,
    minDelegationAmount: Long.ZERO,
    maxRedelegations: Long.ZERO,
    validatorCommissionRate: Long.ZERO,
    rewardDenom: "",
    stakeDenom: "",
  };
}

export const Params: MessageFns<Params, "virtengine.delegation.v1.Params"> = {
  $type: "virtengine.delegation.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.unbondingPeriod.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.unbondingPeriod.toString());
    }
    if (!message.maxValidatorsPerDelegator.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.maxValidatorsPerDelegator.toString());
    }
    if (!message.minDelegationAmount.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.minDelegationAmount.toString());
    }
    if (!message.maxRedelegations.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.maxRedelegations.toString());
    }
    if (!message.validatorCommissionRate.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.validatorCommissionRate.toString());
    }
    if (message.rewardDenom !== "") {
      writer.uint32(50).string(message.rewardDenom);
    }
    if (message.stakeDenom !== "") {
      writer.uint32(58).string(message.stakeDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.unbondingPeriod = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxValidatorsPerDelegator = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minDelegationAmount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxRedelegations = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.validatorCommissionRate = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.rewardDenom = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.stakeDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      unbondingPeriod: isSet(object.unbonding_period) ? Long.fromValue(object.unbonding_period) : Long.ZERO,
      maxValidatorsPerDelegator: isSet(object.max_validators_per_delegator)
        ? Long.fromValue(object.max_validators_per_delegator)
        : Long.ZERO,
      minDelegationAmount: isSet(object.min_delegation_amount)
        ? Long.fromValue(object.min_delegation_amount)
        : Long.ZERO,
      maxRedelegations: isSet(object.max_redelegations) ? Long.fromValue(object.max_redelegations) : Long.ZERO,
      validatorCommissionRate: isSet(object.validator_commission_rate)
        ? Long.fromValue(object.validator_commission_rate)
        : Long.ZERO,
      rewardDenom: isSet(object.reward_denom) ? globalThis.String(object.reward_denom) : "",
      stakeDenom: isSet(object.stake_denom) ? globalThis.String(object.stake_denom) : "",
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (!message.unbondingPeriod.equals(Long.ZERO)) {
      obj.unbonding_period = (message.unbondingPeriod || Long.ZERO).toString();
    }
    if (!message.maxValidatorsPerDelegator.equals(Long.ZERO)) {
      obj.max_validators_per_delegator = (message.maxValidatorsPerDelegator || Long.ZERO).toString();
    }
    if (!message.minDelegationAmount.equals(Long.ZERO)) {
      obj.min_delegation_amount = (message.minDelegationAmount || Long.ZERO).toString();
    }
    if (!message.maxRedelegations.equals(Long.ZERO)) {
      obj.max_redelegations = (message.maxRedelegations || Long.ZERO).toString();
    }
    if (!message.validatorCommissionRate.equals(Long.ZERO)) {
      obj.validator_commission_rate = (message.validatorCommissionRate || Long.ZERO).toString();
    }
    if (message.rewardDenom !== "") {
      obj.reward_denom = message.rewardDenom;
    }
    if (message.stakeDenom !== "") {
      obj.stake_denom = message.stakeDenom;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.unbondingPeriod = (object.unbondingPeriod !== undefined && object.unbondingPeriod !== null)
      ? Long.fromValue(object.unbondingPeriod)
      : Long.ZERO;
    message.maxValidatorsPerDelegator =
      (object.maxValidatorsPerDelegator !== undefined && object.maxValidatorsPerDelegator !== null)
        ? Long.fromValue(object.maxValidatorsPerDelegator)
        : Long.ZERO;
    message.minDelegationAmount = (object.minDelegationAmount !== undefined && object.minDelegationAmount !== null)
      ? Long.fromValue(object.minDelegationAmount)
      : Long.ZERO;
    message.maxRedelegations = (object.maxRedelegations !== undefined && object.maxRedelegations !== null)
      ? Long.fromValue(object.maxRedelegations)
      : Long.ZERO;
    message.validatorCommissionRate =
      (object.validatorCommissionRate !== undefined && object.validatorCommissionRate !== null)
        ? Long.fromValue(object.validatorCommissionRate)
        : Long.ZERO;
    message.rewardDenom = object.rewardDenom ?? "";
    message.stakeDenom = object.stakeDenom ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
