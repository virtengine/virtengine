import { bytesFromBase64, base64FromBytes, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/mfa/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

/** FactorType represents the type of authentication factor */
export enum FactorType {
  /** FACTOR_TYPE_UNSPECIFIED - FACTOR_TYPE_UNSPECIFIED represents an unspecified factor type */
  FACTOR_TYPE_UNSPECIFIED = 0,
  /** FACTOR_TYPE_TOTP - FACTOR_TYPE_TOTP represents Time-based One-Time Password */
  FACTOR_TYPE_TOTP = 1,
  /** FACTOR_TYPE_FIDO2 - FACTOR_TYPE_FIDO2 represents FIDO2/WebAuthn authentication */
  FACTOR_TYPE_FIDO2 = 2,
  /** FACTOR_TYPE_SMS - FACTOR_TYPE_SMS represents SMS OTP authentication */
  FACTOR_TYPE_SMS = 3,
  /** FACTOR_TYPE_EMAIL - FACTOR_TYPE_EMAIL represents Email OTP authentication */
  FACTOR_TYPE_EMAIL = 4,
  /** FACTOR_TYPE_VEID - FACTOR_TYPE_VEID represents VEID identity score threshold */
  FACTOR_TYPE_VEID = 5,
  /** FACTOR_TYPE_TRUSTED_DEVICE - FACTOR_TYPE_TRUSTED_DEVICE represents trusted browser/device binding */
  FACTOR_TYPE_TRUSTED_DEVICE = 6,
  /** FACTOR_TYPE_HARDWARE_KEY - FACTOR_TYPE_HARDWARE_KEY represents X.509/smart card/PIV hardware key authentication */
  FACTOR_TYPE_HARDWARE_KEY = 7,
  UNRECOGNIZED = -1,
}

export function factorTypeFromJSON(object: any): FactorType {
  switch (object) {
    case 0:
    case "FACTOR_TYPE_UNSPECIFIED":
      return FactorType.FACTOR_TYPE_UNSPECIFIED;
    case 1:
    case "FACTOR_TYPE_TOTP":
      return FactorType.FACTOR_TYPE_TOTP;
    case 2:
    case "FACTOR_TYPE_FIDO2":
      return FactorType.FACTOR_TYPE_FIDO2;
    case 3:
    case "FACTOR_TYPE_SMS":
      return FactorType.FACTOR_TYPE_SMS;
    case 4:
    case "FACTOR_TYPE_EMAIL":
      return FactorType.FACTOR_TYPE_EMAIL;
    case 5:
    case "FACTOR_TYPE_VEID":
      return FactorType.FACTOR_TYPE_VEID;
    case 6:
    case "FACTOR_TYPE_TRUSTED_DEVICE":
      return FactorType.FACTOR_TYPE_TRUSTED_DEVICE;
    case 7:
    case "FACTOR_TYPE_HARDWARE_KEY":
      return FactorType.FACTOR_TYPE_HARDWARE_KEY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactorType.UNRECOGNIZED;
  }
}

export function factorTypeToJSON(object: FactorType): string {
  switch (object) {
    case FactorType.FACTOR_TYPE_UNSPECIFIED:
      return "FACTOR_TYPE_UNSPECIFIED";
    case FactorType.FACTOR_TYPE_TOTP:
      return "FACTOR_TYPE_TOTP";
    case FactorType.FACTOR_TYPE_FIDO2:
      return "FACTOR_TYPE_FIDO2";
    case FactorType.FACTOR_TYPE_SMS:
      return "FACTOR_TYPE_SMS";
    case FactorType.FACTOR_TYPE_EMAIL:
      return "FACTOR_TYPE_EMAIL";
    case FactorType.FACTOR_TYPE_VEID:
      return "FACTOR_TYPE_VEID";
    case FactorType.FACTOR_TYPE_TRUSTED_DEVICE:
      return "FACTOR_TYPE_TRUSTED_DEVICE";
    case FactorType.FACTOR_TYPE_HARDWARE_KEY:
      return "FACTOR_TYPE_HARDWARE_KEY";
    case FactorType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** FactorSecurityLevel represents the security level of a factor */
export enum FactorSecurityLevel {
  /** FACTOR_SECURITY_LEVEL_UNSPECIFIED - FACTOR_SECURITY_LEVEL_UNSPECIFIED represents an unspecified security level */
  FACTOR_SECURITY_LEVEL_UNSPECIFIED = 0,
  /** FACTOR_SECURITY_LEVEL_LOW - FACTOR_SECURITY_LEVEL_LOW represents low security factors (email, SMS) */
  FACTOR_SECURITY_LEVEL_LOW = 1,
  /** FACTOR_SECURITY_LEVEL_MEDIUM - FACTOR_SECURITY_LEVEL_MEDIUM represents medium security factors (TOTP) */
  FACTOR_SECURITY_LEVEL_MEDIUM = 2,
  /** FACTOR_SECURITY_LEVEL_HIGH - FACTOR_SECURITY_LEVEL_HIGH represents high security factors (FIDO2, VEID) */
  FACTOR_SECURITY_LEVEL_HIGH = 3,
  UNRECOGNIZED = -1,
}

export function factorSecurityLevelFromJSON(object: any): FactorSecurityLevel {
  switch (object) {
    case 0:
    case "FACTOR_SECURITY_LEVEL_UNSPECIFIED":
      return FactorSecurityLevel.FACTOR_SECURITY_LEVEL_UNSPECIFIED;
    case 1:
    case "FACTOR_SECURITY_LEVEL_LOW":
      return FactorSecurityLevel.FACTOR_SECURITY_LEVEL_LOW;
    case 2:
    case "FACTOR_SECURITY_LEVEL_MEDIUM":
      return FactorSecurityLevel.FACTOR_SECURITY_LEVEL_MEDIUM;
    case 3:
    case "FACTOR_SECURITY_LEVEL_HIGH":
      return FactorSecurityLevel.FACTOR_SECURITY_LEVEL_HIGH;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactorSecurityLevel.UNRECOGNIZED;
  }
}

export function factorSecurityLevelToJSON(object: FactorSecurityLevel): string {
  switch (object) {
    case FactorSecurityLevel.FACTOR_SECURITY_LEVEL_UNSPECIFIED:
      return "FACTOR_SECURITY_LEVEL_UNSPECIFIED";
    case FactorSecurityLevel.FACTOR_SECURITY_LEVEL_LOW:
      return "FACTOR_SECURITY_LEVEL_LOW";
    case FactorSecurityLevel.FACTOR_SECURITY_LEVEL_MEDIUM:
      return "FACTOR_SECURITY_LEVEL_MEDIUM";
    case FactorSecurityLevel.FACTOR_SECURITY_LEVEL_HIGH:
      return "FACTOR_SECURITY_LEVEL_HIGH";
    case FactorSecurityLevel.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** FactorEnrollmentStatus represents the status of a factor enrollment */
export enum FactorEnrollmentStatus {
  /** ENROLLMENT_STATUS_UNSPECIFIED - ENROLLMENT_STATUS_UNSPECIFIED represents an unspecified status */
  ENROLLMENT_STATUS_UNSPECIFIED = 0,
  /** ENROLLMENT_STATUS_PENDING - ENROLLMENT_STATUS_PENDING represents a pending enrollment awaiting verification */
  ENROLLMENT_STATUS_PENDING = 1,
  /** ENROLLMENT_STATUS_ACTIVE - ENROLLMENT_STATUS_ACTIVE represents an active, verified enrollment */
  ENROLLMENT_STATUS_ACTIVE = 2,
  /** ENROLLMENT_STATUS_REVOKED - ENROLLMENT_STATUS_REVOKED represents a revoked enrollment */
  ENROLLMENT_STATUS_REVOKED = 3,
  /** ENROLLMENT_STATUS_EXPIRED - ENROLLMENT_STATUS_EXPIRED represents an expired enrollment */
  ENROLLMENT_STATUS_EXPIRED = 4,
  UNRECOGNIZED = -1,
}

export function factorEnrollmentStatusFromJSON(object: any): FactorEnrollmentStatus {
  switch (object) {
    case 0:
    case "ENROLLMENT_STATUS_UNSPECIFIED":
      return FactorEnrollmentStatus.ENROLLMENT_STATUS_UNSPECIFIED;
    case 1:
    case "ENROLLMENT_STATUS_PENDING":
      return FactorEnrollmentStatus.ENROLLMENT_STATUS_PENDING;
    case 2:
    case "ENROLLMENT_STATUS_ACTIVE":
      return FactorEnrollmentStatus.ENROLLMENT_STATUS_ACTIVE;
    case 3:
    case "ENROLLMENT_STATUS_REVOKED":
      return FactorEnrollmentStatus.ENROLLMENT_STATUS_REVOKED;
    case 4:
    case "ENROLLMENT_STATUS_EXPIRED":
      return FactorEnrollmentStatus.ENROLLMENT_STATUS_EXPIRED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FactorEnrollmentStatus.UNRECOGNIZED;
  }
}

export function factorEnrollmentStatusToJSON(object: FactorEnrollmentStatus): string {
  switch (object) {
    case FactorEnrollmentStatus.ENROLLMENT_STATUS_UNSPECIFIED:
      return "ENROLLMENT_STATUS_UNSPECIFIED";
    case FactorEnrollmentStatus.ENROLLMENT_STATUS_PENDING:
      return "ENROLLMENT_STATUS_PENDING";
    case FactorEnrollmentStatus.ENROLLMENT_STATUS_ACTIVE:
      return "ENROLLMENT_STATUS_ACTIVE";
    case FactorEnrollmentStatus.ENROLLMENT_STATUS_REVOKED:
      return "ENROLLMENT_STATUS_REVOKED";
    case FactorEnrollmentStatus.ENROLLMENT_STATUS_EXPIRED:
      return "ENROLLMENT_STATUS_EXPIRED";
    case FactorEnrollmentStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ChallengeStatus represents the status of an MFA challenge */
export enum ChallengeStatus {
  /** CHALLENGE_STATUS_UNSPECIFIED - CHALLENGE_STATUS_UNSPECIFIED represents an unspecified status */
  CHALLENGE_STATUS_UNSPECIFIED = 0,
  /** CHALLENGE_STATUS_PENDING - CHALLENGE_STATUS_PENDING represents a challenge awaiting response */
  CHALLENGE_STATUS_PENDING = 1,
  /** CHALLENGE_STATUS_VERIFIED - CHALLENGE_STATUS_VERIFIED represents a successfully verified challenge */
  CHALLENGE_STATUS_VERIFIED = 2,
  /** CHALLENGE_STATUS_FAILED - CHALLENGE_STATUS_FAILED represents a failed challenge */
  CHALLENGE_STATUS_FAILED = 3,
  /** CHALLENGE_STATUS_EXPIRED - CHALLENGE_STATUS_EXPIRED represents an expired challenge */
  CHALLENGE_STATUS_EXPIRED = 4,
  /** CHALLENGE_STATUS_CANCELLED - CHALLENGE_STATUS_CANCELLED represents a cancelled challenge */
  CHALLENGE_STATUS_CANCELLED = 5,
  UNRECOGNIZED = -1,
}

export function challengeStatusFromJSON(object: any): ChallengeStatus {
  switch (object) {
    case 0:
    case "CHALLENGE_STATUS_UNSPECIFIED":
      return ChallengeStatus.CHALLENGE_STATUS_UNSPECIFIED;
    case 1:
    case "CHALLENGE_STATUS_PENDING":
      return ChallengeStatus.CHALLENGE_STATUS_PENDING;
    case 2:
    case "CHALLENGE_STATUS_VERIFIED":
      return ChallengeStatus.CHALLENGE_STATUS_VERIFIED;
    case 3:
    case "CHALLENGE_STATUS_FAILED":
      return ChallengeStatus.CHALLENGE_STATUS_FAILED;
    case 4:
    case "CHALLENGE_STATUS_EXPIRED":
      return ChallengeStatus.CHALLENGE_STATUS_EXPIRED;
    case 5:
    case "CHALLENGE_STATUS_CANCELLED":
      return ChallengeStatus.CHALLENGE_STATUS_CANCELLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChallengeStatus.UNRECOGNIZED;
  }
}

export function challengeStatusToJSON(object: ChallengeStatus): string {
  switch (object) {
    case ChallengeStatus.CHALLENGE_STATUS_UNSPECIFIED:
      return "CHALLENGE_STATUS_UNSPECIFIED";
    case ChallengeStatus.CHALLENGE_STATUS_PENDING:
      return "CHALLENGE_STATUS_PENDING";
    case ChallengeStatus.CHALLENGE_STATUS_VERIFIED:
      return "CHALLENGE_STATUS_VERIFIED";
    case ChallengeStatus.CHALLENGE_STATUS_FAILED:
      return "CHALLENGE_STATUS_FAILED";
    case ChallengeStatus.CHALLENGE_STATUS_EXPIRED:
      return "CHALLENGE_STATUS_EXPIRED";
    case ChallengeStatus.CHALLENGE_STATUS_CANCELLED:
      return "CHALLENGE_STATUS_CANCELLED";
    case ChallengeStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SensitiveTransactionType represents types of transactions that require MFA */
export enum SensitiveTransactionType {
  /** SENSITIVE_TX_UNSPECIFIED - SENSITIVE_TX_UNSPECIFIED represents an unspecified transaction type */
  SENSITIVE_TX_UNSPECIFIED = 0,
  /** SENSITIVE_TX_ACCOUNT_RECOVERY - SENSITIVE_TX_ACCOUNT_RECOVERY represents account recovery operations */
  SENSITIVE_TX_ACCOUNT_RECOVERY = 1,
  /** SENSITIVE_TX_KEY_ROTATION - SENSITIVE_TX_KEY_ROTATION represents key rotation operations */
  SENSITIVE_TX_KEY_ROTATION = 2,
  /** SENSITIVE_TX_LARGE_WITHDRAWAL - SENSITIVE_TX_LARGE_WITHDRAWAL represents large token withdrawals */
  SENSITIVE_TX_LARGE_WITHDRAWAL = 3,
  /** SENSITIVE_TX_PROVIDER_REGISTRATION - SENSITIVE_TX_PROVIDER_REGISTRATION represents provider registration */
  SENSITIVE_TX_PROVIDER_REGISTRATION = 4,
  /** SENSITIVE_TX_VALIDATOR_REGISTRATION - SENSITIVE_TX_VALIDATOR_REGISTRATION represents validator registration */
  SENSITIVE_TX_VALIDATOR_REGISTRATION = 5,
  /** SENSITIVE_TX_HIGH_VALUE_ORDER - SENSITIVE_TX_HIGH_VALUE_ORDER represents high-value marketplace orders */
  SENSITIVE_TX_HIGH_VALUE_ORDER = 6,
  /** SENSITIVE_TX_ROLE_ASSIGNMENT - SENSITIVE_TX_ROLE_ASSIGNMENT represents role assignment operations */
  SENSITIVE_TX_ROLE_ASSIGNMENT = 7,
  /** SENSITIVE_TX_GOVERNANCE_PROPOSAL - SENSITIVE_TX_GOVERNANCE_PROPOSAL represents governance proposal creation */
  SENSITIVE_TX_GOVERNANCE_PROPOSAL = 8,
  /** SENSITIVE_TX_PRIMARY_EMAIL_CHANGE - SENSITIVE_TX_PRIMARY_EMAIL_CHANGE represents primary email changes */
  SENSITIVE_TX_PRIMARY_EMAIL_CHANGE = 9,
  /** SENSITIVE_TX_PHONE_NUMBER_CHANGE - SENSITIVE_TX_PHONE_NUMBER_CHANGE represents phone number changes */
  SENSITIVE_TX_PHONE_NUMBER_CHANGE = 10,
  /** SENSITIVE_TX_TWO_FACTOR_DISABLE - SENSITIVE_TX_TWO_FACTOR_DISABLE represents disabling 2FA */
  SENSITIVE_TX_TWO_FACTOR_DISABLE = 11,
  /** SENSITIVE_TX_ACCOUNT_DELETION - SENSITIVE_TX_ACCOUNT_DELETION represents account deletion */
  SENSITIVE_TX_ACCOUNT_DELETION = 12,
  /** SENSITIVE_TX_GOVERNANCE_VOTE - SENSITIVE_TX_GOVERNANCE_VOTE represents high-stake governance votes */
  SENSITIVE_TX_GOVERNANCE_VOTE = 13,
  /** SENSITIVE_TX_FIRST_OFFERING_CREATE - SENSITIVE_TX_FIRST_OFFERING_CREATE represents first offering creation by provider */
  SENSITIVE_TX_FIRST_OFFERING_CREATE = 14,
  /** SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS - SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS represents transfers to new addresses */
  SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS = 15,
  /** SENSITIVE_TX_MEDIUM_WITHDRAWAL - SENSITIVE_TX_MEDIUM_WITHDRAWAL represents medium-value withdrawals */
  SENSITIVE_TX_MEDIUM_WITHDRAWAL = 16,
  /** SENSITIVE_TX_API_KEY_GENERATION - SENSITIVE_TX_API_KEY_GENERATION represents API key generation */
  SENSITIVE_TX_API_KEY_GENERATION = 17,
  /** SENSITIVE_TX_WEBHOOK_CONFIGURATION - SENSITIVE_TX_WEBHOOK_CONFIGURATION represents webhook configuration */
  SENSITIVE_TX_WEBHOOK_CONFIGURATION = 18,
  UNRECOGNIZED = -1,
}

export function sensitiveTransactionTypeFromJSON(object: any): SensitiveTransactionType {
  switch (object) {
    case 0:
    case "SENSITIVE_TX_UNSPECIFIED":
      return SensitiveTransactionType.SENSITIVE_TX_UNSPECIFIED;
    case 1:
    case "SENSITIVE_TX_ACCOUNT_RECOVERY":
      return SensitiveTransactionType.SENSITIVE_TX_ACCOUNT_RECOVERY;
    case 2:
    case "SENSITIVE_TX_KEY_ROTATION":
      return SensitiveTransactionType.SENSITIVE_TX_KEY_ROTATION;
    case 3:
    case "SENSITIVE_TX_LARGE_WITHDRAWAL":
      return SensitiveTransactionType.SENSITIVE_TX_LARGE_WITHDRAWAL;
    case 4:
    case "SENSITIVE_TX_PROVIDER_REGISTRATION":
      return SensitiveTransactionType.SENSITIVE_TX_PROVIDER_REGISTRATION;
    case 5:
    case "SENSITIVE_TX_VALIDATOR_REGISTRATION":
      return SensitiveTransactionType.SENSITIVE_TX_VALIDATOR_REGISTRATION;
    case 6:
    case "SENSITIVE_TX_HIGH_VALUE_ORDER":
      return SensitiveTransactionType.SENSITIVE_TX_HIGH_VALUE_ORDER;
    case 7:
    case "SENSITIVE_TX_ROLE_ASSIGNMENT":
      return SensitiveTransactionType.SENSITIVE_TX_ROLE_ASSIGNMENT;
    case 8:
    case "SENSITIVE_TX_GOVERNANCE_PROPOSAL":
      return SensitiveTransactionType.SENSITIVE_TX_GOVERNANCE_PROPOSAL;
    case 9:
    case "SENSITIVE_TX_PRIMARY_EMAIL_CHANGE":
      return SensitiveTransactionType.SENSITIVE_TX_PRIMARY_EMAIL_CHANGE;
    case 10:
    case "SENSITIVE_TX_PHONE_NUMBER_CHANGE":
      return SensitiveTransactionType.SENSITIVE_TX_PHONE_NUMBER_CHANGE;
    case 11:
    case "SENSITIVE_TX_TWO_FACTOR_DISABLE":
      return SensitiveTransactionType.SENSITIVE_TX_TWO_FACTOR_DISABLE;
    case 12:
    case "SENSITIVE_TX_ACCOUNT_DELETION":
      return SensitiveTransactionType.SENSITIVE_TX_ACCOUNT_DELETION;
    case 13:
    case "SENSITIVE_TX_GOVERNANCE_VOTE":
      return SensitiveTransactionType.SENSITIVE_TX_GOVERNANCE_VOTE;
    case 14:
    case "SENSITIVE_TX_FIRST_OFFERING_CREATE":
      return SensitiveTransactionType.SENSITIVE_TX_FIRST_OFFERING_CREATE;
    case 15:
    case "SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS":
      return SensitiveTransactionType.SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS;
    case 16:
    case "SENSITIVE_TX_MEDIUM_WITHDRAWAL":
      return SensitiveTransactionType.SENSITIVE_TX_MEDIUM_WITHDRAWAL;
    case 17:
    case "SENSITIVE_TX_API_KEY_GENERATION":
      return SensitiveTransactionType.SENSITIVE_TX_API_KEY_GENERATION;
    case 18:
    case "SENSITIVE_TX_WEBHOOK_CONFIGURATION":
      return SensitiveTransactionType.SENSITIVE_TX_WEBHOOK_CONFIGURATION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SensitiveTransactionType.UNRECOGNIZED;
  }
}

export function sensitiveTransactionTypeToJSON(object: SensitiveTransactionType): string {
  switch (object) {
    case SensitiveTransactionType.SENSITIVE_TX_UNSPECIFIED:
      return "SENSITIVE_TX_UNSPECIFIED";
    case SensitiveTransactionType.SENSITIVE_TX_ACCOUNT_RECOVERY:
      return "SENSITIVE_TX_ACCOUNT_RECOVERY";
    case SensitiveTransactionType.SENSITIVE_TX_KEY_ROTATION:
      return "SENSITIVE_TX_KEY_ROTATION";
    case SensitiveTransactionType.SENSITIVE_TX_LARGE_WITHDRAWAL:
      return "SENSITIVE_TX_LARGE_WITHDRAWAL";
    case SensitiveTransactionType.SENSITIVE_TX_PROVIDER_REGISTRATION:
      return "SENSITIVE_TX_PROVIDER_REGISTRATION";
    case SensitiveTransactionType.SENSITIVE_TX_VALIDATOR_REGISTRATION:
      return "SENSITIVE_TX_VALIDATOR_REGISTRATION";
    case SensitiveTransactionType.SENSITIVE_TX_HIGH_VALUE_ORDER:
      return "SENSITIVE_TX_HIGH_VALUE_ORDER";
    case SensitiveTransactionType.SENSITIVE_TX_ROLE_ASSIGNMENT:
      return "SENSITIVE_TX_ROLE_ASSIGNMENT";
    case SensitiveTransactionType.SENSITIVE_TX_GOVERNANCE_PROPOSAL:
      return "SENSITIVE_TX_GOVERNANCE_PROPOSAL";
    case SensitiveTransactionType.SENSITIVE_TX_PRIMARY_EMAIL_CHANGE:
      return "SENSITIVE_TX_PRIMARY_EMAIL_CHANGE";
    case SensitiveTransactionType.SENSITIVE_TX_PHONE_NUMBER_CHANGE:
      return "SENSITIVE_TX_PHONE_NUMBER_CHANGE";
    case SensitiveTransactionType.SENSITIVE_TX_TWO_FACTOR_DISABLE:
      return "SENSITIVE_TX_TWO_FACTOR_DISABLE";
    case SensitiveTransactionType.SENSITIVE_TX_ACCOUNT_DELETION:
      return "SENSITIVE_TX_ACCOUNT_DELETION";
    case SensitiveTransactionType.SENSITIVE_TX_GOVERNANCE_VOTE:
      return "SENSITIVE_TX_GOVERNANCE_VOTE";
    case SensitiveTransactionType.SENSITIVE_TX_FIRST_OFFERING_CREATE:
      return "SENSITIVE_TX_FIRST_OFFERING_CREATE";
    case SensitiveTransactionType.SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS:
      return "SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS";
    case SensitiveTransactionType.SENSITIVE_TX_MEDIUM_WITHDRAWAL:
      return "SENSITIVE_TX_MEDIUM_WITHDRAWAL";
    case SensitiveTransactionType.SENSITIVE_TX_API_KEY_GENERATION:
      return "SENSITIVE_TX_API_KEY_GENERATION";
    case SensitiveTransactionType.SENSITIVE_TX_WEBHOOK_CONFIGURATION:
      return "SENSITIVE_TX_WEBHOOK_CONFIGURATION";
    case SensitiveTransactionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** HardwareKeyType represents the type of hardware key */
export enum HardwareKeyType {
  /** HARDWARE_KEY_TYPE_UNSPECIFIED - HARDWARE_KEY_TYPE_UNSPECIFIED represents an unspecified hardware key type */
  HARDWARE_KEY_TYPE_UNSPECIFIED = 0,
  /** HARDWARE_KEY_TYPE_X509 - HARDWARE_KEY_TYPE_X509 represents X.509 certificate-based authentication */
  HARDWARE_KEY_TYPE_X509 = 1,
  /** HARDWARE_KEY_TYPE_SMART_CARD - HARDWARE_KEY_TYPE_SMART_CARD represents smart card/PIV authentication */
  HARDWARE_KEY_TYPE_SMART_CARD = 2,
  /** HARDWARE_KEY_TYPE_PIV - HARDWARE_KEY_TYPE_PIV represents PIV (Personal Identity Verification) card */
  HARDWARE_KEY_TYPE_PIV = 3,
  UNRECOGNIZED = -1,
}

export function hardwareKeyTypeFromJSON(object: any): HardwareKeyType {
  switch (object) {
    case 0:
    case "HARDWARE_KEY_TYPE_UNSPECIFIED":
      return HardwareKeyType.HARDWARE_KEY_TYPE_UNSPECIFIED;
    case 1:
    case "HARDWARE_KEY_TYPE_X509":
      return HardwareKeyType.HARDWARE_KEY_TYPE_X509;
    case 2:
    case "HARDWARE_KEY_TYPE_SMART_CARD":
      return HardwareKeyType.HARDWARE_KEY_TYPE_SMART_CARD;
    case 3:
    case "HARDWARE_KEY_TYPE_PIV":
      return HardwareKeyType.HARDWARE_KEY_TYPE_PIV;
    case -1:
    case "UNRECOGNIZED":
    default:
      return HardwareKeyType.UNRECOGNIZED;
  }
}

export function hardwareKeyTypeToJSON(object: HardwareKeyType): string {
  switch (object) {
    case HardwareKeyType.HARDWARE_KEY_TYPE_UNSPECIFIED:
      return "HARDWARE_KEY_TYPE_UNSPECIFIED";
    case HardwareKeyType.HARDWARE_KEY_TYPE_X509:
      return "HARDWARE_KEY_TYPE_X509";
    case HardwareKeyType.HARDWARE_KEY_TYPE_SMART_CARD:
      return "HARDWARE_KEY_TYPE_SMART_CARD";
    case HardwareKeyType.HARDWARE_KEY_TYPE_PIV:
      return "HARDWARE_KEY_TYPE_PIV";
    case HardwareKeyType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RevocationStatus represents the revocation status of a certificate */
export enum RevocationStatus {
  /** REVOCATION_STATUS_UNKNOWN - REVOCATION_STATUS_UNKNOWN indicates the revocation status is unknown */
  REVOCATION_STATUS_UNKNOWN = 0,
  /** REVOCATION_STATUS_GOOD - REVOCATION_STATUS_GOOD indicates the certificate is not revoked */
  REVOCATION_STATUS_GOOD = 1,
  /** REVOCATION_STATUS_REVOKED - REVOCATION_STATUS_REVOKED indicates the certificate has been revoked */
  REVOCATION_STATUS_REVOKED = 2,
  /** REVOCATION_STATUS_CHECK_FAILED - REVOCATION_STATUS_CHECK_FAILED indicates the revocation check failed */
  REVOCATION_STATUS_CHECK_FAILED = 3,
  UNRECOGNIZED = -1,
}

export function revocationStatusFromJSON(object: any): RevocationStatus {
  switch (object) {
    case 0:
    case "REVOCATION_STATUS_UNKNOWN":
      return RevocationStatus.REVOCATION_STATUS_UNKNOWN;
    case 1:
    case "REVOCATION_STATUS_GOOD":
      return RevocationStatus.REVOCATION_STATUS_GOOD;
    case 2:
    case "REVOCATION_STATUS_REVOKED":
      return RevocationStatus.REVOCATION_STATUS_REVOKED;
    case 3:
    case "REVOCATION_STATUS_CHECK_FAILED":
      return RevocationStatus.REVOCATION_STATUS_CHECK_FAILED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RevocationStatus.UNRECOGNIZED;
  }
}

export function revocationStatusToJSON(object: RevocationStatus): string {
  switch (object) {
    case RevocationStatus.REVOCATION_STATUS_UNKNOWN:
      return "REVOCATION_STATUS_UNKNOWN";
    case RevocationStatus.REVOCATION_STATUS_GOOD:
      return "REVOCATION_STATUS_GOOD";
    case RevocationStatus.REVOCATION_STATUS_REVOKED:
      return "REVOCATION_STATUS_REVOKED";
    case RevocationStatus.REVOCATION_STATUS_CHECK_FAILED:
      return "REVOCATION_STATUS_CHECK_FAILED";
    case RevocationStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** MFAProof represents proof of MFA verification */
export interface MFAProof {
  /** SessionID is the authorization session ID */
  sessionId: string;
  /** VerifiedFactors are the factors that were verified */
  verifiedFactors: FactorType[];
  /** Timestamp is when the proof was generated (Unix timestamp) */
  timestamp: Long;
  /** Signature is the signature over the proof data */
  signature: Uint8Array;
}

/** FactorCombination represents a set of factors that must ALL be satisfied (AND logic) */
export interface FactorCombination {
  /** Factors is the list of factor types that must all be verified */
  factors: FactorType[];
  /** MinSecurityLevel is the minimum security level required for the combination */
  minSecurityLevel: FactorSecurityLevel;
}

/** FactorMetadata contains type-specific metadata for enrollments */
export interface FactorMetadata {
  /** VEIDThreshold is the minimum VEID score required (for VEID factor) */
  veidThreshold: number;
  /** DeviceInfo contains device information (for TrustedDevice factor) */
  deviceInfo:
    | DeviceInfo
    | undefined;
  /** FIDO2Info contains FIDO2-specific metadata */
  fido2Info:
    | FIDO2CredentialInfo
    | undefined;
  /** ContactHash contains a hash of the contact info (for SMS/Email verification tracking) */
  contactHash: string;
  /** HardwareKeyInfo contains hardware key/X.509/smart card metadata */
  hardwareKeyInfo: HardwareKeyEnrollment | undefined;
}

/** DeviceInfo contains information about a trusted device */
export interface DeviceInfo {
  /** Fingerprint is a unique hash identifying the device */
  fingerprint: string;
  /** UserAgent is the user agent string (sanitized) */
  userAgent: string;
  /** FirstSeenAt is when this device was first seen */
  firstSeenAt: Long;
  /** LastSeenAt is when this device was last seen */
  lastSeenAt: Long;
  /** IPHash is a hash of the last known IP (for change detection, not tracking) */
  ipHash: string;
  /** TrustExpiresAt is when the device trust expires */
  trustExpiresAt: Long;
}

/** FIDO2CredentialInfo contains FIDO2-specific credential information */
export interface FIDO2CredentialInfo {
  /** CredentialID is the FIDO2 credential identifier */
  credentialId: Uint8Array;
  /** PublicKey is the COSE-encoded public key */
  publicKey: Uint8Array;
  /** AAGUID is the Authenticator Attestation GUID */
  aaguid: Uint8Array;
  /** SignCount is the signature counter for clone detection */
  signCount: number;
  /** AttestationType indicates the attestation type used */
  attestationType: string;
}

/** HardwareKeyEnrollment represents a hardware key enrollment for MFA */
export interface HardwareKeyEnrollment {
  /** KeyType is the type of hardware key */
  keyType: HardwareKeyType;
  /** KeyID is a unique identifier for this key (certificate fingerprint or card serial) */
  keyId: string;
  /** SubjectDN is the distinguished name from the certificate subject */
  subjectDn: string;
  /** IssuerDN is the distinguished name of the certificate issuer */
  issuerDn: string;
  /** SerialNumber is the certificate serial number (hex encoded) */
  serialNumber: string;
  /** PublicKeyFingerprint is SHA-256 hash of the public key (hex encoded) */
  publicKeyFingerprint: string;
  /** NotBefore is the certificate validity start time */
  notBefore: Long;
  /** NotAfter is the certificate validity end time */
  notAfter: Long;
  /** KeyUsage indicates the allowed key usage flags */
  keyUsage: string[];
  /** ExtendedKeyUsage indicates extended key usage purposes */
  extendedKeyUsage: string[];
  /** SmartCardInfo contains smart card specific metadata */
  smartCardInfo:
    | SmartCardInfo
    | undefined;
  /** RevocationCheckEnabled indicates if revocation checking is enabled */
  revocationCheckEnabled: boolean;
  /** LastRevocationCheck is the timestamp of the last revocation check */
  lastRevocationCheck: Long;
  /** RevocationStatus is the current revocation status */
  revocationStatus: RevocationStatus;
  /** TrustedCACertFingerprints are the fingerprints of trusted CA certificates */
  trustedCaCertFingerprints: string[];
}

/** SmartCardInfo contains smart card/PIV specific information */
export interface SmartCardInfo {
  /** CardSerialNumber is the smart card serial number */
  cardSerialNumber: string;
  /** CardType indicates the type of smart card (PIV, CAC, etc.) */
  cardType: string;
  /** SlotID indicates which slot the certificate was read from */
  slotId: string;
  /** CHUID is the Card Holder Unique Identifier (for PIV cards) */
  chuid: string;
  /** FASC_N is the Federal Agency Smart Credential Number (if available) */
  fascn: string;
  /** CardHolderName is the name on the card (from CHUID or certificate) */
  cardHolderName: string;
  /** ExpirationDate is when the card expires */
  expirationDate: Long;
  /** LastPINVerification is when PIN was last verified */
  lastPinVerification: Long;
}

/** FactorEnrollment represents a factor enrollment record */
export interface FactorEnrollment {
  /** AccountAddress is the account that owns this enrollment */
  accountAddress: string;
  /** FactorType is the type of factor */
  factorType: FactorType;
  /** FactorID is a unique identifier for this factor enrollment */
  factorId: string;
  /** PublicIdentifier is the public component of the factor */
  publicIdentifier: Uint8Array;
  /** Label is a user-friendly label for the factor */
  label: string;
  /** Status is the current enrollment status */
  status: FactorEnrollmentStatus;
  /** EnrolledAt is the timestamp when the factor was enrolled */
  enrolledAt: Long;
  /** VerifiedAt is the timestamp when the enrollment was verified */
  verifiedAt: Long;
  /** RevokedAt is the timestamp when the factor was revoked */
  revokedAt: Long;
  /** LastUsedAt is the timestamp of the last successful use */
  lastUsedAt: Long;
  /** UseCount tracks how many times this factor has been used */
  useCount: Long;
  /** Metadata contains additional factor-specific metadata */
  metadata: FactorMetadata | undefined;
}

/** TrustedDevicePolicy defines how trusted devices can reduce MFA requirements */
export interface TrustedDevicePolicy {
  /** Enabled indicates if trusted device reduction is enabled */
  enabled: boolean;
  /** TrustDuration is how long a device remains trusted (in seconds) */
  trustDuration: Long;
  /** ReducedFactors is the factor combination to use for trusted devices */
  reducedFactors:
    | FactorCombination
    | undefined;
  /** MaxTrustedDevices is the maximum number of trusted devices per account */
  maxTrustedDevices: number;
  /** RequireReauthForSensitive if true, still requires full MFA for critical actions */
  requireReauthForSensitive: boolean;
}

/** MFAPolicy defines the MFA requirements for an account */
export interface MFAPolicy {
  /** AccountAddress is the account this policy applies to */
  accountAddress: string;
  /** RequiredFactors is a list of factor combinations (OR logic between combinations) */
  requiredFactors: FactorCombination[];
  /** TrustedDeviceRule defines how trusted devices affect MFA requirements */
  trustedDeviceRule:
    | TrustedDevicePolicy
    | undefined;
  /** RecoveryFactors defines factor combinations for account recovery */
  recoveryFactors: FactorCombination[];
  /** KeyRotationFactors defines factor combinations for key rotation */
  keyRotationFactors: FactorCombination[];
  /** SessionDuration is how long an MFA session remains valid (in seconds) */
  sessionDuration: Long;
  /** VEIDThreshold is the minimum VEID score required for VEID-based factors */
  veidThreshold: number;
  /** Enabled indicates if MFA is enabled for this account */
  enabled: boolean;
  /** CreatedAt is when the policy was created */
  createdAt: Long;
  /** UpdatedAt is when the policy was last updated */
  updatedAt: Long;
}

/** ClientInfo contains information about the requesting client */
export interface ClientInfo {
  /** DeviceFingerprint is a hash identifying the device */
  deviceFingerprint: string;
  /** IPHash is a hash of the client IP */
  ipHash: string;
  /** UserAgent is the sanitized user agent string */
  userAgent: string;
  /** RequestedAt is when the request was made */
  requestedAt: Long;
}

/** ChallengeMetadata contains additional challenge information */
export interface ChallengeMetadata {
  /** FIDO2Challenge contains FIDO2-specific challenge data */
  fido2Challenge:
    | FIDO2ChallengeData
    | undefined;
  /** OTPInfo contains OTP-specific tracking data */
  otpInfo:
    | OTPChallengeInfo
    | undefined;
  /** ClientInfo contains information about the requesting client */
  clientInfo:
    | ClientInfo
    | undefined;
  /** HardwareKeyChallenge contains hardware key challenge data */
  hardwareKeyChallenge: HardwareKeyChallenge | undefined;
}

/** FIDO2ChallengeData contains FIDO2-specific challenge information */
export interface FIDO2ChallengeData {
  /** Challenge is the random challenge bytes */
  challenge: Uint8Array;
  /** RelyingPartyID is the relying party identifier */
  relyingPartyId: string;
  /** AllowedCredentials is the list of allowed credential IDs */
  allowedCredentials: Uint8Array[];
  /** UserVerificationRequirement specifies if user verification is required */
  userVerification: string;
}

/** OTPChallengeInfo contains OTP tracking information */
export interface OTPChallengeInfo {
  /** DeliveryMethod indicates how the OTP was delivered */
  deliveryMethod: string;
  /** DeliveryDestinationMasked is the masked delivery destination */
  deliveryDestinationMasked: string;
  /** SentAt is when the OTP was sent */
  sentAt: Long;
  /** ResendCount tracks how many times the OTP was resent */
  resendCount: number;
  /** LastResendAt is when the OTP was last resent */
  lastResendAt: Long;
}

/** HardwareKeyChallenge represents a challenge for hardware key authentication */
export interface HardwareKeyChallenge {
  /** Challenge is the random challenge bytes to be signed */
  challenge: Uint8Array;
  /** KeyID is the expected key ID to use for signing */
  keyId: string;
  /** Nonce is a random nonce for replay protection */
  nonce: string;
  /** CreatedAt is when the challenge was created */
  createdAt: Long;
}

/** Challenge represents an MFA challenge issued to a user */
export interface Challenge {
  /** ChallengeID is the unique identifier for this challenge */
  challengeId: string;
  /** AccountAddress is the account this challenge is for */
  accountAddress: string;
  /** FactorType is the type of factor this challenge is for */
  factorType: FactorType;
  /** FactorID is the specific factor enrollment being challenged */
  factorId: string;
  /** TransactionType is the sensitive transaction this challenge is for */
  transactionType: SensitiveTransactionType;
  /** Status is the current status of the challenge */
  status: ChallengeStatus;
  /** ChallengeData contains factor-specific challenge data */
  challengeData: Uint8Array;
  /** CreatedAt is when the challenge was created */
  createdAt: Long;
  /** ExpiresAt is when the challenge expires */
  expiresAt: Long;
  /** VerifiedAt is when the challenge was verified (if successful) */
  verifiedAt: Long;
  /** AttemptCount tracks the number of verification attempts */
  attemptCount: number;
  /** MaxAttempts is the maximum number of verification attempts allowed */
  maxAttempts: number;
  /** Nonce is a random value for replay protection */
  nonce: string;
  /** SessionID links this challenge to an authorization session */
  sessionId: string;
  /** Metadata contains additional challenge-specific data */
  metadata: ChallengeMetadata | undefined;
}

/** ChallengeResponse represents a response to an MFA challenge */
export interface ChallengeResponse {
  /** ChallengeID is the challenge being responded to */
  challengeId: string;
  /** FactorType is the type of factor used */
  factorType: FactorType;
  /** ResponseData contains the verification data */
  responseData: Uint8Array;
  /** ClientInfo contains information about the responding client */
  clientInfo:
    | ClientInfo
    | undefined;
  /** Timestamp is when the response was created */
  timestamp: Long;
}

/** AuthorizationSession represents a temporary elevated session after MFA verification */
export interface AuthorizationSession {
  /** SessionID is the unique identifier for this session */
  sessionId: string;
  /** AccountAddress is the account this session belongs to */
  accountAddress: string;
  /** TransactionType is the type of transaction authorized */
  transactionType: SensitiveTransactionType;
  /** VerifiedFactors are the factors that were verified for this session */
  verifiedFactors: FactorType[];
  /** CreatedAt is when the session was created */
  createdAt: Long;
  /** ExpiresAt is when the session expires */
  expiresAt: Long;
  /** UsedAt is when the session was used (if single-use) */
  usedAt: Long;
  /** IsSingleUse indicates if the session can only be used once */
  isSingleUse: boolean;
  /** DeviceFingerprint is the device this session is bound to */
  deviceFingerprint: string;
}

/** TrustedDevice represents a stored trusted device record */
export interface TrustedDevice {
  /** AccountAddress is the account that trusts this device */
  accountAddress: string;
  /** DeviceInfo contains the device information */
  deviceInfo:
    | DeviceInfo
    | undefined;
  /** AddedAt is when the device was added */
  addedAt: Long;
  /** LastUsedAt is when the device was last used */
  lastUsedAt: Long;
}

/** SensitiveTxConfig represents the configuration for a sensitive transaction type */
export interface SensitiveTxConfig {
  /** TransactionType is the type of transaction */
  transactionType: SensitiveTransactionType;
  /** Enabled indicates if MFA is required for this transaction type */
  enabled: boolean;
  /** MinVEIDScore is the minimum VEID score required */
  minVeidScore: number;
  /** RequiredFactorCombinations are the default factor combinations required */
  requiredFactorCombinations: FactorCombination[];
  /** SessionDuration is the authorization session duration in seconds */
  sessionDuration: Long;
  /** IsSingleUse indicates if the authorization is single-use */
  isSingleUse: boolean;
  /** AllowTrustedDeviceReduction indicates if trusted devices can reduce MFA */
  allowTrustedDeviceReduction: boolean;
  /** ValueThreshold is the value threshold for amount-based transactions */
  valueThreshold: string;
  /** CooldownPeriod is the cooldown period in seconds for rate-limited operations */
  cooldownPeriod: Long;
  /** Description provides a human-readable description */
  description: string;
}

/** Params defines the parameters for the mfa module */
export interface Params {
  /** DefaultSessionDuration is the default MFA session duration in seconds */
  defaultSessionDuration: Long;
  /** MaxFactorsPerAccount is the maximum number of factors per account */
  maxFactorsPerAccount: number;
  /** MaxChallengeAttempts is the maximum verification attempts per challenge */
  maxChallengeAttempts: number;
  /** ChallengeTTL is the challenge time-to-live in seconds */
  challengeTtl: Long;
  /** MaxTrustedDevices is the maximum trusted devices per account */
  maxTrustedDevices: number;
  /** TrustedDeviceTTL is the trusted device time-to-live in seconds */
  trustedDeviceTtl: Long;
  /** MinVEIDScoreForMFA is the minimum VEID score to enable MFA */
  minVeidScoreForMfa: number;
  /** RequireAtLeastOneFactor requires at least one factor when MFA is enabled */
  requireAtLeastOneFactor: boolean;
  /** AllowedFactorTypes lists the factor types allowed on this chain */
  allowedFactorTypes: FactorType[];
}

/** EventFactorEnrolled is emitted when a factor is enrolled */
export interface EventFactorEnrolled {
  /** AccountAddress is the account that enrolled the factor */
  accountAddress: string;
  /** FactorType is the type of factor enrolled */
  factorType: string;
  /** FactorID is the ID of the enrolled factor */
  factorId: string;
}

/** EventFactorRevoked is emitted when a factor is revoked */
export interface EventFactorRevoked {
  /** AccountAddress is the account that revoked the factor */
  accountAddress: string;
  /** FactorType is the type of factor revoked */
  factorType: string;
  /** FactorID is the ID of the revoked factor */
  factorId: string;
}

/** EventChallengeVerified is emitted when a challenge is verified */
export interface EventChallengeVerified {
  /** AccountAddress is the account that verified the challenge */
  accountAddress: string;
  /** ChallengeID is the ID of the verified challenge */
  challengeId: string;
  /** FactorType is the type of factor used */
  factorType: string;
  /** TransactionType is the transaction type that was authorized */
  transactionType: string;
}

/** EventMFAPolicyUpdated is emitted when an MFA policy is updated */
export interface EventMFAPolicyUpdated {
  /** AccountAddress is the account whose policy was updated */
  accountAddress: string;
  /** Enabled indicates if MFA is now enabled */
  enabled: boolean;
}

function createBaseMFAProof(): MFAProof {
  return { sessionId: "", verifiedFactors: [], timestamp: Long.ZERO, signature: new Uint8Array(0) };
}

export const MFAProof: MessageFns<MFAProof, "virtengine.mfa.v1.MFAProof"> = {
  $type: "virtengine.mfa.v1.MFAProof" as const,

  encode(message: MFAProof, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    for (const v of message.verifiedFactors) {
      writer.uint32(16).int32(v!);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.timestamp.toString());
    }
    if (message.signature.length !== 0) {
      writer.uint32(34).bytes(message.signature);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MFAProof {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMFAProof();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.verifiedFactors.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.verifiedFactors.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.signature = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MFAProof {
    return {
      sessionId: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      verifiedFactors: globalThis.Array.isArray(object?.verified_factors)
        ? object.verified_factors.map((e: any) => factorTypeFromJSON(e))
        : [],
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
      signature: isSet(object.signature) ? bytesFromBase64(object.signature) : new Uint8Array(0),
    };
  },

  toJSON(message: MFAProof): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.session_id = message.sessionId;
    }
    if (message.verifiedFactors?.length) {
      obj.verified_factors = message.verifiedFactors.map((e) => factorTypeToJSON(e));
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    if (message.signature.length !== 0) {
      obj.signature = base64FromBytes(message.signature);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MFAProof>): MFAProof {
    const message = createBaseMFAProof();
    message.sessionId = object.sessionId ?? "";
    message.verifiedFactors = object.verifiedFactors?.map((e) => e) || [];
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    message.signature = object.signature ?? new Uint8Array(0);
    return message;
  },
};

function createBaseFactorCombination(): FactorCombination {
  return { factors: [], minSecurityLevel: 0 };
}

export const FactorCombination: MessageFns<FactorCombination, "virtengine.mfa.v1.FactorCombination"> = {
  $type: "virtengine.mfa.v1.FactorCombination" as const,

  encode(message: FactorCombination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.factors) {
      writer.uint32(8).int32(v!);
    }
    if (message.minSecurityLevel !== 0) {
      writer.uint32(16).int32(message.minSecurityLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactorCombination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactorCombination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.factors.push(reader.int32() as any);

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.factors.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.minSecurityLevel = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactorCombination {
    return {
      factors: globalThis.Array.isArray(object?.factors) ? object.factors.map((e: any) => factorTypeFromJSON(e)) : [],
      minSecurityLevel: isSet(object.min_security_level) ? factorSecurityLevelFromJSON(object.min_security_level) : 0,
    };
  },

  toJSON(message: FactorCombination): unknown {
    const obj: any = {};
    if (message.factors?.length) {
      obj.factors = message.factors.map((e) => factorTypeToJSON(e));
    }
    if (message.minSecurityLevel !== 0) {
      obj.min_security_level = factorSecurityLevelToJSON(message.minSecurityLevel);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FactorCombination>): FactorCombination {
    const message = createBaseFactorCombination();
    message.factors = object.factors?.map((e) => e) || [];
    message.minSecurityLevel = object.minSecurityLevel ?? 0;
    return message;
  },
};

function createBaseFactorMetadata(): FactorMetadata {
  return { veidThreshold: 0, deviceInfo: undefined, fido2Info: undefined, contactHash: "", hardwareKeyInfo: undefined };
}

export const FactorMetadata: MessageFns<FactorMetadata, "virtengine.mfa.v1.FactorMetadata"> = {
  $type: "virtengine.mfa.v1.FactorMetadata" as const,

  encode(message: FactorMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.veidThreshold !== 0) {
      writer.uint32(8).uint32(message.veidThreshold);
    }
    if (message.deviceInfo !== undefined) {
      DeviceInfo.encode(message.deviceInfo, writer.uint32(18).fork()).join();
    }
    if (message.fido2Info !== undefined) {
      FIDO2CredentialInfo.encode(message.fido2Info, writer.uint32(26).fork()).join();
    }
    if (message.contactHash !== "") {
      writer.uint32(34).string(message.contactHash);
    }
    if (message.hardwareKeyInfo !== undefined) {
      HardwareKeyEnrollment.encode(message.hardwareKeyInfo, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactorMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactorMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.veidThreshold = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deviceInfo = DeviceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.fido2Info = FIDO2CredentialInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.contactHash = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.hardwareKeyInfo = HardwareKeyEnrollment.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactorMetadata {
    return {
      veidThreshold: isSet(object.veid_threshold) ? globalThis.Number(object.veid_threshold) : 0,
      deviceInfo: isSet(object.device_info) ? DeviceInfo.fromJSON(object.device_info) : undefined,
      fido2Info: isSet(object.fido2_info) ? FIDO2CredentialInfo.fromJSON(object.fido2_info) : undefined,
      contactHash: isSet(object.contact_hash) ? globalThis.String(object.contact_hash) : "",
      hardwareKeyInfo: isSet(object.hardware_key_info)
        ? HardwareKeyEnrollment.fromJSON(object.hardware_key_info)
        : undefined,
    };
  },

  toJSON(message: FactorMetadata): unknown {
    const obj: any = {};
    if (message.veidThreshold !== 0) {
      obj.veid_threshold = Math.round(message.veidThreshold);
    }
    if (message.deviceInfo !== undefined) {
      obj.device_info = DeviceInfo.toJSON(message.deviceInfo);
    }
    if (message.fido2Info !== undefined) {
      obj.fido2_info = FIDO2CredentialInfo.toJSON(message.fido2Info);
    }
    if (message.contactHash !== "") {
      obj.contact_hash = message.contactHash;
    }
    if (message.hardwareKeyInfo !== undefined) {
      obj.hardware_key_info = HardwareKeyEnrollment.toJSON(message.hardwareKeyInfo);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FactorMetadata>): FactorMetadata {
    const message = createBaseFactorMetadata();
    message.veidThreshold = object.veidThreshold ?? 0;
    message.deviceInfo = (object.deviceInfo !== undefined && object.deviceInfo !== null)
      ? DeviceInfo.fromPartial(object.deviceInfo)
      : undefined;
    message.fido2Info = (object.fido2Info !== undefined && object.fido2Info !== null)
      ? FIDO2CredentialInfo.fromPartial(object.fido2Info)
      : undefined;
    message.contactHash = object.contactHash ?? "";
    message.hardwareKeyInfo = (object.hardwareKeyInfo !== undefined && object.hardwareKeyInfo !== null)
      ? HardwareKeyEnrollment.fromPartial(object.hardwareKeyInfo)
      : undefined;
    return message;
  },
};

function createBaseDeviceInfo(): DeviceInfo {
  return {
    fingerprint: "",
    userAgent: "",
    firstSeenAt: Long.ZERO,
    lastSeenAt: Long.ZERO,
    ipHash: "",
    trustExpiresAt: Long.ZERO,
  };
}

export const DeviceInfo: MessageFns<DeviceInfo, "virtengine.mfa.v1.DeviceInfo"> = {
  $type: "virtengine.mfa.v1.DeviceInfo" as const,

  encode(message: DeviceInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fingerprint !== "") {
      writer.uint32(10).string(message.fingerprint);
    }
    if (message.userAgent !== "") {
      writer.uint32(18).string(message.userAgent);
    }
    if (!message.firstSeenAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.firstSeenAt.toString());
    }
    if (!message.lastSeenAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastSeenAt.toString());
    }
    if (message.ipHash !== "") {
      writer.uint32(42).string(message.ipHash);
    }
    if (!message.trustExpiresAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.trustExpiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeviceInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeviceInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fingerprint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.firstSeenAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastSeenAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.trustExpiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeviceInfo {
    return {
      fingerprint: isSet(object.fingerprint) ? globalThis.String(object.fingerprint) : "",
      userAgent: isSet(object.user_agent) ? globalThis.String(object.user_agent) : "",
      firstSeenAt: isSet(object.first_seen_at) ? Long.fromValue(object.first_seen_at) : Long.ZERO,
      lastSeenAt: isSet(object.last_seen_at) ? Long.fromValue(object.last_seen_at) : Long.ZERO,
      ipHash: isSet(object.ip_hash) ? globalThis.String(object.ip_hash) : "",
      trustExpiresAt: isSet(object.trust_expires_at) ? Long.fromValue(object.trust_expires_at) : Long.ZERO,
    };
  },

  toJSON(message: DeviceInfo): unknown {
    const obj: any = {};
    if (message.fingerprint !== "") {
      obj.fingerprint = message.fingerprint;
    }
    if (message.userAgent !== "") {
      obj.user_agent = message.userAgent;
    }
    if (!message.firstSeenAt.equals(Long.ZERO)) {
      obj.first_seen_at = (message.firstSeenAt || Long.ZERO).toString();
    }
    if (!message.lastSeenAt.equals(Long.ZERO)) {
      obj.last_seen_at = (message.lastSeenAt || Long.ZERO).toString();
    }
    if (message.ipHash !== "") {
      obj.ip_hash = message.ipHash;
    }
    if (!message.trustExpiresAt.equals(Long.ZERO)) {
      obj.trust_expires_at = (message.trustExpiresAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DeviceInfo>): DeviceInfo {
    const message = createBaseDeviceInfo();
    message.fingerprint = object.fingerprint ?? "";
    message.userAgent = object.userAgent ?? "";
    message.firstSeenAt = (object.firstSeenAt !== undefined && object.firstSeenAt !== null)
      ? Long.fromValue(object.firstSeenAt)
      : Long.ZERO;
    message.lastSeenAt = (object.lastSeenAt !== undefined && object.lastSeenAt !== null)
      ? Long.fromValue(object.lastSeenAt)
      : Long.ZERO;
    message.ipHash = object.ipHash ?? "";
    message.trustExpiresAt = (object.trustExpiresAt !== undefined && object.trustExpiresAt !== null)
      ? Long.fromValue(object.trustExpiresAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseFIDO2CredentialInfo(): FIDO2CredentialInfo {
  return {
    credentialId: new Uint8Array(0),
    publicKey: new Uint8Array(0),
    aaguid: new Uint8Array(0),
    signCount: 0,
    attestationType: "",
  };
}

export const FIDO2CredentialInfo: MessageFns<FIDO2CredentialInfo, "virtengine.mfa.v1.FIDO2CredentialInfo"> = {
  $type: "virtengine.mfa.v1.FIDO2CredentialInfo" as const,

  encode(message: FIDO2CredentialInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.credentialId.length !== 0) {
      writer.uint32(10).bytes(message.credentialId);
    }
    if (message.publicKey.length !== 0) {
      writer.uint32(18).bytes(message.publicKey);
    }
    if (message.aaguid.length !== 0) {
      writer.uint32(26).bytes(message.aaguid);
    }
    if (message.signCount !== 0) {
      writer.uint32(32).uint32(message.signCount);
    }
    if (message.attestationType !== "") {
      writer.uint32(42).string(message.attestationType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FIDO2CredentialInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFIDO2CredentialInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.credentialId = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.publicKey = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aaguid = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.signCount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.attestationType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FIDO2CredentialInfo {
    return {
      credentialId: isSet(object.credential_id) ? bytesFromBase64(object.credential_id) : new Uint8Array(0),
      publicKey: isSet(object.public_key) ? bytesFromBase64(object.public_key) : new Uint8Array(0),
      aaguid: isSet(object.aaguid) ? bytesFromBase64(object.aaguid) : new Uint8Array(0),
      signCount: isSet(object.sign_count) ? globalThis.Number(object.sign_count) : 0,
      attestationType: isSet(object.attestation_type) ? globalThis.String(object.attestation_type) : "",
    };
  },

  toJSON(message: FIDO2CredentialInfo): unknown {
    const obj: any = {};
    if (message.credentialId.length !== 0) {
      obj.credential_id = base64FromBytes(message.credentialId);
    }
    if (message.publicKey.length !== 0) {
      obj.public_key = base64FromBytes(message.publicKey);
    }
    if (message.aaguid.length !== 0) {
      obj.aaguid = base64FromBytes(message.aaguid);
    }
    if (message.signCount !== 0) {
      obj.sign_count = Math.round(message.signCount);
    }
    if (message.attestationType !== "") {
      obj.attestation_type = message.attestationType;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FIDO2CredentialInfo>): FIDO2CredentialInfo {
    const message = createBaseFIDO2CredentialInfo();
    message.credentialId = object.credentialId ?? new Uint8Array(0);
    message.publicKey = object.publicKey ?? new Uint8Array(0);
    message.aaguid = object.aaguid ?? new Uint8Array(0);
    message.signCount = object.signCount ?? 0;
    message.attestationType = object.attestationType ?? "";
    return message;
  },
};

function createBaseHardwareKeyEnrollment(): HardwareKeyEnrollment {
  return {
    keyType: 0,
    keyId: "",
    subjectDn: "",
    issuerDn: "",
    serialNumber: "",
    publicKeyFingerprint: "",
    notBefore: Long.ZERO,
    notAfter: Long.ZERO,
    keyUsage: [],
    extendedKeyUsage: [],
    smartCardInfo: undefined,
    revocationCheckEnabled: false,
    lastRevocationCheck: Long.ZERO,
    revocationStatus: 0,
    trustedCaCertFingerprints: [],
  };
}

export const HardwareKeyEnrollment: MessageFns<HardwareKeyEnrollment, "virtengine.mfa.v1.HardwareKeyEnrollment"> = {
  $type: "virtengine.mfa.v1.HardwareKeyEnrollment" as const,

  encode(message: HardwareKeyEnrollment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.keyType !== 0) {
      writer.uint32(8).int32(message.keyType);
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    if (message.subjectDn !== "") {
      writer.uint32(26).string(message.subjectDn);
    }
    if (message.issuerDn !== "") {
      writer.uint32(34).string(message.issuerDn);
    }
    if (message.serialNumber !== "") {
      writer.uint32(42).string(message.serialNumber);
    }
    if (message.publicKeyFingerprint !== "") {
      writer.uint32(50).string(message.publicKeyFingerprint);
    }
    if (!message.notBefore.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.notBefore.toString());
    }
    if (!message.notAfter.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.notAfter.toString());
    }
    for (const v of message.keyUsage) {
      writer.uint32(74).string(v!);
    }
    for (const v of message.extendedKeyUsage) {
      writer.uint32(82).string(v!);
    }
    if (message.smartCardInfo !== undefined) {
      SmartCardInfo.encode(message.smartCardInfo, writer.uint32(90).fork()).join();
    }
    if (message.revocationCheckEnabled !== false) {
      writer.uint32(96).bool(message.revocationCheckEnabled);
    }
    if (!message.lastRevocationCheck.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.lastRevocationCheck.toString());
    }
    if (message.revocationStatus !== 0) {
      writer.uint32(112).int32(message.revocationStatus);
    }
    for (const v of message.trustedCaCertFingerprints) {
      writer.uint32(122).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareKeyEnrollment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareKeyEnrollment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.keyType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subjectDn = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.issuerDn = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.serialNumber = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.publicKeyFingerprint = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.notBefore = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.notAfter = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.keyUsage.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.extendedKeyUsage.push(reader.string());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.smartCardInfo = SmartCardInfo.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.revocationCheckEnabled = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lastRevocationCheck = Long.fromString(reader.int64().toString());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.revocationStatus = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.trustedCaCertFingerprints.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareKeyEnrollment {
    return {
      keyType: isSet(object.key_type) ? hardwareKeyTypeFromJSON(object.key_type) : 0,
      keyId: isSet(object.key_id) ? globalThis.String(object.key_id) : "",
      subjectDn: isSet(object.subject_dn) ? globalThis.String(object.subject_dn) : "",
      issuerDn: isSet(object.issuer_dn) ? globalThis.String(object.issuer_dn) : "",
      serialNumber: isSet(object.serial_number) ? globalThis.String(object.serial_number) : "",
      publicKeyFingerprint: isSet(object.public_key_fingerprint)
        ? globalThis.String(object.public_key_fingerprint)
        : "",
      notBefore: isSet(object.not_before) ? Long.fromValue(object.not_before) : Long.ZERO,
      notAfter: isSet(object.not_after) ? Long.fromValue(object.not_after) : Long.ZERO,
      keyUsage: globalThis.Array.isArray(object?.key_usage)
        ? object.key_usage.map((e: any) => globalThis.String(e))
        : [],
      extendedKeyUsage: globalThis.Array.isArray(object?.extended_key_usage)
        ? object.extended_key_usage.map((e: any) => globalThis.String(e))
        : [],
      smartCardInfo: isSet(object.smart_card_info) ? SmartCardInfo.fromJSON(object.smart_card_info) : undefined,
      revocationCheckEnabled: isSet(object.revocation_check_enabled)
        ? globalThis.Boolean(object.revocation_check_enabled)
        : false,
      lastRevocationCheck: isSet(object.last_revocation_check)
        ? Long.fromValue(object.last_revocation_check)
        : Long.ZERO,
      revocationStatus: isSet(object.revocation_status) ? revocationStatusFromJSON(object.revocation_status) : 0,
      trustedCaCertFingerprints: globalThis.Array.isArray(object?.trusted_ca_cert_fingerprints)
        ? object.trusted_ca_cert_fingerprints.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: HardwareKeyEnrollment): unknown {
    const obj: any = {};
    if (message.keyType !== 0) {
      obj.key_type = hardwareKeyTypeToJSON(message.keyType);
    }
    if (message.keyId !== "") {
      obj.key_id = message.keyId;
    }
    if (message.subjectDn !== "") {
      obj.subject_dn = message.subjectDn;
    }
    if (message.issuerDn !== "") {
      obj.issuer_dn = message.issuerDn;
    }
    if (message.serialNumber !== "") {
      obj.serial_number = message.serialNumber;
    }
    if (message.publicKeyFingerprint !== "") {
      obj.public_key_fingerprint = message.publicKeyFingerprint;
    }
    if (!message.notBefore.equals(Long.ZERO)) {
      obj.not_before = (message.notBefore || Long.ZERO).toString();
    }
    if (!message.notAfter.equals(Long.ZERO)) {
      obj.not_after = (message.notAfter || Long.ZERO).toString();
    }
    if (message.keyUsage?.length) {
      obj.key_usage = message.keyUsage;
    }
    if (message.extendedKeyUsage?.length) {
      obj.extended_key_usage = message.extendedKeyUsage;
    }
    if (message.smartCardInfo !== undefined) {
      obj.smart_card_info = SmartCardInfo.toJSON(message.smartCardInfo);
    }
    if (message.revocationCheckEnabled !== false) {
      obj.revocation_check_enabled = message.revocationCheckEnabled;
    }
    if (!message.lastRevocationCheck.equals(Long.ZERO)) {
      obj.last_revocation_check = (message.lastRevocationCheck || Long.ZERO).toString();
    }
    if (message.revocationStatus !== 0) {
      obj.revocation_status = revocationStatusToJSON(message.revocationStatus);
    }
    if (message.trustedCaCertFingerprints?.length) {
      obj.trusted_ca_cert_fingerprints = message.trustedCaCertFingerprints;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HardwareKeyEnrollment>): HardwareKeyEnrollment {
    const message = createBaseHardwareKeyEnrollment();
    message.keyType = object.keyType ?? 0;
    message.keyId = object.keyId ?? "";
    message.subjectDn = object.subjectDn ?? "";
    message.issuerDn = object.issuerDn ?? "";
    message.serialNumber = object.serialNumber ?? "";
    message.publicKeyFingerprint = object.publicKeyFingerprint ?? "";
    message.notBefore = (object.notBefore !== undefined && object.notBefore !== null)
      ? Long.fromValue(object.notBefore)
      : Long.ZERO;
    message.notAfter = (object.notAfter !== undefined && object.notAfter !== null)
      ? Long.fromValue(object.notAfter)
      : Long.ZERO;
    message.keyUsage = object.keyUsage?.map((e) => e) || [];
    message.extendedKeyUsage = object.extendedKeyUsage?.map((e) => e) || [];
    message.smartCardInfo = (object.smartCardInfo !== undefined && object.smartCardInfo !== null)
      ? SmartCardInfo.fromPartial(object.smartCardInfo)
      : undefined;
    message.revocationCheckEnabled = object.revocationCheckEnabled ?? false;
    message.lastRevocationCheck = (object.lastRevocationCheck !== undefined && object.lastRevocationCheck !== null)
      ? Long.fromValue(object.lastRevocationCheck)
      : Long.ZERO;
    message.revocationStatus = object.revocationStatus ?? 0;
    message.trustedCaCertFingerprints = object.trustedCaCertFingerprints?.map((e) => e) || [];
    return message;
  },
};

function createBaseSmartCardInfo(): SmartCardInfo {
  return {
    cardSerialNumber: "",
    cardType: "",
    slotId: "",
    chuid: "",
    fascn: "",
    cardHolderName: "",
    expirationDate: Long.ZERO,
    lastPinVerification: Long.ZERO,
  };
}

export const SmartCardInfo: MessageFns<SmartCardInfo, "virtengine.mfa.v1.SmartCardInfo"> = {
  $type: "virtengine.mfa.v1.SmartCardInfo" as const,

  encode(message: SmartCardInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cardSerialNumber !== "") {
      writer.uint32(10).string(message.cardSerialNumber);
    }
    if (message.cardType !== "") {
      writer.uint32(18).string(message.cardType);
    }
    if (message.slotId !== "") {
      writer.uint32(26).string(message.slotId);
    }
    if (message.chuid !== "") {
      writer.uint32(34).string(message.chuid);
    }
    if (message.fascn !== "") {
      writer.uint32(42).string(message.fascn);
    }
    if (message.cardHolderName !== "") {
      writer.uint32(50).string(message.cardHolderName);
    }
    if (!message.expirationDate.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.expirationDate.toString());
    }
    if (!message.lastPinVerification.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.lastPinVerification.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SmartCardInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSmartCardInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cardSerialNumber = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cardType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.slotId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.chuid = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.fascn = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.cardHolderName = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.expirationDate = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.lastPinVerification = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SmartCardInfo {
    return {
      cardSerialNumber: isSet(object.card_serial_number) ? globalThis.String(object.card_serial_number) : "",
      cardType: isSet(object.card_type) ? globalThis.String(object.card_type) : "",
      slotId: isSet(object.slot_id) ? globalThis.String(object.slot_id) : "",
      chuid: isSet(object.chuid) ? globalThis.String(object.chuid) : "",
      fascn: isSet(object.fascn) ? globalThis.String(object.fascn) : "",
      cardHolderName: isSet(object.card_holder_name) ? globalThis.String(object.card_holder_name) : "",
      expirationDate: isSet(object.expiration_date) ? Long.fromValue(object.expiration_date) : Long.ZERO,
      lastPinVerification: isSet(object.last_pin_verification)
        ? Long.fromValue(object.last_pin_verification)
        : Long.ZERO,
    };
  },

  toJSON(message: SmartCardInfo): unknown {
    const obj: any = {};
    if (message.cardSerialNumber !== "") {
      obj.card_serial_number = message.cardSerialNumber;
    }
    if (message.cardType !== "") {
      obj.card_type = message.cardType;
    }
    if (message.slotId !== "") {
      obj.slot_id = message.slotId;
    }
    if (message.chuid !== "") {
      obj.chuid = message.chuid;
    }
    if (message.fascn !== "") {
      obj.fascn = message.fascn;
    }
    if (message.cardHolderName !== "") {
      obj.card_holder_name = message.cardHolderName;
    }
    if (!message.expirationDate.equals(Long.ZERO)) {
      obj.expiration_date = (message.expirationDate || Long.ZERO).toString();
    }
    if (!message.lastPinVerification.equals(Long.ZERO)) {
      obj.last_pin_verification = (message.lastPinVerification || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<SmartCardInfo>): SmartCardInfo {
    const message = createBaseSmartCardInfo();
    message.cardSerialNumber = object.cardSerialNumber ?? "";
    message.cardType = object.cardType ?? "";
    message.slotId = object.slotId ?? "";
    message.chuid = object.chuid ?? "";
    message.fascn = object.fascn ?? "";
    message.cardHolderName = object.cardHolderName ?? "";
    message.expirationDate = (object.expirationDate !== undefined && object.expirationDate !== null)
      ? Long.fromValue(object.expirationDate)
      : Long.ZERO;
    message.lastPinVerification = (object.lastPinVerification !== undefined && object.lastPinVerification !== null)
      ? Long.fromValue(object.lastPinVerification)
      : Long.ZERO;
    return message;
  },
};

function createBaseFactorEnrollment(): FactorEnrollment {
  return {
    accountAddress: "",
    factorType: 0,
    factorId: "",
    publicIdentifier: new Uint8Array(0),
    label: "",
    status: 0,
    enrolledAt: Long.ZERO,
    verifiedAt: Long.ZERO,
    revokedAt: Long.ZERO,
    lastUsedAt: Long.ZERO,
    useCount: Long.UZERO,
    metadata: undefined,
  };
}

export const FactorEnrollment: MessageFns<FactorEnrollment, "virtengine.mfa.v1.FactorEnrollment"> = {
  $type: "virtengine.mfa.v1.FactorEnrollment" as const,

  encode(message: FactorEnrollment, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.factorType !== 0) {
      writer.uint32(16).int32(message.factorType);
    }
    if (message.factorId !== "") {
      writer.uint32(26).string(message.factorId);
    }
    if (message.publicIdentifier.length !== 0) {
      writer.uint32(34).bytes(message.publicIdentifier);
    }
    if (message.label !== "") {
      writer.uint32(42).string(message.label);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (!message.enrolledAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.enrolledAt.toString());
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.verifiedAt.toString());
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.revokedAt.toString());
    }
    if (!message.lastUsedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.lastUsedAt.toString());
    }
    if (!message.useCount.equals(Long.UZERO)) {
      writer.uint32(88).uint64(message.useCount.toString());
    }
    if (message.metadata !== undefined) {
      FactorMetadata.encode(message.metadata, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FactorEnrollment {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFactorEnrollment();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.factorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.publicIdentifier = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.enrolledAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.verifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.revokedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.lastUsedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.useCount = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = FactorMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FactorEnrollment {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      factorType: isSet(object.factor_type) ? factorTypeFromJSON(object.factor_type) : 0,
      factorId: isSet(object.factor_id) ? globalThis.String(object.factor_id) : "",
      publicIdentifier: isSet(object.public_identifier) ? bytesFromBase64(object.public_identifier) : new Uint8Array(0),
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      status: isSet(object.status) ? factorEnrollmentStatusFromJSON(object.status) : 0,
      enrolledAt: isSet(object.enrolled_at) ? Long.fromValue(object.enrolled_at) : Long.ZERO,
      verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      revokedAt: isSet(object.revoked_at) ? Long.fromValue(object.revoked_at) : Long.ZERO,
      lastUsedAt: isSet(object.last_used_at) ? Long.fromValue(object.last_used_at) : Long.ZERO,
      useCount: isSet(object.use_count) ? Long.fromValue(object.use_count) : Long.UZERO,
      metadata: isSet(object.metadata) ? FactorMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: FactorEnrollment): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.factorType !== 0) {
      obj.factor_type = factorTypeToJSON(message.factorType);
    }
    if (message.factorId !== "") {
      obj.factor_id = message.factorId;
    }
    if (message.publicIdentifier.length !== 0) {
      obj.public_identifier = base64FromBytes(message.publicIdentifier);
    }
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.status !== 0) {
      obj.status = factorEnrollmentStatusToJSON(message.status);
    }
    if (!message.enrolledAt.equals(Long.ZERO)) {
      obj.enrolled_at = (message.enrolledAt || Long.ZERO).toString();
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
    }
    if (!message.revokedAt.equals(Long.ZERO)) {
      obj.revoked_at = (message.revokedAt || Long.ZERO).toString();
    }
    if (!message.lastUsedAt.equals(Long.ZERO)) {
      obj.last_used_at = (message.lastUsedAt || Long.ZERO).toString();
    }
    if (!message.useCount.equals(Long.UZERO)) {
      obj.use_count = (message.useCount || Long.UZERO).toString();
    }
    if (message.metadata !== undefined) {
      obj.metadata = FactorMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FactorEnrollment>): FactorEnrollment {
    const message = createBaseFactorEnrollment();
    message.accountAddress = object.accountAddress ?? "";
    message.factorType = object.factorType ?? 0;
    message.factorId = object.factorId ?? "";
    message.publicIdentifier = object.publicIdentifier ?? new Uint8Array(0);
    message.label = object.label ?? "";
    message.status = object.status ?? 0;
    message.enrolledAt = (object.enrolledAt !== undefined && object.enrolledAt !== null)
      ? Long.fromValue(object.enrolledAt)
      : Long.ZERO;
    message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
      ? Long.fromValue(object.verifiedAt)
      : Long.ZERO;
    message.revokedAt = (object.revokedAt !== undefined && object.revokedAt !== null)
      ? Long.fromValue(object.revokedAt)
      : Long.ZERO;
    message.lastUsedAt = (object.lastUsedAt !== undefined && object.lastUsedAt !== null)
      ? Long.fromValue(object.lastUsedAt)
      : Long.ZERO;
    message.useCount = (object.useCount !== undefined && object.useCount !== null)
      ? Long.fromValue(object.useCount)
      : Long.UZERO;
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? FactorMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseTrustedDevicePolicy(): TrustedDevicePolicy {
  return {
    enabled: false,
    trustDuration: Long.ZERO,
    reducedFactors: undefined,
    maxTrustedDevices: 0,
    requireReauthForSensitive: false,
  };
}

export const TrustedDevicePolicy: MessageFns<TrustedDevicePolicy, "virtengine.mfa.v1.TrustedDevicePolicy"> = {
  $type: "virtengine.mfa.v1.TrustedDevicePolicy" as const,

  encode(message: TrustedDevicePolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.enabled !== false) {
      writer.uint32(8).bool(message.enabled);
    }
    if (!message.trustDuration.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.trustDuration.toString());
    }
    if (message.reducedFactors !== undefined) {
      FactorCombination.encode(message.reducedFactors, writer.uint32(26).fork()).join();
    }
    if (message.maxTrustedDevices !== 0) {
      writer.uint32(32).uint32(message.maxTrustedDevices);
    }
    if (message.requireReauthForSensitive !== false) {
      writer.uint32(40).bool(message.requireReauthForSensitive);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrustedDevicePolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrustedDevicePolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.trustDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reducedFactors = FactorCombination.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxTrustedDevices = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.requireReauthForSensitive = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrustedDevicePolicy {
    return {
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      trustDuration: isSet(object.trust_duration) ? Long.fromValue(object.trust_duration) : Long.ZERO,
      reducedFactors: isSet(object.reduced_factors) ? FactorCombination.fromJSON(object.reduced_factors) : undefined,
      maxTrustedDevices: isSet(object.max_trusted_devices) ? globalThis.Number(object.max_trusted_devices) : 0,
      requireReauthForSensitive: isSet(object.require_reauth_for_sensitive)
        ? globalThis.Boolean(object.require_reauth_for_sensitive)
        : false,
    };
  },

  toJSON(message: TrustedDevicePolicy): unknown {
    const obj: any = {};
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (!message.trustDuration.equals(Long.ZERO)) {
      obj.trust_duration = (message.trustDuration || Long.ZERO).toString();
    }
    if (message.reducedFactors !== undefined) {
      obj.reduced_factors = FactorCombination.toJSON(message.reducedFactors);
    }
    if (message.maxTrustedDevices !== 0) {
      obj.max_trusted_devices = Math.round(message.maxTrustedDevices);
    }
    if (message.requireReauthForSensitive !== false) {
      obj.require_reauth_for_sensitive = message.requireReauthForSensitive;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<TrustedDevicePolicy>): TrustedDevicePolicy {
    const message = createBaseTrustedDevicePolicy();
    message.enabled = object.enabled ?? false;
    message.trustDuration = (object.trustDuration !== undefined && object.trustDuration !== null)
      ? Long.fromValue(object.trustDuration)
      : Long.ZERO;
    message.reducedFactors = (object.reducedFactors !== undefined && object.reducedFactors !== null)
      ? FactorCombination.fromPartial(object.reducedFactors)
      : undefined;
    message.maxTrustedDevices = object.maxTrustedDevices ?? 0;
    message.requireReauthForSensitive = object.requireReauthForSensitive ?? false;
    return message;
  },
};

function createBaseMFAPolicy(): MFAPolicy {
  return {
    accountAddress: "",
    requiredFactors: [],
    trustedDeviceRule: undefined,
    recoveryFactors: [],
    keyRotationFactors: [],
    sessionDuration: Long.ZERO,
    veidThreshold: 0,
    enabled: false,
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
  };
}

export const MFAPolicy: MessageFns<MFAPolicy, "virtengine.mfa.v1.MFAPolicy"> = {
  $type: "virtengine.mfa.v1.MFAPolicy" as const,

  encode(message: MFAPolicy, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    for (const v of message.requiredFactors) {
      FactorCombination.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.trustedDeviceRule !== undefined) {
      TrustedDevicePolicy.encode(message.trustedDeviceRule, writer.uint32(26).fork()).join();
    }
    for (const v of message.recoveryFactors) {
      FactorCombination.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.keyRotationFactors) {
      FactorCombination.encode(v!, writer.uint32(42).fork()).join();
    }
    if (!message.sessionDuration.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.sessionDuration.toString());
    }
    if (message.veidThreshold !== 0) {
      writer.uint32(56).uint32(message.veidThreshold);
    }
    if (message.enabled !== false) {
      writer.uint32(64).bool(message.enabled);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.updatedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MFAPolicy {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMFAPolicy();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.requiredFactors.push(FactorCombination.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trustedDeviceRule = TrustedDevicePolicy.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.recoveryFactors.push(FactorCombination.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.keyRotationFactors.push(FactorCombination.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.sessionDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.veidThreshold = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MFAPolicy {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      requiredFactors: globalThis.Array.isArray(object?.required_factors)
        ? object.required_factors.map((e: any) => FactorCombination.fromJSON(e))
        : [],
      trustedDeviceRule: isSet(object.trusted_device_rule)
        ? TrustedDevicePolicy.fromJSON(object.trusted_device_rule)
        : undefined,
      recoveryFactors: globalThis.Array.isArray(object?.recovery_factors)
        ? object.recovery_factors.map((e: any) => FactorCombination.fromJSON(e))
        : [],
      keyRotationFactors: globalThis.Array.isArray(object?.key_rotation_factors)
        ? object.key_rotation_factors.map((e: any) => FactorCombination.fromJSON(e))
        : [],
      sessionDuration: isSet(object.session_duration) ? Long.fromValue(object.session_duration) : Long.ZERO,
      veidThreshold: isSet(object.veid_threshold) ? globalThis.Number(object.veid_threshold) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      updatedAt: isSet(object.updated_at) ? Long.fromValue(object.updated_at) : Long.ZERO,
    };
  },

  toJSON(message: MFAPolicy): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.requiredFactors?.length) {
      obj.required_factors = message.requiredFactors.map((e) => FactorCombination.toJSON(e));
    }
    if (message.trustedDeviceRule !== undefined) {
      obj.trusted_device_rule = TrustedDevicePolicy.toJSON(message.trustedDeviceRule);
    }
    if (message.recoveryFactors?.length) {
      obj.recovery_factors = message.recoveryFactors.map((e) => FactorCombination.toJSON(e));
    }
    if (message.keyRotationFactors?.length) {
      obj.key_rotation_factors = message.keyRotationFactors.map((e) => FactorCombination.toJSON(e));
    }
    if (!message.sessionDuration.equals(Long.ZERO)) {
      obj.session_duration = (message.sessionDuration || Long.ZERO).toString();
    }
    if (message.veidThreshold !== 0) {
      obj.veid_threshold = Math.round(message.veidThreshold);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updated_at = (message.updatedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MFAPolicy>): MFAPolicy {
    const message = createBaseMFAPolicy();
    message.accountAddress = object.accountAddress ?? "";
    message.requiredFactors = object.requiredFactors?.map((e) => FactorCombination.fromPartial(e)) || [];
    message.trustedDeviceRule = (object.trustedDeviceRule !== undefined && object.trustedDeviceRule !== null)
      ? TrustedDevicePolicy.fromPartial(object.trustedDeviceRule)
      : undefined;
    message.recoveryFactors = object.recoveryFactors?.map((e) => FactorCombination.fromPartial(e)) || [];
    message.keyRotationFactors = object.keyRotationFactors?.map((e) => FactorCombination.fromPartial(e)) || [];
    message.sessionDuration = (object.sessionDuration !== undefined && object.sessionDuration !== null)
      ? Long.fromValue(object.sessionDuration)
      : Long.ZERO;
    message.veidThreshold = object.veidThreshold ?? 0;
    message.enabled = object.enabled ?? false;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseClientInfo(): ClientInfo {
  return { deviceFingerprint: "", ipHash: "", userAgent: "", requestedAt: Long.ZERO };
}

export const ClientInfo: MessageFns<ClientInfo, "virtengine.mfa.v1.ClientInfo"> = {
  $type: "virtengine.mfa.v1.ClientInfo" as const,

  encode(message: ClientInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deviceFingerprint !== "") {
      writer.uint32(10).string(message.deviceFingerprint);
    }
    if (message.ipHash !== "") {
      writer.uint32(18).string(message.ipHash);
    }
    if (message.userAgent !== "") {
      writer.uint32(26).string(message.userAgent);
    }
    if (!message.requestedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.requestedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deviceFingerprint = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.ipHash = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.userAgent = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requestedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientInfo {
    return {
      deviceFingerprint: isSet(object.device_fingerprint) ? globalThis.String(object.device_fingerprint) : "",
      ipHash: isSet(object.ip_hash) ? globalThis.String(object.ip_hash) : "",
      userAgent: isSet(object.user_agent) ? globalThis.String(object.user_agent) : "",
      requestedAt: isSet(object.requested_at) ? Long.fromValue(object.requested_at) : Long.ZERO,
    };
  },

  toJSON(message: ClientInfo): unknown {
    const obj: any = {};
    if (message.deviceFingerprint !== "") {
      obj.device_fingerprint = message.deviceFingerprint;
    }
    if (message.ipHash !== "") {
      obj.ip_hash = message.ipHash;
    }
    if (message.userAgent !== "") {
      obj.user_agent = message.userAgent;
    }
    if (!message.requestedAt.equals(Long.ZERO)) {
      obj.requested_at = (message.requestedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ClientInfo>): ClientInfo {
    const message = createBaseClientInfo();
    message.deviceFingerprint = object.deviceFingerprint ?? "";
    message.ipHash = object.ipHash ?? "";
    message.userAgent = object.userAgent ?? "";
    message.requestedAt = (object.requestedAt !== undefined && object.requestedAt !== null)
      ? Long.fromValue(object.requestedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseChallengeMetadata(): ChallengeMetadata {
  return { fido2Challenge: undefined, otpInfo: undefined, clientInfo: undefined, hardwareKeyChallenge: undefined };
}

export const ChallengeMetadata: MessageFns<ChallengeMetadata, "virtengine.mfa.v1.ChallengeMetadata"> = {
  $type: "virtengine.mfa.v1.ChallengeMetadata" as const,

  encode(message: ChallengeMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.fido2Challenge !== undefined) {
      FIDO2ChallengeData.encode(message.fido2Challenge, writer.uint32(10).fork()).join();
    }
    if (message.otpInfo !== undefined) {
      OTPChallengeInfo.encode(message.otpInfo, writer.uint32(18).fork()).join();
    }
    if (message.clientInfo !== undefined) {
      ClientInfo.encode(message.clientInfo, writer.uint32(26).fork()).join();
    }
    if (message.hardwareKeyChallenge !== undefined) {
      HardwareKeyChallenge.encode(message.hardwareKeyChallenge, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChallengeMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.fido2Challenge = FIDO2ChallengeData.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.otpInfo = OTPChallengeInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.clientInfo = ClientInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.hardwareKeyChallenge = HardwareKeyChallenge.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeMetadata {
    return {
      fido2Challenge: isSet(object.fido2_challenge) ? FIDO2ChallengeData.fromJSON(object.fido2_challenge) : undefined,
      otpInfo: isSet(object.otp_info) ? OTPChallengeInfo.fromJSON(object.otp_info) : undefined,
      clientInfo: isSet(object.client_info) ? ClientInfo.fromJSON(object.client_info) : undefined,
      hardwareKeyChallenge: isSet(object.hardware_key_challenge)
        ? HardwareKeyChallenge.fromJSON(object.hardware_key_challenge)
        : undefined,
    };
  },

  toJSON(message: ChallengeMetadata): unknown {
    const obj: any = {};
    if (message.fido2Challenge !== undefined) {
      obj.fido2_challenge = FIDO2ChallengeData.toJSON(message.fido2Challenge);
    }
    if (message.otpInfo !== undefined) {
      obj.otp_info = OTPChallengeInfo.toJSON(message.otpInfo);
    }
    if (message.clientInfo !== undefined) {
      obj.client_info = ClientInfo.toJSON(message.clientInfo);
    }
    if (message.hardwareKeyChallenge !== undefined) {
      obj.hardware_key_challenge = HardwareKeyChallenge.toJSON(message.hardwareKeyChallenge);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ChallengeMetadata>): ChallengeMetadata {
    const message = createBaseChallengeMetadata();
    message.fido2Challenge = (object.fido2Challenge !== undefined && object.fido2Challenge !== null)
      ? FIDO2ChallengeData.fromPartial(object.fido2Challenge)
      : undefined;
    message.otpInfo = (object.otpInfo !== undefined && object.otpInfo !== null)
      ? OTPChallengeInfo.fromPartial(object.otpInfo)
      : undefined;
    message.clientInfo = (object.clientInfo !== undefined && object.clientInfo !== null)
      ? ClientInfo.fromPartial(object.clientInfo)
      : undefined;
    message.hardwareKeyChallenge = (object.hardwareKeyChallenge !== undefined && object.hardwareKeyChallenge !== null)
      ? HardwareKeyChallenge.fromPartial(object.hardwareKeyChallenge)
      : undefined;
    return message;
  },
};

function createBaseFIDO2ChallengeData(): FIDO2ChallengeData {
  return { challenge: new Uint8Array(0), relyingPartyId: "", allowedCredentials: [], userVerification: "" };
}

export const FIDO2ChallengeData: MessageFns<FIDO2ChallengeData, "virtengine.mfa.v1.FIDO2ChallengeData"> = {
  $type: "virtengine.mfa.v1.FIDO2ChallengeData" as const,

  encode(message: FIDO2ChallengeData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.challenge.length !== 0) {
      writer.uint32(10).bytes(message.challenge);
    }
    if (message.relyingPartyId !== "") {
      writer.uint32(18).string(message.relyingPartyId);
    }
    for (const v of message.allowedCredentials) {
      writer.uint32(26).bytes(v!);
    }
    if (message.userVerification !== "") {
      writer.uint32(34).string(message.userVerification);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FIDO2ChallengeData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFIDO2ChallengeData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.challenge = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.relyingPartyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowedCredentials.push(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userVerification = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FIDO2ChallengeData {
    return {
      challenge: isSet(object.challenge) ? bytesFromBase64(object.challenge) : new Uint8Array(0),
      relyingPartyId: isSet(object.relying_party_id) ? globalThis.String(object.relying_party_id) : "",
      allowedCredentials: globalThis.Array.isArray(object?.allowed_credentials)
        ? object.allowed_credentials.map((e: any) => bytesFromBase64(e))
        : [],
      userVerification: isSet(object.user_verification) ? globalThis.String(object.user_verification) : "",
    };
  },

  toJSON(message: FIDO2ChallengeData): unknown {
    const obj: any = {};
    if (message.challenge.length !== 0) {
      obj.challenge = base64FromBytes(message.challenge);
    }
    if (message.relyingPartyId !== "") {
      obj.relying_party_id = message.relyingPartyId;
    }
    if (message.allowedCredentials?.length) {
      obj.allowed_credentials = message.allowedCredentials.map((e) => base64FromBytes(e));
    }
    if (message.userVerification !== "") {
      obj.user_verification = message.userVerification;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FIDO2ChallengeData>): FIDO2ChallengeData {
    const message = createBaseFIDO2ChallengeData();
    message.challenge = object.challenge ?? new Uint8Array(0);
    message.relyingPartyId = object.relyingPartyId ?? "";
    message.allowedCredentials = object.allowedCredentials?.map((e) => e) || [];
    message.userVerification = object.userVerification ?? "";
    return message;
  },
};

function createBaseOTPChallengeInfo(): OTPChallengeInfo {
  return {
    deliveryMethod: "",
    deliveryDestinationMasked: "",
    sentAt: Long.ZERO,
    resendCount: 0,
    lastResendAt: Long.ZERO,
  };
}

export const OTPChallengeInfo: MessageFns<OTPChallengeInfo, "virtengine.mfa.v1.OTPChallengeInfo"> = {
  $type: "virtengine.mfa.v1.OTPChallengeInfo" as const,

  encode(message: OTPChallengeInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deliveryMethod !== "") {
      writer.uint32(10).string(message.deliveryMethod);
    }
    if (message.deliveryDestinationMasked !== "") {
      writer.uint32(18).string(message.deliveryDestinationMasked);
    }
    if (!message.sentAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.sentAt.toString());
    }
    if (message.resendCount !== 0) {
      writer.uint32(32).uint32(message.resendCount);
    }
    if (!message.lastResendAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.lastResendAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OTPChallengeInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOTPChallengeInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.deliveryMethod = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deliveryDestinationMasked = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sentAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.resendCount = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.lastResendAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OTPChallengeInfo {
    return {
      deliveryMethod: isSet(object.delivery_method) ? globalThis.String(object.delivery_method) : "",
      deliveryDestinationMasked: isSet(object.delivery_destination_masked)
        ? globalThis.String(object.delivery_destination_masked)
        : "",
      sentAt: isSet(object.sent_at) ? Long.fromValue(object.sent_at) : Long.ZERO,
      resendCount: isSet(object.resend_count) ? globalThis.Number(object.resend_count) : 0,
      lastResendAt: isSet(object.last_resend_at) ? Long.fromValue(object.last_resend_at) : Long.ZERO,
    };
  },

  toJSON(message: OTPChallengeInfo): unknown {
    const obj: any = {};
    if (message.deliveryMethod !== "") {
      obj.delivery_method = message.deliveryMethod;
    }
    if (message.deliveryDestinationMasked !== "") {
      obj.delivery_destination_masked = message.deliveryDestinationMasked;
    }
    if (!message.sentAt.equals(Long.ZERO)) {
      obj.sent_at = (message.sentAt || Long.ZERO).toString();
    }
    if (message.resendCount !== 0) {
      obj.resend_count = Math.round(message.resendCount);
    }
    if (!message.lastResendAt.equals(Long.ZERO)) {
      obj.last_resend_at = (message.lastResendAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<OTPChallengeInfo>): OTPChallengeInfo {
    const message = createBaseOTPChallengeInfo();
    message.deliveryMethod = object.deliveryMethod ?? "";
    message.deliveryDestinationMasked = object.deliveryDestinationMasked ?? "";
    message.sentAt = (object.sentAt !== undefined && object.sentAt !== null)
      ? Long.fromValue(object.sentAt)
      : Long.ZERO;
    message.resendCount = object.resendCount ?? 0;
    message.lastResendAt = (object.lastResendAt !== undefined && object.lastResendAt !== null)
      ? Long.fromValue(object.lastResendAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseHardwareKeyChallenge(): HardwareKeyChallenge {
  return { challenge: new Uint8Array(0), keyId: "", nonce: "", createdAt: Long.ZERO };
}

export const HardwareKeyChallenge: MessageFns<HardwareKeyChallenge, "virtengine.mfa.v1.HardwareKeyChallenge"> = {
  $type: "virtengine.mfa.v1.HardwareKeyChallenge" as const,

  encode(message: HardwareKeyChallenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.challenge.length !== 0) {
      writer.uint32(10).bytes(message.challenge);
    }
    if (message.keyId !== "") {
      writer.uint32(18).string(message.keyId);
    }
    if (message.nonce !== "") {
      writer.uint32(26).string(message.nonce);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.createdAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HardwareKeyChallenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHardwareKeyChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.challenge = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.keyId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HardwareKeyChallenge {
    return {
      challenge: isSet(object.challenge) ? bytesFromBase64(object.challenge) : new Uint8Array(0),
      keyId: isSet(object.key_id) ? globalThis.String(object.key_id) : "",
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
    };
  },

  toJSON(message: HardwareKeyChallenge): unknown {
    const obj: any = {};
    if (message.challenge.length !== 0) {
      obj.challenge = base64FromBytes(message.challenge);
    }
    if (message.keyId !== "") {
      obj.key_id = message.keyId;
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<HardwareKeyChallenge>): HardwareKeyChallenge {
    const message = createBaseHardwareKeyChallenge();
    message.challenge = object.challenge ?? new Uint8Array(0);
    message.keyId = object.keyId ?? "";
    message.nonce = object.nonce ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseChallenge(): Challenge {
  return {
    challengeId: "",
    accountAddress: "",
    factorType: 0,
    factorId: "",
    transactionType: 0,
    status: 0,
    challengeData: new Uint8Array(0),
    createdAt: Long.ZERO,
    expiresAt: Long.ZERO,
    verifiedAt: Long.ZERO,
    attemptCount: 0,
    maxAttempts: 0,
    nonce: "",
    sessionId: "",
    metadata: undefined,
  };
}

export const Challenge: MessageFns<Challenge, "virtengine.mfa.v1.Challenge"> = {
  $type: "virtengine.mfa.v1.Challenge" as const,

  encode(message: Challenge, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.challengeId !== "") {
      writer.uint32(10).string(message.challengeId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.factorType !== 0) {
      writer.uint32(24).int32(message.factorType);
    }
    if (message.factorId !== "") {
      writer.uint32(34).string(message.factorId);
    }
    if (message.transactionType !== 0) {
      writer.uint32(40).int32(message.transactionType);
    }
    if (message.status !== 0) {
      writer.uint32(48).int32(message.status);
    }
    if (message.challengeData.length !== 0) {
      writer.uint32(58).bytes(message.challengeData);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.createdAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.expiresAt.toString());
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.verifiedAt.toString());
    }
    if (message.attemptCount !== 0) {
      writer.uint32(88).uint32(message.attemptCount);
    }
    if (message.maxAttempts !== 0) {
      writer.uint32(96).uint32(message.maxAttempts);
    }
    if (message.nonce !== "") {
      writer.uint32(106).string(message.nonce);
    }
    if (message.sessionId !== "") {
      writer.uint32(114).string(message.sessionId);
    }
    if (message.metadata !== undefined) {
      ChallengeMetadata.encode(message.metadata, writer.uint32(122).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Challenge {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallenge();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.challengeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.factorType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.factorId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.challengeData = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.verifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.attemptCount = reader.uint32();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.maxAttempts = reader.uint32();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.nonce = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.metadata = ChallengeMetadata.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Challenge {
    return {
      challengeId: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      factorType: isSet(object.factor_type) ? factorTypeFromJSON(object.factor_type) : 0,
      factorId: isSet(object.factor_id) ? globalThis.String(object.factor_id) : "",
      transactionType: isSet(object.transaction_type) ? sensitiveTransactionTypeFromJSON(object.transaction_type) : 0,
      status: isSet(object.status) ? challengeStatusFromJSON(object.status) : 0,
      challengeData: isSet(object.challenge_data) ? bytesFromBase64(object.challenge_data) : new Uint8Array(0),
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      verifiedAt: isSet(object.verified_at) ? Long.fromValue(object.verified_at) : Long.ZERO,
      attemptCount: isSet(object.attempt_count) ? globalThis.Number(object.attempt_count) : 0,
      maxAttempts: isSet(object.max_attempts) ? globalThis.Number(object.max_attempts) : 0,
      nonce: isSet(object.nonce) ? globalThis.String(object.nonce) : "",
      sessionId: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      metadata: isSet(object.metadata) ? ChallengeMetadata.fromJSON(object.metadata) : undefined,
    };
  },

  toJSON(message: Challenge): unknown {
    const obj: any = {};
    if (message.challengeId !== "") {
      obj.challenge_id = message.challengeId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.factorType !== 0) {
      obj.factor_type = factorTypeToJSON(message.factorType);
    }
    if (message.factorId !== "") {
      obj.factor_id = message.factorId;
    }
    if (message.transactionType !== 0) {
      obj.transaction_type = sensitiveTransactionTypeToJSON(message.transactionType);
    }
    if (message.status !== 0) {
      obj.status = challengeStatusToJSON(message.status);
    }
    if (message.challengeData.length !== 0) {
      obj.challenge_data = base64FromBytes(message.challengeData);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (!message.verifiedAt.equals(Long.ZERO)) {
      obj.verified_at = (message.verifiedAt || Long.ZERO).toString();
    }
    if (message.attemptCount !== 0) {
      obj.attempt_count = Math.round(message.attemptCount);
    }
    if (message.maxAttempts !== 0) {
      obj.max_attempts = Math.round(message.maxAttempts);
    }
    if (message.nonce !== "") {
      obj.nonce = message.nonce;
    }
    if (message.sessionId !== "") {
      obj.session_id = message.sessionId;
    }
    if (message.metadata !== undefined) {
      obj.metadata = ChallengeMetadata.toJSON(message.metadata);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Challenge>): Challenge {
    const message = createBaseChallenge();
    message.challengeId = object.challengeId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.factorType = object.factorType ?? 0;
    message.factorId = object.factorId ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.status = object.status ?? 0;
    message.challengeData = object.challengeData ?? new Uint8Array(0);
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.verifiedAt = (object.verifiedAt !== undefined && object.verifiedAt !== null)
      ? Long.fromValue(object.verifiedAt)
      : Long.ZERO;
    message.attemptCount = object.attemptCount ?? 0;
    message.maxAttempts = object.maxAttempts ?? 0;
    message.nonce = object.nonce ?? "";
    message.sessionId = object.sessionId ?? "";
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? ChallengeMetadata.fromPartial(object.metadata)
      : undefined;
    return message;
  },
};

function createBaseChallengeResponse(): ChallengeResponse {
  return {
    challengeId: "",
    factorType: 0,
    responseData: new Uint8Array(0),
    clientInfo: undefined,
    timestamp: Long.ZERO,
  };
}

export const ChallengeResponse: MessageFns<ChallengeResponse, "virtengine.mfa.v1.ChallengeResponse"> = {
  $type: "virtengine.mfa.v1.ChallengeResponse" as const,

  encode(message: ChallengeResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.challengeId !== "") {
      writer.uint32(10).string(message.challengeId);
    }
    if (message.factorType !== 0) {
      writer.uint32(16).int32(message.factorType);
    }
    if (message.responseData.length !== 0) {
      writer.uint32(26).bytes(message.responseData);
    }
    if (message.clientInfo !== undefined) {
      ClientInfo.encode(message.clientInfo, writer.uint32(34).fork()).join();
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.timestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChallengeResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChallengeResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.challengeId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.factorType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.responseData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.clientInfo = ClientInfo.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChallengeResponse {
    return {
      challengeId: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "",
      factorType: isSet(object.factor_type) ? factorTypeFromJSON(object.factor_type) : 0,
      responseData: isSet(object.response_data) ? bytesFromBase64(object.response_data) : new Uint8Array(0),
      clientInfo: isSet(object.client_info) ? ClientInfo.fromJSON(object.client_info) : undefined,
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.ZERO,
    };
  },

  toJSON(message: ChallengeResponse): unknown {
    const obj: any = {};
    if (message.challengeId !== "") {
      obj.challenge_id = message.challengeId;
    }
    if (message.factorType !== 0) {
      obj.factor_type = factorTypeToJSON(message.factorType);
    }
    if (message.responseData.length !== 0) {
      obj.response_data = base64FromBytes(message.responseData);
    }
    if (message.clientInfo !== undefined) {
      obj.client_info = ClientInfo.toJSON(message.clientInfo);
    }
    if (!message.timestamp.equals(Long.ZERO)) {
      obj.timestamp = (message.timestamp || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ChallengeResponse>): ChallengeResponse {
    const message = createBaseChallengeResponse();
    message.challengeId = object.challengeId ?? "";
    message.factorType = object.factorType ?? 0;
    message.responseData = object.responseData ?? new Uint8Array(0);
    message.clientInfo = (object.clientInfo !== undefined && object.clientInfo !== null)
      ? ClientInfo.fromPartial(object.clientInfo)
      : undefined;
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.ZERO;
    return message;
  },
};

function createBaseAuthorizationSession(): AuthorizationSession {
  return {
    sessionId: "",
    accountAddress: "",
    transactionType: 0,
    verifiedFactors: [],
    createdAt: Long.ZERO,
    expiresAt: Long.ZERO,
    usedAt: Long.ZERO,
    isSingleUse: false,
    deviceFingerprint: "",
  };
}

export const AuthorizationSession: MessageFns<AuthorizationSession, "virtengine.mfa.v1.AuthorizationSession"> = {
  $type: "virtengine.mfa.v1.AuthorizationSession" as const,

  encode(message: AuthorizationSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.accountAddress !== "") {
      writer.uint32(18).string(message.accountAddress);
    }
    if (message.transactionType !== 0) {
      writer.uint32(24).int32(message.transactionType);
    }
    for (const v of message.verifiedFactors) {
      writer.uint32(32).int32(v!);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.createdAt.toString());
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.expiresAt.toString());
    }
    if (!message.usedAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.usedAt.toString());
    }
    if (message.isSingleUse !== false) {
      writer.uint32(64).bool(message.isSingleUse);
    }
    if (message.deviceFingerprint !== "") {
      writer.uint32(74).string(message.deviceFingerprint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthorizationSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthorizationSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag === 32) {
            message.verifiedFactors.push(reader.int32() as any);

            continue;
          }

          if (tag === 34) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.verifiedFactors.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.usedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isSingleUse = reader.bool();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.deviceFingerprint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthorizationSession {
    return {
      sessionId: isSet(object.session_id) ? globalThis.String(object.session_id) : "",
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      transactionType: isSet(object.transaction_type) ? sensitiveTransactionTypeFromJSON(object.transaction_type) : 0,
      verifiedFactors: globalThis.Array.isArray(object?.verified_factors)
        ? object.verified_factors.map((e: any) => factorTypeFromJSON(e))
        : [],
      createdAt: isSet(object.created_at) ? Long.fromValue(object.created_at) : Long.ZERO,
      expiresAt: isSet(object.expires_at) ? Long.fromValue(object.expires_at) : Long.ZERO,
      usedAt: isSet(object.used_at) ? Long.fromValue(object.used_at) : Long.ZERO,
      isSingleUse: isSet(object.is_single_use) ? globalThis.Boolean(object.is_single_use) : false,
      deviceFingerprint: isSet(object.device_fingerprint) ? globalThis.String(object.device_fingerprint) : "",
    };
  },

  toJSON(message: AuthorizationSession): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.session_id = message.sessionId;
    }
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.transactionType !== 0) {
      obj.transaction_type = sensitiveTransactionTypeToJSON(message.transactionType);
    }
    if (message.verifiedFactors?.length) {
      obj.verified_factors = message.verifiedFactors.map((e) => factorTypeToJSON(e));
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.created_at = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expires_at = (message.expiresAt || Long.ZERO).toString();
    }
    if (!message.usedAt.equals(Long.ZERO)) {
      obj.used_at = (message.usedAt || Long.ZERO).toString();
    }
    if (message.isSingleUse !== false) {
      obj.is_single_use = message.isSingleUse;
    }
    if (message.deviceFingerprint !== "") {
      obj.device_fingerprint = message.deviceFingerprint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<AuthorizationSession>): AuthorizationSession {
    const message = createBaseAuthorizationSession();
    message.sessionId = object.sessionId ?? "";
    message.accountAddress = object.accountAddress ?? "";
    message.transactionType = object.transactionType ?? 0;
    message.verifiedFactors = object.verifiedFactors?.map((e) => e) || [];
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    message.usedAt = (object.usedAt !== undefined && object.usedAt !== null)
      ? Long.fromValue(object.usedAt)
      : Long.ZERO;
    message.isSingleUse = object.isSingleUse ?? false;
    message.deviceFingerprint = object.deviceFingerprint ?? "";
    return message;
  },
};

function createBaseTrustedDevice(): TrustedDevice {
  return { accountAddress: "", deviceInfo: undefined, addedAt: Long.ZERO, lastUsedAt: Long.ZERO };
}

export const TrustedDevice: MessageFns<TrustedDevice, "virtengine.mfa.v1.TrustedDevice"> = {
  $type: "virtengine.mfa.v1.TrustedDevice" as const,

  encode(message: TrustedDevice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.deviceInfo !== undefined) {
      DeviceInfo.encode(message.deviceInfo, writer.uint32(18).fork()).join();
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.addedAt.toString());
    }
    if (!message.lastUsedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.lastUsedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrustedDevice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrustedDevice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.deviceInfo = DeviceInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.addedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.lastUsedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrustedDevice {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      deviceInfo: isSet(object.device_info) ? DeviceInfo.fromJSON(object.device_info) : undefined,
      addedAt: isSet(object.added_at) ? Long.fromValue(object.added_at) : Long.ZERO,
      lastUsedAt: isSet(object.last_used_at) ? Long.fromValue(object.last_used_at) : Long.ZERO,
    };
  },

  toJSON(message: TrustedDevice): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.deviceInfo !== undefined) {
      obj.device_info = DeviceInfo.toJSON(message.deviceInfo);
    }
    if (!message.addedAt.equals(Long.ZERO)) {
      obj.added_at = (message.addedAt || Long.ZERO).toString();
    }
    if (!message.lastUsedAt.equals(Long.ZERO)) {
      obj.last_used_at = (message.lastUsedAt || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<TrustedDevice>): TrustedDevice {
    const message = createBaseTrustedDevice();
    message.accountAddress = object.accountAddress ?? "";
    message.deviceInfo = (object.deviceInfo !== undefined && object.deviceInfo !== null)
      ? DeviceInfo.fromPartial(object.deviceInfo)
      : undefined;
    message.addedAt = (object.addedAt !== undefined && object.addedAt !== null)
      ? Long.fromValue(object.addedAt)
      : Long.ZERO;
    message.lastUsedAt = (object.lastUsedAt !== undefined && object.lastUsedAt !== null)
      ? Long.fromValue(object.lastUsedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseSensitiveTxConfig(): SensitiveTxConfig {
  return {
    transactionType: 0,
    enabled: false,
    minVeidScore: 0,
    requiredFactorCombinations: [],
    sessionDuration: Long.ZERO,
    isSingleUse: false,
    allowTrustedDeviceReduction: false,
    valueThreshold: "",
    cooldownPeriod: Long.ZERO,
    description: "",
  };
}

export const SensitiveTxConfig: MessageFns<SensitiveTxConfig, "virtengine.mfa.v1.SensitiveTxConfig"> = {
  $type: "virtengine.mfa.v1.SensitiveTxConfig" as const,

  encode(message: SensitiveTxConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transactionType !== 0) {
      writer.uint32(8).int32(message.transactionType);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    if (message.minVeidScore !== 0) {
      writer.uint32(24).uint32(message.minVeidScore);
    }
    for (const v of message.requiredFactorCombinations) {
      FactorCombination.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.sessionDuration.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.sessionDuration.toString());
    }
    if (message.isSingleUse !== false) {
      writer.uint32(48).bool(message.isSingleUse);
    }
    if (message.allowTrustedDeviceReduction !== false) {
      writer.uint32(56).bool(message.allowTrustedDeviceReduction);
    }
    if (message.valueThreshold !== "") {
      writer.uint32(66).string(message.valueThreshold);
    }
    if (!message.cooldownPeriod.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.cooldownPeriod.toString());
    }
    if (message.description !== "") {
      writer.uint32(82).string(message.description);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SensitiveTxConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSensitiveTxConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.transactionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.minVeidScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.requiredFactorCombinations.push(FactorCombination.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sessionDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isSingleUse = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.allowTrustedDeviceReduction = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.valueThreshold = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.cooldownPeriod = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.description = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SensitiveTxConfig {
    return {
      transactionType: isSet(object.transaction_type) ? sensitiveTransactionTypeFromJSON(object.transaction_type) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      minVeidScore: isSet(object.min_veid_score) ? globalThis.Number(object.min_veid_score) : 0,
      requiredFactorCombinations: globalThis.Array.isArray(object?.required_factor_combinations)
        ? object.required_factor_combinations.map((e: any) => FactorCombination.fromJSON(e))
        : [],
      sessionDuration: isSet(object.session_duration) ? Long.fromValue(object.session_duration) : Long.ZERO,
      isSingleUse: isSet(object.is_single_use) ? globalThis.Boolean(object.is_single_use) : false,
      allowTrustedDeviceReduction: isSet(object.allow_trusted_device_reduction)
        ? globalThis.Boolean(object.allow_trusted_device_reduction)
        : false,
      valueThreshold: isSet(object.value_threshold) ? globalThis.String(object.value_threshold) : "",
      cooldownPeriod: isSet(object.cooldown_period) ? Long.fromValue(object.cooldown_period) : Long.ZERO,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
    };
  },

  toJSON(message: SensitiveTxConfig): unknown {
    const obj: any = {};
    if (message.transactionType !== 0) {
      obj.transaction_type = sensitiveTransactionTypeToJSON(message.transactionType);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.minVeidScore !== 0) {
      obj.min_veid_score = Math.round(message.minVeidScore);
    }
    if (message.requiredFactorCombinations?.length) {
      obj.required_factor_combinations = message.requiredFactorCombinations.map((e) => FactorCombination.toJSON(e));
    }
    if (!message.sessionDuration.equals(Long.ZERO)) {
      obj.session_duration = (message.sessionDuration || Long.ZERO).toString();
    }
    if (message.isSingleUse !== false) {
      obj.is_single_use = message.isSingleUse;
    }
    if (message.allowTrustedDeviceReduction !== false) {
      obj.allow_trusted_device_reduction = message.allowTrustedDeviceReduction;
    }
    if (message.valueThreshold !== "") {
      obj.value_threshold = message.valueThreshold;
    }
    if (!message.cooldownPeriod.equals(Long.ZERO)) {
      obj.cooldown_period = (message.cooldownPeriod || Long.ZERO).toString();
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<SensitiveTxConfig>): SensitiveTxConfig {
    const message = createBaseSensitiveTxConfig();
    message.transactionType = object.transactionType ?? 0;
    message.enabled = object.enabled ?? false;
    message.minVeidScore = object.minVeidScore ?? 0;
    message.requiredFactorCombinations =
      object.requiredFactorCombinations?.map((e) => FactorCombination.fromPartial(e)) || [];
    message.sessionDuration = (object.sessionDuration !== undefined && object.sessionDuration !== null)
      ? Long.fromValue(object.sessionDuration)
      : Long.ZERO;
    message.isSingleUse = object.isSingleUse ?? false;
    message.allowTrustedDeviceReduction = object.allowTrustedDeviceReduction ?? false;
    message.valueThreshold = object.valueThreshold ?? "";
    message.cooldownPeriod = (object.cooldownPeriod !== undefined && object.cooldownPeriod !== null)
      ? Long.fromValue(object.cooldownPeriod)
      : Long.ZERO;
    message.description = object.description ?? "";
    return message;
  },
};

function createBaseParams(): Params {
  return {
    defaultSessionDuration: Long.ZERO,
    maxFactorsPerAccount: 0,
    maxChallengeAttempts: 0,
    challengeTtl: Long.ZERO,
    maxTrustedDevices: 0,
    trustedDeviceTtl: Long.ZERO,
    minVeidScoreForMfa: 0,
    requireAtLeastOneFactor: false,
    allowedFactorTypes: [],
  };
}

export const Params: MessageFns<Params, "virtengine.mfa.v1.Params"> = {
  $type: "virtengine.mfa.v1.Params" as const,

  encode(message: Params, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.defaultSessionDuration.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.defaultSessionDuration.toString());
    }
    if (message.maxFactorsPerAccount !== 0) {
      writer.uint32(16).uint32(message.maxFactorsPerAccount);
    }
    if (message.maxChallengeAttempts !== 0) {
      writer.uint32(24).uint32(message.maxChallengeAttempts);
    }
    if (!message.challengeTtl.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.challengeTtl.toString());
    }
    if (message.maxTrustedDevices !== 0) {
      writer.uint32(40).uint32(message.maxTrustedDevices);
    }
    if (!message.trustedDeviceTtl.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.trustedDeviceTtl.toString());
    }
    if (message.minVeidScoreForMfa !== 0) {
      writer.uint32(56).uint32(message.minVeidScoreForMfa);
    }
    if (message.requireAtLeastOneFactor !== false) {
      writer.uint32(64).bool(message.requireAtLeastOneFactor);
    }
    for (const v of message.allowedFactorTypes) {
      writer.uint32(72).int32(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Params {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.defaultSessionDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.maxFactorsPerAccount = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxChallengeAttempts = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.challengeTtl = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.maxTrustedDevices = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.trustedDeviceTtl = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minVeidScoreForMfa = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.requireAtLeastOneFactor = reader.bool();
          continue;
        }
        case 9: {
          if (tag === 72) {
            message.allowedFactorTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 74) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.allowedFactorTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Params {
    return {
      defaultSessionDuration: isSet(object.default_session_duration)
        ? Long.fromValue(object.default_session_duration)
        : Long.ZERO,
      maxFactorsPerAccount: isSet(object.max_factors_per_account)
        ? globalThis.Number(object.max_factors_per_account)
        : 0,
      maxChallengeAttempts: isSet(object.max_challenge_attempts) ? globalThis.Number(object.max_challenge_attempts) : 0,
      challengeTtl: isSet(object.challenge_ttl) ? Long.fromValue(object.challenge_ttl) : Long.ZERO,
      maxTrustedDevices: isSet(object.max_trusted_devices) ? globalThis.Number(object.max_trusted_devices) : 0,
      trustedDeviceTtl: isSet(object.trusted_device_ttl) ? Long.fromValue(object.trusted_device_ttl) : Long.ZERO,
      minVeidScoreForMfa: isSet(object.min_veid_score_for_mfa) ? globalThis.Number(object.min_veid_score_for_mfa) : 0,
      requireAtLeastOneFactor: isSet(object.require_at_least_one_factor)
        ? globalThis.Boolean(object.require_at_least_one_factor)
        : false,
      allowedFactorTypes: globalThis.Array.isArray(object?.allowed_factor_types)
        ? object.allowed_factor_types.map((e: any) => factorTypeFromJSON(e))
        : [],
    };
  },

  toJSON(message: Params): unknown {
    const obj: any = {};
    if (!message.defaultSessionDuration.equals(Long.ZERO)) {
      obj.default_session_duration = (message.defaultSessionDuration || Long.ZERO).toString();
    }
    if (message.maxFactorsPerAccount !== 0) {
      obj.max_factors_per_account = Math.round(message.maxFactorsPerAccount);
    }
    if (message.maxChallengeAttempts !== 0) {
      obj.max_challenge_attempts = Math.round(message.maxChallengeAttempts);
    }
    if (!message.challengeTtl.equals(Long.ZERO)) {
      obj.challenge_ttl = (message.challengeTtl || Long.ZERO).toString();
    }
    if (message.maxTrustedDevices !== 0) {
      obj.max_trusted_devices = Math.round(message.maxTrustedDevices);
    }
    if (!message.trustedDeviceTtl.equals(Long.ZERO)) {
      obj.trusted_device_ttl = (message.trustedDeviceTtl || Long.ZERO).toString();
    }
    if (message.minVeidScoreForMfa !== 0) {
      obj.min_veid_score_for_mfa = Math.round(message.minVeidScoreForMfa);
    }
    if (message.requireAtLeastOneFactor !== false) {
      obj.require_at_least_one_factor = message.requireAtLeastOneFactor;
    }
    if (message.allowedFactorTypes?.length) {
      obj.allowed_factor_types = message.allowedFactorTypes.map((e) => factorTypeToJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Params>): Params {
    const message = createBaseParams();
    message.defaultSessionDuration =
      (object.defaultSessionDuration !== undefined && object.defaultSessionDuration !== null)
        ? Long.fromValue(object.defaultSessionDuration)
        : Long.ZERO;
    message.maxFactorsPerAccount = object.maxFactorsPerAccount ?? 0;
    message.maxChallengeAttempts = object.maxChallengeAttempts ?? 0;
    message.challengeTtl = (object.challengeTtl !== undefined && object.challengeTtl !== null)
      ? Long.fromValue(object.challengeTtl)
      : Long.ZERO;
    message.maxTrustedDevices = object.maxTrustedDevices ?? 0;
    message.trustedDeviceTtl = (object.trustedDeviceTtl !== undefined && object.trustedDeviceTtl !== null)
      ? Long.fromValue(object.trustedDeviceTtl)
      : Long.ZERO;
    message.minVeidScoreForMfa = object.minVeidScoreForMfa ?? 0;
    message.requireAtLeastOneFactor = object.requireAtLeastOneFactor ?? false;
    message.allowedFactorTypes = object.allowedFactorTypes?.map((e) => e) || [];
    return message;
  },
};

function createBaseEventFactorEnrolled(): EventFactorEnrolled {
  return { accountAddress: "", factorType: "", factorId: "" };
}

export const EventFactorEnrolled: MessageFns<EventFactorEnrolled, "virtengine.mfa.v1.EventFactorEnrolled"> = {
  $type: "virtengine.mfa.v1.EventFactorEnrolled" as const,

  encode(message: EventFactorEnrolled, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.factorType !== "") {
      writer.uint32(18).string(message.factorType);
    }
    if (message.factorId !== "") {
      writer.uint32(26).string(message.factorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFactorEnrolled {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFactorEnrolled();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.factorType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFactorEnrolled {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      factorType: isSet(object.factor_type) ? globalThis.String(object.factor_type) : "",
      factorId: isSet(object.factor_id) ? globalThis.String(object.factor_id) : "",
    };
  },

  toJSON(message: EventFactorEnrolled): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.factorType !== "") {
      obj.factor_type = message.factorType;
    }
    if (message.factorId !== "") {
      obj.factor_id = message.factorId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventFactorEnrolled>): EventFactorEnrolled {
    const message = createBaseEventFactorEnrolled();
    message.accountAddress = object.accountAddress ?? "";
    message.factorType = object.factorType ?? "";
    message.factorId = object.factorId ?? "";
    return message;
  },
};

function createBaseEventFactorRevoked(): EventFactorRevoked {
  return { accountAddress: "", factorType: "", factorId: "" };
}

export const EventFactorRevoked: MessageFns<EventFactorRevoked, "virtengine.mfa.v1.EventFactorRevoked"> = {
  $type: "virtengine.mfa.v1.EventFactorRevoked" as const,

  encode(message: EventFactorRevoked, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.factorType !== "") {
      writer.uint32(18).string(message.factorType);
    }
    if (message.factorId !== "") {
      writer.uint32(26).string(message.factorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventFactorRevoked {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventFactorRevoked();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.factorType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventFactorRevoked {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      factorType: isSet(object.factor_type) ? globalThis.String(object.factor_type) : "",
      factorId: isSet(object.factor_id) ? globalThis.String(object.factor_id) : "",
    };
  },

  toJSON(message: EventFactorRevoked): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.factorType !== "") {
      obj.factor_type = message.factorType;
    }
    if (message.factorId !== "") {
      obj.factor_id = message.factorId;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventFactorRevoked>): EventFactorRevoked {
    const message = createBaseEventFactorRevoked();
    message.accountAddress = object.accountAddress ?? "";
    message.factorType = object.factorType ?? "";
    message.factorId = object.factorId ?? "";
    return message;
  },
};

function createBaseEventChallengeVerified(): EventChallengeVerified {
  return { accountAddress: "", challengeId: "", factorType: "", transactionType: "" };
}

export const EventChallengeVerified: MessageFns<EventChallengeVerified, "virtengine.mfa.v1.EventChallengeVerified"> = {
  $type: "virtengine.mfa.v1.EventChallengeVerified" as const,

  encode(message: EventChallengeVerified, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.challengeId !== "") {
      writer.uint32(18).string(message.challengeId);
    }
    if (message.factorType !== "") {
      writer.uint32(26).string(message.factorType);
    }
    if (message.transactionType !== "") {
      writer.uint32(34).string(message.transactionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventChallengeVerified {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventChallengeVerified();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.challengeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.factorType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.transactionType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventChallengeVerified {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      challengeId: isSet(object.challenge_id) ? globalThis.String(object.challenge_id) : "",
      factorType: isSet(object.factor_type) ? globalThis.String(object.factor_type) : "",
      transactionType: isSet(object.transaction_type) ? globalThis.String(object.transaction_type) : "",
    };
  },

  toJSON(message: EventChallengeVerified): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.challengeId !== "") {
      obj.challenge_id = message.challengeId;
    }
    if (message.factorType !== "") {
      obj.factor_type = message.factorType;
    }
    if (message.transactionType !== "") {
      obj.transaction_type = message.transactionType;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventChallengeVerified>): EventChallengeVerified {
    const message = createBaseEventChallengeVerified();
    message.accountAddress = object.accountAddress ?? "";
    message.challengeId = object.challengeId ?? "";
    message.factorType = object.factorType ?? "";
    message.transactionType = object.transactionType ?? "";
    return message;
  },
};

function createBaseEventMFAPolicyUpdated(): EventMFAPolicyUpdated {
  return { accountAddress: "", enabled: false };
}

export const EventMFAPolicyUpdated: MessageFns<EventMFAPolicyUpdated, "virtengine.mfa.v1.EventMFAPolicyUpdated"> = {
  $type: "virtengine.mfa.v1.EventMFAPolicyUpdated" as const,

  encode(message: EventMFAPolicyUpdated, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.accountAddress !== "") {
      writer.uint32(10).string(message.accountAddress);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EventMFAPolicyUpdated {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEventMFAPolicyUpdated();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.accountAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EventMFAPolicyUpdated {
    return {
      accountAddress: isSet(object.account_address) ? globalThis.String(object.account_address) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: EventMFAPolicyUpdated): unknown {
    const obj: any = {};
    if (message.accountAddress !== "") {
      obj.account_address = message.accountAddress;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EventMFAPolicyUpdated>): EventMFAPolicyUpdated {
    const message = createBaseEventMFAPolicyUpdated();
    message.accountAddress = object.accountAddress ?? "";
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
