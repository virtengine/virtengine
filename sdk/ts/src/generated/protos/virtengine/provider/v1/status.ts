import { toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isObject, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/provider/v1/status.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";
import { Quantity } from "../../../k8s.io/apimachinery/pkg/api/resource/generated.ts";
import { Cluster } from "../../inventory/v1/cluster.ts";

/** ResourceMetrics */
export interface ResourcesMetric {
  cpu: Quantity | undefined;
  memory: Quantity | undefined;
  gpu: Quantity | undefined;
  ephemeralStorage: Quantity | undefined;
  storage: { [key: string]: Quantity };
}

export interface ResourcesMetric_StorageEntry {
  key: string;
  value: Quantity | undefined;
}

/** Leases */
export interface Leases {
  active: number;
}

/** ReservationsMetric */
export interface ReservationsMetric {
  count: number;
  resources: ResourcesMetric | undefined;
}

/** Reservations */
export interface Reservations {
  pending: ReservationsMetric | undefined;
  active: ReservationsMetric | undefined;
}

/** Inventory */
export interface Inventory {
  cluster: Cluster | undefined;
  reservations: Reservations | undefined;
}

/** ClusterStatus */
export interface ClusterStatus {
  leases: Leases | undefined;
  inventory: Inventory | undefined;
}

/** BidEngineStatus */
export interface BidEngineStatus {
  orders: number;
}

/** ManifestStatus */
export interface ManifestStatus {
  deployments: number;
}

/** Status */
export interface Status {
  errors: string[];
  cluster: ClusterStatus | undefined;
  bidEngine: BidEngineStatus | undefined;
  manifest: ManifestStatus | undefined;
  publicHostnames: string[];
  timestamp: Date | undefined;
}

function createBaseResourcesMetric(): ResourcesMetric {
  return { cpu: undefined, memory: undefined, gpu: undefined, ephemeralStorage: undefined, storage: {} };
}

export const ResourcesMetric: MessageFns<ResourcesMetric, "virtengine.provider.v1.ResourcesMetric"> = {
  $type: "virtengine.provider.v1.ResourcesMetric" as const,

  encode(message: ResourcesMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cpu !== undefined) {
      Quantity.encode(message.cpu, writer.uint32(10).fork()).join();
    }
    if (message.memory !== undefined) {
      Quantity.encode(message.memory, writer.uint32(18).fork()).join();
    }
    if (message.gpu !== undefined) {
      Quantity.encode(message.gpu, writer.uint32(26).fork()).join();
    }
    if (message.ephemeralStorage !== undefined) {
      Quantity.encode(message.ephemeralStorage, writer.uint32(34).fork()).join();
    }
    Object.entries(message.storage).forEach(([key, value]) => {
      ResourcesMetric_StorageEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourcesMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcesMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cpu = Quantity.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memory = Quantity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.gpu = Quantity.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.ephemeralStorage = Quantity.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = ResourcesMetric_StorageEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.storage[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcesMetric {
    return {
      cpu: isSet(object.cpu) ? Quantity.fromJSON(object.cpu) : undefined,
      memory: isSet(object.memory) ? Quantity.fromJSON(object.memory) : undefined,
      gpu: isSet(object.gpu) ? Quantity.fromJSON(object.gpu) : undefined,
      ephemeralStorage: isSet(object.ephemeral_storage) ? Quantity.fromJSON(object.ephemeral_storage) : undefined,
      storage: isObject(object.storage)
        ? Object.entries(object.storage).reduce<{ [key: string]: Quantity }>((acc, [key, value]) => {
          acc[key] = Quantity.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ResourcesMetric): unknown {
    const obj: any = {};
    if (message.cpu !== undefined) {
      obj.cpu = Quantity.toJSON(message.cpu);
    }
    if (message.memory !== undefined) {
      obj.memory = Quantity.toJSON(message.memory);
    }
    if (message.gpu !== undefined) {
      obj.gpu = Quantity.toJSON(message.gpu);
    }
    if (message.ephemeralStorage !== undefined) {
      obj.ephemeral_storage = Quantity.toJSON(message.ephemeralStorage);
    }
    if (message.storage) {
      const entries = Object.entries(message.storage);
      if (entries.length > 0) {
        obj.storage = {};
        entries.forEach(([k, v]) => {
          obj.storage[k] = Quantity.toJSON(v);
        });
      }
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ResourcesMetric>): ResourcesMetric {
    const message = createBaseResourcesMetric();
    message.cpu = (object.cpu !== undefined && object.cpu !== null) ? Quantity.fromPartial(object.cpu) : undefined;
    message.memory = (object.memory !== undefined && object.memory !== null)
      ? Quantity.fromPartial(object.memory)
      : undefined;
    message.gpu = (object.gpu !== undefined && object.gpu !== null) ? Quantity.fromPartial(object.gpu) : undefined;
    message.ephemeralStorage = (object.ephemeralStorage !== undefined && object.ephemeralStorage !== null)
      ? Quantity.fromPartial(object.ephemeralStorage)
      : undefined;
    message.storage = Object.entries(object.storage ?? {}).reduce<{ [key: string]: Quantity }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = Quantity.fromPartial(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseResourcesMetric_StorageEntry(): ResourcesMetric_StorageEntry {
  return { key: "", value: undefined };
}

export const ResourcesMetric_StorageEntry: MessageFns<
  ResourcesMetric_StorageEntry,
  "virtengine.provider.v1.ResourcesMetric.StorageEntry"
> = {
  $type: "virtengine.provider.v1.ResourcesMetric.StorageEntry" as const,

  encode(message: ResourcesMetric_StorageEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      Quantity.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResourcesMetric_StorageEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResourcesMetric_StorageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = Quantity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResourcesMetric_StorageEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? Quantity.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ResourcesMetric_StorageEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = Quantity.toJSON(message.value);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ResourcesMetric_StorageEntry>): ResourcesMetric_StorageEntry {
    const message = createBaseResourcesMetric_StorageEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? Quantity.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseLeases(): Leases {
  return { active: 0 };
}

export const Leases: MessageFns<Leases, "virtengine.provider.v1.Leases"> = {
  $type: "virtengine.provider.v1.Leases" as const,

  encode(message: Leases, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.active !== 0) {
      writer.uint32(8).uint32(message.active);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Leases {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeases();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.active = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Leases {
    return { active: isSet(object.active) ? globalThis.Number(object.active) : 0 };
  },

  toJSON(message: Leases): unknown {
    const obj: any = {};
    if (message.active !== 0) {
      obj.active = Math.round(message.active);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Leases>): Leases {
    const message = createBaseLeases();
    message.active = object.active ?? 0;
    return message;
  },
};

function createBaseReservationsMetric(): ReservationsMetric {
  return { count: 0, resources: undefined };
}

export const ReservationsMetric: MessageFns<ReservationsMetric, "virtengine.provider.v1.ReservationsMetric"> = {
  $type: "virtengine.provider.v1.ReservationsMetric" as const,

  encode(message: ReservationsMetric, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.count !== 0) {
      writer.uint32(8).uint32(message.count);
    }
    if (message.resources !== undefined) {
      ResourcesMetric.encode(message.resources, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReservationsMetric {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservationsMetric();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.count = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.resources = ResourcesMetric.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReservationsMetric {
    return {
      count: isSet(object.count) ? globalThis.Number(object.count) : 0,
      resources: isSet(object.resources) ? ResourcesMetric.fromJSON(object.resources) : undefined,
    };
  },

  toJSON(message: ReservationsMetric): unknown {
    const obj: any = {};
    if (message.count !== 0) {
      obj.count = Math.round(message.count);
    }
    if (message.resources !== undefined) {
      obj.resources = ResourcesMetric.toJSON(message.resources);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ReservationsMetric>): ReservationsMetric {
    const message = createBaseReservationsMetric();
    message.count = object.count ?? 0;
    message.resources = (object.resources !== undefined && object.resources !== null)
      ? ResourcesMetric.fromPartial(object.resources)
      : undefined;
    return message;
  },
};

function createBaseReservations(): Reservations {
  return { pending: undefined, active: undefined };
}

export const Reservations: MessageFns<Reservations, "virtengine.provider.v1.Reservations"> = {
  $type: "virtengine.provider.v1.Reservations" as const,

  encode(message: Reservations, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.pending !== undefined) {
      ReservationsMetric.encode(message.pending, writer.uint32(10).fork()).join();
    }
    if (message.active !== undefined) {
      ReservationsMetric.encode(message.active, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Reservations {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReservations();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.pending = ReservationsMetric.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.active = ReservationsMetric.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Reservations {
    return {
      pending: isSet(object.pending) ? ReservationsMetric.fromJSON(object.pending) : undefined,
      active: isSet(object.active) ? ReservationsMetric.fromJSON(object.active) : undefined,
    };
  },

  toJSON(message: Reservations): unknown {
    const obj: any = {};
    if (message.pending !== undefined) {
      obj.pending = ReservationsMetric.toJSON(message.pending);
    }
    if (message.active !== undefined) {
      obj.active = ReservationsMetric.toJSON(message.active);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Reservations>): Reservations {
    const message = createBaseReservations();
    message.pending = (object.pending !== undefined && object.pending !== null)
      ? ReservationsMetric.fromPartial(object.pending)
      : undefined;
    message.active = (object.active !== undefined && object.active !== null)
      ? ReservationsMetric.fromPartial(object.active)
      : undefined;
    return message;
  },
};

function createBaseInventory(): Inventory {
  return { cluster: undefined, reservations: undefined };
}

export const Inventory: MessageFns<Inventory, "virtengine.provider.v1.Inventory"> = {
  $type: "virtengine.provider.v1.Inventory" as const,

  encode(message: Inventory, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cluster !== undefined) {
      Cluster.encode(message.cluster, writer.uint32(10).fork()).join();
    }
    if (message.reservations !== undefined) {
      Reservations.encode(message.reservations, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Inventory {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInventory();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cluster = Cluster.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reservations = Reservations.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Inventory {
    return {
      cluster: isSet(object.cluster) ? Cluster.fromJSON(object.cluster) : undefined,
      reservations: isSet(object.reservations) ? Reservations.fromJSON(object.reservations) : undefined,
    };
  },

  toJSON(message: Inventory): unknown {
    const obj: any = {};
    if (message.cluster !== undefined) {
      obj.cluster = Cluster.toJSON(message.cluster);
    }
    if (message.reservations !== undefined) {
      obj.reservations = Reservations.toJSON(message.reservations);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Inventory>): Inventory {
    const message = createBaseInventory();
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? Cluster.fromPartial(object.cluster)
      : undefined;
    message.reservations = (object.reservations !== undefined && object.reservations !== null)
      ? Reservations.fromPartial(object.reservations)
      : undefined;
    return message;
  },
};

function createBaseClusterStatus(): ClusterStatus {
  return { leases: undefined, inventory: undefined };
}

export const ClusterStatus: MessageFns<ClusterStatus, "virtengine.provider.v1.ClusterStatus"> = {
  $type: "virtengine.provider.v1.ClusterStatus" as const,

  encode(message: ClusterStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.leases !== undefined) {
      Leases.encode(message.leases, writer.uint32(10).fork()).join();
    }
    if (message.inventory !== undefined) {
      Inventory.encode(message.inventory, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClusterStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClusterStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.leases = Leases.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inventory = Inventory.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClusterStatus {
    return {
      leases: isSet(object.leases) ? Leases.fromJSON(object.leases) : undefined,
      inventory: isSet(object.inventory) ? Inventory.fromJSON(object.inventory) : undefined,
    };
  },

  toJSON(message: ClusterStatus): unknown {
    const obj: any = {};
    if (message.leases !== undefined) {
      obj.leases = Leases.toJSON(message.leases);
    }
    if (message.inventory !== undefined) {
      obj.inventory = Inventory.toJSON(message.inventory);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ClusterStatus>): ClusterStatus {
    const message = createBaseClusterStatus();
    message.leases = (object.leases !== undefined && object.leases !== null)
      ? Leases.fromPartial(object.leases)
      : undefined;
    message.inventory = (object.inventory !== undefined && object.inventory !== null)
      ? Inventory.fromPartial(object.inventory)
      : undefined;
    return message;
  },
};

function createBaseBidEngineStatus(): BidEngineStatus {
  return { orders: 0 };
}

export const BidEngineStatus: MessageFns<BidEngineStatus, "virtengine.provider.v1.BidEngineStatus"> = {
  $type: "virtengine.provider.v1.BidEngineStatus" as const,

  encode(message: BidEngineStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.orders !== 0) {
      writer.uint32(8).uint32(message.orders);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BidEngineStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBidEngineStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.orders = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BidEngineStatus {
    return { orders: isSet(object.orders) ? globalThis.Number(object.orders) : 0 };
  },

  toJSON(message: BidEngineStatus): unknown {
    const obj: any = {};
    if (message.orders !== 0) {
      obj.orders = Math.round(message.orders);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<BidEngineStatus>): BidEngineStatus {
    const message = createBaseBidEngineStatus();
    message.orders = object.orders ?? 0;
    return message;
  },
};

function createBaseManifestStatus(): ManifestStatus {
  return { deployments: 0 };
}

export const ManifestStatus: MessageFns<ManifestStatus, "virtengine.provider.v1.ManifestStatus"> = {
  $type: "virtengine.provider.v1.ManifestStatus" as const,

  encode(message: ManifestStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.deployments !== 0) {
      writer.uint32(8).uint32(message.deployments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ManifestStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseManifestStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.deployments = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ManifestStatus {
    return { deployments: isSet(object.deployments) ? globalThis.Number(object.deployments) : 0 };
  },

  toJSON(message: ManifestStatus): unknown {
    const obj: any = {};
    if (message.deployments !== 0) {
      obj.deployments = Math.round(message.deployments);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ManifestStatus>): ManifestStatus {
    const message = createBaseManifestStatus();
    message.deployments = object.deployments ?? 0;
    return message;
  },
};

function createBaseStatus(): Status {
  return {
    errors: [],
    cluster: undefined,
    bidEngine: undefined,
    manifest: undefined,
    publicHostnames: [],
    timestamp: undefined,
  };
}

export const Status: MessageFns<Status, "virtengine.provider.v1.Status"> = {
  $type: "virtengine.provider.v1.Status" as const,

  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      writer.uint32(10).string(v!);
    }
    if (message.cluster !== undefined) {
      ClusterStatus.encode(message.cluster, writer.uint32(18).fork()).join();
    }
    if (message.bidEngine !== undefined) {
      BidEngineStatus.encode(message.bidEngine, writer.uint32(26).fork()).join();
    }
    if (message.manifest !== undefined) {
      ManifestStatus.encode(message.manifest, writer.uint32(34).fork()).join();
    }
    for (const v of message.publicHostnames) {
      writer.uint32(42).string(v!);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cluster = ClusterStatus.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.bidEngine = BidEngineStatus.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.manifest = ManifestStatus.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.publicHostnames.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      errors: globalThis.Array.isArray(object?.errors) ? object.errors.map((e: any) => globalThis.String(e)) : [],
      cluster: isSet(object.cluster) ? ClusterStatus.fromJSON(object.cluster) : undefined,
      bidEngine: isSet(object.bid_engine) ? BidEngineStatus.fromJSON(object.bid_engine) : undefined,
      manifest: isSet(object.manifest) ? ManifestStatus.fromJSON(object.manifest) : undefined,
      publicHostnames: globalThis.Array.isArray(object?.public_hostnames)
        ? object.public_hostnames.map((e: any) => globalThis.String(e))
        : [],
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors;
    }
    if (message.cluster !== undefined) {
      obj.cluster = ClusterStatus.toJSON(message.cluster);
    }
    if (message.bidEngine !== undefined) {
      obj.bid_engine = BidEngineStatus.toJSON(message.bidEngine);
    }
    if (message.manifest !== undefined) {
      obj.manifest = ManifestStatus.toJSON(message.manifest);
    }
    if (message.publicHostnames?.length) {
      obj.public_hostnames = message.publicHostnames;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Status>): Status {
    const message = createBaseStatus();
    message.errors = object.errors?.map((e) => e) || [];
    message.cluster = (object.cluster !== undefined && object.cluster !== null)
      ? ClusterStatus.fromPartial(object.cluster)
      : undefined;
    message.bidEngine = (object.bidEngine !== undefined && object.bidEngine !== null)
      ? BidEngineStatus.fromPartial(object.bidEngine)
      : undefined;
    message.manifest = (object.manifest !== undefined && object.manifest !== null)
      ? ManifestStatus.fromPartial(object.manifest)
      : undefined;
    message.publicHostnames = object.publicHostnames?.map((e) => e) || [];
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
