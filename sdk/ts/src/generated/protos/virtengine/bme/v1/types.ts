import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/bme/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin.ts";

/** MintStatus indicates the current state of mint */
export enum MintStatus {
  /** mint_status_unspecified - MINT_STATUS_UNSPECIFIED is the default value */
  mint_status_unspecified = 0,
  /** mint_status_healthy - MINT_STATUS_HEALTHY indicates normal operation (CR > warn threshold) */
  mint_status_healthy = 1,
  /** mint_status_warning - MINT_STATUS_WARNING indicates CR is below warning threshold */
  mint_status_warning = 2,
  /** mint_status_halt_cr - MINT_STATUS_HALT_CR indicates CR is below halt threshold, mints paused */
  mint_status_halt_cr = 3,
  /** mint_status_halt_oracle - MINT_STATUS_HALT_ORACLE indicates circuit breaker tripped due to unhealthy oracle price */
  mint_status_halt_oracle = 4,
  UNRECOGNIZED = -1,
}

export function mintStatusFromJSON(object: any): MintStatus {
  switch (object) {
    case 0:
    case "mint_status_unspecified":
      return MintStatus.mint_status_unspecified;
    case 1:
    case "mint_status_healthy":
      return MintStatus.mint_status_healthy;
    case 2:
    case "mint_status_warning":
      return MintStatus.mint_status_warning;
    case 3:
    case "mint_status_halt_cr":
      return MintStatus.mint_status_halt_cr;
    case 4:
    case "mint_status_halt_oracle":
      return MintStatus.mint_status_halt_oracle;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MintStatus.UNRECOGNIZED;
  }
}

export function mintStatusToJSON(object: MintStatus): string {
  switch (object) {
    case MintStatus.mint_status_unspecified:
      return "mint_status_unspecified";
    case MintStatus.mint_status_healthy:
      return "mint_status_healthy";
    case MintStatus.mint_status_warning:
      return "mint_status_warning";
    case MintStatus.mint_status_halt_cr:
      return "mint_status_halt_cr";
    case MintStatus.mint_status_halt_oracle:
      return "mint_status_halt_oracle";
    case MintStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LedgerRecordStatus indicates the current state of a burn/mint ledger record */
export enum LedgerRecordStatus {
  /**
   * ledger_record_status_invalid - LEDGER_RECORD_STATUS_INVALID is the default/uninitialized value
   * This status should never appear in a valid ledger record
   */
  ledger_record_status_invalid = 0,
  /**
   * ledger_record_status_pending - LEDGER_RECORD_STATUS_PENDING indicates a burn/mint operation has been initiated
   * but not yet executed (e.g., waiting for oracle price or circuit breaker clearance)
   */
  ledger_record_status_pending = 1,
  /**
   * ledger_record_status_executed - LEDGER_RECORD_STATUS_EXECUTED indicates the burn/mint operation has been
   * successfully completed and tokens have been burned and minted
   */
  ledger_record_status_executed = 2,
  UNRECOGNIZED = -1,
}

export function ledgerRecordStatusFromJSON(object: any): LedgerRecordStatus {
  switch (object) {
    case 0:
    case "ledger_record_status_invalid":
      return LedgerRecordStatus.ledger_record_status_invalid;
    case 1:
    case "ledger_record_status_pending":
      return LedgerRecordStatus.ledger_record_status_pending;
    case 2:
    case "ledger_record_status_executed":
      return LedgerRecordStatus.ledger_record_status_executed;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LedgerRecordStatus.UNRECOGNIZED;
  }
}

export function ledgerRecordStatusToJSON(object: LedgerRecordStatus): string {
  switch (object) {
    case LedgerRecordStatus.ledger_record_status_invalid:
      return "ledger_record_status_invalid";
    case LedgerRecordStatus.ledger_record_status_pending:
      return "ledger_record_status_pending";
    case LedgerRecordStatus.ledger_record_status_executed:
      return "ledger_record_status_executed";
    case LedgerRecordStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** LedgerID uniquely identifies a ledger entry by block height and sequence number */
export interface LedgerID {
  /** height is the block height when the ledger entry was created */
  height: Long;
  /** sequence is the sequence number within the block (for ordering) */
  sequence: Long;
}

/** CollateralRatio represents the current collateral ratio */
export interface CollateralRatio {
  /** ratio is CR = (VaultAKT * Price) / OutstandingACT */
  ratio: string;
  /** status indicates the current circuit breaker status */
  status: MintStatus;
  /** reference_price is the price used to calculate CR */
  referencePrice: string;
}

/** State tracks net burn metrics since BME start */
export interface State {
  /** burned is the cumulative burn for tracked tokens */
  balances: Coin[];
  /** burned is the cumulative burn for tracked tokens */
  totalBurned: Coin[];
  /** minted is the cumulative mint back for tracked tokens */
  totalMinted: Coin[];
  /**
   * remint_credits tracks available credits for reminting tokens
   * (e.g., from previous burns that can be reminted without additional collateral)
   */
  remintCredits: Coin[];
}

/** CoinPrice represents a coin amount with its associated oracle price at a specific point in time */
export interface CoinPrice {
  /** coin is the token amount */
  coin:
    | Coin
    | undefined;
  /** price (at oracle) of the coin at burn/mint event */
  price: string;
}

/** BurnMintPair represents a pair of burn and mint operations with their respective prices */
export interface BurnMintPair {
  /** burned is the coin burned */
  burned:
    | CoinPrice
    | undefined;
  /** minted is coin minted */
  minted: CoinPrice | undefined;
}

/** LedgerRecordID */
export interface LedgerRecordID {
  /** denom is the asset denomination */
  denom: string;
  /** to_denom is what denom swap to */
  toDenom: string;
  source: string;
  height: Long;
  sequence: Long;
}

/** LedgerPendingRecord */
export interface LedgerPendingRecord {
  /** owner source of the coins to be burned */
  owner: string;
  /**
   * to destination of the minted coins.
   * if minted coin is ACT, "to" must be same as signer
   */
  to: string;
  /** coins_to_burn */
  coinsToBurn:
    | Coin
    | undefined;
  /** denom_to_mint */
  denomToMint: string;
}

/** LedgerRecord stores information of burn/mint event of token A burn to mint token B */
export interface LedgerRecord {
  /** burned_from source address of the tokens burned */
  burnedFrom: string;
  /** minted_to destination address of the tokens minted */
  mintedTo: string;
  /** module is module account performing burn */
  burner: string;
  /** module is module account performing mint */
  minter: string;
  /** burned is the coin burned at price */
  burned:
    | CoinPrice
    | undefined;
  /** minted is coin minted at price */
  minted: CoinPrice | undefined;
  remintCreditIssued: CoinPrice | undefined;
  remintCreditAccrued: CoinPrice | undefined;
}

/** Status stores status of mint operations */
export interface Status {
  status: MintStatus;
  previousStatus: MintStatus;
  epochHeightDiff: Long;
}

/** MintEpoch stores information about mint epoch */
export interface MintEpoch {
  nextEpoch: Long;
}

function createBaseLedgerID(): LedgerID {
  return { height: Long.ZERO, sequence: Long.ZERO };
}

export const LedgerID: MessageFns<LedgerID, "virtengine.bme.v1.LedgerID"> = {
  $type: "virtengine.bme.v1.LedgerID" as const,

  encode(message: LedgerID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.height.toString());
    }
    if (!message.sequence.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.sequence.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.sequence = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerID {
    return {
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
      sequence: isSet(object.sequence) ? Long.fromValue(object.sequence) : Long.ZERO,
    };
  },

  toJSON(message: LedgerID): unknown {
    const obj: any = {};
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    if (!message.sequence.equals(Long.ZERO)) {
      obj.sequence = (message.sequence || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<LedgerID>): LedgerID {
    const message = createBaseLedgerID();
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    message.sequence = (object.sequence !== undefined && object.sequence !== null)
      ? Long.fromValue(object.sequence)
      : Long.ZERO;
    return message;
  },
};

function createBaseCollateralRatio(): CollateralRatio {
  return { ratio: "", status: 0, referencePrice: "" };
}

export const CollateralRatio: MessageFns<CollateralRatio, "virtengine.bme.v1.CollateralRatio"> = {
  $type: "virtengine.bme.v1.CollateralRatio" as const,

  encode(message: CollateralRatio, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.ratio !== "") {
      writer.uint32(10).string(message.ratio);
    }
    if (message.status !== 0) {
      writer.uint32(16).int32(message.status);
    }
    if (message.referencePrice !== "") {
      writer.uint32(26).string(message.referencePrice);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CollateralRatio {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollateralRatio();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.ratio = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.referencePrice = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CollateralRatio {
    return {
      ratio: isSet(object.ratio) ? globalThis.String(object.ratio) : "",
      status: isSet(object.status) ? mintStatusFromJSON(object.status) : 0,
      referencePrice: isSet(object.reference_price) ? globalThis.String(object.reference_price) : "",
    };
  },

  toJSON(message: CollateralRatio): unknown {
    const obj: any = {};
    if (message.ratio !== "") {
      obj.ratio = message.ratio;
    }
    if (message.status !== 0) {
      obj.status = mintStatusToJSON(message.status);
    }
    if (message.referencePrice !== "") {
      obj.reference_price = message.referencePrice;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<CollateralRatio>): CollateralRatio {
    const message = createBaseCollateralRatio();
    message.ratio = object.ratio ?? "";
    message.status = object.status ?? 0;
    message.referencePrice = object.referencePrice ?? "";
    return message;
  },
};

function createBaseState(): State {
  return { balances: [], totalBurned: [], totalMinted: [], remintCredits: [] };
}

export const State: MessageFns<State, "virtengine.bme.v1.State"> = {
  $type: "virtengine.bme.v1.State" as const,

  encode(message: State, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.balances) {
      Coin.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.totalBurned) {
      Coin.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.totalMinted) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.remintCredits) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): State {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balances.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.totalBurned.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalMinted.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remintCredits.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): State {
    return {
      balances: globalThis.Array.isArray(object?.balances) ? object.balances.map((e: any) => Coin.fromJSON(e)) : [],
      totalBurned: globalThis.Array.isArray(object?.total_burned)
        ? object.total_burned.map((e: any) => Coin.fromJSON(e))
        : [],
      totalMinted: globalThis.Array.isArray(object?.total_minted)
        ? object.total_minted.map((e: any) => Coin.fromJSON(e))
        : [],
      remintCredits: globalThis.Array.isArray(object?.remint_credits)
        ? object.remint_credits.map((e: any) => Coin.fromJSON(e))
        : [],
    };
  },

  toJSON(message: State): unknown {
    const obj: any = {};
    if (message.balances?.length) {
      obj.balances = message.balances.map((e) => Coin.toJSON(e));
    }
    if (message.totalBurned?.length) {
      obj.total_burned = message.totalBurned.map((e) => Coin.toJSON(e));
    }
    if (message.totalMinted?.length) {
      obj.total_minted = message.totalMinted.map((e) => Coin.toJSON(e));
    }
    if (message.remintCredits?.length) {
      obj.remint_credits = message.remintCredits.map((e) => Coin.toJSON(e));
    }
    return obj;
  },
  fromPartial(object: DeepPartial<State>): State {
    const message = createBaseState();
    message.balances = object.balances?.map((e) => Coin.fromPartial(e)) || [];
    message.totalBurned = object.totalBurned?.map((e) => Coin.fromPartial(e)) || [];
    message.totalMinted = object.totalMinted?.map((e) => Coin.fromPartial(e)) || [];
    message.remintCredits = object.remintCredits?.map((e) => Coin.fromPartial(e)) || [];
    return message;
  },
};

function createBaseCoinPrice(): CoinPrice {
  return { coin: undefined, price: "" };
}

export const CoinPrice: MessageFns<CoinPrice, "virtengine.bme.v1.CoinPrice"> = {
  $type: "virtengine.bme.v1.CoinPrice" as const,

  encode(message: CoinPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.coin !== undefined) {
      Coin.encode(message.coin, writer.uint32(10).fork()).join();
    }
    if (message.price !== "") {
      writer.uint32(18).string(message.price);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CoinPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCoinPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.coin = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.price = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CoinPrice {
    return {
      coin: isSet(object.coin) ? Coin.fromJSON(object.coin) : undefined,
      price: isSet(object.price) ? globalThis.String(object.price) : "",
    };
  },

  toJSON(message: CoinPrice): unknown {
    const obj: any = {};
    if (message.coin !== undefined) {
      obj.coin = Coin.toJSON(message.coin);
    }
    if (message.price !== "") {
      obj.price = message.price;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<CoinPrice>): CoinPrice {
    const message = createBaseCoinPrice();
    message.coin = (object.coin !== undefined && object.coin !== null) ? Coin.fromPartial(object.coin) : undefined;
    message.price = object.price ?? "";
    return message;
  },
};

function createBaseBurnMintPair(): BurnMintPair {
  return { burned: undefined, minted: undefined };
}

export const BurnMintPair: MessageFns<BurnMintPair, "virtengine.bme.v1.BurnMintPair"> = {
  $type: "virtengine.bme.v1.BurnMintPair" as const,

  encode(message: BurnMintPair, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.burned !== undefined) {
      CoinPrice.encode(message.burned, writer.uint32(10).fork()).join();
    }
    if (message.minted !== undefined) {
      CoinPrice.encode(message.minted, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BurnMintPair {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBurnMintPair();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.burned = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.minted = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BurnMintPair {
    return {
      burned: isSet(object.burned) ? CoinPrice.fromJSON(object.burned) : undefined,
      minted: isSet(object.minted) ? CoinPrice.fromJSON(object.minted) : undefined,
    };
  },

  toJSON(message: BurnMintPair): unknown {
    const obj: any = {};
    if (message.burned !== undefined) {
      obj.burned = CoinPrice.toJSON(message.burned);
    }
    if (message.minted !== undefined) {
      obj.minted = CoinPrice.toJSON(message.minted);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<BurnMintPair>): BurnMintPair {
    const message = createBaseBurnMintPair();
    message.burned = (object.burned !== undefined && object.burned !== null)
      ? CoinPrice.fromPartial(object.burned)
      : undefined;
    message.minted = (object.minted !== undefined && object.minted !== null)
      ? CoinPrice.fromPartial(object.minted)
      : undefined;
    return message;
  },
};

function createBaseLedgerRecordID(): LedgerRecordID {
  return { denom: "", toDenom: "", source: "", height: Long.ZERO, sequence: Long.ZERO };
}

export const LedgerRecordID: MessageFns<LedgerRecordID, "virtengine.bme.v1.LedgerRecordID"> = {
  $type: "virtengine.bme.v1.LedgerRecordID" as const,

  encode(message: LedgerRecordID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.toDenom !== "") {
      writer.uint32(18).string(message.toDenom);
    }
    if (message.source !== "") {
      writer.uint32(26).string(message.source);
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.height.toString());
    }
    if (!message.sequence.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.sequence.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerRecordID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerRecordID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.toDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.source = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.sequence = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerRecordID {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      toDenom: isSet(object.to_denom) ? globalThis.String(object.to_denom) : "",
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
      sequence: isSet(object.sequence) ? Long.fromValue(object.sequence) : Long.ZERO,
    };
  },

  toJSON(message: LedgerRecordID): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.toDenom !== "") {
      obj.to_denom = message.toDenom;
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    if (!message.sequence.equals(Long.ZERO)) {
      obj.sequence = (message.sequence || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<LedgerRecordID>): LedgerRecordID {
    const message = createBaseLedgerRecordID();
    message.denom = object.denom ?? "";
    message.toDenom = object.toDenom ?? "";
    message.source = object.source ?? "";
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    message.sequence = (object.sequence !== undefined && object.sequence !== null)
      ? Long.fromValue(object.sequence)
      : Long.ZERO;
    return message;
  },
};

function createBaseLedgerPendingRecord(): LedgerPendingRecord {
  return { owner: "", to: "", coinsToBurn: undefined, denomToMint: "" };
}

export const LedgerPendingRecord: MessageFns<LedgerPendingRecord, "virtengine.bme.v1.LedgerPendingRecord"> = {
  $type: "virtengine.bme.v1.LedgerPendingRecord" as const,

  encode(message: LedgerPendingRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.owner !== "") {
      writer.uint32(10).string(message.owner);
    }
    if (message.to !== "") {
      writer.uint32(18).string(message.to);
    }
    if (message.coinsToBurn !== undefined) {
      Coin.encode(message.coinsToBurn, writer.uint32(26).fork()).join();
    }
    if (message.denomToMint !== "") {
      writer.uint32(34).string(message.denomToMint);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerPendingRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerPendingRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.to = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.coinsToBurn = Coin.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.denomToMint = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerPendingRecord {
    return {
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      to: isSet(object.to) ? globalThis.String(object.to) : "",
      coinsToBurn: isSet(object.coins_to_burn) ? Coin.fromJSON(object.coins_to_burn) : undefined,
      denomToMint: isSet(object.denom_to_mint) ? globalThis.String(object.denom_to_mint) : "",
    };
  },

  toJSON(message: LedgerPendingRecord): unknown {
    const obj: any = {};
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.to !== "") {
      obj.to = message.to;
    }
    if (message.coinsToBurn !== undefined) {
      obj.coins_to_burn = Coin.toJSON(message.coinsToBurn);
    }
    if (message.denomToMint !== "") {
      obj.denom_to_mint = message.denomToMint;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<LedgerPendingRecord>): LedgerPendingRecord {
    const message = createBaseLedgerPendingRecord();
    message.owner = object.owner ?? "";
    message.to = object.to ?? "";
    message.coinsToBurn = (object.coinsToBurn !== undefined && object.coinsToBurn !== null)
      ? Coin.fromPartial(object.coinsToBurn)
      : undefined;
    message.denomToMint = object.denomToMint ?? "";
    return message;
  },
};

function createBaseLedgerRecord(): LedgerRecord {
  return {
    burnedFrom: "",
    mintedTo: "",
    burner: "",
    minter: "",
    burned: undefined,
    minted: undefined,
    remintCreditIssued: undefined,
    remintCreditAccrued: undefined,
  };
}

export const LedgerRecord: MessageFns<LedgerRecord, "virtengine.bme.v1.LedgerRecord"> = {
  $type: "virtengine.bme.v1.LedgerRecord" as const,

  encode(message: LedgerRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.burnedFrom !== "") {
      writer.uint32(10).string(message.burnedFrom);
    }
    if (message.mintedTo !== "") {
      writer.uint32(18).string(message.mintedTo);
    }
    if (message.burner !== "") {
      writer.uint32(26).string(message.burner);
    }
    if (message.minter !== "") {
      writer.uint32(34).string(message.minter);
    }
    if (message.burned !== undefined) {
      CoinPrice.encode(message.burned, writer.uint32(42).fork()).join();
    }
    if (message.minted !== undefined) {
      CoinPrice.encode(message.minted, writer.uint32(50).fork()).join();
    }
    if (message.remintCreditIssued !== undefined) {
      CoinPrice.encode(message.remintCreditIssued, writer.uint32(58).fork()).join();
    }
    if (message.remintCreditAccrued !== undefined) {
      CoinPrice.encode(message.remintCreditAccrued, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LedgerRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLedgerRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.burnedFrom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mintedTo = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.burner = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minter = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.burned = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.minted = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.remintCreditIssued = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.remintCreditAccrued = CoinPrice.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LedgerRecord {
    return {
      burnedFrom: isSet(object.burned_from) ? globalThis.String(object.burned_from) : "",
      mintedTo: isSet(object.minted_to) ? globalThis.String(object.minted_to) : "",
      burner: isSet(object.burner) ? globalThis.String(object.burner) : "",
      minter: isSet(object.minter) ? globalThis.String(object.minter) : "",
      burned: isSet(object.burned) ? CoinPrice.fromJSON(object.burned) : undefined,
      minted: isSet(object.minted) ? CoinPrice.fromJSON(object.minted) : undefined,
      remintCreditIssued: isSet(object.remint_credit_issued)
        ? CoinPrice.fromJSON(object.remint_credit_issued)
        : undefined,
      remintCreditAccrued: isSet(object.remint_credit_accrued)
        ? CoinPrice.fromJSON(object.remint_credit_accrued)
        : undefined,
    };
  },

  toJSON(message: LedgerRecord): unknown {
    const obj: any = {};
    if (message.burnedFrom !== "") {
      obj.burned_from = message.burnedFrom;
    }
    if (message.mintedTo !== "") {
      obj.minted_to = message.mintedTo;
    }
    if (message.burner !== "") {
      obj.burner = message.burner;
    }
    if (message.minter !== "") {
      obj.minter = message.minter;
    }
    if (message.burned !== undefined) {
      obj.burned = CoinPrice.toJSON(message.burned);
    }
    if (message.minted !== undefined) {
      obj.minted = CoinPrice.toJSON(message.minted);
    }
    if (message.remintCreditIssued !== undefined) {
      obj.remint_credit_issued = CoinPrice.toJSON(message.remintCreditIssued);
    }
    if (message.remintCreditAccrued !== undefined) {
      obj.remint_credit_accrued = CoinPrice.toJSON(message.remintCreditAccrued);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<LedgerRecord>): LedgerRecord {
    const message = createBaseLedgerRecord();
    message.burnedFrom = object.burnedFrom ?? "";
    message.mintedTo = object.mintedTo ?? "";
    message.burner = object.burner ?? "";
    message.minter = object.minter ?? "";
    message.burned = (object.burned !== undefined && object.burned !== null)
      ? CoinPrice.fromPartial(object.burned)
      : undefined;
    message.minted = (object.minted !== undefined && object.minted !== null)
      ? CoinPrice.fromPartial(object.minted)
      : undefined;
    message.remintCreditIssued = (object.remintCreditIssued !== undefined && object.remintCreditIssued !== null)
      ? CoinPrice.fromPartial(object.remintCreditIssued)
      : undefined;
    message.remintCreditAccrued = (object.remintCreditAccrued !== undefined && object.remintCreditAccrued !== null)
      ? CoinPrice.fromPartial(object.remintCreditAccrued)
      : undefined;
    return message;
  },
};

function createBaseStatus(): Status {
  return { status: 0, previousStatus: 0, epochHeightDiff: Long.ZERO };
}

export const Status: MessageFns<Status, "virtengine.bme.v1.Status"> = {
  $type: "virtengine.bme.v1.Status" as const,

  encode(message: Status, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.status !== 0) {
      writer.uint32(8).int32(message.status);
    }
    if (message.previousStatus !== 0) {
      writer.uint32(16).int32(message.previousStatus);
    }
    if (!message.epochHeightDiff.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.epochHeightDiff.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Status {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.previousStatus = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.epochHeightDiff = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Status {
    return {
      status: isSet(object.status) ? mintStatusFromJSON(object.status) : 0,
      previousStatus: isSet(object.previous_status) ? mintStatusFromJSON(object.previous_status) : 0,
      epochHeightDiff: isSet(object.epoch_height_diff) ? Long.fromValue(object.epoch_height_diff) : Long.ZERO,
    };
  },

  toJSON(message: Status): unknown {
    const obj: any = {};
    if (message.status !== 0) {
      obj.status = mintStatusToJSON(message.status);
    }
    if (message.previousStatus !== 0) {
      obj.previous_status = mintStatusToJSON(message.previousStatus);
    }
    if (!message.epochHeightDiff.equals(Long.ZERO)) {
      obj.epoch_height_diff = (message.epochHeightDiff || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<Status>): Status {
    const message = createBaseStatus();
    message.status = object.status ?? 0;
    message.previousStatus = object.previousStatus ?? 0;
    message.epochHeightDiff = (object.epochHeightDiff !== undefined && object.epochHeightDiff !== null)
      ? Long.fromValue(object.epochHeightDiff)
      : Long.ZERO;
    return message;
  },
};

function createBaseMintEpoch(): MintEpoch {
  return { nextEpoch: Long.ZERO };
}

export const MintEpoch: MessageFns<MintEpoch, "virtengine.bme.v1.MintEpoch"> = {
  $type: "virtengine.bme.v1.MintEpoch" as const,

  encode(message: MintEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.nextEpoch.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.nextEpoch.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MintEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMintEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.nextEpoch = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MintEpoch {
    return { nextEpoch: isSet(object.next_epoch) ? Long.fromValue(object.next_epoch) : Long.ZERO };
  },

  toJSON(message: MintEpoch): unknown {
    const obj: any = {};
    if (!message.nextEpoch.equals(Long.ZERO)) {
      obj.next_epoch = (message.nextEpoch || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MintEpoch>): MintEpoch {
    const message = createBaseMintEpoch();
    message.nextEpoch = (object.nextEpoch !== undefined && object.nextEpoch !== null)
      ? Long.fromValue(object.nextEpoch)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
