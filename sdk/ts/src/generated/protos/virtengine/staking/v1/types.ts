import { toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/staking/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Coin } from "../../../cosmos/base/v1beta1/coin.ts";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** SlashReason indicates the reason for slashing */
export enum SlashReason {
  /** SLASH_REASON_UNSPECIFIED - SLASH_REASON_UNSPECIFIED is the default/invalid reason */
  SLASH_REASON_UNSPECIFIED = 0,
  /** SLASH_REASON_DOUBLE_SIGNING - SLASH_REASON_DOUBLE_SIGNING is for double signing infractions */
  SLASH_REASON_DOUBLE_SIGNING = 1,
  /** SLASH_REASON_DOWNTIME - SLASH_REASON_DOWNTIME is for excessive downtime */
  SLASH_REASON_DOWNTIME = 2,
  /** SLASH_REASON_INVALID_VEID_ATTESTATION - SLASH_REASON_INVALID_VEID_ATTESTATION is for invalid VEID attestations */
  SLASH_REASON_INVALID_VEID_ATTESTATION = 3,
  /** SLASH_REASON_MISSED_RECOMPUTATION - SLASH_REASON_MISSED_RECOMPUTATION is for missing VEID recomputation */
  SLASH_REASON_MISSED_RECOMPUTATION = 4,
  /** SLASH_REASON_INCONSISTENT_SCORE - SLASH_REASON_INCONSISTENT_SCORE is for scores differing from consensus */
  SLASH_REASON_INCONSISTENT_SCORE = 5,
  /** SLASH_REASON_EXPIRED_ATTESTATION - SLASH_REASON_EXPIRED_ATTESTATION is for expired attestation */
  SLASH_REASON_EXPIRED_ATTESTATION = 6,
  /** SLASH_REASON_DEBUG_MODE_ENABLED - SLASH_REASON_DEBUG_MODE_ENABLED is for enclave debug mode */
  SLASH_REASON_DEBUG_MODE_ENABLED = 7,
  /** SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT - SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT is for non-allowlisted enclave measurement */
  SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT = 8,
  UNRECOGNIZED = -1,
}

export function slashReasonFromJSON(object: any): SlashReason {
  switch (object) {
    case 0:
    case "SLASH_REASON_UNSPECIFIED":
      return SlashReason.SLASH_REASON_UNSPECIFIED;
    case 1:
    case "SLASH_REASON_DOUBLE_SIGNING":
      return SlashReason.SLASH_REASON_DOUBLE_SIGNING;
    case 2:
    case "SLASH_REASON_DOWNTIME":
      return SlashReason.SLASH_REASON_DOWNTIME;
    case 3:
    case "SLASH_REASON_INVALID_VEID_ATTESTATION":
      return SlashReason.SLASH_REASON_INVALID_VEID_ATTESTATION;
    case 4:
    case "SLASH_REASON_MISSED_RECOMPUTATION":
      return SlashReason.SLASH_REASON_MISSED_RECOMPUTATION;
    case 5:
    case "SLASH_REASON_INCONSISTENT_SCORE":
      return SlashReason.SLASH_REASON_INCONSISTENT_SCORE;
    case 6:
    case "SLASH_REASON_EXPIRED_ATTESTATION":
      return SlashReason.SLASH_REASON_EXPIRED_ATTESTATION;
    case 7:
    case "SLASH_REASON_DEBUG_MODE_ENABLED":
      return SlashReason.SLASH_REASON_DEBUG_MODE_ENABLED;
    case 8:
    case "SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT":
      return SlashReason.SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SlashReason.UNRECOGNIZED;
  }
}

export function slashReasonToJSON(object: SlashReason): string {
  switch (object) {
    case SlashReason.SLASH_REASON_UNSPECIFIED:
      return "SLASH_REASON_UNSPECIFIED";
    case SlashReason.SLASH_REASON_DOUBLE_SIGNING:
      return "SLASH_REASON_DOUBLE_SIGNING";
    case SlashReason.SLASH_REASON_DOWNTIME:
      return "SLASH_REASON_DOWNTIME";
    case SlashReason.SLASH_REASON_INVALID_VEID_ATTESTATION:
      return "SLASH_REASON_INVALID_VEID_ATTESTATION";
    case SlashReason.SLASH_REASON_MISSED_RECOMPUTATION:
      return "SLASH_REASON_MISSED_RECOMPUTATION";
    case SlashReason.SLASH_REASON_INCONSISTENT_SCORE:
      return "SLASH_REASON_INCONSISTENT_SCORE";
    case SlashReason.SLASH_REASON_EXPIRED_ATTESTATION:
      return "SLASH_REASON_EXPIRED_ATTESTATION";
    case SlashReason.SLASH_REASON_DEBUG_MODE_ENABLED:
      return "SLASH_REASON_DEBUG_MODE_ENABLED";
    case SlashReason.SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT:
      return "SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT";
    case SlashReason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** RewardType indicates the type of reward */
export enum RewardType {
  /** REWARD_TYPE_UNSPECIFIED - REWARD_TYPE_UNSPECIFIED is the default/invalid reward type */
  REWARD_TYPE_UNSPECIFIED = 0,
  /** REWARD_TYPE_BLOCK_PROPOSAL - REWARD_TYPE_BLOCK_PROPOSAL is for block proposal rewards */
  REWARD_TYPE_BLOCK_PROPOSAL = 1,
  /** REWARD_TYPE_VEID_VERIFICATION - REWARD_TYPE_VEID_VERIFICATION is for VEID verification rewards */
  REWARD_TYPE_VEID_VERIFICATION = 2,
  /** REWARD_TYPE_UPTIME - REWARD_TYPE_UPTIME is for uptime-based rewards */
  REWARD_TYPE_UPTIME = 3,
  /** REWARD_TYPE_IDENTITY_NETWORK - REWARD_TYPE_IDENTITY_NETWORK is for identity network participation rewards */
  REWARD_TYPE_IDENTITY_NETWORK = 4,
  /** REWARD_TYPE_STAKING - REWARD_TYPE_STAKING is for base staking rewards */
  REWARD_TYPE_STAKING = 5,
  UNRECOGNIZED = -1,
}

export function rewardTypeFromJSON(object: any): RewardType {
  switch (object) {
    case 0:
    case "REWARD_TYPE_UNSPECIFIED":
      return RewardType.REWARD_TYPE_UNSPECIFIED;
    case 1:
    case "REWARD_TYPE_BLOCK_PROPOSAL":
      return RewardType.REWARD_TYPE_BLOCK_PROPOSAL;
    case 2:
    case "REWARD_TYPE_VEID_VERIFICATION":
      return RewardType.REWARD_TYPE_VEID_VERIFICATION;
    case 3:
    case "REWARD_TYPE_UPTIME":
      return RewardType.REWARD_TYPE_UPTIME;
    case 4:
    case "REWARD_TYPE_IDENTITY_NETWORK":
      return RewardType.REWARD_TYPE_IDENTITY_NETWORK;
    case 5:
    case "REWARD_TYPE_STAKING":
      return RewardType.REWARD_TYPE_STAKING;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RewardType.UNRECOGNIZED;
  }
}

export function rewardTypeToJSON(object: RewardType): string {
  switch (object) {
    case RewardType.REWARD_TYPE_UNSPECIFIED:
      return "REWARD_TYPE_UNSPECIFIED";
    case RewardType.REWARD_TYPE_BLOCK_PROPOSAL:
      return "REWARD_TYPE_BLOCK_PROPOSAL";
    case RewardType.REWARD_TYPE_VEID_VERIFICATION:
      return "REWARD_TYPE_VEID_VERIFICATION";
    case RewardType.REWARD_TYPE_UPTIME:
      return "REWARD_TYPE_UPTIME";
    case RewardType.REWARD_TYPE_IDENTITY_NETWORK:
      return "REWARD_TYPE_IDENTITY_NETWORK";
    case RewardType.REWARD_TYPE_STAKING:
      return "REWARD_TYPE_STAKING";
    case RewardType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ValidatorPerformance represents a validator's performance metrics */
export interface ValidatorPerformance {
  /** ValidatorAddress is the validator's blockchain address */
  validatorAddress: string;
  /** BlocksProposed is the number of blocks proposed in the current epoch */
  blocksProposed: Long;
  /** BlocksExpected is the expected number of blocks based on stake weight */
  blocksExpected: Long;
  /** BlocksMissed is the number of missed blocks (when expected to sign) */
  blocksMissed: Long;
  /** TotalSignatures is the total number of blocks signed */
  totalSignatures: Long;
  /** VEIDVerificationsCompleted is the number of VEID verifications completed */
  veidVerificationsCompleted: Long;
  /** VEIDVerificationsExpected is the expected VEID verifications based on committee selection */
  veidVerificationsExpected: Long;
  /** VEIDVerificationScore is the quality score for VEID verifications (0-10000) */
  veidVerificationScore: Long;
  /** UptimeSeconds is the total uptime in seconds */
  uptimeSeconds: Long;
  /** DowntimeSeconds is the total downtime in seconds */
  downtimeSeconds: Long;
  /** ConsecutiveMissedBlocks is the current streak of missed blocks */
  consecutiveMissedBlocks: Long;
  /** LastProposedHeight is the last height where this validator proposed a block */
  lastProposedHeight: Long;
  /** LastSignedHeight is the last height where this validator signed */
  lastSignedHeight: Long;
  /** EpochNumber is the epoch this performance record belongs to */
  epochNumber: Long;
  /** UpdatedAt is when this record was last updated */
  updatedAt:
    | Date
    | undefined;
  /** OverallScore is the computed overall performance score (0-10000) */
  overallScore: Long;
}

/** ValidatorSigningInfo contains validator signing information for slashing */
export interface ValidatorSigningInfo {
  /** ValidatorAddress is the validator's blockchain address */
  validatorAddress: string;
  /** StartHeight is the height at which validator started signing */
  startHeight: Long;
  /** IndexOffset is the current index offset into the signed blocks window */
  indexOffset: Long;
  /** JailedUntil is the time until which the validator is jailed */
  jailedUntil:
    | Date
    | undefined;
  /** Tombstoned indicates if the validator has been tombstoned (permanently banned) */
  tombstoned: boolean;
  /** MissedBlocksCounter is the counter for missed blocks in the current window */
  missedBlocksCounter: Long;
  /** InfractionCount is the total number of infractions */
  infractionCount: Long;
}

/** RewardEpoch represents a reward epoch */
export interface RewardEpoch {
  /** EpochNumber is the epoch identifier */
  epochNumber: Long;
  /** StartHeight is the starting block height */
  startHeight: Long;
  /** EndHeight is the ending block height */
  endHeight: Long;
  /** StartTime is when the epoch started */
  startTime:
    | Date
    | undefined;
  /** EndTime is when the epoch ended (zero if current) */
  endTime:
    | Date
    | undefined;
  /** TotalRewardsDistributed is the total rewards distributed */
  totalRewardsDistributed: Coin[];
  /** BlockProposalRewards is rewards from block proposals */
  blockProposalRewards: Coin[];
  /** VEIDRewards is rewards from VEID verification work */
  veidRewards: Coin[];
  /** UptimeRewards is rewards from uptime */
  uptimeRewards: Coin[];
  /** ValidatorCount is the number of validators in this epoch */
  validatorCount: Long;
  /** TotalStake is the total stake in this epoch */
  totalStake: string;
  /** Finalized indicates if this epoch is finalized */
  finalized: boolean;
}

/** ValidatorReward represents a validator's rewards for an epoch */
export interface ValidatorReward {
  /** ValidatorAddress is the validator's address */
  validatorAddress: string;
  /** EpochNumber is the epoch this reward belongs to */
  epochNumber: Long;
  /** TotalReward is the total reward amount */
  totalReward: Coin[];
  /** BlockProposalReward is reward from block proposals */
  blockProposalReward: Coin[];
  /** VEIDReward is reward from VEID verification */
  veidReward: Coin[];
  /** UptimeReward is reward from uptime */
  uptimeReward: Coin[];
  /** IdentityNetworkReward is reward from identity network participation */
  identityNetworkReward: Coin[];
  /** PerformanceScore is the performance score used for calculation */
  performanceScore: Long;
  /** StakeWeight is the stake weight used for calculation */
  stakeWeight: string;
  /** CalculatedAt is when the reward was calculated */
  calculatedAt:
    | Date
    | undefined;
  /** BlockHeight is when the reward was recorded */
  blockHeight: Long;
  /** Claimed indicates if the reward has been claimed */
  claimed: boolean;
  /** ClaimedAt is when the reward was claimed */
  claimedAt: Date | undefined;
}

/** SlashRecord represents a slashing record */
export interface SlashRecord {
  /** SlashID is the unique identifier for this slashing event */
  slashId: string;
  /** ValidatorAddress is the validator being slashed */
  validatorAddress: string;
  /** Reason is the reason for slashing */
  reason: SlashReason;
  /** Amount is the amount slashed */
  amount: Coin[];
  /** SlashPercent is the percentage slashed (fixed-point, 1e6 scale) */
  slashPercent: Long;
  /** InfractionHeight is the block height of the infraction */
  infractionHeight: Long;
  /** SlashHeight is the block height when slash was executed */
  slashHeight: Long;
  /** SlashTime is when the slash was executed */
  slashTime:
    | Date
    | undefined;
  /** Jailed indicates if the validator was jailed */
  jailed: boolean;
  /** JailDuration is how long the validator is jailed */
  jailDuration: Long;
  /** JailedUntil is when the jail period ends */
  jailedUntil:
    | Date
    | undefined;
  /** Tombstoned indicates if validator is permanently banned */
  tombstoned: boolean;
  /** Evidence contains the infraction evidence */
  evidence: string;
  /** EvidenceHash is the hash of the evidence */
  evidenceHash: string;
  /** ReporterAddress is who reported the infraction (if any) */
  reporterAddress: string;
}

/** DoubleSignEvidence represents evidence of double signing */
export interface DoubleSignEvidence {
  /** EvidenceID is the unique identifier */
  evidenceId: string;
  /** ValidatorAddress is the validator who double signed */
  validatorAddress: string;
  /** Height1 is the first height of the double sign */
  height1: Long;
  /** Height2 is the second height of the double sign */
  height2: Long;
  /** VoteHash1 is the hash of the first vote */
  voteHash1: string;
  /** VoteHash2 is the hash of the second vote */
  voteHash2: string;
  /** DetectedAt is when the double sign was detected */
  detectedAt:
    | Date
    | undefined;
  /** DetectedHeight is the block height when detected */
  detectedHeight: Long;
  /** Processed indicates if this evidence has been processed */
  processed: boolean;
}

/** InvalidVEIDAttestation represents evidence of invalid VEID attestation */
export interface InvalidVEIDAttestation {
  /** RecordID is the unique identifier */
  recordId: string;
  /** ValidatorAddress is the validator with invalid attestation */
  validatorAddress: string;
  /** AttestationID is the ID of the invalid attestation */
  attestationId: string;
  /** Reason is why the attestation is invalid */
  reason: string;
  /** ExpectedScore is the expected score from consensus */
  expectedScore: Long;
  /** ActualScore is the score the validator reported */
  actualScore: Long;
  /** ScoreDifference is the difference between expected and actual */
  scoreDifference: Long;
  /** DetectedAt is when the issue was detected */
  detectedAt:
    | Date
    | undefined;
  /** DetectedHeight is the block height when detected */
  detectedHeight: Long;
  /** Processed indicates if this evidence has been processed */
  processed: boolean;
}

/** SlashConfig defines the slashing configuration for a reason */
export interface SlashConfig {
  /** Reason is the slash reason */
  reason: SlashReason;
  /** SlashPercent is the base slash percentage (fixed-point, 1e6 scale) */
  slashPercent: Long;
  /** JailDuration is the jail duration in seconds */
  jailDuration: Long;
  /** IsTombstone indicates if this should tombstone the validator */
  isTombstone: boolean;
  /** EscalationMultiplier is the multiplier for repeat offenses */
  escalationMultiplier: Long;
}

function createBaseValidatorPerformance(): ValidatorPerformance {
  return {
    validatorAddress: "",
    blocksProposed: Long.ZERO,
    blocksExpected: Long.ZERO,
    blocksMissed: Long.ZERO,
    totalSignatures: Long.ZERO,
    veidVerificationsCompleted: Long.ZERO,
    veidVerificationsExpected: Long.ZERO,
    veidVerificationScore: Long.ZERO,
    uptimeSeconds: Long.ZERO,
    downtimeSeconds: Long.ZERO,
    consecutiveMissedBlocks: Long.ZERO,
    lastProposedHeight: Long.ZERO,
    lastSignedHeight: Long.ZERO,
    epochNumber: Long.UZERO,
    updatedAt: undefined,
    overallScore: Long.ZERO,
  };
}

export const ValidatorPerformance: MessageFns<ValidatorPerformance, "virtengine.staking.v1.ValidatorPerformance"> = {
  $type: "virtengine.staking.v1.ValidatorPerformance" as const,

  encode(message: ValidatorPerformance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (!message.blocksProposed.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.blocksProposed.toString());
    }
    if (!message.blocksExpected.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.blocksExpected.toString());
    }
    if (!message.blocksMissed.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.blocksMissed.toString());
    }
    if (!message.totalSignatures.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.totalSignatures.toString());
    }
    if (!message.veidVerificationsCompleted.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.veidVerificationsCompleted.toString());
    }
    if (!message.veidVerificationsExpected.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.veidVerificationsExpected.toString());
    }
    if (!message.veidVerificationScore.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.veidVerificationScore.toString());
    }
    if (!message.uptimeSeconds.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.uptimeSeconds.toString());
    }
    if (!message.downtimeSeconds.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.downtimeSeconds.toString());
    }
    if (!message.consecutiveMissedBlocks.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.consecutiveMissedBlocks.toString());
    }
    if (!message.lastProposedHeight.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.lastProposedHeight.toString());
    }
    if (!message.lastSignedHeight.equals(Long.ZERO)) {
      writer.uint32(104).int64(message.lastSignedHeight.toString());
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      writer.uint32(112).uint64(message.epochNumber.toString());
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(122).fork()).join();
    }
    if (!message.overallScore.equals(Long.ZERO)) {
      writer.uint32(128).int64(message.overallScore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorPerformance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorPerformance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.blocksProposed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blocksExpected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blocksMissed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalSignatures = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.veidVerificationsCompleted = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.veidVerificationsExpected = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.veidVerificationScore = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.uptimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.downtimeSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.consecutiveMissedBlocks = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.lastProposedHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.lastSignedHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.epochNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.overallScore = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorPerformance {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      blocksProposed: isSet(object.blocks_proposed) ? Long.fromValue(object.blocks_proposed) : Long.ZERO,
      blocksExpected: isSet(object.blocks_expected) ? Long.fromValue(object.blocks_expected) : Long.ZERO,
      blocksMissed: isSet(object.blocks_missed) ? Long.fromValue(object.blocks_missed) : Long.ZERO,
      totalSignatures: isSet(object.total_signatures) ? Long.fromValue(object.total_signatures) : Long.ZERO,
      veidVerificationsCompleted: isSet(object.veid_verifications_completed)
        ? Long.fromValue(object.veid_verifications_completed)
        : Long.ZERO,
      veidVerificationsExpected: isSet(object.veid_verifications_expected)
        ? Long.fromValue(object.veid_verifications_expected)
        : Long.ZERO,
      veidVerificationScore: isSet(object.veid_verification_score)
        ? Long.fromValue(object.veid_verification_score)
        : Long.ZERO,
      uptimeSeconds: isSet(object.uptime_seconds) ? Long.fromValue(object.uptime_seconds) : Long.ZERO,
      downtimeSeconds: isSet(object.downtime_seconds) ? Long.fromValue(object.downtime_seconds) : Long.ZERO,
      consecutiveMissedBlocks: isSet(object.consecutive_missed_blocks)
        ? Long.fromValue(object.consecutive_missed_blocks)
        : Long.ZERO,
      lastProposedHeight: isSet(object.last_proposed_height) ? Long.fromValue(object.last_proposed_height) : Long.ZERO,
      lastSignedHeight: isSet(object.last_signed_height) ? Long.fromValue(object.last_signed_height) : Long.ZERO,
      epochNumber: isSet(object.epoch_number) ? Long.fromValue(object.epoch_number) : Long.UZERO,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      overallScore: isSet(object.overall_score) ? Long.fromValue(object.overall_score) : Long.ZERO,
    };
  },

  toJSON(message: ValidatorPerformance): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.blocksProposed.equals(Long.ZERO)) {
      obj.blocks_proposed = (message.blocksProposed || Long.ZERO).toString();
    }
    if (!message.blocksExpected.equals(Long.ZERO)) {
      obj.blocks_expected = (message.blocksExpected || Long.ZERO).toString();
    }
    if (!message.blocksMissed.equals(Long.ZERO)) {
      obj.blocks_missed = (message.blocksMissed || Long.ZERO).toString();
    }
    if (!message.totalSignatures.equals(Long.ZERO)) {
      obj.total_signatures = (message.totalSignatures || Long.ZERO).toString();
    }
    if (!message.veidVerificationsCompleted.equals(Long.ZERO)) {
      obj.veid_verifications_completed = (message.veidVerificationsCompleted || Long.ZERO).toString();
    }
    if (!message.veidVerificationsExpected.equals(Long.ZERO)) {
      obj.veid_verifications_expected = (message.veidVerificationsExpected || Long.ZERO).toString();
    }
    if (!message.veidVerificationScore.equals(Long.ZERO)) {
      obj.veid_verification_score = (message.veidVerificationScore || Long.ZERO).toString();
    }
    if (!message.uptimeSeconds.equals(Long.ZERO)) {
      obj.uptime_seconds = (message.uptimeSeconds || Long.ZERO).toString();
    }
    if (!message.downtimeSeconds.equals(Long.ZERO)) {
      obj.downtime_seconds = (message.downtimeSeconds || Long.ZERO).toString();
    }
    if (!message.consecutiveMissedBlocks.equals(Long.ZERO)) {
      obj.consecutive_missed_blocks = (message.consecutiveMissedBlocks || Long.ZERO).toString();
    }
    if (!message.lastProposedHeight.equals(Long.ZERO)) {
      obj.last_proposed_height = (message.lastProposedHeight || Long.ZERO).toString();
    }
    if (!message.lastSignedHeight.equals(Long.ZERO)) {
      obj.last_signed_height = (message.lastSignedHeight || Long.ZERO).toString();
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      obj.epoch_number = (message.epochNumber || Long.UZERO).toString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (!message.overallScore.equals(Long.ZERO)) {
      obj.overall_score = (message.overallScore || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorPerformance>): ValidatorPerformance {
    const message = createBaseValidatorPerformance();
    message.validatorAddress = object.validatorAddress ?? "";
    message.blocksProposed = (object.blocksProposed !== undefined && object.blocksProposed !== null)
      ? Long.fromValue(object.blocksProposed)
      : Long.ZERO;
    message.blocksExpected = (object.blocksExpected !== undefined && object.blocksExpected !== null)
      ? Long.fromValue(object.blocksExpected)
      : Long.ZERO;
    message.blocksMissed = (object.blocksMissed !== undefined && object.blocksMissed !== null)
      ? Long.fromValue(object.blocksMissed)
      : Long.ZERO;
    message.totalSignatures = (object.totalSignatures !== undefined && object.totalSignatures !== null)
      ? Long.fromValue(object.totalSignatures)
      : Long.ZERO;
    message.veidVerificationsCompleted =
      (object.veidVerificationsCompleted !== undefined && object.veidVerificationsCompleted !== null)
        ? Long.fromValue(object.veidVerificationsCompleted)
        : Long.ZERO;
    message.veidVerificationsExpected =
      (object.veidVerificationsExpected !== undefined && object.veidVerificationsExpected !== null)
        ? Long.fromValue(object.veidVerificationsExpected)
        : Long.ZERO;
    message.veidVerificationScore =
      (object.veidVerificationScore !== undefined && object.veidVerificationScore !== null)
        ? Long.fromValue(object.veidVerificationScore)
        : Long.ZERO;
    message.uptimeSeconds = (object.uptimeSeconds !== undefined && object.uptimeSeconds !== null)
      ? Long.fromValue(object.uptimeSeconds)
      : Long.ZERO;
    message.downtimeSeconds = (object.downtimeSeconds !== undefined && object.downtimeSeconds !== null)
      ? Long.fromValue(object.downtimeSeconds)
      : Long.ZERO;
    message.consecutiveMissedBlocks =
      (object.consecutiveMissedBlocks !== undefined && object.consecutiveMissedBlocks !== null)
        ? Long.fromValue(object.consecutiveMissedBlocks)
        : Long.ZERO;
    message.lastProposedHeight = (object.lastProposedHeight !== undefined && object.lastProposedHeight !== null)
      ? Long.fromValue(object.lastProposedHeight)
      : Long.ZERO;
    message.lastSignedHeight = (object.lastSignedHeight !== undefined && object.lastSignedHeight !== null)
      ? Long.fromValue(object.lastSignedHeight)
      : Long.ZERO;
    message.epochNumber = (object.epochNumber !== undefined && object.epochNumber !== null)
      ? Long.fromValue(object.epochNumber)
      : Long.UZERO;
    message.updatedAt = object.updatedAt ?? undefined;
    message.overallScore = (object.overallScore !== undefined && object.overallScore !== null)
      ? Long.fromValue(object.overallScore)
      : Long.ZERO;
    return message;
  },
};

function createBaseValidatorSigningInfo(): ValidatorSigningInfo {
  return {
    validatorAddress: "",
    startHeight: Long.ZERO,
    indexOffset: Long.ZERO,
    jailedUntil: undefined,
    tombstoned: false,
    missedBlocksCounter: Long.ZERO,
    infractionCount: Long.ZERO,
  };
}

export const ValidatorSigningInfo: MessageFns<ValidatorSigningInfo, "virtengine.staking.v1.ValidatorSigningInfo"> = {
  $type: "virtengine.staking.v1.ValidatorSigningInfo" as const,

  encode(message: ValidatorSigningInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (!message.startHeight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.startHeight.toString());
    }
    if (!message.indexOffset.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.indexOffset.toString());
    }
    if (message.jailedUntil !== undefined) {
      Timestamp.encode(toTimestamp(message.jailedUntil), writer.uint32(34).fork()).join();
    }
    if (message.tombstoned !== false) {
      writer.uint32(40).bool(message.tombstoned);
    }
    if (!message.missedBlocksCounter.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.missedBlocksCounter.toString());
    }
    if (!message.infractionCount.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.infractionCount.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorSigningInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorSigningInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.indexOffset = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jailedUntil = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.tombstoned = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.missedBlocksCounter = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.infractionCount = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorSigningInfo {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      startHeight: isSet(object.start_height) ? Long.fromValue(object.start_height) : Long.ZERO,
      indexOffset: isSet(object.index_offset) ? Long.fromValue(object.index_offset) : Long.ZERO,
      jailedUntil: isSet(object.jailed_until) ? fromJsonTimestamp(object.jailed_until) : undefined,
      tombstoned: isSet(object.tombstoned) ? globalThis.Boolean(object.tombstoned) : false,
      missedBlocksCounter: isSet(object.missed_blocks_counter)
        ? Long.fromValue(object.missed_blocks_counter)
        : Long.ZERO,
      infractionCount: isSet(object.infraction_count) ? Long.fromValue(object.infraction_count) : Long.ZERO,
    };
  },

  toJSON(message: ValidatorSigningInfo): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.startHeight.equals(Long.ZERO)) {
      obj.start_height = (message.startHeight || Long.ZERO).toString();
    }
    if (!message.indexOffset.equals(Long.ZERO)) {
      obj.index_offset = (message.indexOffset || Long.ZERO).toString();
    }
    if (message.jailedUntil !== undefined) {
      obj.jailed_until = message.jailedUntil.toISOString();
    }
    if (message.tombstoned !== false) {
      obj.tombstoned = message.tombstoned;
    }
    if (!message.missedBlocksCounter.equals(Long.ZERO)) {
      obj.missed_blocks_counter = (message.missedBlocksCounter || Long.ZERO).toString();
    }
    if (!message.infractionCount.equals(Long.ZERO)) {
      obj.infraction_count = (message.infractionCount || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorSigningInfo>): ValidatorSigningInfo {
    const message = createBaseValidatorSigningInfo();
    message.validatorAddress = object.validatorAddress ?? "";
    message.startHeight = (object.startHeight !== undefined && object.startHeight !== null)
      ? Long.fromValue(object.startHeight)
      : Long.ZERO;
    message.indexOffset = (object.indexOffset !== undefined && object.indexOffset !== null)
      ? Long.fromValue(object.indexOffset)
      : Long.ZERO;
    message.jailedUntil = object.jailedUntil ?? undefined;
    message.tombstoned = object.tombstoned ?? false;
    message.missedBlocksCounter = (object.missedBlocksCounter !== undefined && object.missedBlocksCounter !== null)
      ? Long.fromValue(object.missedBlocksCounter)
      : Long.ZERO;
    message.infractionCount = (object.infractionCount !== undefined && object.infractionCount !== null)
      ? Long.fromValue(object.infractionCount)
      : Long.ZERO;
    return message;
  },
};

function createBaseRewardEpoch(): RewardEpoch {
  return {
    epochNumber: Long.UZERO,
    startHeight: Long.ZERO,
    endHeight: Long.ZERO,
    startTime: undefined,
    endTime: undefined,
    totalRewardsDistributed: [],
    blockProposalRewards: [],
    veidRewards: [],
    uptimeRewards: [],
    validatorCount: Long.ZERO,
    totalStake: "",
    finalized: false,
  };
}

export const RewardEpoch: MessageFns<RewardEpoch, "virtengine.staking.v1.RewardEpoch"> = {
  $type: "virtengine.staking.v1.RewardEpoch" as const,

  encode(message: RewardEpoch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.epochNumber.equals(Long.UZERO)) {
      writer.uint32(8).uint64(message.epochNumber.toString());
    }
    if (!message.startHeight.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.startHeight.toString());
    }
    if (!message.endHeight.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.endHeight.toString());
    }
    if (message.startTime !== undefined) {
      Timestamp.encode(toTimestamp(message.startTime), writer.uint32(34).fork()).join();
    }
    if (message.endTime !== undefined) {
      Timestamp.encode(toTimestamp(message.endTime), writer.uint32(42).fork()).join();
    }
    for (const v of message.totalRewardsDistributed) {
      Coin.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.blockProposalRewards) {
      Coin.encode(v!, writer.uint32(58).fork()).join();
    }
    for (const v of message.veidRewards) {
      Coin.encode(v!, writer.uint32(66).fork()).join();
    }
    for (const v of message.uptimeRewards) {
      Coin.encode(v!, writer.uint32(74).fork()).join();
    }
    if (!message.validatorCount.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.validatorCount.toString());
    }
    if (message.totalStake !== "") {
      writer.uint32(90).string(message.totalStake);
    }
    if (message.finalized !== false) {
      writer.uint32(96).bool(message.finalized);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RewardEpoch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRewardEpoch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.epochNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.startTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.endTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.totalRewardsDistributed.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.blockProposalRewards.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.veidRewards.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.uptimeRewards.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.validatorCount = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.totalStake = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.finalized = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RewardEpoch {
    return {
      epochNumber: isSet(object.epoch_number) ? Long.fromValue(object.epoch_number) : Long.UZERO,
      startHeight: isSet(object.start_height) ? Long.fromValue(object.start_height) : Long.ZERO,
      endHeight: isSet(object.end_height) ? Long.fromValue(object.end_height) : Long.ZERO,
      startTime: isSet(object.start_time) ? fromJsonTimestamp(object.start_time) : undefined,
      endTime: isSet(object.end_time) ? fromJsonTimestamp(object.end_time) : undefined,
      totalRewardsDistributed: globalThis.Array.isArray(object?.total_rewards_distributed)
        ? object.total_rewards_distributed.map((e: any) => Coin.fromJSON(e))
        : [],
      blockProposalRewards: globalThis.Array.isArray(object?.block_proposal_rewards)
        ? object.block_proposal_rewards.map((e: any) => Coin.fromJSON(e))
        : [],
      veidRewards: globalThis.Array.isArray(object?.veid_rewards)
        ? object.veid_rewards.map((e: any) => Coin.fromJSON(e))
        : [],
      uptimeRewards: globalThis.Array.isArray(object?.uptime_rewards)
        ? object.uptime_rewards.map((e: any) => Coin.fromJSON(e))
        : [],
      validatorCount: isSet(object.validator_count) ? Long.fromValue(object.validator_count) : Long.ZERO,
      totalStake: isSet(object.total_stake) ? globalThis.String(object.total_stake) : "",
      finalized: isSet(object.finalized) ? globalThis.Boolean(object.finalized) : false,
    };
  },

  toJSON(message: RewardEpoch): unknown {
    const obj: any = {};
    if (!message.epochNumber.equals(Long.UZERO)) {
      obj.epoch_number = (message.epochNumber || Long.UZERO).toString();
    }
    if (!message.startHeight.equals(Long.ZERO)) {
      obj.start_height = (message.startHeight || Long.ZERO).toString();
    }
    if (!message.endHeight.equals(Long.ZERO)) {
      obj.end_height = (message.endHeight || Long.ZERO).toString();
    }
    if (message.startTime !== undefined) {
      obj.start_time = message.startTime.toISOString();
    }
    if (message.endTime !== undefined) {
      obj.end_time = message.endTime.toISOString();
    }
    if (message.totalRewardsDistributed?.length) {
      obj.total_rewards_distributed = message.totalRewardsDistributed.map((e) => Coin.toJSON(e));
    }
    if (message.blockProposalRewards?.length) {
      obj.block_proposal_rewards = message.blockProposalRewards.map((e) => Coin.toJSON(e));
    }
    if (message.veidRewards?.length) {
      obj.veid_rewards = message.veidRewards.map((e) => Coin.toJSON(e));
    }
    if (message.uptimeRewards?.length) {
      obj.uptime_rewards = message.uptimeRewards.map((e) => Coin.toJSON(e));
    }
    if (!message.validatorCount.equals(Long.ZERO)) {
      obj.validator_count = (message.validatorCount || Long.ZERO).toString();
    }
    if (message.totalStake !== "") {
      obj.total_stake = message.totalStake;
    }
    if (message.finalized !== false) {
      obj.finalized = message.finalized;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<RewardEpoch>): RewardEpoch {
    const message = createBaseRewardEpoch();
    message.epochNumber = (object.epochNumber !== undefined && object.epochNumber !== null)
      ? Long.fromValue(object.epochNumber)
      : Long.UZERO;
    message.startHeight = (object.startHeight !== undefined && object.startHeight !== null)
      ? Long.fromValue(object.startHeight)
      : Long.ZERO;
    message.endHeight = (object.endHeight !== undefined && object.endHeight !== null)
      ? Long.fromValue(object.endHeight)
      : Long.ZERO;
    message.startTime = object.startTime ?? undefined;
    message.endTime = object.endTime ?? undefined;
    message.totalRewardsDistributed = object.totalRewardsDistributed?.map((e) => Coin.fromPartial(e)) || [];
    message.blockProposalRewards = object.blockProposalRewards?.map((e) => Coin.fromPartial(e)) || [];
    message.veidRewards = object.veidRewards?.map((e) => Coin.fromPartial(e)) || [];
    message.uptimeRewards = object.uptimeRewards?.map((e) => Coin.fromPartial(e)) || [];
    message.validatorCount = (object.validatorCount !== undefined && object.validatorCount !== null)
      ? Long.fromValue(object.validatorCount)
      : Long.ZERO;
    message.totalStake = object.totalStake ?? "";
    message.finalized = object.finalized ?? false;
    return message;
  },
};

function createBaseValidatorReward(): ValidatorReward {
  return {
    validatorAddress: "",
    epochNumber: Long.UZERO,
    totalReward: [],
    blockProposalReward: [],
    veidReward: [],
    uptimeReward: [],
    identityNetworkReward: [],
    performanceScore: Long.ZERO,
    stakeWeight: "",
    calculatedAt: undefined,
    blockHeight: Long.ZERO,
    claimed: false,
    claimedAt: undefined,
  };
}

export const ValidatorReward: MessageFns<ValidatorReward, "virtengine.staking.v1.ValidatorReward"> = {
  $type: "virtengine.staking.v1.ValidatorReward" as const,

  encode(message: ValidatorReward, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      writer.uint32(16).uint64(message.epochNumber.toString());
    }
    for (const v of message.totalReward) {
      Coin.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.blockProposalReward) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.veidReward) {
      Coin.encode(v!, writer.uint32(42).fork()).join();
    }
    for (const v of message.uptimeReward) {
      Coin.encode(v!, writer.uint32(50).fork()).join();
    }
    for (const v of message.identityNetworkReward) {
      Coin.encode(v!, writer.uint32(58).fork()).join();
    }
    if (!message.performanceScore.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.performanceScore.toString());
    }
    if (message.stakeWeight !== "") {
      writer.uint32(74).string(message.stakeWeight);
    }
    if (message.calculatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.calculatedAt), writer.uint32(82).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.blockHeight.toString());
    }
    if (message.claimed !== false) {
      writer.uint32(96).bool(message.claimed);
    }
    if (message.claimedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.claimedAt), writer.uint32(106).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ValidatorReward {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseValidatorReward();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.epochNumber = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.totalReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.blockProposalReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.veidReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.uptimeReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.identityNetworkReward.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.performanceScore = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.stakeWeight = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.calculatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.claimed = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.claimedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ValidatorReward {
    return {
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      epochNumber: isSet(object.epoch_number) ? Long.fromValue(object.epoch_number) : Long.UZERO,
      totalReward: globalThis.Array.isArray(object?.total_reward)
        ? object.total_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      blockProposalReward: globalThis.Array.isArray(object?.block_proposal_reward)
        ? object.block_proposal_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      veidReward: globalThis.Array.isArray(object?.veid_reward)
        ? object.veid_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      uptimeReward: globalThis.Array.isArray(object?.uptime_reward)
        ? object.uptime_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      identityNetworkReward: globalThis.Array.isArray(object?.identity_network_reward)
        ? object.identity_network_reward.map((e: any) => Coin.fromJSON(e))
        : [],
      performanceScore: isSet(object.performance_score) ? Long.fromValue(object.performance_score) : Long.ZERO,
      stakeWeight: isSet(object.stake_weight) ? globalThis.String(object.stake_weight) : "",
      calculatedAt: isSet(object.calculated_at) ? fromJsonTimestamp(object.calculated_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      claimed: isSet(object.claimed) ? globalThis.Boolean(object.claimed) : false,
      claimedAt: isSet(object.claimed_at) ? fromJsonTimestamp(object.claimed_at) : undefined,
    };
  },

  toJSON(message: ValidatorReward): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.epochNumber.equals(Long.UZERO)) {
      obj.epoch_number = (message.epochNumber || Long.UZERO).toString();
    }
    if (message.totalReward?.length) {
      obj.total_reward = message.totalReward.map((e) => Coin.toJSON(e));
    }
    if (message.blockProposalReward?.length) {
      obj.block_proposal_reward = message.blockProposalReward.map((e) => Coin.toJSON(e));
    }
    if (message.veidReward?.length) {
      obj.veid_reward = message.veidReward.map((e) => Coin.toJSON(e));
    }
    if (message.uptimeReward?.length) {
      obj.uptime_reward = message.uptimeReward.map((e) => Coin.toJSON(e));
    }
    if (message.identityNetworkReward?.length) {
      obj.identity_network_reward = message.identityNetworkReward.map((e) => Coin.toJSON(e));
    }
    if (!message.performanceScore.equals(Long.ZERO)) {
      obj.performance_score = (message.performanceScore || Long.ZERO).toString();
    }
    if (message.stakeWeight !== "") {
      obj.stake_weight = message.stakeWeight;
    }
    if (message.calculatedAt !== undefined) {
      obj.calculated_at = message.calculatedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.claimed !== false) {
      obj.claimed = message.claimed;
    }
    if (message.claimedAt !== undefined) {
      obj.claimed_at = message.claimedAt.toISOString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ValidatorReward>): ValidatorReward {
    const message = createBaseValidatorReward();
    message.validatorAddress = object.validatorAddress ?? "";
    message.epochNumber = (object.epochNumber !== undefined && object.epochNumber !== null)
      ? Long.fromValue(object.epochNumber)
      : Long.UZERO;
    message.totalReward = object.totalReward?.map((e) => Coin.fromPartial(e)) || [];
    message.blockProposalReward = object.blockProposalReward?.map((e) => Coin.fromPartial(e)) || [];
    message.veidReward = object.veidReward?.map((e) => Coin.fromPartial(e)) || [];
    message.uptimeReward = object.uptimeReward?.map((e) => Coin.fromPartial(e)) || [];
    message.identityNetworkReward = object.identityNetworkReward?.map((e) => Coin.fromPartial(e)) || [];
    message.performanceScore = (object.performanceScore !== undefined && object.performanceScore !== null)
      ? Long.fromValue(object.performanceScore)
      : Long.ZERO;
    message.stakeWeight = object.stakeWeight ?? "";
    message.calculatedAt = object.calculatedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.claimed = object.claimed ?? false;
    message.claimedAt = object.claimedAt ?? undefined;
    return message;
  },
};

function createBaseSlashRecord(): SlashRecord {
  return {
    slashId: "",
    validatorAddress: "",
    reason: 0,
    amount: [],
    slashPercent: Long.ZERO,
    infractionHeight: Long.ZERO,
    slashHeight: Long.ZERO,
    slashTime: undefined,
    jailed: false,
    jailDuration: Long.ZERO,
    jailedUntil: undefined,
    tombstoned: false,
    evidence: "",
    evidenceHash: "",
    reporterAddress: "",
  };
}

export const SlashRecord: MessageFns<SlashRecord, "virtengine.staking.v1.SlashRecord"> = {
  $type: "virtengine.staking.v1.SlashRecord" as const,

  encode(message: SlashRecord, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.slashId !== "") {
      writer.uint32(10).string(message.slashId);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.reason !== 0) {
      writer.uint32(24).int32(message.reason);
    }
    for (const v of message.amount) {
      Coin.encode(v!, writer.uint32(34).fork()).join();
    }
    if (!message.slashPercent.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.slashPercent.toString());
    }
    if (!message.infractionHeight.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.infractionHeight.toString());
    }
    if (!message.slashHeight.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.slashHeight.toString());
    }
    if (message.slashTime !== undefined) {
      Timestamp.encode(toTimestamp(message.slashTime), writer.uint32(66).fork()).join();
    }
    if (message.jailed !== false) {
      writer.uint32(72).bool(message.jailed);
    }
    if (!message.jailDuration.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.jailDuration.toString());
    }
    if (message.jailedUntil !== undefined) {
      Timestamp.encode(toTimestamp(message.jailedUntil), writer.uint32(90).fork()).join();
    }
    if (message.tombstoned !== false) {
      writer.uint32(96).bool(message.tombstoned);
    }
    if (message.evidence !== "") {
      writer.uint32(106).string(message.evidence);
    }
    if (message.evidenceHash !== "") {
      writer.uint32(114).string(message.evidenceHash);
    }
    if (message.reporterAddress !== "") {
      writer.uint32(122).string(message.reporterAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlashRecord {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlashRecord();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.slashId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.amount.push(Coin.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.slashPercent = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.infractionHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.slashHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.slashTime = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.jailed = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.jailDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.jailedUntil = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.tombstoned = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.evidence = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.evidenceHash = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.reporterAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlashRecord {
    return {
      slashId: isSet(object.slash_id) ? globalThis.String(object.slash_id) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      reason: isSet(object.reason) ? slashReasonFromJSON(object.reason) : 0,
      amount: globalThis.Array.isArray(object?.amount) ? object.amount.map((e: any) => Coin.fromJSON(e)) : [],
      slashPercent: isSet(object.slash_percent) ? Long.fromValue(object.slash_percent) : Long.ZERO,
      infractionHeight: isSet(object.infraction_height) ? Long.fromValue(object.infraction_height) : Long.ZERO,
      slashHeight: isSet(object.slash_height) ? Long.fromValue(object.slash_height) : Long.ZERO,
      slashTime: isSet(object.slash_time) ? fromJsonTimestamp(object.slash_time) : undefined,
      jailed: isSet(object.jailed) ? globalThis.Boolean(object.jailed) : false,
      jailDuration: isSet(object.jail_duration) ? Long.fromValue(object.jail_duration) : Long.ZERO,
      jailedUntil: isSet(object.jailed_until) ? fromJsonTimestamp(object.jailed_until) : undefined,
      tombstoned: isSet(object.tombstoned) ? globalThis.Boolean(object.tombstoned) : false,
      evidence: isSet(object.evidence) ? globalThis.String(object.evidence) : "",
      evidenceHash: isSet(object.evidence_hash) ? globalThis.String(object.evidence_hash) : "",
      reporterAddress: isSet(object.reporter_address) ? globalThis.String(object.reporter_address) : "",
    };
  },

  toJSON(message: SlashRecord): unknown {
    const obj: any = {};
    if (message.slashId !== "") {
      obj.slash_id = message.slashId;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.reason !== 0) {
      obj.reason = slashReasonToJSON(message.reason);
    }
    if (message.amount?.length) {
      obj.amount = message.amount.map((e) => Coin.toJSON(e));
    }
    if (!message.slashPercent.equals(Long.ZERO)) {
      obj.slash_percent = (message.slashPercent || Long.ZERO).toString();
    }
    if (!message.infractionHeight.equals(Long.ZERO)) {
      obj.infraction_height = (message.infractionHeight || Long.ZERO).toString();
    }
    if (!message.slashHeight.equals(Long.ZERO)) {
      obj.slash_height = (message.slashHeight || Long.ZERO).toString();
    }
    if (message.slashTime !== undefined) {
      obj.slash_time = message.slashTime.toISOString();
    }
    if (message.jailed !== false) {
      obj.jailed = message.jailed;
    }
    if (!message.jailDuration.equals(Long.ZERO)) {
      obj.jail_duration = (message.jailDuration || Long.ZERO).toString();
    }
    if (message.jailedUntil !== undefined) {
      obj.jailed_until = message.jailedUntil.toISOString();
    }
    if (message.tombstoned !== false) {
      obj.tombstoned = message.tombstoned;
    }
    if (message.evidence !== "") {
      obj.evidence = message.evidence;
    }
    if (message.evidenceHash !== "") {
      obj.evidence_hash = message.evidenceHash;
    }
    if (message.reporterAddress !== "") {
      obj.reporter_address = message.reporterAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<SlashRecord>): SlashRecord {
    const message = createBaseSlashRecord();
    message.slashId = object.slashId ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.reason = object.reason ?? 0;
    message.amount = object.amount?.map((e) => Coin.fromPartial(e)) || [];
    message.slashPercent = (object.slashPercent !== undefined && object.slashPercent !== null)
      ? Long.fromValue(object.slashPercent)
      : Long.ZERO;
    message.infractionHeight = (object.infractionHeight !== undefined && object.infractionHeight !== null)
      ? Long.fromValue(object.infractionHeight)
      : Long.ZERO;
    message.slashHeight = (object.slashHeight !== undefined && object.slashHeight !== null)
      ? Long.fromValue(object.slashHeight)
      : Long.ZERO;
    message.slashTime = object.slashTime ?? undefined;
    message.jailed = object.jailed ?? false;
    message.jailDuration = (object.jailDuration !== undefined && object.jailDuration !== null)
      ? Long.fromValue(object.jailDuration)
      : Long.ZERO;
    message.jailedUntil = object.jailedUntil ?? undefined;
    message.tombstoned = object.tombstoned ?? false;
    message.evidence = object.evidence ?? "";
    message.evidenceHash = object.evidenceHash ?? "";
    message.reporterAddress = object.reporterAddress ?? "";
    return message;
  },
};

function createBaseDoubleSignEvidence(): DoubleSignEvidence {
  return {
    evidenceId: "",
    validatorAddress: "",
    height1: Long.ZERO,
    height2: Long.ZERO,
    voteHash1: "",
    voteHash2: "",
    detectedAt: undefined,
    detectedHeight: Long.ZERO,
    processed: false,
  };
}

export const DoubleSignEvidence: MessageFns<DoubleSignEvidence, "virtengine.staking.v1.DoubleSignEvidence"> = {
  $type: "virtengine.staking.v1.DoubleSignEvidence" as const,

  encode(message: DoubleSignEvidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.evidenceId !== "") {
      writer.uint32(10).string(message.evidenceId);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (!message.height1.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.height1.toString());
    }
    if (!message.height2.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.height2.toString());
    }
    if (message.voteHash1 !== "") {
      writer.uint32(42).string(message.voteHash1);
    }
    if (message.voteHash2 !== "") {
      writer.uint32(50).string(message.voteHash2);
    }
    if (message.detectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.detectedAt), writer.uint32(58).fork()).join();
    }
    if (!message.detectedHeight.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.detectedHeight.toString());
    }
    if (message.processed !== false) {
      writer.uint32(72).bool(message.processed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DoubleSignEvidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDoubleSignEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.evidenceId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height1 = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height2 = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.voteHash1 = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.voteHash2 = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.detectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.detectedHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DoubleSignEvidence {
    return {
      evidenceId: isSet(object.evidence_id) ? globalThis.String(object.evidence_id) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      height1: isSet(object.height_1) ? Long.fromValue(object.height_1) : Long.ZERO,
      height2: isSet(object.height_2) ? Long.fromValue(object.height_2) : Long.ZERO,
      voteHash1: isSet(object.vote_hash_1) ? globalThis.String(object.vote_hash_1) : "",
      voteHash2: isSet(object.vote_hash_2) ? globalThis.String(object.vote_hash_2) : "",
      detectedAt: isSet(object.detected_at) ? fromJsonTimestamp(object.detected_at) : undefined,
      detectedHeight: isSet(object.detected_height) ? Long.fromValue(object.detected_height) : Long.ZERO,
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
    };
  },

  toJSON(message: DoubleSignEvidence): unknown {
    const obj: any = {};
    if (message.evidenceId !== "") {
      obj.evidence_id = message.evidenceId;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.height1.equals(Long.ZERO)) {
      obj.height_1 = (message.height1 || Long.ZERO).toString();
    }
    if (!message.height2.equals(Long.ZERO)) {
      obj.height_2 = (message.height2 || Long.ZERO).toString();
    }
    if (message.voteHash1 !== "") {
      obj.vote_hash_1 = message.voteHash1;
    }
    if (message.voteHash2 !== "") {
      obj.vote_hash_2 = message.voteHash2;
    }
    if (message.detectedAt !== undefined) {
      obj.detected_at = message.detectedAt.toISOString();
    }
    if (!message.detectedHeight.equals(Long.ZERO)) {
      obj.detected_height = (message.detectedHeight || Long.ZERO).toString();
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<DoubleSignEvidence>): DoubleSignEvidence {
    const message = createBaseDoubleSignEvidence();
    message.evidenceId = object.evidenceId ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.height1 = (object.height1 !== undefined && object.height1 !== null)
      ? Long.fromValue(object.height1)
      : Long.ZERO;
    message.height2 = (object.height2 !== undefined && object.height2 !== null)
      ? Long.fromValue(object.height2)
      : Long.ZERO;
    message.voteHash1 = object.voteHash1 ?? "";
    message.voteHash2 = object.voteHash2 ?? "";
    message.detectedAt = object.detectedAt ?? undefined;
    message.detectedHeight = (object.detectedHeight !== undefined && object.detectedHeight !== null)
      ? Long.fromValue(object.detectedHeight)
      : Long.ZERO;
    message.processed = object.processed ?? false;
    return message;
  },
};

function createBaseInvalidVEIDAttestation(): InvalidVEIDAttestation {
  return {
    recordId: "",
    validatorAddress: "",
    attestationId: "",
    reason: "",
    expectedScore: Long.ZERO,
    actualScore: Long.ZERO,
    scoreDifference: Long.ZERO,
    detectedAt: undefined,
    detectedHeight: Long.ZERO,
    processed: false,
  };
}

export const InvalidVEIDAttestation: MessageFns<
  InvalidVEIDAttestation,
  "virtengine.staking.v1.InvalidVEIDAttestation"
> = {
  $type: "virtengine.staking.v1.InvalidVEIDAttestation" as const,

  encode(message: InvalidVEIDAttestation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.recordId !== "") {
      writer.uint32(10).string(message.recordId);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.attestationId !== "") {
      writer.uint32(26).string(message.attestationId);
    }
    if (message.reason !== "") {
      writer.uint32(34).string(message.reason);
    }
    if (!message.expectedScore.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.expectedScore.toString());
    }
    if (!message.actualScore.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.actualScore.toString());
    }
    if (!message.scoreDifference.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.scoreDifference.toString());
    }
    if (message.detectedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.detectedAt), writer.uint32(66).fork()).join();
    }
    if (!message.detectedHeight.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.detectedHeight.toString());
    }
    if (message.processed !== false) {
      writer.uint32(80).bool(message.processed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InvalidVEIDAttestation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInvalidVEIDAttestation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.recordId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.attestationId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.reason = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.expectedScore = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.actualScore = Long.fromString(reader.int64().toString());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scoreDifference = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.detectedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.detectedHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.processed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InvalidVEIDAttestation {
    return {
      recordId: isSet(object.record_id) ? globalThis.String(object.record_id) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      attestationId: isSet(object.attestation_id) ? globalThis.String(object.attestation_id) : "",
      reason: isSet(object.reason) ? globalThis.String(object.reason) : "",
      expectedScore: isSet(object.expected_score) ? Long.fromValue(object.expected_score) : Long.ZERO,
      actualScore: isSet(object.actual_score) ? Long.fromValue(object.actual_score) : Long.ZERO,
      scoreDifference: isSet(object.score_difference) ? Long.fromValue(object.score_difference) : Long.ZERO,
      detectedAt: isSet(object.detected_at) ? fromJsonTimestamp(object.detected_at) : undefined,
      detectedHeight: isSet(object.detected_height) ? Long.fromValue(object.detected_height) : Long.ZERO,
      processed: isSet(object.processed) ? globalThis.Boolean(object.processed) : false,
    };
  },

  toJSON(message: InvalidVEIDAttestation): unknown {
    const obj: any = {};
    if (message.recordId !== "") {
      obj.record_id = message.recordId;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.attestationId !== "") {
      obj.attestation_id = message.attestationId;
    }
    if (message.reason !== "") {
      obj.reason = message.reason;
    }
    if (!message.expectedScore.equals(Long.ZERO)) {
      obj.expected_score = (message.expectedScore || Long.ZERO).toString();
    }
    if (!message.actualScore.equals(Long.ZERO)) {
      obj.actual_score = (message.actualScore || Long.ZERO).toString();
    }
    if (!message.scoreDifference.equals(Long.ZERO)) {
      obj.score_difference = (message.scoreDifference || Long.ZERO).toString();
    }
    if (message.detectedAt !== undefined) {
      obj.detected_at = message.detectedAt.toISOString();
    }
    if (!message.detectedHeight.equals(Long.ZERO)) {
      obj.detected_height = (message.detectedHeight || Long.ZERO).toString();
    }
    if (message.processed !== false) {
      obj.processed = message.processed;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<InvalidVEIDAttestation>): InvalidVEIDAttestation {
    const message = createBaseInvalidVEIDAttestation();
    message.recordId = object.recordId ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.attestationId = object.attestationId ?? "";
    message.reason = object.reason ?? "";
    message.expectedScore = (object.expectedScore !== undefined && object.expectedScore !== null)
      ? Long.fromValue(object.expectedScore)
      : Long.ZERO;
    message.actualScore = (object.actualScore !== undefined && object.actualScore !== null)
      ? Long.fromValue(object.actualScore)
      : Long.ZERO;
    message.scoreDifference = (object.scoreDifference !== undefined && object.scoreDifference !== null)
      ? Long.fromValue(object.scoreDifference)
      : Long.ZERO;
    message.detectedAt = object.detectedAt ?? undefined;
    message.detectedHeight = (object.detectedHeight !== undefined && object.detectedHeight !== null)
      ? Long.fromValue(object.detectedHeight)
      : Long.ZERO;
    message.processed = object.processed ?? false;
    return message;
  },
};

function createBaseSlashConfig(): SlashConfig {
  return {
    reason: 0,
    slashPercent: Long.ZERO,
    jailDuration: Long.ZERO,
    isTombstone: false,
    escalationMultiplier: Long.ZERO,
  };
}

export const SlashConfig: MessageFns<SlashConfig, "virtengine.staking.v1.SlashConfig"> = {
  $type: "virtengine.staking.v1.SlashConfig" as const,

  encode(message: SlashConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reason !== 0) {
      writer.uint32(8).int32(message.reason);
    }
    if (!message.slashPercent.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.slashPercent.toString());
    }
    if (!message.jailDuration.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.jailDuration.toString());
    }
    if (message.isTombstone !== false) {
      writer.uint32(32).bool(message.isTombstone);
    }
    if (!message.escalationMultiplier.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.escalationMultiplier.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SlashConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSlashConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.slashPercent = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.jailDuration = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isTombstone = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.escalationMultiplier = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SlashConfig {
    return {
      reason: isSet(object.reason) ? slashReasonFromJSON(object.reason) : 0,
      slashPercent: isSet(object.slash_percent) ? Long.fromValue(object.slash_percent) : Long.ZERO,
      jailDuration: isSet(object.jail_duration) ? Long.fromValue(object.jail_duration) : Long.ZERO,
      isTombstone: isSet(object.is_tombstone) ? globalThis.Boolean(object.is_tombstone) : false,
      escalationMultiplier: isSet(object.escalation_multiplier)
        ? Long.fromValue(object.escalation_multiplier)
        : Long.ZERO,
    };
  },

  toJSON(message: SlashConfig): unknown {
    const obj: any = {};
    if (message.reason !== 0) {
      obj.reason = slashReasonToJSON(message.reason);
    }
    if (!message.slashPercent.equals(Long.ZERO)) {
      obj.slash_percent = (message.slashPercent || Long.ZERO).toString();
    }
    if (!message.jailDuration.equals(Long.ZERO)) {
      obj.jail_duration = (message.jailDuration || Long.ZERO).toString();
    }
    if (message.isTombstone !== false) {
      obj.is_tombstone = message.isTombstone;
    }
    if (!message.escalationMultiplier.equals(Long.ZERO)) {
      obj.escalation_multiplier = (message.escalationMultiplier || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<SlashConfig>): SlashConfig {
    const message = createBaseSlashConfig();
    message.reason = object.reason ?? 0;
    message.slashPercent = (object.slashPercent !== undefined && object.slashPercent !== null)
      ? Long.fromValue(object.slashPercent)
      : Long.ZERO;
    message.jailDuration = (object.jailDuration !== undefined && object.jailDuration !== null)
      ? Long.fromValue(object.jailDuration)
      : Long.ZERO;
    message.isTombstone = object.isTombstone ?? false;
    message.escalationMultiplier = (object.escalationMultiplier !== undefined && object.escalationMultiplier !== null)
      ? Long.fromValue(object.escalationMultiplier)
      : Long.ZERO;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
