import { isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/staking/v1/tx.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Params } from "./params.ts";
import { SlashReason, slashReasonFromJSON, slashReasonToJSON } from "./types.ts";

/** MsgUpdateParams is the message for updating module parameters */
export interface MsgUpdateParams {
  /** Authority is the address that controls the module (x/gov module account) */
  authority: string;
  /** Params are the new module parameters */
  params: Params | undefined;
}

/** MsgUpdateParamsResponse is the response for MsgUpdateParams */
export interface MsgUpdateParamsResponse {
}

/** MsgSlashValidator is the message for slashing a validator */
export interface MsgSlashValidator {
  /** Authority is the address that controls the module */
  authority: string;
  /** ValidatorAddress is the validator to slash */
  validatorAddress: string;
  /** Reason is the slashing reason */
  reason: SlashReason;
  /** InfractionHeight is when the infraction occurred */
  infractionHeight: Long;
  /** Evidence is the evidence supporting the slash */
  evidence: string;
}

/** MsgSlashValidatorResponse is the response for MsgSlashValidator */
export interface MsgSlashValidatorResponse {
}

/** MsgUnjailValidator is the message for unjailing a validator */
export interface MsgUnjailValidator {
  /** ValidatorAddress is the validator to unjail */
  validatorAddress: string;
}

/** MsgUnjailValidatorResponse is the response for MsgUnjailValidator */
export interface MsgUnjailValidatorResponse {
}

/** MsgRecordPerformance is the message for recording validator performance */
export interface MsgRecordPerformance {
  /** Authority is the address that controls the module */
  authority: string;
  /** ValidatorAddress is the validator */
  validatorAddress: string;
  /** BlocksProposed is the number of blocks proposed */
  blocksProposed: Long;
  /** BlocksSigned is the number of blocks signed */
  blocksSigned: Long;
  /** VEIDVerificationsCompleted is VEID verifications completed */
  veidVerificationsCompleted: Long;
  /** VEIDVerificationScore is the VEID verification quality score */
  veidVerificationScore: Long;
}

/** MsgRecordPerformanceResponse is the response for MsgRecordPerformance */
export interface MsgRecordPerformanceResponse {
}

function createBaseMsgUpdateParams(): MsgUpdateParams {
  return { authority: "", params: undefined };
}

export const MsgUpdateParams: MessageFns<MsgUpdateParams, "virtengine.staking.v1.MsgUpdateParams"> = {
  $type: "virtengine.staking.v1.MsgUpdateParams" as const,

  encode(message: MsgUpdateParams, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.params !== undefined) {
      Params.encode(message.params, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParams {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParams();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.params = Params.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUpdateParams {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      params: isSet(object.params) ? Params.fromJSON(object.params) : undefined,
    };
  },

  toJSON(message: MsgUpdateParams): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.params !== undefined) {
      obj.params = Params.toJSON(message.params);
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUpdateParams>): MsgUpdateParams {
    const message = createBaseMsgUpdateParams();
    message.authority = object.authority ?? "";
    message.params = (object.params !== undefined && object.params !== null)
      ? Params.fromPartial(object.params)
      : undefined;
    return message;
  },
};

function createBaseMsgUpdateParamsResponse(): MsgUpdateParamsResponse {
  return {};
}

export const MsgUpdateParamsResponse: MessageFns<
  MsgUpdateParamsResponse,
  "virtengine.staking.v1.MsgUpdateParamsResponse"
> = {
  $type: "virtengine.staking.v1.MsgUpdateParamsResponse" as const,

  encode(_: MsgUpdateParamsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUpdateParamsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUpdateParamsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUpdateParamsResponse {
    return {};
  },

  toJSON(_: MsgUpdateParamsResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUpdateParamsResponse>): MsgUpdateParamsResponse {
    const message = createBaseMsgUpdateParamsResponse();
    return message;
  },
};

function createBaseMsgSlashValidator(): MsgSlashValidator {
  return { authority: "", validatorAddress: "", reason: 0, infractionHeight: Long.ZERO, evidence: "" };
}

export const MsgSlashValidator: MessageFns<MsgSlashValidator, "virtengine.staking.v1.MsgSlashValidator"> = {
  $type: "virtengine.staking.v1.MsgSlashValidator" as const,

  encode(message: MsgSlashValidator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (message.reason !== 0) {
      writer.uint32(24).int32(message.reason);
    }
    if (!message.infractionHeight.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.infractionHeight.toString());
    }
    if (message.evidence !== "") {
      writer.uint32(42).string(message.evidence);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSlashValidator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSlashValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.infractionHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.evidence = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgSlashValidator {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      reason: isSet(object.reason) ? slashReasonFromJSON(object.reason) : 0,
      infractionHeight: isSet(object.infraction_height) ? Long.fromValue(object.infraction_height) : Long.ZERO,
      evidence: isSet(object.evidence) ? globalThis.String(object.evidence) : "",
    };
  },

  toJSON(message: MsgSlashValidator): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (message.reason !== 0) {
      obj.reason = slashReasonToJSON(message.reason);
    }
    if (!message.infractionHeight.equals(Long.ZERO)) {
      obj.infraction_height = (message.infractionHeight || Long.ZERO).toString();
    }
    if (message.evidence !== "") {
      obj.evidence = message.evidence;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgSlashValidator>): MsgSlashValidator {
    const message = createBaseMsgSlashValidator();
    message.authority = object.authority ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.reason = object.reason ?? 0;
    message.infractionHeight = (object.infractionHeight !== undefined && object.infractionHeight !== null)
      ? Long.fromValue(object.infractionHeight)
      : Long.ZERO;
    message.evidence = object.evidence ?? "";
    return message;
  },
};

function createBaseMsgSlashValidatorResponse(): MsgSlashValidatorResponse {
  return {};
}

export const MsgSlashValidatorResponse: MessageFns<
  MsgSlashValidatorResponse,
  "virtengine.staking.v1.MsgSlashValidatorResponse"
> = {
  $type: "virtengine.staking.v1.MsgSlashValidatorResponse" as const,

  encode(_: MsgSlashValidatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgSlashValidatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgSlashValidatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgSlashValidatorResponse {
    return {};
  },

  toJSON(_: MsgSlashValidatorResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgSlashValidatorResponse>): MsgSlashValidatorResponse {
    const message = createBaseMsgSlashValidatorResponse();
    return message;
  },
};

function createBaseMsgUnjailValidator(): MsgUnjailValidator {
  return { validatorAddress: "" };
}

export const MsgUnjailValidator: MessageFns<MsgUnjailValidator, "virtengine.staking.v1.MsgUnjailValidator"> = {
  $type: "virtengine.staking.v1.MsgUnjailValidator" as const,

  encode(message: MsgUnjailValidator, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.validatorAddress !== "") {
      writer.uint32(10).string(message.validatorAddress);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnjailValidator {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnjailValidator();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgUnjailValidator {
    return { validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "" };
  },

  toJSON(message: MsgUnjailValidator): unknown {
    const obj: any = {};
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgUnjailValidator>): MsgUnjailValidator {
    const message = createBaseMsgUnjailValidator();
    message.validatorAddress = object.validatorAddress ?? "";
    return message;
  },
};

function createBaseMsgUnjailValidatorResponse(): MsgUnjailValidatorResponse {
  return {};
}

export const MsgUnjailValidatorResponse: MessageFns<
  MsgUnjailValidatorResponse,
  "virtengine.staking.v1.MsgUnjailValidatorResponse"
> = {
  $type: "virtengine.staking.v1.MsgUnjailValidatorResponse" as const,

  encode(_: MsgUnjailValidatorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgUnjailValidatorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgUnjailValidatorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgUnjailValidatorResponse {
    return {};
  },

  toJSON(_: MsgUnjailValidatorResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgUnjailValidatorResponse>): MsgUnjailValidatorResponse {
    const message = createBaseMsgUnjailValidatorResponse();
    return message;
  },
};

function createBaseMsgRecordPerformance(): MsgRecordPerformance {
  return {
    authority: "",
    validatorAddress: "",
    blocksProposed: Long.ZERO,
    blocksSigned: Long.ZERO,
    veidVerificationsCompleted: Long.ZERO,
    veidVerificationScore: Long.ZERO,
  };
}

export const MsgRecordPerformance: MessageFns<MsgRecordPerformance, "virtengine.staking.v1.MsgRecordPerformance"> = {
  $type: "virtengine.staking.v1.MsgRecordPerformance" as const,

  encode(message: MsgRecordPerformance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.authority !== "") {
      writer.uint32(10).string(message.authority);
    }
    if (message.validatorAddress !== "") {
      writer.uint32(18).string(message.validatorAddress);
    }
    if (!message.blocksProposed.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.blocksProposed.toString());
    }
    if (!message.blocksSigned.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.blocksSigned.toString());
    }
    if (!message.veidVerificationsCompleted.equals(Long.ZERO)) {
      writer.uint32(40).int64(message.veidVerificationsCompleted.toString());
    }
    if (!message.veidVerificationScore.equals(Long.ZERO)) {
      writer.uint32(48).int64(message.veidVerificationScore.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRecordPerformance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRecordPerformance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.authority = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.validatorAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.blocksProposed = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.blocksSigned = Long.fromString(reader.int64().toString());
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.veidVerificationsCompleted = Long.fromString(reader.int64().toString());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.veidVerificationScore = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MsgRecordPerformance {
    return {
      authority: isSet(object.authority) ? globalThis.String(object.authority) : "",
      validatorAddress: isSet(object.validator_address) ? globalThis.String(object.validator_address) : "",
      blocksProposed: isSet(object.blocks_proposed) ? Long.fromValue(object.blocks_proposed) : Long.ZERO,
      blocksSigned: isSet(object.blocks_signed) ? Long.fromValue(object.blocks_signed) : Long.ZERO,
      veidVerificationsCompleted: isSet(object.veid_verifications_completed)
        ? Long.fromValue(object.veid_verifications_completed)
        : Long.ZERO,
      veidVerificationScore: isSet(object.veid_verification_score)
        ? Long.fromValue(object.veid_verification_score)
        : Long.ZERO,
    };
  },

  toJSON(message: MsgRecordPerformance): unknown {
    const obj: any = {};
    if (message.authority !== "") {
      obj.authority = message.authority;
    }
    if (message.validatorAddress !== "") {
      obj.validator_address = message.validatorAddress;
    }
    if (!message.blocksProposed.equals(Long.ZERO)) {
      obj.blocks_proposed = (message.blocksProposed || Long.ZERO).toString();
    }
    if (!message.blocksSigned.equals(Long.ZERO)) {
      obj.blocks_signed = (message.blocksSigned || Long.ZERO).toString();
    }
    if (!message.veidVerificationsCompleted.equals(Long.ZERO)) {
      obj.veid_verifications_completed = (message.veidVerificationsCompleted || Long.ZERO).toString();
    }
    if (!message.veidVerificationScore.equals(Long.ZERO)) {
      obj.veid_verification_score = (message.veidVerificationScore || Long.ZERO).toString();
    }
    return obj;
  },
  fromPartial(object: DeepPartial<MsgRecordPerformance>): MsgRecordPerformance {
    const message = createBaseMsgRecordPerformance();
    message.authority = object.authority ?? "";
    message.validatorAddress = object.validatorAddress ?? "";
    message.blocksProposed = (object.blocksProposed !== undefined && object.blocksProposed !== null)
      ? Long.fromValue(object.blocksProposed)
      : Long.ZERO;
    message.blocksSigned = (object.blocksSigned !== undefined && object.blocksSigned !== null)
      ? Long.fromValue(object.blocksSigned)
      : Long.ZERO;
    message.veidVerificationsCompleted =
      (object.veidVerificationsCompleted !== undefined && object.veidVerificationsCompleted !== null)
        ? Long.fromValue(object.veidVerificationsCompleted)
        : Long.ZERO;
    message.veidVerificationScore =
      (object.veidVerificationScore !== undefined && object.veidVerificationScore !== null)
        ? Long.fromValue(object.veidVerificationScore)
        : Long.ZERO;
    return message;
  },
};

function createBaseMsgRecordPerformanceResponse(): MsgRecordPerformanceResponse {
  return {};
}

export const MsgRecordPerformanceResponse: MessageFns<
  MsgRecordPerformanceResponse,
  "virtengine.staking.v1.MsgRecordPerformanceResponse"
> = {
  $type: "virtengine.staking.v1.MsgRecordPerformanceResponse" as const,

  encode(_: MsgRecordPerformanceResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MsgRecordPerformanceResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMsgRecordPerformanceResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MsgRecordPerformanceResponse {
    return {};
  },

  toJSON(_: MsgRecordPerformanceResponse): unknown {
    const obj: any = {};
    return obj;
  },
  fromPartial(_: DeepPartial<MsgRecordPerformanceResponse>): MsgRecordPerformanceResponse {
    const message = createBaseMsgRecordPerformanceResponse();
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
