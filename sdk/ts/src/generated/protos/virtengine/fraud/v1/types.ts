import { bytesFromBase64, base64FromBytes, toTimestamp, fromTimestamp, fromJsonTimestamp, numberToLong, isSet } from "../../../../../encoding/typeEncodingHelpers.ts"
import type { DeepPartial, MessageFns } from "../../../../../encoding/typeEncodingHelpers.ts"
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/fraud/v1/types.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** FraudReportStatus represents the state of a fraud report */
export enum FraudReportStatus {
  /** FRAUD_REPORT_STATUS_UNSPECIFIED - FRAUD_REPORT_STATUS_UNSPECIFIED represents an unspecified status */
  FRAUD_REPORT_STATUS_UNSPECIFIED = 0,
  /** FRAUD_REPORT_STATUS_SUBMITTED - FRAUD_REPORT_STATUS_SUBMITTED indicates the report has been submitted and is awaiting review */
  FRAUD_REPORT_STATUS_SUBMITTED = 1,
  /** FRAUD_REPORT_STATUS_REVIEWING - FRAUD_REPORT_STATUS_REVIEWING indicates a moderator is actively reviewing the report */
  FRAUD_REPORT_STATUS_REVIEWING = 2,
  /** FRAUD_REPORT_STATUS_RESOLVED - FRAUD_REPORT_STATUS_RESOLVED indicates the report has been resolved (action taken) */
  FRAUD_REPORT_STATUS_RESOLVED = 3,
  /** FRAUD_REPORT_STATUS_REJECTED - FRAUD_REPORT_STATUS_REJECTED indicates the report was rejected (no fraud found) */
  FRAUD_REPORT_STATUS_REJECTED = 4,
  /** FRAUD_REPORT_STATUS_ESCALATED - FRAUD_REPORT_STATUS_ESCALATED indicates the report has been escalated to admin */
  FRAUD_REPORT_STATUS_ESCALATED = 5,
  UNRECOGNIZED = -1,
}

export function fraudReportStatusFromJSON(object: any): FraudReportStatus {
  switch (object) {
    case 0:
    case "FRAUD_REPORT_STATUS_UNSPECIFIED":
      return FraudReportStatus.FRAUD_REPORT_STATUS_UNSPECIFIED;
    case 1:
    case "FRAUD_REPORT_STATUS_SUBMITTED":
      return FraudReportStatus.FRAUD_REPORT_STATUS_SUBMITTED;
    case 2:
    case "FRAUD_REPORT_STATUS_REVIEWING":
      return FraudReportStatus.FRAUD_REPORT_STATUS_REVIEWING;
    case 3:
    case "FRAUD_REPORT_STATUS_RESOLVED":
      return FraudReportStatus.FRAUD_REPORT_STATUS_RESOLVED;
    case 4:
    case "FRAUD_REPORT_STATUS_REJECTED":
      return FraudReportStatus.FRAUD_REPORT_STATUS_REJECTED;
    case 5:
    case "FRAUD_REPORT_STATUS_ESCALATED":
      return FraudReportStatus.FRAUD_REPORT_STATUS_ESCALATED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FraudReportStatus.UNRECOGNIZED;
  }
}

export function fraudReportStatusToJSON(object: FraudReportStatus): string {
  switch (object) {
    case FraudReportStatus.FRAUD_REPORT_STATUS_UNSPECIFIED:
      return "FRAUD_REPORT_STATUS_UNSPECIFIED";
    case FraudReportStatus.FRAUD_REPORT_STATUS_SUBMITTED:
      return "FRAUD_REPORT_STATUS_SUBMITTED";
    case FraudReportStatus.FRAUD_REPORT_STATUS_REVIEWING:
      return "FRAUD_REPORT_STATUS_REVIEWING";
    case FraudReportStatus.FRAUD_REPORT_STATUS_RESOLVED:
      return "FRAUD_REPORT_STATUS_RESOLVED";
    case FraudReportStatus.FRAUD_REPORT_STATUS_REJECTED:
      return "FRAUD_REPORT_STATUS_REJECTED";
    case FraudReportStatus.FRAUD_REPORT_STATUS_ESCALATED:
      return "FRAUD_REPORT_STATUS_ESCALATED";
    case FraudReportStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** FraudCategory represents the category of fraud being reported */
export enum FraudCategory {
  /** FRAUD_CATEGORY_UNSPECIFIED - FRAUD_CATEGORY_UNSPECIFIED represents an unspecified category */
  FRAUD_CATEGORY_UNSPECIFIED = 0,
  /** FRAUD_CATEGORY_FAKE_IDENTITY - FRAUD_CATEGORY_FAKE_IDENTITY indicates fake or stolen identity */
  FRAUD_CATEGORY_FAKE_IDENTITY = 1,
  /** FRAUD_CATEGORY_PAYMENT_FRAUD - FRAUD_CATEGORY_PAYMENT_FRAUD indicates payment-related fraud */
  FRAUD_CATEGORY_PAYMENT_FRAUD = 2,
  /** FRAUD_CATEGORY_SERVICE_MISREPRESENTATION - FRAUD_CATEGORY_SERVICE_MISREPRESENTATION indicates misrepresented services */
  FRAUD_CATEGORY_SERVICE_MISREPRESENTATION = 3,
  /** FRAUD_CATEGORY_RESOURCE_ABUSE - FRAUD_CATEGORY_RESOURCE_ABUSE indicates abuse of allocated resources */
  FRAUD_CATEGORY_RESOURCE_ABUSE = 4,
  /** FRAUD_CATEGORY_SYBIL_ATTACK - FRAUD_CATEGORY_SYBIL_ATTACK indicates suspected sybil attack */
  FRAUD_CATEGORY_SYBIL_ATTACK = 5,
  /** FRAUD_CATEGORY_MALICIOUS_CONTENT - FRAUD_CATEGORY_MALICIOUS_CONTENT indicates malicious content or software */
  FRAUD_CATEGORY_MALICIOUS_CONTENT = 6,
  /** FRAUD_CATEGORY_TERMS_VIOLATION - FRAUD_CATEGORY_TERMS_VIOLATION indicates terms of service violation */
  FRAUD_CATEGORY_TERMS_VIOLATION = 7,
  /** FRAUD_CATEGORY_OTHER - FRAUD_CATEGORY_OTHER indicates other fraud types */
  FRAUD_CATEGORY_OTHER = 8,
  UNRECOGNIZED = -1,
}

export function fraudCategoryFromJSON(object: any): FraudCategory {
  switch (object) {
    case 0:
    case "FRAUD_CATEGORY_UNSPECIFIED":
      return FraudCategory.FRAUD_CATEGORY_UNSPECIFIED;
    case 1:
    case "FRAUD_CATEGORY_FAKE_IDENTITY":
      return FraudCategory.FRAUD_CATEGORY_FAKE_IDENTITY;
    case 2:
    case "FRAUD_CATEGORY_PAYMENT_FRAUD":
      return FraudCategory.FRAUD_CATEGORY_PAYMENT_FRAUD;
    case 3:
    case "FRAUD_CATEGORY_SERVICE_MISREPRESENTATION":
      return FraudCategory.FRAUD_CATEGORY_SERVICE_MISREPRESENTATION;
    case 4:
    case "FRAUD_CATEGORY_RESOURCE_ABUSE":
      return FraudCategory.FRAUD_CATEGORY_RESOURCE_ABUSE;
    case 5:
    case "FRAUD_CATEGORY_SYBIL_ATTACK":
      return FraudCategory.FRAUD_CATEGORY_SYBIL_ATTACK;
    case 6:
    case "FRAUD_CATEGORY_MALICIOUS_CONTENT":
      return FraudCategory.FRAUD_CATEGORY_MALICIOUS_CONTENT;
    case 7:
    case "FRAUD_CATEGORY_TERMS_VIOLATION":
      return FraudCategory.FRAUD_CATEGORY_TERMS_VIOLATION;
    case 8:
    case "FRAUD_CATEGORY_OTHER":
      return FraudCategory.FRAUD_CATEGORY_OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FraudCategory.UNRECOGNIZED;
  }
}

export function fraudCategoryToJSON(object: FraudCategory): string {
  switch (object) {
    case FraudCategory.FRAUD_CATEGORY_UNSPECIFIED:
      return "FRAUD_CATEGORY_UNSPECIFIED";
    case FraudCategory.FRAUD_CATEGORY_FAKE_IDENTITY:
      return "FRAUD_CATEGORY_FAKE_IDENTITY";
    case FraudCategory.FRAUD_CATEGORY_PAYMENT_FRAUD:
      return "FRAUD_CATEGORY_PAYMENT_FRAUD";
    case FraudCategory.FRAUD_CATEGORY_SERVICE_MISREPRESENTATION:
      return "FRAUD_CATEGORY_SERVICE_MISREPRESENTATION";
    case FraudCategory.FRAUD_CATEGORY_RESOURCE_ABUSE:
      return "FRAUD_CATEGORY_RESOURCE_ABUSE";
    case FraudCategory.FRAUD_CATEGORY_SYBIL_ATTACK:
      return "FRAUD_CATEGORY_SYBIL_ATTACK";
    case FraudCategory.FRAUD_CATEGORY_MALICIOUS_CONTENT:
      return "FRAUD_CATEGORY_MALICIOUS_CONTENT";
    case FraudCategory.FRAUD_CATEGORY_TERMS_VIOLATION:
      return "FRAUD_CATEGORY_TERMS_VIOLATION";
    case FraudCategory.FRAUD_CATEGORY_OTHER:
      return "FRAUD_CATEGORY_OTHER";
    case FraudCategory.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** ResolutionType represents the type of resolution for a fraud report */
export enum ResolutionType {
  /** RESOLUTION_TYPE_UNSPECIFIED - RESOLUTION_TYPE_UNSPECIFIED represents no resolution yet */
  RESOLUTION_TYPE_UNSPECIFIED = 0,
  /** RESOLUTION_TYPE_WARNING - RESOLUTION_TYPE_WARNING indicates a warning was issued */
  RESOLUTION_TYPE_WARNING = 1,
  /** RESOLUTION_TYPE_SUSPENSION - RESOLUTION_TYPE_SUSPENSION indicates account suspension */
  RESOLUTION_TYPE_SUSPENSION = 2,
  /** RESOLUTION_TYPE_TERMINATION - RESOLUTION_TYPE_TERMINATION indicates account termination */
  RESOLUTION_TYPE_TERMINATION = 3,
  /** RESOLUTION_TYPE_REFUND - RESOLUTION_TYPE_REFUND indicates a refund was processed */
  RESOLUTION_TYPE_REFUND = 4,
  /** RESOLUTION_TYPE_NO_ACTION - RESOLUTION_TYPE_NO_ACTION indicates no action taken (rejected) */
  RESOLUTION_TYPE_NO_ACTION = 5,
  UNRECOGNIZED = -1,
}

export function resolutionTypeFromJSON(object: any): ResolutionType {
  switch (object) {
    case 0:
    case "RESOLUTION_TYPE_UNSPECIFIED":
      return ResolutionType.RESOLUTION_TYPE_UNSPECIFIED;
    case 1:
    case "RESOLUTION_TYPE_WARNING":
      return ResolutionType.RESOLUTION_TYPE_WARNING;
    case 2:
    case "RESOLUTION_TYPE_SUSPENSION":
      return ResolutionType.RESOLUTION_TYPE_SUSPENSION;
    case 3:
    case "RESOLUTION_TYPE_TERMINATION":
      return ResolutionType.RESOLUTION_TYPE_TERMINATION;
    case 4:
    case "RESOLUTION_TYPE_REFUND":
      return ResolutionType.RESOLUTION_TYPE_REFUND;
    case 5:
    case "RESOLUTION_TYPE_NO_ACTION":
      return ResolutionType.RESOLUTION_TYPE_NO_ACTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ResolutionType.UNRECOGNIZED;
  }
}

export function resolutionTypeToJSON(object: ResolutionType): string {
  switch (object) {
    case ResolutionType.RESOLUTION_TYPE_UNSPECIFIED:
      return "RESOLUTION_TYPE_UNSPECIFIED";
    case ResolutionType.RESOLUTION_TYPE_WARNING:
      return "RESOLUTION_TYPE_WARNING";
    case ResolutionType.RESOLUTION_TYPE_SUSPENSION:
      return "RESOLUTION_TYPE_SUSPENSION";
    case ResolutionType.RESOLUTION_TYPE_TERMINATION:
      return "RESOLUTION_TYPE_TERMINATION";
    case ResolutionType.RESOLUTION_TYPE_REFUND:
      return "RESOLUTION_TYPE_REFUND";
    case ResolutionType.RESOLUTION_TYPE_NO_ACTION:
      return "RESOLUTION_TYPE_NO_ACTION";
    case ResolutionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** AuditAction represents the type of action recorded in the audit log */
export enum AuditAction {
  /** AUDIT_ACTION_UNSPECIFIED - AUDIT_ACTION_UNSPECIFIED represents an unspecified action */
  AUDIT_ACTION_UNSPECIFIED = 0,
  /** AUDIT_ACTION_SUBMITTED - AUDIT_ACTION_SUBMITTED indicates report was submitted */
  AUDIT_ACTION_SUBMITTED = 1,
  /** AUDIT_ACTION_ASSIGNED - AUDIT_ACTION_ASSIGNED indicates report was assigned to moderator */
  AUDIT_ACTION_ASSIGNED = 2,
  /** AUDIT_ACTION_STATUS_CHANGED - AUDIT_ACTION_STATUS_CHANGED indicates status was changed */
  AUDIT_ACTION_STATUS_CHANGED = 3,
  /** AUDIT_ACTION_EVIDENCE_VIEWED - AUDIT_ACTION_EVIDENCE_VIEWED indicates evidence was viewed by moderator */
  AUDIT_ACTION_EVIDENCE_VIEWED = 4,
  /** AUDIT_ACTION_RESOLVED - AUDIT_ACTION_RESOLVED indicates report was resolved */
  AUDIT_ACTION_RESOLVED = 5,
  /** AUDIT_ACTION_REJECTED - AUDIT_ACTION_REJECTED indicates report was rejected */
  AUDIT_ACTION_REJECTED = 6,
  /** AUDIT_ACTION_ESCALATED - AUDIT_ACTION_ESCALATED indicates report was escalated */
  AUDIT_ACTION_ESCALATED = 7,
  /** AUDIT_ACTION_COMMENT_ADDED - AUDIT_ACTION_COMMENT_ADDED indicates a comment was added */
  AUDIT_ACTION_COMMENT_ADDED = 8,
  UNRECOGNIZED = -1,
}

export function auditActionFromJSON(object: any): AuditAction {
  switch (object) {
    case 0:
    case "AUDIT_ACTION_UNSPECIFIED":
      return AuditAction.AUDIT_ACTION_UNSPECIFIED;
    case 1:
    case "AUDIT_ACTION_SUBMITTED":
      return AuditAction.AUDIT_ACTION_SUBMITTED;
    case 2:
    case "AUDIT_ACTION_ASSIGNED":
      return AuditAction.AUDIT_ACTION_ASSIGNED;
    case 3:
    case "AUDIT_ACTION_STATUS_CHANGED":
      return AuditAction.AUDIT_ACTION_STATUS_CHANGED;
    case 4:
    case "AUDIT_ACTION_EVIDENCE_VIEWED":
      return AuditAction.AUDIT_ACTION_EVIDENCE_VIEWED;
    case 5:
    case "AUDIT_ACTION_RESOLVED":
      return AuditAction.AUDIT_ACTION_RESOLVED;
    case 6:
    case "AUDIT_ACTION_REJECTED":
      return AuditAction.AUDIT_ACTION_REJECTED;
    case 7:
    case "AUDIT_ACTION_ESCALATED":
      return AuditAction.AUDIT_ACTION_ESCALATED;
    case 8:
    case "AUDIT_ACTION_COMMENT_ADDED":
      return AuditAction.AUDIT_ACTION_COMMENT_ADDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AuditAction.UNRECOGNIZED;
  }
}

export function auditActionToJSON(object: AuditAction): string {
  switch (object) {
    case AuditAction.AUDIT_ACTION_UNSPECIFIED:
      return "AUDIT_ACTION_UNSPECIFIED";
    case AuditAction.AUDIT_ACTION_SUBMITTED:
      return "AUDIT_ACTION_SUBMITTED";
    case AuditAction.AUDIT_ACTION_ASSIGNED:
      return "AUDIT_ACTION_ASSIGNED";
    case AuditAction.AUDIT_ACTION_STATUS_CHANGED:
      return "AUDIT_ACTION_STATUS_CHANGED";
    case AuditAction.AUDIT_ACTION_EVIDENCE_VIEWED:
      return "AUDIT_ACTION_EVIDENCE_VIEWED";
    case AuditAction.AUDIT_ACTION_RESOLVED:
      return "AUDIT_ACTION_RESOLVED";
    case AuditAction.AUDIT_ACTION_REJECTED:
      return "AUDIT_ACTION_REJECTED";
    case AuditAction.AUDIT_ACTION_ESCALATED:
      return "AUDIT_ACTION_ESCALATED";
    case AuditAction.AUDIT_ACTION_COMMENT_ADDED:
      return "AUDIT_ACTION_COMMENT_ADDED";
    case AuditAction.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** EncryptedEvidence holds encrypted evidence for a fraud report */
export interface EncryptedEvidence {
  /** AlgorithmID identifies the encryption algorithm used */
  algorithmId: string;
  /** RecipientKeyIDs are the fingerprints of moderator public keys */
  recipientKeyIds: string[];
  /** EncryptedKeys contains the data encryption key encrypted for each recipient */
  encryptedKeys: Uint8Array[];
  /** Nonce is the initialization vector for encryption */
  nonce: Uint8Array;
  /** Ciphertext is the encrypted evidence data */
  ciphertext: Uint8Array;
  /** SenderSignature is the signature for authenticity verification */
  senderSignature: Uint8Array;
  /** SenderPubKey is the sender's public key */
  senderPubKey: Uint8Array;
  /** ContentType indicates the type of evidence (e.g., "image/png", "application/json") */
  contentType: string;
  /** EvidenceHash is SHA256 hash of the original evidence for integrity verification */
  evidenceHash: string;
}

/** FraudReport represents a fraud report submitted by a provider */
export interface FraudReport {
  /** ID is the unique identifier for this report */
  id: string;
  /** Reporter is the provider address who submitted the report */
  reporter: string;
  /** ReportedParty is the address of the party being reported */
  reportedParty: string;
  /** Category is the type of fraud being reported */
  category: FraudCategory;
  /** Description is the detailed description of the fraud */
  description: string;
  /** Evidence contains the encrypted evidence attachments */
  evidence: EncryptedEvidence[];
  /** Status is the current status of the report */
  status: FraudReportStatus;
  /** AssignedModerator is the moderator assigned to review this report */
  assignedModerator: string;
  /** Resolution is the resolution type if resolved */
  resolution: ResolutionType;
  /** ResolutionNotes are notes provided by the moderator upon resolution */
  resolutionNotes: string;
  /** SubmittedAt is when the report was submitted */
  submittedAt:
    | Date
    | undefined;
  /** UpdatedAt is when the report was last updated */
  updatedAt:
    | Date
    | undefined;
  /** ResolvedAt is when the report was resolved (if applicable) */
  resolvedAt:
    | Date
    | undefined;
  /** BlockHeight is the block height when submitted */
  blockHeight: Long;
  /** ContentHash is SHA256 hash of the report content for integrity */
  contentHash: string;
  /** RelatedOrderIDs are order IDs related to this fraud report */
  relatedOrderIds: string[];
}

/** FraudAuditLog represents an audit log entry for a fraud report */
export interface FraudAuditLog {
  /** ID is the unique identifier for this log entry */
  id: string;
  /** ReportID is the associated fraud report ID */
  reportId: string;
  /** Action is the type of action performed */
  action: AuditAction;
  /** Actor is the address that performed the action */
  actor: string;
  /** PreviousStatus is the status before the action (if applicable) */
  previousStatus: FraudReportStatus;
  /** NewStatus is the status after the action (if applicable) */
  newStatus: FraudReportStatus;
  /** Details contains additional action-specific details */
  details: string;
  /** Timestamp is when the action was performed */
  timestamp:
    | Date
    | undefined;
  /** BlockHeight is the block height when the action occurred */
  blockHeight: Long;
  /** TxHash is the transaction hash (if applicable) */
  txHash: string;
}

/** ModeratorQueueEntry represents an entry in the moderator queue */
export interface ModeratorQueueEntry {
  /** ReportID is the fraud report ID */
  reportId: string;
  /** Priority is the queue priority (higher = more urgent) */
  priority: number;
  /** QueuedAt is when the report was added to the queue */
  queuedAt:
    | Date
    | undefined;
  /** Category is the fraud category for routing */
  category: FraudCategory;
  /** AssignedTo is the moderator assigned (empty if unassigned) */
  assignedTo: string;
}

function createBaseEncryptedEvidence(): EncryptedEvidence {
  return {
    algorithmId: "",
    recipientKeyIds: [],
    encryptedKeys: [],
    nonce: new Uint8Array(0),
    ciphertext: new Uint8Array(0),
    senderSignature: new Uint8Array(0),
    senderPubKey: new Uint8Array(0),
    contentType: "",
    evidenceHash: "",
  };
}

export const EncryptedEvidence: MessageFns<EncryptedEvidence, "virtengine.fraud.v1.EncryptedEvidence"> = {
  $type: "virtengine.fraud.v1.EncryptedEvidence" as const,

  encode(message: EncryptedEvidence, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.algorithmId !== "") {
      writer.uint32(10).string(message.algorithmId);
    }
    for (const v of message.recipientKeyIds) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.encryptedKeys) {
      writer.uint32(26).bytes(v!);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(34).bytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      writer.uint32(42).bytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      writer.uint32(50).bytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      writer.uint32(58).bytes(message.senderPubKey);
    }
    if (message.contentType !== "") {
      writer.uint32(66).string(message.contentType);
    }
    if (message.evidenceHash !== "") {
      writer.uint32(74).string(message.evidenceHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EncryptedEvidence {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEncryptedEvidence();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.algorithmId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.recipientKeyIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.encryptedKeys.push(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ciphertext = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.senderSignature = reader.bytes();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.senderPubKey = reader.bytes();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.evidenceHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EncryptedEvidence {
    return {
      algorithmId: isSet(object.algorithm_id) ? globalThis.String(object.algorithm_id) : "",
      recipientKeyIds: globalThis.Array.isArray(object?.recipient_key_ids)
        ? object.recipient_key_ids.map((e: any) => globalThis.String(e))
        : [],
      encryptedKeys: globalThis.Array.isArray(object?.encrypted_keys)
        ? object.encrypted_keys.map((e: any) => bytesFromBase64(e))
        : [],
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
      ciphertext: isSet(object.ciphertext) ? bytesFromBase64(object.ciphertext) : new Uint8Array(0),
      senderSignature: isSet(object.sender_signature) ? bytesFromBase64(object.sender_signature) : new Uint8Array(0),
      senderPubKey: isSet(object.sender_pub_key) ? bytesFromBase64(object.sender_pub_key) : new Uint8Array(0),
      contentType: isSet(object.content_type) ? globalThis.String(object.content_type) : "",
      evidenceHash: isSet(object.evidence_hash) ? globalThis.String(object.evidence_hash) : "",
    };
  },

  toJSON(message: EncryptedEvidence): unknown {
    const obj: any = {};
    if (message.algorithmId !== "") {
      obj.algorithm_id = message.algorithmId;
    }
    if (message.recipientKeyIds?.length) {
      obj.recipient_key_ids = message.recipientKeyIds;
    }
    if (message.encryptedKeys?.length) {
      obj.encrypted_keys = message.encryptedKeys.map((e) => base64FromBytes(e));
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    if (message.ciphertext.length !== 0) {
      obj.ciphertext = base64FromBytes(message.ciphertext);
    }
    if (message.senderSignature.length !== 0) {
      obj.sender_signature = base64FromBytes(message.senderSignature);
    }
    if (message.senderPubKey.length !== 0) {
      obj.sender_pub_key = base64FromBytes(message.senderPubKey);
    }
    if (message.contentType !== "") {
      obj.content_type = message.contentType;
    }
    if (message.evidenceHash !== "") {
      obj.evidence_hash = message.evidenceHash;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<EncryptedEvidence>): EncryptedEvidence {
    const message = createBaseEncryptedEvidence();
    message.algorithmId = object.algorithmId ?? "";
    message.recipientKeyIds = object.recipientKeyIds?.map((e) => e) || [];
    message.encryptedKeys = object.encryptedKeys?.map((e) => e) || [];
    message.nonce = object.nonce ?? new Uint8Array(0);
    message.ciphertext = object.ciphertext ?? new Uint8Array(0);
    message.senderSignature = object.senderSignature ?? new Uint8Array(0);
    message.senderPubKey = object.senderPubKey ?? new Uint8Array(0);
    message.contentType = object.contentType ?? "";
    message.evidenceHash = object.evidenceHash ?? "";
    return message;
  },
};

function createBaseFraudReport(): FraudReport {
  return {
    id: "",
    reporter: "",
    reportedParty: "",
    category: 0,
    description: "",
    evidence: [],
    status: 0,
    assignedModerator: "",
    resolution: 0,
    resolutionNotes: "",
    submittedAt: undefined,
    updatedAt: undefined,
    resolvedAt: undefined,
    blockHeight: Long.ZERO,
    contentHash: "",
    relatedOrderIds: [],
  };
}

export const FraudReport: MessageFns<FraudReport, "virtengine.fraud.v1.FraudReport"> = {
  $type: "virtengine.fraud.v1.FraudReport" as const,

  encode(message: FraudReport, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reporter !== "") {
      writer.uint32(18).string(message.reporter);
    }
    if (message.reportedParty !== "") {
      writer.uint32(26).string(message.reportedParty);
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.description !== "") {
      writer.uint32(42).string(message.description);
    }
    for (const v of message.evidence) {
      EncryptedEvidence.encode(v!, writer.uint32(50).fork()).join();
    }
    if (message.status !== 0) {
      writer.uint32(56).int32(message.status);
    }
    if (message.assignedModerator !== "") {
      writer.uint32(66).string(message.assignedModerator);
    }
    if (message.resolution !== 0) {
      writer.uint32(72).int32(message.resolution);
    }
    if (message.resolutionNotes !== "") {
      writer.uint32(82).string(message.resolutionNotes);
    }
    if (message.submittedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.submittedAt), writer.uint32(90).fork()).join();
    }
    if (message.updatedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.updatedAt), writer.uint32(98).fork()).join();
    }
    if (message.resolvedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.resolvedAt), writer.uint32(106).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(112).int64(message.blockHeight.toString());
    }
    if (message.contentHash !== "") {
      writer.uint32(122).string(message.contentHash);
    }
    for (const v of message.relatedOrderIds) {
      writer.uint32(130).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudReport {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudReport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reporter = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.reportedParty = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.evidence.push(EncryptedEvidence.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.assignedModerator = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.resolution = reader.int32() as any;
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.resolutionNotes = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.submittedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.updatedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.resolvedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.contentHash = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.relatedOrderIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudReport {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reporter: isSet(object.reporter) ? globalThis.String(object.reporter) : "",
      reportedParty: isSet(object.reported_party) ? globalThis.String(object.reported_party) : "",
      category: isSet(object.category) ? fraudCategoryFromJSON(object.category) : 0,
      description: isSet(object.description) ? globalThis.String(object.description) : "",
      evidence: globalThis.Array.isArray(object?.evidence)
        ? object.evidence.map((e: any) => EncryptedEvidence.fromJSON(e))
        : [],
      status: isSet(object.status) ? fraudReportStatusFromJSON(object.status) : 0,
      assignedModerator: isSet(object.assigned_moderator) ? globalThis.String(object.assigned_moderator) : "",
      resolution: isSet(object.resolution) ? resolutionTypeFromJSON(object.resolution) : 0,
      resolutionNotes: isSet(object.resolution_notes) ? globalThis.String(object.resolution_notes) : "",
      submittedAt: isSet(object.submitted_at) ? fromJsonTimestamp(object.submitted_at) : undefined,
      updatedAt: isSet(object.updated_at) ? fromJsonTimestamp(object.updated_at) : undefined,
      resolvedAt: isSet(object.resolved_at) ? fromJsonTimestamp(object.resolved_at) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      contentHash: isSet(object.content_hash) ? globalThis.String(object.content_hash) : "",
      relatedOrderIds: globalThis.Array.isArray(object?.related_order_ids)
        ? object.related_order_ids.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: FraudReport): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reporter !== "") {
      obj.reporter = message.reporter;
    }
    if (message.reportedParty !== "") {
      obj.reported_party = message.reportedParty;
    }
    if (message.category !== 0) {
      obj.category = fraudCategoryToJSON(message.category);
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.evidence?.length) {
      obj.evidence = message.evidence.map((e) => EncryptedEvidence.toJSON(e));
    }
    if (message.status !== 0) {
      obj.status = fraudReportStatusToJSON(message.status);
    }
    if (message.assignedModerator !== "") {
      obj.assigned_moderator = message.assignedModerator;
    }
    if (message.resolution !== 0) {
      obj.resolution = resolutionTypeToJSON(message.resolution);
    }
    if (message.resolutionNotes !== "") {
      obj.resolution_notes = message.resolutionNotes;
    }
    if (message.submittedAt !== undefined) {
      obj.submitted_at = message.submittedAt.toISOString();
    }
    if (message.updatedAt !== undefined) {
      obj.updated_at = message.updatedAt.toISOString();
    }
    if (message.resolvedAt !== undefined) {
      obj.resolved_at = message.resolvedAt.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.contentHash !== "") {
      obj.content_hash = message.contentHash;
    }
    if (message.relatedOrderIds?.length) {
      obj.related_order_ids = message.relatedOrderIds;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FraudReport>): FraudReport {
    const message = createBaseFraudReport();
    message.id = object.id ?? "";
    message.reporter = object.reporter ?? "";
    message.reportedParty = object.reportedParty ?? "";
    message.category = object.category ?? 0;
    message.description = object.description ?? "";
    message.evidence = object.evidence?.map((e) => EncryptedEvidence.fromPartial(e)) || [];
    message.status = object.status ?? 0;
    message.assignedModerator = object.assignedModerator ?? "";
    message.resolution = object.resolution ?? 0;
    message.resolutionNotes = object.resolutionNotes ?? "";
    message.submittedAt = object.submittedAt ?? undefined;
    message.updatedAt = object.updatedAt ?? undefined;
    message.resolvedAt = object.resolvedAt ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.contentHash = object.contentHash ?? "";
    message.relatedOrderIds = object.relatedOrderIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseFraudAuditLog(): FraudAuditLog {
  return {
    id: "",
    reportId: "",
    action: 0,
    actor: "",
    previousStatus: 0,
    newStatus: 0,
    details: "",
    timestamp: undefined,
    blockHeight: Long.ZERO,
    txHash: "",
  };
}

export const FraudAuditLog: MessageFns<FraudAuditLog, "virtengine.fraud.v1.FraudAuditLog"> = {
  $type: "virtengine.fraud.v1.FraudAuditLog" as const,

  encode(message: FraudAuditLog, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.reportId !== "") {
      writer.uint32(18).string(message.reportId);
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    if (message.actor !== "") {
      writer.uint32(34).string(message.actor);
    }
    if (message.previousStatus !== 0) {
      writer.uint32(40).int32(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      writer.uint32(48).int32(message.newStatus);
    }
    if (message.details !== "") {
      writer.uint32(58).string(message.details);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(66).fork()).join();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.blockHeight.toString());
    }
    if (message.txHash !== "") {
      writer.uint32(82).string(message.txHash);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FraudAuditLog {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFraudAuditLog();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.reportId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.actor = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.previousStatus = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.newStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.details = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.blockHeight = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.txHash = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FraudAuditLog {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      reportId: isSet(object.report_id) ? globalThis.String(object.report_id) : "",
      action: isSet(object.action) ? auditActionFromJSON(object.action) : 0,
      actor: isSet(object.actor) ? globalThis.String(object.actor) : "",
      previousStatus: isSet(object.previous_status) ? fraudReportStatusFromJSON(object.previous_status) : 0,
      newStatus: isSet(object.new_status) ? fraudReportStatusFromJSON(object.new_status) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      blockHeight: isSet(object.block_height) ? Long.fromValue(object.block_height) : Long.ZERO,
      txHash: isSet(object.tx_hash) ? globalThis.String(object.tx_hash) : "",
    };
  },

  toJSON(message: FraudAuditLog): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.reportId !== "") {
      obj.report_id = message.reportId;
    }
    if (message.action !== 0) {
      obj.action = auditActionToJSON(message.action);
    }
    if (message.actor !== "") {
      obj.actor = message.actor;
    }
    if (message.previousStatus !== 0) {
      obj.previous_status = fraudReportStatusToJSON(message.previousStatus);
    }
    if (message.newStatus !== 0) {
      obj.new_status = fraudReportStatusToJSON(message.newStatus);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (!message.blockHeight.equals(Long.ZERO)) {
      obj.block_height = (message.blockHeight || Long.ZERO).toString();
    }
    if (message.txHash !== "") {
      obj.tx_hash = message.txHash;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<FraudAuditLog>): FraudAuditLog {
    const message = createBaseFraudAuditLog();
    message.id = object.id ?? "";
    message.reportId = object.reportId ?? "";
    message.action = object.action ?? 0;
    message.actor = object.actor ?? "";
    message.previousStatus = object.previousStatus ?? 0;
    message.newStatus = object.newStatus ?? 0;
    message.details = object.details ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.blockHeight = (object.blockHeight !== undefined && object.blockHeight !== null)
      ? Long.fromValue(object.blockHeight)
      : Long.ZERO;
    message.txHash = object.txHash ?? "";
    return message;
  },
};

function createBaseModeratorQueueEntry(): ModeratorQueueEntry {
  return { reportId: "", priority: 0, queuedAt: undefined, category: 0, assignedTo: "" };
}

export const ModeratorQueueEntry: MessageFns<ModeratorQueueEntry, "virtengine.fraud.v1.ModeratorQueueEntry"> = {
  $type: "virtengine.fraud.v1.ModeratorQueueEntry" as const,

  encode(message: ModeratorQueueEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reportId !== "") {
      writer.uint32(10).string(message.reportId);
    }
    if (message.priority !== 0) {
      writer.uint32(16).uint32(message.priority);
    }
    if (message.queuedAt !== undefined) {
      Timestamp.encode(toTimestamp(message.queuedAt), writer.uint32(26).fork()).join();
    }
    if (message.category !== 0) {
      writer.uint32(32).int32(message.category);
    }
    if (message.assignedTo !== "") {
      writer.uint32(42).string(message.assignedTo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModeratorQueueEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModeratorQueueEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.reportId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.queuedAt = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.category = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.assignedTo = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModeratorQueueEntry {
    return {
      reportId: isSet(object.report_id) ? globalThis.String(object.report_id) : "",
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
      queuedAt: isSet(object.queued_at) ? fromJsonTimestamp(object.queued_at) : undefined,
      category: isSet(object.category) ? fraudCategoryFromJSON(object.category) : 0,
      assignedTo: isSet(object.assigned_to) ? globalThis.String(object.assigned_to) : "",
    };
  },

  toJSON(message: ModeratorQueueEntry): unknown {
    const obj: any = {};
    if (message.reportId !== "") {
      obj.report_id = message.reportId;
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    if (message.queuedAt !== undefined) {
      obj.queued_at = message.queuedAt.toISOString();
    }
    if (message.category !== 0) {
      obj.category = fraudCategoryToJSON(message.category);
    }
    if (message.assignedTo !== "") {
      obj.assigned_to = message.assignedTo;
    }
    return obj;
  },
  fromPartial(object: DeepPartial<ModeratorQueueEntry>): ModeratorQueueEntry {
    const message = createBaseModeratorQueueEntry();
    message.reportId = object.reportId ?? "";
    message.priority = object.priority ?? 0;
    message.queuedAt = object.queuedAt ?? undefined;
    message.category = object.category ?? 0;
    message.assignedTo = object.assignedTo ?? "";
    return message;
  },
};

function _unused_bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function _unused_base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type _unused_DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function _unused_toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function _unused_fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function _unused_fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function _unused_numberToLong(number: number) {
  return Long.fromNumber(number);
}

function _unused_isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface _unused_MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
