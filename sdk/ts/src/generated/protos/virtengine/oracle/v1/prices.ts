// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               unknown
// source: virtengine/oracle/v1/prices.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { PageRequest, PageResponse } from "../../../cosmos/base/query/v1beta1/pagination.ts";
import { Timestamp } from "../../../google/protobuf/timestamp.ts";

/** DataID uniquely identifies a price pair by asset and base denomination */
export interface DataID {
  /** denom is the asset denomination (e.g., "uve") */
  denom: string;
  /** base_denom is the base denomination for the price pair (e.g., "usd") */
  baseDenom: string;
}

/** PriceDataID identifies price data from a specific source for a specific pair */
export interface PriceDataID {
  /** source is the index of the price source (oracle provider) */
  source: number;
  /** denom is the asset denomination */
  denom: string;
  /** base_denom is the base denomination for the price pair */
  baseDenom: string;
}

/**
 * PriceDataRecordID represents a price from a specific source at a specific time.
 * It also represents a single data point in TWAP history
 */
export interface PriceDataRecordID {
  /** source is the index of the price source (oracle provider) */
  source: number;
  /** denom is the asset denomination */
  denom: string;
  /** base_denom is the base denomination for the price pair */
  baseDenom: string;
  /** height is the block height when this price was recorded */
  height: Long;
}

/** PriceDataState represents the price value and timestamp for a price entry */
export interface PriceDataState {
  /** price is the decimal price value */
  price: string;
  /** timestamp is when the price was recorded */
  timestamp: Date | undefined;
}

/** PriceData combines a price record identifier with its state */
export interface PriceData {
  /** id uniquely identifies this price record */
  id:
    | PriceDataRecordID
    | undefined;
  /** state contains the price value and timestamp */
  state: PriceDataState | undefined;
}

/** AggregatedPrice represents the final aggregated price from all sources */
export interface AggregatedPrice {
  /** denom is the asset denomination */
  denom: string;
  /** twap is the time-weighted average price over the configured window */
  twap: string;
  /** median_price is the median of all source prices */
  medianPrice: string;
  /** min_price is the minimum price from all sources */
  minPrice: string;
  /** max_price is the maximum price from all sources */
  maxPrice: string;
  /** timestamp is when the aggregated price was computed */
  timestamp:
    | Date
    | undefined;
  /** num_sources is the number of price sources contributing to this aggregation */
  numSources: number;
  /** deviation_bps is the price deviation in basis points between min and max prices */
  deviationBps: Long;
}

/** PriceHealth represents the health status of a price feed */
export interface PriceHealth {
  /** denom is the asset denomination */
  denom: string;
  /** is_healthy indicates if the price feed meets all health requirements */
  isHealthy: boolean;
  /** has_min_sources indicates if minimum number of sources are reporting */
  hasMinSources: boolean;
  /** deviation_ok indicates if price deviation is within acceptable limits */
  deviationOk: boolean;
  /** total_sources indicates total amount of sources registered for price calculations */
  totalSources: number;
  /** total_healthy_sources indicates total usable sources for price calculations */
  totalHealthySources: number;
  /** failure_reason lists reasons for unhealthy status, if any */
  failureReason: string[];
}

/** PricesFilter defines filters used to query price data */
export interface PricesFilter {
  /** asset_denom is the asset denomination to filter by */
  assetDenom: string;
  /** base_denom is the base denomination to filter by */
  baseDenom: string;
  /** height is the block height to filter by */
  height: Long;
}

/** QueryPricesRequest is the request type for querying price history */
export interface QueryPricesRequest {
  /** filters holds the price fields to filter the request */
  filters:
    | PricesFilter
    | undefined;
  /** pagination is used to paginate the request */
  pagination: PageRequest | undefined;
}

/** QueryPricesResponse is the response type for querying price history */
export interface QueryPricesResponse {
  /** prices is the list of historical price data matching the filters */
  prices: PriceData[];
  /** pagination contains the information about response pagination */
  pagination: PageResponse | undefined;
}

function createBaseDataID(): DataID {
  return { denom: "", baseDenom: "" };
}

export const DataID: MessageFns<DataID, "virtengine.oracle.v1.DataID"> = {
  $type: "virtengine.oracle.v1.DataID" as const,

  encode(message: DataID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataID {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      baseDenom: isSet(object.base_denom) ? globalThis.String(object.base_denom) : "",
    };
  },

  toJSON(message: DataID): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.baseDenom !== "") {
      obj.base_denom = message.baseDenom;
    }
    return obj;
  },

  create(base?: DeepPartial<DataID>): DataID {
    return DataID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataID>): DataID {
    const message = createBaseDataID();
    message.denom = object.denom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    return message;
  },
};

function createBasePriceDataID(): PriceDataID {
  return { source: 0, denom: "", baseDenom: "" };
}

export const PriceDataID: MessageFns<PriceDataID, "virtengine.oracle.v1.PriceDataID"> = {
  $type: "virtengine.oracle.v1.PriceDataID" as const,

  encode(message: PriceDataID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== 0) {
      writer.uint32(8).uint32(message.source);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceDataID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceDataID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceDataID {
    return {
      source: isSet(object.source) ? globalThis.Number(object.source) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      baseDenom: isSet(object.base_denom) ? globalThis.String(object.base_denom) : "",
    };
  },

  toJSON(message: PriceDataID): unknown {
    const obj: any = {};
    if (message.source !== 0) {
      obj.source = Math.round(message.source);
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.baseDenom !== "") {
      obj.base_denom = message.baseDenom;
    }
    return obj;
  },

  create(base?: DeepPartial<PriceDataID>): PriceDataID {
    return PriceDataID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceDataID>): PriceDataID {
    const message = createBasePriceDataID();
    message.source = object.source ?? 0;
    message.denom = object.denom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    return message;
  },
};

function createBasePriceDataRecordID(): PriceDataRecordID {
  return { source: 0, denom: "", baseDenom: "", height: Long.ZERO };
}

export const PriceDataRecordID: MessageFns<PriceDataRecordID, "virtengine.oracle.v1.PriceDataRecordID"> = {
  $type: "virtengine.oracle.v1.PriceDataRecordID" as const,

  encode(message: PriceDataRecordID, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.source !== 0) {
      writer.uint32(8).uint32(message.source);
    }
    if (message.denom !== "") {
      writer.uint32(18).string(message.denom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(26).string(message.baseDenom);
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.height.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceDataRecordID {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceDataRecordID();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.source = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceDataRecordID {
    return {
      source: isSet(object.source) ? globalThis.Number(object.source) : 0,
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      baseDenom: isSet(object.base_denom) ? globalThis.String(object.base_denom) : "",
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
    };
  },

  toJSON(message: PriceDataRecordID): unknown {
    const obj: any = {};
    if (message.source !== 0) {
      obj.source = Math.round(message.source);
    }
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.baseDenom !== "") {
      obj.base_denom = message.baseDenom;
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PriceDataRecordID>): PriceDataRecordID {
    return PriceDataRecordID.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceDataRecordID>): PriceDataRecordID {
    const message = createBasePriceDataRecordID();
    message.source = object.source ?? 0;
    message.denom = object.denom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    return message;
  },
};

function createBasePriceDataState(): PriceDataState {
  return { price: "", timestamp: undefined };
}

export const PriceDataState: MessageFns<PriceDataState, "virtengine.oracle.v1.PriceDataState"> = {
  $type: "virtengine.oracle.v1.PriceDataState" as const,

  encode(message: PriceDataState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.price !== "") {
      writer.uint32(10).string(message.price);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceDataState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceDataState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.price = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceDataState {
    return {
      price: isSet(object.price) ? globalThis.String(object.price) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
    };
  },

  toJSON(message: PriceDataState): unknown {
    const obj: any = {};
    if (message.price !== "") {
      obj.price = message.price;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    return obj;
  },

  create(base?: DeepPartial<PriceDataState>): PriceDataState {
    return PriceDataState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceDataState>): PriceDataState {
    const message = createBasePriceDataState();
    message.price = object.price ?? "";
    message.timestamp = object.timestamp ?? undefined;
    return message;
  },
};

function createBasePriceData(): PriceData {
  return { id: undefined, state: undefined };
}

export const PriceData: MessageFns<PriceData, "virtengine.oracle.v1.PriceData"> = {
  $type: "virtengine.oracle.v1.PriceData" as const,

  encode(message: PriceData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      PriceDataRecordID.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.state !== undefined) {
      PriceDataState.encode(message.state, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = PriceDataRecordID.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.state = PriceDataState.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceData {
    return {
      id: isSet(object.id) ? PriceDataRecordID.fromJSON(object.id) : undefined,
      state: isSet(object.state) ? PriceDataState.fromJSON(object.state) : undefined,
    };
  },

  toJSON(message: PriceData): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = PriceDataRecordID.toJSON(message.id);
    }
    if (message.state !== undefined) {
      obj.state = PriceDataState.toJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<PriceData>): PriceData {
    return PriceData.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceData>): PriceData {
    const message = createBasePriceData();
    message.id = (object.id !== undefined && object.id !== null) ? PriceDataRecordID.fromPartial(object.id) : undefined;
    message.state = (object.state !== undefined && object.state !== null)
      ? PriceDataState.fromPartial(object.state)
      : undefined;
    return message;
  },
};

function createBaseAggregatedPrice(): AggregatedPrice {
  return {
    denom: "",
    twap: "",
    medianPrice: "",
    minPrice: "",
    maxPrice: "",
    timestamp: undefined,
    numSources: 0,
    deviationBps: Long.UZERO,
  };
}

export const AggregatedPrice: MessageFns<AggregatedPrice, "virtengine.oracle.v1.AggregatedPrice"> = {
  $type: "virtengine.oracle.v1.AggregatedPrice" as const,

  encode(message: AggregatedPrice, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.twap !== "") {
      writer.uint32(18).string(message.twap);
    }
    if (message.medianPrice !== "") {
      writer.uint32(26).string(message.medianPrice);
    }
    if (message.minPrice !== "") {
      writer.uint32(34).string(message.minPrice);
    }
    if (message.maxPrice !== "") {
      writer.uint32(42).string(message.maxPrice);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(50).fork()).join();
    }
    if (message.numSources !== 0) {
      writer.uint32(56).uint32(message.numSources);
    }
    if (!message.deviationBps.equals(Long.UZERO)) {
      writer.uint32(64).uint64(message.deviationBps.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AggregatedPrice {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAggregatedPrice();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.twap = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.medianPrice = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.minPrice = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.maxPrice = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.numSources = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.deviationBps = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AggregatedPrice {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      twap: isSet(object.twap) ? globalThis.String(object.twap) : "",
      medianPrice: isSet(object.median_price) ? globalThis.String(object.median_price) : "",
      minPrice: isSet(object.min_price) ? globalThis.String(object.min_price) : "",
      maxPrice: isSet(object.max_price) ? globalThis.String(object.max_price) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      numSources: isSet(object.num_sources) ? globalThis.Number(object.num_sources) : 0,
      deviationBps: isSet(object.deviation_bps) ? Long.fromValue(object.deviation_bps) : Long.UZERO,
    };
  },

  toJSON(message: AggregatedPrice): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.twap !== "") {
      obj.twap = message.twap;
    }
    if (message.medianPrice !== "") {
      obj.median_price = message.medianPrice;
    }
    if (message.minPrice !== "") {
      obj.min_price = message.minPrice;
    }
    if (message.maxPrice !== "") {
      obj.max_price = message.maxPrice;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.numSources !== 0) {
      obj.num_sources = Math.round(message.numSources);
    }
    if (!message.deviationBps.equals(Long.UZERO)) {
      obj.deviation_bps = (message.deviationBps || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<AggregatedPrice>): AggregatedPrice {
    return AggregatedPrice.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AggregatedPrice>): AggregatedPrice {
    const message = createBaseAggregatedPrice();
    message.denom = object.denom ?? "";
    message.twap = object.twap ?? "";
    message.medianPrice = object.medianPrice ?? "";
    message.minPrice = object.minPrice ?? "";
    message.maxPrice = object.maxPrice ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.numSources = object.numSources ?? 0;
    message.deviationBps = (object.deviationBps !== undefined && object.deviationBps !== null)
      ? Long.fromValue(object.deviationBps)
      : Long.UZERO;
    return message;
  },
};

function createBasePriceHealth(): PriceHealth {
  return {
    denom: "",
    isHealthy: false,
    hasMinSources: false,
    deviationOk: false,
    totalSources: 0,
    totalHealthySources: 0,
    failureReason: [],
  };
}

export const PriceHealth: MessageFns<PriceHealth, "virtengine.oracle.v1.PriceHealth"> = {
  $type: "virtengine.oracle.v1.PriceHealth" as const,

  encode(message: PriceHealth, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.denom !== "") {
      writer.uint32(10).string(message.denom);
    }
    if (message.isHealthy !== false) {
      writer.uint32(24).bool(message.isHealthy);
    }
    if (message.hasMinSources !== false) {
      writer.uint32(32).bool(message.hasMinSources);
    }
    if (message.deviationOk !== false) {
      writer.uint32(40).bool(message.deviationOk);
    }
    if (message.totalSources !== 0) {
      writer.uint32(48).uint32(message.totalSources);
    }
    if (message.totalHealthySources !== 0) {
      writer.uint32(56).uint32(message.totalHealthySources);
    }
    for (const v of message.failureReason) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PriceHealth {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePriceHealth();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.denom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isHealthy = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hasMinSources = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.deviationOk = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.totalSources = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.totalHealthySources = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.failureReason.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PriceHealth {
    return {
      denom: isSet(object.denom) ? globalThis.String(object.denom) : "",
      isHealthy: isSet(object.is_healthy) ? globalThis.Boolean(object.is_healthy) : false,
      hasMinSources: isSet(object.has_min_sources) ? globalThis.Boolean(object.has_min_sources) : false,
      deviationOk: isSet(object.deviation_ok) ? globalThis.Boolean(object.deviation_ok) : false,
      totalSources: isSet(object.total_sources) ? globalThis.Number(object.total_sources) : 0,
      totalHealthySources: isSet(object.total_healthy_sources) ? globalThis.Number(object.total_healthy_sources) : 0,
      failureReason: globalThis.Array.isArray(object?.failure_reason)
        ? object.failure_reason.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: PriceHealth): unknown {
    const obj: any = {};
    if (message.denom !== "") {
      obj.denom = message.denom;
    }
    if (message.isHealthy !== false) {
      obj.is_healthy = message.isHealthy;
    }
    if (message.hasMinSources !== false) {
      obj.has_min_sources = message.hasMinSources;
    }
    if (message.deviationOk !== false) {
      obj.deviation_ok = message.deviationOk;
    }
    if (message.totalSources !== 0) {
      obj.total_sources = Math.round(message.totalSources);
    }
    if (message.totalHealthySources !== 0) {
      obj.total_healthy_sources = Math.round(message.totalHealthySources);
    }
    if (message.failureReason?.length) {
      obj.failure_reason = message.failureReason;
    }
    return obj;
  },

  create(base?: DeepPartial<PriceHealth>): PriceHealth {
    return PriceHealth.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PriceHealth>): PriceHealth {
    const message = createBasePriceHealth();
    message.denom = object.denom ?? "";
    message.isHealthy = object.isHealthy ?? false;
    message.hasMinSources = object.hasMinSources ?? false;
    message.deviationOk = object.deviationOk ?? false;
    message.totalSources = object.totalSources ?? 0;
    message.totalHealthySources = object.totalHealthySources ?? 0;
    message.failureReason = object.failureReason?.map((e) => e) || [];
    return message;
  },
};

function createBasePricesFilter(): PricesFilter {
  return { assetDenom: "", baseDenom: "", height: Long.ZERO };
}

export const PricesFilter: MessageFns<PricesFilter, "virtengine.oracle.v1.PricesFilter"> = {
  $type: "virtengine.oracle.v1.PricesFilter" as const,

  encode(message: PricesFilter, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.assetDenom !== "") {
      writer.uint32(10).string(message.assetDenom);
    }
    if (message.baseDenom !== "") {
      writer.uint32(18).string(message.baseDenom);
    }
    if (!message.height.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.height.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PricesFilter {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePricesFilter();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.assetDenom = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.baseDenom = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PricesFilter {
    return {
      assetDenom: isSet(object.asset_denom) ? globalThis.String(object.asset_denom) : "",
      baseDenom: isSet(object.base_denom) ? globalThis.String(object.base_denom) : "",
      height: isSet(object.height) ? Long.fromValue(object.height) : Long.ZERO,
    };
  },

  toJSON(message: PricesFilter): unknown {
    const obj: any = {};
    if (message.assetDenom !== "") {
      obj.asset_denom = message.assetDenom;
    }
    if (message.baseDenom !== "") {
      obj.base_denom = message.baseDenom;
    }
    if (!message.height.equals(Long.ZERO)) {
      obj.height = (message.height || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<PricesFilter>): PricesFilter {
    return PricesFilter.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<PricesFilter>): PricesFilter {
    const message = createBasePricesFilter();
    message.assetDenom = object.assetDenom ?? "";
    message.baseDenom = object.baseDenom ?? "";
    message.height = (object.height !== undefined && object.height !== null)
      ? Long.fromValue(object.height)
      : Long.ZERO;
    return message;
  },
};

function createBaseQueryPricesRequest(): QueryPricesRequest {
  return { filters: undefined, pagination: undefined };
}

export const QueryPricesRequest: MessageFns<QueryPricesRequest, "virtengine.oracle.v1.QueryPricesRequest"> = {
  $type: "virtengine.oracle.v1.QueryPricesRequest" as const,

  encode(message: QueryPricesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.filters !== undefined) {
      PricesFilter.encode(message.filters, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageRequest.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPricesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPricesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.filters = PricesFilter.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageRequest.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPricesRequest {
    return {
      filters: isSet(object.filters) ? PricesFilter.fromJSON(object.filters) : undefined,
      pagination: isSet(object.pagination) ? PageRequest.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPricesRequest): unknown {
    const obj: any = {};
    if (message.filters !== undefined) {
      obj.filters = PricesFilter.toJSON(message.filters);
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageRequest.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPricesRequest>): QueryPricesRequest {
    return QueryPricesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPricesRequest>): QueryPricesRequest {
    const message = createBaseQueryPricesRequest();
    message.filters = (object.filters !== undefined && object.filters !== null)
      ? PricesFilter.fromPartial(object.filters)
      : undefined;
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageRequest.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseQueryPricesResponse(): QueryPricesResponse {
  return { prices: [], pagination: undefined };
}

export const QueryPricesResponse: MessageFns<QueryPricesResponse, "virtengine.oracle.v1.QueryPricesResponse"> = {
  $type: "virtengine.oracle.v1.QueryPricesResponse" as const,

  encode(message: QueryPricesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.prices) {
      PriceData.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      PageResponse.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryPricesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryPricesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.prices.push(PriceData.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = PageResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryPricesResponse {
    return {
      prices: globalThis.Array.isArray(object?.prices) ? object.prices.map((e: any) => PriceData.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? PageResponse.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: QueryPricesResponse): unknown {
    const obj: any = {};
    if (message.prices?.length) {
      obj.prices = message.prices.map((e) => PriceData.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = PageResponse.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<QueryPricesResponse>): QueryPricesResponse {
    return QueryPricesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<QueryPricesResponse>): QueryPricesResponse {
    const message = createBaseQueryPricesResponse();
    message.prices = object.prices?.map((e) => PriceData.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? PageResponse.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function toTimestamp(date: Date): Timestamp {
  const seconds = numberToLong(Math.trunc(date.getTime() / 1_000));
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds.toNumber() || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function numberToLong(number: number) {
  return Long.fromNumber(number);
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T, V extends string> {
  readonly $type: V;
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
