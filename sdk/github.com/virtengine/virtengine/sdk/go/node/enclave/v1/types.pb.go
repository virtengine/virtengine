// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/enclave/v1/types.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// TEEType represents the type of Trusted Execution Environment
type TEEType int32

const (
	// TEE_TYPE_UNSPECIFIED is the default/invalid TEE type
	TEETypeUnspecified TEEType = 0
	// TEE_TYPE_SGX is Intel SGX
	TEETypeSGX TEEType = 1
	// TEE_TYPE_SEV_SNP is AMD SEV-SNP
	TEETypeSEVSNP TEEType = 2
	// TEE_TYPE_NITRO is AWS Nitro Enclaves
	TEETypeNitro TEEType = 3
	// TEE_TYPE_TRUSTZONE is ARM TrustZone (future)
	TEETypeTrustZone TEEType = 4
)

var TEEType_name = map[int32]string{
	0: "TEE_TYPE_UNSPECIFIED",
	1: "TEE_TYPE_SGX",
	2: "TEE_TYPE_SEV_SNP",
	3: "TEE_TYPE_NITRO",
	4: "TEE_TYPE_TRUSTZONE",
}

var TEEType_value = map[string]int32{
	"TEE_TYPE_UNSPECIFIED": 0,
	"TEE_TYPE_SGX":         1,
	"TEE_TYPE_SEV_SNP":     2,
	"TEE_TYPE_NITRO":       3,
	"TEE_TYPE_TRUSTZONE":   4,
}

func (x TEEType) String() string {
	return proto.EnumName(TEEType_name, int32(x))
}

func (TEEType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{0}
}

// EnclaveIdentityStatus represents the status of an enclave identity
type EnclaveIdentityStatus int32

const (
	// ENCLAVE_IDENTITY_STATUS_UNSPECIFIED is the default/invalid status
	EnclaveIdentityStatusUnspecified EnclaveIdentityStatus = 0
	// ENCLAVE_IDENTITY_STATUS_ACTIVE indicates the enclave identity is active
	EnclaveIdentityStatusActive EnclaveIdentityStatus = 1
	// ENCLAVE_IDENTITY_STATUS_PENDING indicates the enclave identity is pending verification
	EnclaveIdentityStatusPending EnclaveIdentityStatus = 2
	// ENCLAVE_IDENTITY_STATUS_EXPIRED indicates the enclave identity has expired
	EnclaveIdentityStatusExpired EnclaveIdentityStatus = 3
	// ENCLAVE_IDENTITY_STATUS_REVOKED indicates the enclave identity has been revoked
	EnclaveIdentityStatusRevoked EnclaveIdentityStatus = 4
	// ENCLAVE_IDENTITY_STATUS_ROTATING indicates key rotation is in progress
	EnclaveIdentityStatusRotating EnclaveIdentityStatus = 5
)

var EnclaveIdentityStatus_name = map[int32]string{
	0: "ENCLAVE_IDENTITY_STATUS_UNSPECIFIED",
	1: "ENCLAVE_IDENTITY_STATUS_ACTIVE",
	2: "ENCLAVE_IDENTITY_STATUS_PENDING",
	3: "ENCLAVE_IDENTITY_STATUS_EXPIRED",
	4: "ENCLAVE_IDENTITY_STATUS_REVOKED",
	5: "ENCLAVE_IDENTITY_STATUS_ROTATING",
}

var EnclaveIdentityStatus_value = map[string]int32{
	"ENCLAVE_IDENTITY_STATUS_UNSPECIFIED": 0,
	"ENCLAVE_IDENTITY_STATUS_ACTIVE":      1,
	"ENCLAVE_IDENTITY_STATUS_PENDING":     2,
	"ENCLAVE_IDENTITY_STATUS_EXPIRED":     3,
	"ENCLAVE_IDENTITY_STATUS_REVOKED":     4,
	"ENCLAVE_IDENTITY_STATUS_ROTATING":    5,
}

func (x EnclaveIdentityStatus) String() string {
	return proto.EnumName(EnclaveIdentityStatus_name, int32(x))
}

func (EnclaveIdentityStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{1}
}

// KeyRotationStatus represents the status of a key rotation
type KeyRotationStatus int32

const (
	// KEY_ROTATION_STATUS_UNSPECIFIED is the default/invalid status
	KeyRotationStatusUnspecified KeyRotationStatus = 0
	// KEY_ROTATION_STATUS_PENDING indicates rotation is pending
	KeyRotationStatusPending KeyRotationStatus = 1
	// KEY_ROTATION_STATUS_ACTIVE indicates rotation is active (overlap period)
	KeyRotationStatusActive KeyRotationStatus = 2
	// KEY_ROTATION_STATUS_COMPLETED indicates rotation is completed
	KeyRotationStatusCompleted KeyRotationStatus = 3
	// KEY_ROTATION_STATUS_CANCELLED indicates rotation was cancelled
	KeyRotationStatusCancelled KeyRotationStatus = 4
)

var KeyRotationStatus_name = map[int32]string{
	0: "KEY_ROTATION_STATUS_UNSPECIFIED",
	1: "KEY_ROTATION_STATUS_PENDING",
	2: "KEY_ROTATION_STATUS_ACTIVE",
	3: "KEY_ROTATION_STATUS_COMPLETED",
	4: "KEY_ROTATION_STATUS_CANCELLED",
}

var KeyRotationStatus_value = map[string]int32{
	"KEY_ROTATION_STATUS_UNSPECIFIED": 0,
	"KEY_ROTATION_STATUS_PENDING":     1,
	"KEY_ROTATION_STATUS_ACTIVE":      2,
	"KEY_ROTATION_STATUS_COMPLETED":   3,
	"KEY_ROTATION_STATUS_CANCELLED":   4,
}

func (x KeyRotationStatus) String() string {
	return proto.EnumName(KeyRotationStatus_name, int32(x))
}

func (KeyRotationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{2}
}

// EnclaveIdentity represents a validator's enclave identity record
type EnclaveIdentity struct {
	// ValidatorAddress is the validator operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// TEEType is the type of TEE (SGX, SEV-SNP, NITRO)
	TeeType TEEType `protobuf:"varint,2,opt,name=tee_type,json=teeType,proto3,enum=virtengine.enclave.v1.TEEType" json:"tee_type" yaml:"tee_type"`
	// MeasurementHash is the enclave measurement (MRENCLAVE for SGX)
	MeasurementHash []byte `protobuf:"bytes,3,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// SignerHash is the signer measurement (MRSIGNER for SGX)
	SignerHash []byte `protobuf:"bytes,4,opt,name=signer_hash,json=signerHash,proto3" json:"signer_hash,omitempty" yaml:"signer_hash"`
	// EncryptionPubKey is the enclave's public key for encryption
	EncryptionPubKey []byte `protobuf:"bytes,5,opt,name=encryption_pub_key,json=encryptionPubKey,proto3" json:"encryption_pub_key" yaml:"encryption_pub_key"`
	// SigningPubKey is the enclave's public key for signing attestations
	SigningPubKey []byte `protobuf:"bytes,6,opt,name=signing_pub_key,json=signingPubKey,proto3" json:"signing_pub_key" yaml:"signing_pub_key"`
	// AttestationQuote is the raw attestation quote from the TEE
	AttestationQuote []byte `protobuf:"bytes,7,opt,name=attestation_quote,json=attestationQuote,proto3" json:"attestation_quote" yaml:"attestation_quote"`
	// AttestationChain is the certificate chain for attestation verification
	AttestationChain [][]byte `protobuf:"bytes,8,rep,name=attestation_chain,json=attestationChain,proto3" json:"attestation_chain" yaml:"attestation_chain"`
	// ISVProdID is the Independent Software Vendor Product ID
	IsvProdId uint32 `protobuf:"varint,9,opt,name=isv_prod_id,json=isvProdId,proto3" json:"isv_prod_id" yaml:"isv_prod_id"`
	// ISVSVN is the Independent Software Vendor Security Version Number
	IsvSvn uint32 `protobuf:"varint,10,opt,name=isv_svn,json=isvSvn,proto3" json:"isv_svn" yaml:"isv_svn"`
	// QuoteVersion is the attestation quote format version
	QuoteVersion uint32 `protobuf:"varint,11,opt,name=quote_version,json=quoteVersion,proto3" json:"quote_version" yaml:"quote_version"`
	// DebugMode indicates if the enclave is in debug mode (must be false for production)
	DebugMode bool `protobuf:"varint,12,opt,name=debug_mode,json=debugMode,proto3" json:"debug_mode" yaml:"debug_mode"`
	// Epoch is the registration epoch
	Epoch uint64 `protobuf:"varint,13,opt,name=epoch,proto3" json:"epoch" yaml:"epoch"`
	// ExpiryHeight is the block height when this identity expires
	ExpiryHeight int64 `protobuf:"varint,14,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height" yaml:"expiry_height"`
	// RegisteredAt is the timestamp when this identity was registered
	RegisteredAt time.Time `protobuf:"bytes,15,opt,name=registered_at,json=registeredAt,proto3,stdtime" json:"registered_at" yaml:"registered_at"`
	// UpdatedAt is the timestamp when this identity was last updated
	UpdatedAt time.Time `protobuf:"bytes,16,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	// Status is the current status of the enclave identity
	Status EnclaveIdentityStatus `protobuf:"varint,17,opt,name=status,proto3,enum=virtengine.enclave.v1.EnclaveIdentityStatus" json:"status" yaml:"status"`
}

func (m *EnclaveIdentity) Reset()         { *m = EnclaveIdentity{} }
func (m *EnclaveIdentity) String() string { return proto.CompactTextString(m) }
func (*EnclaveIdentity) ProtoMessage()    {}
func (*EnclaveIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{0}
}
func (m *EnclaveIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EnclaveIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EnclaveIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EnclaveIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EnclaveIdentity.Merge(m, src)
}
func (m *EnclaveIdentity) XXX_Size() int {
	return m.Size()
}
func (m *EnclaveIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_EnclaveIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_EnclaveIdentity proto.InternalMessageInfo

func (m *EnclaveIdentity) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *EnclaveIdentity) GetTeeType() TEEType {
	if m != nil {
		return m.TeeType
	}
	return TEETypeUnspecified
}

func (m *EnclaveIdentity) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *EnclaveIdentity) GetSignerHash() []byte {
	if m != nil {
		return m.SignerHash
	}
	return nil
}

func (m *EnclaveIdentity) GetEncryptionPubKey() []byte {
	if m != nil {
		return m.EncryptionPubKey
	}
	return nil
}

func (m *EnclaveIdentity) GetSigningPubKey() []byte {
	if m != nil {
		return m.SigningPubKey
	}
	return nil
}

func (m *EnclaveIdentity) GetAttestationQuote() []byte {
	if m != nil {
		return m.AttestationQuote
	}
	return nil
}

func (m *EnclaveIdentity) GetAttestationChain() [][]byte {
	if m != nil {
		return m.AttestationChain
	}
	return nil
}

func (m *EnclaveIdentity) GetIsvProdId() uint32 {
	if m != nil {
		return m.IsvProdId
	}
	return 0
}

func (m *EnclaveIdentity) GetIsvSvn() uint32 {
	if m != nil {
		return m.IsvSvn
	}
	return 0
}

func (m *EnclaveIdentity) GetQuoteVersion() uint32 {
	if m != nil {
		return m.QuoteVersion
	}
	return 0
}

func (m *EnclaveIdentity) GetDebugMode() bool {
	if m != nil {
		return m.DebugMode
	}
	return false
}

func (m *EnclaveIdentity) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EnclaveIdentity) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *EnclaveIdentity) GetRegisteredAt() time.Time {
	if m != nil {
		return m.RegisteredAt
	}
	return time.Time{}
}

func (m *EnclaveIdentity) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *EnclaveIdentity) GetStatus() EnclaveIdentityStatus {
	if m != nil {
		return m.Status
	}
	return EnclaveIdentityStatusUnspecified
}

// MeasurementRecord represents an approved enclave measurement in the allowlist
type MeasurementRecord struct {
	// MeasurementHash is the enclave measurement hash
	MeasurementHash []byte `protobuf:"bytes,1,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// TEEType is the TEE type this measurement is for
	TeeType TEEType `protobuf:"varint,2,opt,name=tee_type,json=teeType,proto3,enum=virtengine.enclave.v1.TEEType" json:"tee_type" yaml:"tee_type"`
	// Description is a human-readable description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description" yaml:"description"`
	// MinISVSVN is the minimum required security version
	MinIsvSvn uint32 `protobuf:"varint,4,opt,name=min_isv_svn,json=minIsvSvn,proto3" json:"min_isv_svn" yaml:"min_isv_svn"`
	// AddedAt is when this measurement was added
	AddedAt time.Time `protobuf:"bytes,5,opt,name=added_at,json=addedAt,proto3,stdtime" json:"added_at" yaml:"added_at"`
	// AddedByProposal is the governance proposal ID that added this measurement
	AddedByProposal uint64 `protobuf:"varint,6,opt,name=added_by_proposal,json=addedByProposal,proto3" json:"added_by_proposal" yaml:"added_by_proposal"`
	// ExpiryHeight is when this measurement expires (0 for no expiry)
	ExpiryHeight int64 `protobuf:"varint,7,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height,omitempty" yaml:"expiry_height"`
	// Revoked indicates if this measurement has been revoked
	Revoked bool `protobuf:"varint,8,opt,name=revoked,proto3" json:"revoked" yaml:"revoked"`
	// RevokedAt is when this measurement was revoked (if applicable)
	RevokedAt *time.Time `protobuf:"bytes,9,opt,name=revoked_at,json=revokedAt,proto3,stdtime" json:"revoked_at,omitempty" yaml:"revoked_at"`
	// RevokedByProposal is the governance proposal that revoked this (if applicable)
	RevokedByProposal uint64 `protobuf:"varint,10,opt,name=revoked_by_proposal,json=revokedByProposal,proto3" json:"revoked_by_proposal,omitempty" yaml:"revoked_by_proposal"`
}

func (m *MeasurementRecord) Reset()         { *m = MeasurementRecord{} }
func (m *MeasurementRecord) String() string { return proto.CompactTextString(m) }
func (*MeasurementRecord) ProtoMessage()    {}
func (*MeasurementRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{1}
}
func (m *MeasurementRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MeasurementRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MeasurementRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MeasurementRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MeasurementRecord.Merge(m, src)
}
func (m *MeasurementRecord) XXX_Size() int {
	return m.Size()
}
func (m *MeasurementRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_MeasurementRecord.DiscardUnknown(m)
}

var xxx_messageInfo_MeasurementRecord proto.InternalMessageInfo

func (m *MeasurementRecord) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *MeasurementRecord) GetTeeType() TEEType {
	if m != nil {
		return m.TeeType
	}
	return TEETypeUnspecified
}

func (m *MeasurementRecord) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MeasurementRecord) GetMinIsvSvn() uint32 {
	if m != nil {
		return m.MinIsvSvn
	}
	return 0
}

func (m *MeasurementRecord) GetAddedAt() time.Time {
	if m != nil {
		return m.AddedAt
	}
	return time.Time{}
}

func (m *MeasurementRecord) GetAddedByProposal() uint64 {
	if m != nil {
		return m.AddedByProposal
	}
	return 0
}

func (m *MeasurementRecord) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *MeasurementRecord) GetRevoked() bool {
	if m != nil {
		return m.Revoked
	}
	return false
}

func (m *MeasurementRecord) GetRevokedAt() *time.Time {
	if m != nil {
		return m.RevokedAt
	}
	return nil
}

func (m *MeasurementRecord) GetRevokedByProposal() uint64 {
	if m != nil {
		return m.RevokedByProposal
	}
	return 0
}

// KeyRotationRecord represents a key rotation event
type KeyRotationRecord struct {
	// ValidatorAddress is the validator operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// Epoch is the epoch when rotation was initiated
	Epoch uint64 `protobuf:"varint,2,opt,name=epoch,proto3" json:"epoch" yaml:"epoch"`
	// OldKeyFingerprint is the fingerprint of the old key
	OldKeyFingerprint string `protobuf:"bytes,3,opt,name=old_key_fingerprint,json=oldKeyFingerprint,proto3" json:"old_key_fingerprint" yaml:"old_key_fingerprint"`
	// NewKeyFingerprint is the fingerprint of the new key
	NewKeyFingerprint string `protobuf:"bytes,4,opt,name=new_key_fingerprint,json=newKeyFingerprint,proto3" json:"new_key_fingerprint" yaml:"new_key_fingerprint"`
	// OverlapStartHeight is when both keys become valid
	OverlapStartHeight int64 `protobuf:"varint,5,opt,name=overlap_start_height,json=overlapStartHeight,proto3" json:"overlap_start_height" yaml:"overlap_start_height"`
	// OverlapEndHeight is when the old key becomes invalid
	OverlapEndHeight int64 `protobuf:"varint,6,opt,name=overlap_end_height,json=overlapEndHeight,proto3" json:"overlap_end_height" yaml:"overlap_end_height"`
	// InitiatedAt is when the rotation was initiated
	InitiatedAt time.Time `protobuf:"bytes,7,opt,name=initiated_at,json=initiatedAt,proto3,stdtime" json:"initiated_at" yaml:"initiated_at"`
	// CompletedAt is when the rotation was completed (old key invalidated)
	CompletedAt *time.Time `protobuf:"bytes,8,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at,omitempty" yaml:"completed_at"`
	// Status is the current status of the rotation
	Status KeyRotationStatus `protobuf:"varint,9,opt,name=status,proto3,enum=virtengine.enclave.v1.KeyRotationStatus" json:"status" yaml:"status"`
}

func (m *KeyRotationRecord) Reset()         { *m = KeyRotationRecord{} }
func (m *KeyRotationRecord) String() string { return proto.CompactTextString(m) }
func (*KeyRotationRecord) ProtoMessage()    {}
func (*KeyRotationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{2}
}
func (m *KeyRotationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRotationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRotationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRotationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRotationRecord.Merge(m, src)
}
func (m *KeyRotationRecord) XXX_Size() int {
	return m.Size()
}
func (m *KeyRotationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRotationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRotationRecord proto.InternalMessageInfo

func (m *KeyRotationRecord) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *KeyRotationRecord) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *KeyRotationRecord) GetOldKeyFingerprint() string {
	if m != nil {
		return m.OldKeyFingerprint
	}
	return ""
}

func (m *KeyRotationRecord) GetNewKeyFingerprint() string {
	if m != nil {
		return m.NewKeyFingerprint
	}
	return ""
}

func (m *KeyRotationRecord) GetOverlapStartHeight() int64 {
	if m != nil {
		return m.OverlapStartHeight
	}
	return 0
}

func (m *KeyRotationRecord) GetOverlapEndHeight() int64 {
	if m != nil {
		return m.OverlapEndHeight
	}
	return 0
}

func (m *KeyRotationRecord) GetInitiatedAt() time.Time {
	if m != nil {
		return m.InitiatedAt
	}
	return time.Time{}
}

func (m *KeyRotationRecord) GetCompletedAt() *time.Time {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

func (m *KeyRotationRecord) GetStatus() KeyRotationStatus {
	if m != nil {
		return m.Status
	}
	return KeyRotationStatusUnspecified
}

// AttestedScoringResult represents an enclave-attested scoring output
type AttestedScoringResult struct {
	// ScopeID is the identity scope that was scored
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// AccountAddress is the account that owns the identity
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Score is the computed identity score (0-100)
	Score uint32 `protobuf:"varint,3,opt,name=score,proto3" json:"score" yaml:"score"`
	// Status is the verification status
	Status string `protobuf:"bytes,4,opt,name=status,proto3" json:"status" yaml:"status"`
	// ReasonCodes are structured reason codes for the score
	ReasonCodes []string `protobuf:"bytes,5,rep,name=reason_codes,json=reasonCodes,proto3" json:"reason_codes,omitempty" yaml:"reason_codes"`
	// ModelVersionHash is the hash of the ML model used
	ModelVersionHash []byte `protobuf:"bytes,6,opt,name=model_version_hash,json=modelVersionHash,proto3" json:"model_version_hash" yaml:"model_version_hash"`
	// InputHash is the hash of the input data (for determinism verification)
	InputHash []byte `protobuf:"bytes,7,opt,name=input_hash,json=inputHash,proto3" json:"input_hash" yaml:"input_hash"`
	// EvidenceHashes are hashes of evidence artifacts (face embeddings, OCR, etc.)
	EvidenceHashes [][]byte `protobuf:"bytes,8,rep,name=evidence_hashes,json=evidenceHashes,proto3" json:"evidence_hashes,omitempty" yaml:"evidence_hashes"`
	// EnclaveMeasurementHash is the measurement of the enclave that computed this
	EnclaveMeasurementHash []byte `protobuf:"bytes,9,opt,name=enclave_measurement_hash,json=enclaveMeasurementHash,proto3" json:"enclave_measurement_hash" yaml:"enclave_measurement_hash"`
	// EnclaveSignature is the signature from the enclave signing key
	EnclaveSignature []byte `protobuf:"bytes,10,opt,name=enclave_signature,json=enclaveSignature,proto3" json:"enclave_signature" yaml:"enclave_signature"`
	// AttestationReference is a reference to the attestation quote (hash or ID)
	AttestationReference []byte `protobuf:"bytes,11,opt,name=attestation_reference,json=attestationReference,proto3" json:"attestation_reference" yaml:"attestation_reference"`
	// ValidatorAddress is the validator that produced this result
	ValidatorAddress string `protobuf:"bytes,12,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// BlockHeight is the block height where this result was produced
	BlockHeight int64 `protobuf:"varint,13,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
	// Timestamp is when this result was computed
	Timestamp time.Time `protobuf:"bytes,14,opt,name=timestamp,proto3,stdtime" json:"timestamp" yaml:"timestamp"`
}

func (m *AttestedScoringResult) Reset()         { *m = AttestedScoringResult{} }
func (m *AttestedScoringResult) String() string { return proto.CompactTextString(m) }
func (*AttestedScoringResult) ProtoMessage()    {}
func (*AttestedScoringResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{3}
}
func (m *AttestedScoringResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AttestedScoringResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AttestedScoringResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AttestedScoringResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttestedScoringResult.Merge(m, src)
}
func (m *AttestedScoringResult) XXX_Size() int {
	return m.Size()
}
func (m *AttestedScoringResult) XXX_DiscardUnknown() {
	xxx_messageInfo_AttestedScoringResult.DiscardUnknown(m)
}

var xxx_messageInfo_AttestedScoringResult proto.InternalMessageInfo

func (m *AttestedScoringResult) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *AttestedScoringResult) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *AttestedScoringResult) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *AttestedScoringResult) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *AttestedScoringResult) GetReasonCodes() []string {
	if m != nil {
		return m.ReasonCodes
	}
	return nil
}

func (m *AttestedScoringResult) GetModelVersionHash() []byte {
	if m != nil {
		return m.ModelVersionHash
	}
	return nil
}

func (m *AttestedScoringResult) GetInputHash() []byte {
	if m != nil {
		return m.InputHash
	}
	return nil
}

func (m *AttestedScoringResult) GetEvidenceHashes() [][]byte {
	if m != nil {
		return m.EvidenceHashes
	}
	return nil
}

func (m *AttestedScoringResult) GetEnclaveMeasurementHash() []byte {
	if m != nil {
		return m.EnclaveMeasurementHash
	}
	return nil
}

func (m *AttestedScoringResult) GetEnclaveSignature() []byte {
	if m != nil {
		return m.EnclaveSignature
	}
	return nil
}

func (m *AttestedScoringResult) GetAttestationReference() []byte {
	if m != nil {
		return m.AttestationReference
	}
	return nil
}

func (m *AttestedScoringResult) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *AttestedScoringResult) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *AttestedScoringResult) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

// ValidatorKeyInfo contains key information for a validator
type ValidatorKeyInfo struct {
	// ValidatorAddress is the validator operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// EncryptionKeyID is the key identifier
	EncryptionKeyId string `protobuf:"bytes,2,opt,name=encryption_key_id,json=encryptionKeyId,proto3" json:"encryption_key_id" yaml:"encryption_key_id"`
	// EncryptionPubKey is the public key for encryption
	EncryptionPubKey []byte `protobuf:"bytes,3,opt,name=encryption_pub_key,json=encryptionPubKey,proto3" json:"encryption_pub_key" yaml:"encryption_pub_key"`
	// MeasurementHash is the enclave measurement hash
	MeasurementHash []byte `protobuf:"bytes,4,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// ExpiryHeight is when the identity expires
	ExpiryHeight int64 `protobuf:"varint,5,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height" yaml:"expiry_height"`
	// IsInRotation indicates if key rotation is in progress
	IsInRotation bool `protobuf:"varint,6,opt,name=is_in_rotation,json=isInRotation,proto3" json:"is_in_rotation" yaml:"is_in_rotation"`
}

func (m *ValidatorKeyInfo) Reset()         { *m = ValidatorKeyInfo{} }
func (m *ValidatorKeyInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorKeyInfo) ProtoMessage()    {}
func (*ValidatorKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{4}
}
func (m *ValidatorKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorKeyInfo.Merge(m, src)
}
func (m *ValidatorKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorKeyInfo proto.InternalMessageInfo

func (m *ValidatorKeyInfo) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorKeyInfo) GetEncryptionKeyId() string {
	if m != nil {
		return m.EncryptionKeyId
	}
	return ""
}

func (m *ValidatorKeyInfo) GetEncryptionPubKey() []byte {
	if m != nil {
		return m.EncryptionPubKey
	}
	return nil
}

func (m *ValidatorKeyInfo) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *ValidatorKeyInfo) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

func (m *ValidatorKeyInfo) GetIsInRotation() bool {
	if m != nil {
		return m.IsInRotation
	}
	return false
}

// Params defines the parameters for the enclave module
type Params struct {
	// MaxEnclaveKeysPerValidator is the maximum number of enclave keys a validator can have
	MaxEnclaveKeysPerValidator uint32 `protobuf:"varint,1,opt,name=max_enclave_keys_per_validator,json=maxEnclaveKeysPerValidator,proto3" json:"max_enclave_keys_per_validator" yaml:"max_enclave_keys_per_validator"`
	// DefaultExpiryBlocks is the default number of blocks until enclave identity expires
	DefaultExpiryBlocks int64 `protobuf:"varint,2,opt,name=default_expiry_blocks,json=defaultExpiryBlocks,proto3" json:"default_expiry_blocks" yaml:"default_expiry_blocks"`
	// KeyRotationOverlapBlocks is the default overlap period for key rotations
	KeyRotationOverlapBlocks int64 `protobuf:"varint,3,opt,name=key_rotation_overlap_blocks,json=keyRotationOverlapBlocks,proto3" json:"key_rotation_overlap_blocks" yaml:"key_rotation_overlap_blocks"`
	// MinQuoteVersion is the minimum attestation quote version required
	MinQuoteVersion uint32 `protobuf:"varint,4,opt,name=min_quote_version,json=minQuoteVersion,proto3" json:"min_quote_version" yaml:"min_quote_version"`
	// AllowedTEETypes is the list of allowed TEE types
	AllowedTeeTypes []TEEType `protobuf:"varint,5,rep,packed,name=allowed_tee_types,json=allowedTeeTypes,proto3,enum=virtengine.enclave.v1.TEEType" json:"allowed_tee_types" yaml:"allowed_tee_types"`
	// ScoreTolerance is the maximum allowed score difference for consensus
	ScoreTolerance uint32 `protobuf:"varint,6,opt,name=score_tolerance,json=scoreTolerance,proto3" json:"score_tolerance" yaml:"score_tolerance"`
	// RequireAttestationChain indicates if attestation chain verification is required
	RequireAttestationChain bool `protobuf:"varint,7,opt,name=require_attestation_chain,json=requireAttestationChain,proto3" json:"require_attestation_chain" yaml:"require_attestation_chain"`
	// MaxAttestationAge is the maximum age of attestation in blocks
	MaxAttestationAge int64 `protobuf:"varint,8,opt,name=max_attestation_age,json=maxAttestationAge,proto3" json:"max_attestation_age" yaml:"max_attestation_age"`
	// EnableCommitteeMode enables committee-based identity processing
	EnableCommitteeMode bool `protobuf:"varint,9,opt,name=enable_committee_mode,json=enableCommitteeMode,proto3" json:"enable_committee_mode" yaml:"enable_committee_mode"`
	// CommitteeSize is the size of the identity committee (if committee mode enabled)
	CommitteeSize uint32 `protobuf:"varint,10,opt,name=committee_size,json=committeeSize,proto3" json:"committee_size,omitempty" yaml:"committee_size"`
	// CommitteeEpochBlocks is the number of blocks per committee epoch
	CommitteeEpochBlocks int64 `protobuf:"varint,11,opt,name=committee_epoch_blocks,json=committeeEpochBlocks,proto3" json:"committee_epoch_blocks,omitempty" yaml:"committee_epoch_blocks"`
	// EnableMeasurementCleanup enables automatic cleanup of expired measurements
	EnableMeasurementCleanup bool `protobuf:"varint,12,opt,name=enable_measurement_cleanup,json=enableMeasurementCleanup,proto3" json:"enable_measurement_cleanup" yaml:"enable_measurement_cleanup"`
	// MaxRegistrationsPerBlock limits registrations per block (0 = unlimited)
	MaxRegistrationsPerBlock uint32 `protobuf:"varint,13,opt,name=max_registrations_per_block,json=maxRegistrationsPerBlock,proto3" json:"max_registrations_per_block" yaml:"max_registrations_per_block"`
	// RegistrationCooldownBlocks enforces cooldown between re-registrations
	RegistrationCooldownBlocks int64 `protobuf:"varint,14,opt,name=registration_cooldown_blocks,json=registrationCooldownBlocks,proto3" json:"registration_cooldown_blocks" yaml:"registration_cooldown_blocks"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_b6fc02a8d61873a8, []int{5}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxEnclaveKeysPerValidator() uint32 {
	if m != nil {
		return m.MaxEnclaveKeysPerValidator
	}
	return 0
}

func (m *Params) GetDefaultExpiryBlocks() int64 {
	if m != nil {
		return m.DefaultExpiryBlocks
	}
	return 0
}

func (m *Params) GetKeyRotationOverlapBlocks() int64 {
	if m != nil {
		return m.KeyRotationOverlapBlocks
	}
	return 0
}

func (m *Params) GetMinQuoteVersion() uint32 {
	if m != nil {
		return m.MinQuoteVersion
	}
	return 0
}

func (m *Params) GetAllowedTeeTypes() []TEEType {
	if m != nil {
		return m.AllowedTeeTypes
	}
	return nil
}

func (m *Params) GetScoreTolerance() uint32 {
	if m != nil {
		return m.ScoreTolerance
	}
	return 0
}

func (m *Params) GetRequireAttestationChain() bool {
	if m != nil {
		return m.RequireAttestationChain
	}
	return false
}

func (m *Params) GetMaxAttestationAge() int64 {
	if m != nil {
		return m.MaxAttestationAge
	}
	return 0
}

func (m *Params) GetEnableCommitteeMode() bool {
	if m != nil {
		return m.EnableCommitteeMode
	}
	return false
}

func (m *Params) GetCommitteeSize() uint32 {
	if m != nil {
		return m.CommitteeSize
	}
	return 0
}

func (m *Params) GetCommitteeEpochBlocks() int64 {
	if m != nil {
		return m.CommitteeEpochBlocks
	}
	return 0
}

func (m *Params) GetEnableMeasurementCleanup() bool {
	if m != nil {
		return m.EnableMeasurementCleanup
	}
	return false
}

func (m *Params) GetMaxRegistrationsPerBlock() uint32 {
	if m != nil {
		return m.MaxRegistrationsPerBlock
	}
	return 0
}

func (m *Params) GetRegistrationCooldownBlocks() int64 {
	if m != nil {
		return m.RegistrationCooldownBlocks
	}
	return 0
}

func init() {
	proto.RegisterEnum("virtengine.enclave.v1.TEEType", TEEType_name, TEEType_value)
	proto.RegisterEnum("virtengine.enclave.v1.EnclaveIdentityStatus", EnclaveIdentityStatus_name, EnclaveIdentityStatus_value)
	proto.RegisterEnum("virtengine.enclave.v1.KeyRotationStatus", KeyRotationStatus_name, KeyRotationStatus_value)
	proto.RegisterType((*EnclaveIdentity)(nil), "virtengine.enclave.v1.EnclaveIdentity")
	proto.RegisterType((*MeasurementRecord)(nil), "virtengine.enclave.v1.MeasurementRecord")
	proto.RegisterType((*KeyRotationRecord)(nil), "virtengine.enclave.v1.KeyRotationRecord")
	proto.RegisterType((*AttestedScoringResult)(nil), "virtengine.enclave.v1.AttestedScoringResult")
	proto.RegisterType((*ValidatorKeyInfo)(nil), "virtengine.enclave.v1.ValidatorKeyInfo")
	proto.RegisterType((*Params)(nil), "virtengine.enclave.v1.Params")
}

func init() { proto.RegisterFile("virtengine/enclave/v1/types.proto", fileDescriptor_b6fc02a8d61873a8) }

var fileDescriptor_b6fc02a8d61873a8 = []byte{
	// 2762 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0x5b, 0x6f, 0x1b, 0xc7,
	0xf5, 0x37, 0x75, 0xe7, 0x88, 0x94, 0xc8, 0xb5, 0x64, 0xd3, 0xb4, 0xad, 0xd9, 0x4c, 0x12, 0x44,
	0xb9, 0x89, 0x7f, 0x27, 0xf8, 0x37, 0xa8, 0x8b, 0xa2, 0x20, 0xe9, 0x8d, 0xc3, 0xca, 0xa6, 0x98,
	0x21, 0x2d, 0x38, 0x46, 0x93, 0xed, 0x8a, 0x3b, 0xa2, 0x16, 0x22, 0x77, 0x99, 0xdd, 0x25, 0x6d,
	0xa6, 0xc8, 0x43, 0x8b, 0x3e, 0xb4, 0x7c, 0x69, 0xd0, 0x77, 0x01, 0x05, 0xf2, 0x05, 0x5a, 0xa0,
	0x1f, 0x22, 0x6f, 0x4d, 0xfb, 0xd4, 0xa7, 0x6d, 0xe0, 0x00, 0x6d, 0xc1, 0x47, 0x7e, 0x82, 0x62,
	0x2e, 0x7b, 0x23, 0x57, 0x52, 0x8a, 0x26, 0xc8, 0x8b, 0xc1, 0xf9, 0xfd, 0xce, 0x9c, 0xb3, 0x73,
	0x39, 0x67, 0xce, 0x39, 0x16, 0x78, 0x61, 0x68, 0xd8, 0x2e, 0x31, 0x3b, 0x86, 0x49, 0x4a, 0xc4,
	0x6c, 0x77, 0xb5, 0x21, 0x29, 0x0d, 0xef, 0x94, 0xdc, 0x51, 0x9f, 0x38, 0x7b, 0x7d, 0xdb, 0x72,
	0x2d, 0x69, 0x3b, 0x14, 0xd9, 0x13, 0x22, 0x7b, 0xc3, 0x3b, 0xc5, 0xad, 0x8e, 0xd5, 0xb1, 0x98,
	0x44, 0x89, 0xfe, 0xe2, 0xc2, 0xc5, 0x1b, 0x6d, 0xcb, 0xe9, 0x59, 0x8e, 0xca, 0x09, 0x3e, 0x10,
	0x54, 0x5e, 0xeb, 0x19, 0xa6, 0x55, 0x62, 0xff, 0x0a, 0x08, 0x76, 0x2c, 0xab, 0xd3, 0x25, 0x25,
	0x36, 0x3a, 0x1a, 0x1c, 0x97, 0x5c, 0xa3, 0x47, 0x1c, 0x57, 0xeb, 0xf5, 0xb9, 0x00, 0xfa, 0xe7,
	0x3a, 0xd8, 0x54, 0xb8, 0xcd, 0x9a, 0x4e, 0x4c, 0xd7, 0x70, 0x47, 0xd2, 0x10, 0xe4, 0x87, 0x5a,
	0xd7, 0xd0, 0x35, 0xd7, 0xb2, 0x55, 0x4d, 0xd7, 0x6d, 0xe2, 0x38, 0x85, 0x94, 0x9c, 0xda, 0x4d,
	0x57, 0x6a, 0x13, 0x0f, 0xce, 0x93, 0x53, 0x0f, 0x16, 0x46, 0x5a, 0xaf, 0x7b, 0x17, 0xcd, 0x51,
	0xe8, 0x6f, 0x7f, 0x7e, 0x73, 0x4b, 0x7c, 0x65, 0x99, 0x43, 0x4d, 0xd7, 0x36, 0xcc, 0x0e, 0xce,
	0x05, 0xb2, 0x02, 0x97, 0x9e, 0x80, 0x35, 0x97, 0x10, 0x95, 0x6e, 0x4d, 0x61, 0x41, 0x4e, 0xed,
	0x6e, 0xbc, 0xb5, 0xb3, 0x97, 0xb8, 0x35, 0x7b, 0x2d, 0x45, 0x69, 0x8d, 0xfa, 0xa4, 0x02, 0x27,
	0x1e, 0x0c, 0xe6, 0x4c, 0x3d, 0xb8, 0xc9, 0xbf, 0xc2, 0x47, 0x10, 0x5e, 0x75, 0x09, 0xa1, 0x92,
	0xd2, 0x13, 0x90, 0xeb, 0x11, 0xcd, 0x19, 0xd8, 0xa4, 0x47, 0x4c, 0x57, 0x3d, 0xd1, 0x9c, 0x93,
	0xc2, 0xa2, 0x9c, 0xda, 0xcd, 0x54, 0x4a, 0x13, 0x0f, 0xce, 0x71, 0x53, 0x0f, 0x5e, 0xe7, 0xba,
	0x66, 0x19, 0x84, 0x37, 0x23, 0xd0, 0x7b, 0x9a, 0x73, 0x22, 0x35, 0xc0, 0xba, 0x63, 0x74, 0x4c,
	0x62, 0x73, 0xb5, 0x4b, 0x81, 0xda, 0xed, 0x08, 0xfc, 0x86, 0xd5, 0x33, 0x5c, 0xd2, 0xeb, 0xbb,
	0xa3, 0xa9, 0x07, 0x25, 0xae, 0x3b, 0x42, 0x23, 0x0c, 0xf8, 0x88, 0x69, 0xd4, 0x80, 0x44, 0xcc,
	0xb6, 0x3d, 0xea, 0xbb, 0x86, 0x65, 0xaa, 0xfd, 0xc1, 0x91, 0x7a, 0x4a, 0x46, 0x85, 0x65, 0xa6,
	0xf8, 0xed, 0x89, 0x07, 0x13, 0xd8, 0xa9, 0x07, 0x6f, 0x70, 0xad, 0xf3, 0x1c, 0xc2, 0xb9, 0x10,
	0x6c, 0x0c, 0x8e, 0xf6, 0xc9, 0x48, 0x7a, 0x04, 0x36, 0xa9, 0x41, 0xc3, 0xec, 0x04, 0xfa, 0x57,
	0x98, 0xfe, 0x37, 0x27, 0x1e, 0x9c, 0xa5, 0xa6, 0x1e, 0xbc, 0x16, 0x7e, 0x72, 0x84, 0x40, 0x38,
	0x2b, 0x10, 0xa1, 0xf6, 0x23, 0x90, 0xd7, 0x5c, 0x97, 0x5e, 0x31, 0xf6, 0x01, 0x1f, 0x0f, 0x2c,
	0x97, 0x14, 0x56, 0x99, 0xe2, 0x3b, 0xf4, 0xee, 0xcc, 0x91, 0xe1, 0xdd, 0x99, 0xa3, 0x10, 0xce,
	0x45, 0xb0, 0xf7, 0x29, 0x34, 0xab, 0xbf, 0x7d, 0xa2, 0x19, 0x66, 0x61, 0x4d, 0x5e, 0x4c, 0xd2,
	0xcf, 0xc8, 0x64, 0xfd, 0x8c, 0x8a, 0xeb, 0xaf, 0x52, 0x48, 0x52, 0xc0, 0xba, 0xe1, 0x0c, 0xa9,
	0x77, 0xe9, 0xaa, 0xa1, 0x17, 0xd2, 0x72, 0x6a, 0x37, 0x5b, 0x79, 0x79, 0xe2, 0xc1, 0x28, 0x1c,
	0x9e, 0x60, 0x04, 0x44, 0x38, 0x6d, 0x38, 0xc3, 0x86, 0x6d, 0xe9, 0x35, 0x5d, 0xfa, 0x01, 0x58,
	0xa5, 0x94, 0x33, 0x34, 0x0b, 0x80, 0xa9, 0xb8, 0x3d, 0xf1, 0xa0, 0x0f, 0x4d, 0x3d, 0xb8, 0x11,
	0x4e, 0x77, 0x86, 0x26, 0xc2, 0x2b, 0x86, 0x33, 0x6c, 0x0e, 0x4d, 0xa9, 0x0e, 0xb2, 0x6c, 0xe9,
	0xea, 0x90, 0xd8, 0x8e, 0x61, 0x99, 0x85, 0x75, 0x36, 0xfb, 0xd5, 0x89, 0x07, 0xe3, 0xc4, 0xd4,
	0x83, 0x5b, 0x5c, 0x47, 0x0c, 0x46, 0x38, 0xc3, 0xc6, 0x87, 0x7c, 0x28, 0x55, 0x00, 0xd0, 0xc9,
	0xd1, 0xa0, 0xa3, 0xf6, 0x2c, 0x9d, 0x14, 0x32, 0x72, 0x6a, 0x77, 0xad, 0xf2, 0xe2, 0xc4, 0x83,
	0x11, 0x74, 0xea, 0xc1, 0x3c, 0xd7, 0x14, 0x62, 0x08, 0xa7, 0xd9, 0xe0, 0xa1, 0xa5, 0x13, 0xa9,
	0x04, 0x96, 0x49, 0xdf, 0x6a, 0x9f, 0x14, 0xb2, 0x72, 0x6a, 0x77, 0xa9, 0x72, 0x63, 0xe2, 0x41,
	0x0e, 0x4c, 0x3d, 0x98, 0x11, 0x57, 0x8e, 0x0e, 0x11, 0xe6, 0x30, 0x5d, 0x04, 0x79, 0xd6, 0x37,
	0xec, 0x91, 0x7a, 0x42, 0x8c, 0xce, 0x89, 0x5b, 0xd8, 0x90, 0x53, 0xbb, 0x8b, 0x7c, 0x11, 0x31,
	0x22, 0x5c, 0x44, 0x0c, 0x46, 0x38, 0xc3, 0xc7, 0xef, 0xb1, 0xa1, 0x64, 0x83, 0xac, 0x4d, 0x3a,
	0x86, 0xe3, 0x12, 0x9b, 0xe8, 0xaa, 0xe6, 0x16, 0x36, 0xe5, 0xd4, 0xee, 0xfa, 0x5b, 0xc5, 0x3d,
	0x1e, 0xdc, 0xf6, 0xfc, 0xe0, 0xb6, 0xd7, 0xf2, 0x83, 0x5b, 0xe5, 0xce, 0x17, 0x1e, 0xbc, 0x42,
	0xed, 0xc5, 0x26, 0x86, 0xf6, 0x62, 0x30, 0xfa, 0xec, 0x1f, 0x30, 0x85, 0x33, 0x21, 0x56, 0x76,
	0xa5, 0x63, 0x00, 0x06, 0x7d, 0x5d, 0x73, 0xb9, 0xc1, 0xdc, 0xa5, 0x06, 0x5f, 0x17, 0x06, 0x23,
	0xb3, 0xc2, 0x8d, 0x0d, 0x31, 0x6e, 0x2a, 0x2d, 0x80, 0xb2, 0x2b, 0x69, 0x60, 0x85, 0xde, 0xbf,
	0x81, 0x53, 0xc8, 0xb3, 0x88, 0xf7, 0xc6, 0x39, 0x11, 0x6f, 0x26, 0x46, 0x37, 0xd9, 0x9c, 0xca,
	0xcd, 0x89, 0x07, 0xc5, 0xfc, 0xa9, 0x07, 0xb3, 0xc2, 0x45, 0xd9, 0x18, 0x61, 0x41, 0xdc, 0x5d,
	0xfa, 0xf7, 0x1f, 0x60, 0x0a, 0xfd, 0x7e, 0x15, 0xe4, 0x1f, 0x86, 0x81, 0x0b, 0x93, 0xb6, 0x65,
	0xeb, 0x89, 0x61, 0x31, 0xf5, 0x2d, 0x85, 0xc5, 0xef, 0x32, 0x9c, 0xdf, 0x07, 0xeb, 0x3a, 0x71,
	0xda, 0xb6, 0xc1, 0x42, 0x1a, 0x8b, 0xe4, 0x69, 0xee, 0xa6, 0x11, 0x38, 0x74, 0xd3, 0x08, 0x88,
	0x70, 0x54, 0x84, 0xfa, 0x7b, 0xcf, 0x30, 0x55, 0xdf, 0x59, 0x97, 0x42, 0x7f, 0x8f, 0xc0, 0xa1,
	0xa2, 0x08, 0x88, 0x70, 0xba, 0x67, 0x98, 0x35, 0xee, 0xb7, 0x1f, 0x81, 0x35, 0x4d, 0xd7, 0xf9,
	0x65, 0x59, 0xbe, 0xf4, 0xb2, 0xbc, 0x22, 0x2e, 0x4b, 0x30, 0x27, 0x5c, 0xab, 0x8f, 0xf0, 0x8b,
	0xb2, 0xca, 0x86, 0x65, 0x57, 0xfa, 0x10, 0xe4, 0x39, 0x73, 0x34, 0xa2, 0xf1, 0xa6, 0x6f, 0x39,
	0x5a, 0x97, 0xc5, 0xeb, 0x25, 0x11, 0xf6, 0x66, 0xc9, 0x48, 0xd8, 0x9b, 0xa5, 0x10, 0xde, 0x64,
	0x58, 0x65, 0xd4, 0x10, 0x88, 0xf4, 0x78, 0xd6, 0x63, 0x57, 0x99, 0xc7, 0xd2, 0xa7, 0xe6, 0x7a,
	0x8c, 0x88, 0xbd, 0x62, 0xdf, 0xc4, 0x77, 0xdf, 0x01, 0xab, 0x36, 0x19, 0x5a, 0xa7, 0x44, 0x2f,
	0xac, 0xb1, 0xe8, 0xc3, 0x02, 0xa1, 0x80, 0xc2, 0x40, 0x28, 0x00, 0x84, 0x7d, 0x4a, 0xea, 0x02,
	0x20, 0x7e, 0xd2, 0x3d, 0x4d, 0x5f, 0xee, 0xf1, 0x13, 0x0f, 0x6e, 0x85, 0x33, 0x62, 0x1f, 0x9a,
	0x8f, 0x19, 0x09, 0xdd, 0x50, 0x00, 0x65, 0x57, 0xb2, 0xc0, 0x55, 0x9f, 0x8d, 0xee, 0x30, 0x60,
	0x3b, 0xfc, 0x93, 0x89, 0x07, 0x6f, 0x27, 0xd0, 0x31, 0x1b, 0xc5, 0xb8, 0x8d, 0xd8, 0x7e, 0xe7,
	0x05, 0x1a, 0xee, 0xb8, 0x70, 0xca, 0xcf, 0x57, 0x41, 0x7e, 0x9f, 0x8c, 0xb0, 0xc5, 0x9f, 0x20,
	0xe1, 0x94, 0xdf, 0x57, 0xfe, 0x15, 0x04, 0xfa, 0x85, 0x6f, 0x18, 0xe8, 0x09, 0xb8, 0x6a, 0x75,
	0x75, 0x9a, 0x07, 0xa8, 0xc7, 0x86, 0xd9, 0x21, 0x76, 0xdf, 0x36, 0x4c, 0x57, 0x78, 0xe3, 0xff,
	0x4f, 0x3c, 0x98, 0x44, 0x87, 0x7b, 0x95, 0x40, 0x22, 0x9c, 0xb7, 0xba, 0xfa, 0x3e, 0x19, 0xbd,
	0x1b, 0x62, 0xd4, 0x8c, 0x49, 0x9e, 0xce, 0x99, 0x59, 0x0a, 0xcd, 0x24, 0xd0, 0xa1, 0x99, 0x04,
	0x12, 0xe1, 0xbc, 0x49, 0x9e, 0xce, 0x98, 0x31, 0xc0, 0x96, 0x35, 0x24, 0x76, 0x57, 0xeb, 0xab,
	0x8e, 0xab, 0xd9, 0xae, 0xef, 0x0b, 0xcb, 0xcc, 0x17, 0xde, 0xa1, 0xf7, 0x2b, 0x89, 0x9f, 0x7a,
	0xf0, 0xa6, 0x58, 0x4f, 0x02, 0x8b, 0xb0, 0x24, 0xe0, 0x26, 0x45, 0x85, 0x57, 0x68, 0xc0, 0x47,
	0x55, 0x62, 0xea, 0xbe, 0xa1, 0x95, 0xc0, 0xe9, 0x12, 0xd8, 0x30, 0xbf, 0x9b, 0xe7, 0x10, 0xce,
	0x09, 0x50, 0x31, 0x75, 0x61, 0xc2, 0x04, 0x19, 0xc3, 0x34, 0x5c, 0xc3, 0x7f, 0xc2, 0x56, 0x2f,
	0xf5, 0xa0, 0x92, 0x88, 0x4a, 0xb1, 0x79, 0x53, 0x0f, 0x5e, 0x15, 0xb9, 0x4a, 0x04, 0xe5, 0xfe,
	0xb3, 0x1e, 0x40, 0x65, 0x57, 0x72, 0x41, 0xa6, 0x6d, 0xf5, 0xfa, 0x5d, 0x22, 0xec, 0xad, 0x5d,
	0x6a, 0x8f, 0x9e, 0xdc, 0xb5, 0xe8, 0x9c, 0x98, 0x3f, 0x09, 0xab, 0x51, 0x5e, 0x58, 0x0d, 0x20,
	0x16, 0x17, 0xfd, 0xe7, 0x33, 0xcd, 0x5e, 0x98, 0xdd, 0x73, 0x5e, 0x98, 0x88, 0x93, 0xfd, 0xf7,
	0x4f, 0xe7, 0xaf, 0x00, 0xd8, 0x2e, 0xb3, 0x44, 0x91, 0xe8, 0xcd, 0xb6, 0xc5, 0xbc, 0x87, 0x38,
	0x83, 0xae, 0x2b, 0xdd, 0x05, 0x6b, 0x4e, 0xdb, 0xea, 0x13, 0x9a, 0x2a, 0x72, 0x07, 0x65, 0x4f,
	0x98, 0x8f, 0x85, 0x61, 0xdd, 0x47, 0x10, 0x5e, 0x65, 0x3f, 0x6b, 0xba, 0x64, 0x82, 0x4d, 0xad,
	0xdd, 0xb6, 0x06, 0xa6, 0x1b, 0xf8, 0xf8, 0x02, 0x53, 0xa1, 0xd0, 0x04, 0x7c, 0x86, 0x0a, 0x13,
	0xf0, 0x19, 0xe2, 0x7c, 0xff, 0xde, 0x10, 0x92, 0x11, 0xef, 0x76, 0xda, 0x96, 0x4d, 0x98, 0x7b,
	0x66, 0xb9, 0x77, 0x33, 0x20, 0xf4, 0x6e, 0x36, 0x44, 0x98, 0xc3, 0xd2, 0xdb, 0xc1, 0xde, 0x72,
	0x4f, 0xfb, 0x26, 0x3b, 0x26, 0xb5, 0x40, 0xc6, 0x26, 0x9a, 0x43, 0x53, 0x6c, 0x4b, 0x27, 0x4e,
	0x61, 0x59, 0x5e, 0xdc, 0x4d, 0xb3, 0xe0, 0x7c, 0x2d, 0x8a, 0x27, 0x1d, 0x75, 0x94, 0x47, 0x78,
	0x9d, 0x0f, 0xab, 0x74, 0x44, 0xfd, 0x85, 0xa6, 0xa5, 0x5d, 0x3f, 0xcd, 0xe5, 0x89, 0xca, 0x4a,
	0x58, 0x0f, 0xcd, 0xb3, 0xa1, 0xbf, 0xcc, 0x73, 0x08, 0xe7, 0x18, 0x28, 0xb2, 0x64, 0x96, 0xad,
	0x54, 0x00, 0x30, 0xcc, 0xfe, 0x40, 0xe4, 0x40, 0xbc, 0x62, 0x61, 0x99, 0x72, 0x88, 0x86, 0x2f,
	0x49, 0x88, 0xd1, 0xac, 0x9f, 0x0e, 0x98, 0x8e, 0x9f, 0x83, 0x4d, 0x32, 0x34, 0x74, 0x62, 0xb6,
	0x09, 0x23, 0x89, 0x23, 0x4a, 0x13, 0x1a, 0x3c, 0x6e, 0xcc, 0x50, 0xb1, 0x2d, 0x10, 0x87, 0x3b,
	0x23, 0x82, 0xf0, 0x86, 0x8f, 0xbc, 0xc7, 0x00, 0x69, 0x04, 0x0a, 0xe2, 0x56, 0xab, 0x73, 0x79,
	0x5b, 0x9a, 0x7d, 0x33, 0x7d, 0xac, 0xce, 0x95, 0x99, 0x7a, 0x10, 0x06, 0x45, 0x62, 0xa2, 0x04,
	0xc2, 0xd7, 0x04, 0xf5, 0x70, 0x26, 0x9d, 0xfb, 0x08, 0xe4, 0xfd, 0x49, 0xb4, 0xe4, 0xd3, 0xdc,
	0x81, 0x4d, 0xd8, 0x03, 0x29, 0x2a, 0xaf, 0x39, 0x32, 0x7c, 0x95, 0xe6, 0x28, 0x5e, 0x90, 0x52,
	0xac, 0xe9, 0x43, 0x92, 0x09, 0xb6, 0xa3, 0x15, 0x9a, 0x4d, 0x8e, 0x89, 0x4d, 0x57, 0xce, 0x4a,
	0xa0, 0x4c, 0xe5, 0x87, 0xb4, 0x9e, 0x4e, 0x14, 0x98, 0x7a, 0xf0, 0xd6, 0x7c, 0x85, 0x17, 0xd0,
	0x08, 0x6f, 0x45, 0x70, 0xec, 0xc3, 0xc9, 0xaf, 0x6c, 0xe6, 0xbb, 0x7f, 0x65, 0x7f, 0x0a, 0x32,
	0x47, 0x5d, 0xab, 0x7d, 0xea, 0x47, 0xfd, 0x2c, 0x8b, 0xfa, 0xaf, 0xd0, 0xc0, 0x1b, 0xc5, 0x43,
	0xbf, 0x88, 0xa2, 0x08, 0xaf, 0xb3, 0xa1, 0x08, 0xf2, 0x6d, 0x90, 0x0e, 0x1a, 0x3a, 0xac, 0xca,
	0xba, 0x38, 0xe2, 0xbe, 0x2a, 0x22, 0x7c, 0x38, 0x69, 0xea, 0xc1, 0x9c, 0x48, 0xb2, 0x7d, 0x48,
	0xe4, 0x46, 0xc1, 0x58, 0x04, 0xc1, 0xbf, 0x2e, 0x81, 0xdc, 0xa1, 0xbf, 0x96, 0x7d, 0x32, 0xaa,
	0x99, 0xc7, 0xd6, 0xf7, 0x96, 0xa9, 0x7c, 0xc8, 0xee, 0xa2, 0xdf, 0xe5, 0xa0, 0x8f, 0xbb, 0xa1,
	0x8b, 0xe8, 0xe9, 0xdf, 0xc5, 0x38, 0x19, 0xbb, 0x8b, 0x71, 0x0a, 0xe1, 0xcd, 0x10, 0xa3, 0x0b,
	0xd3, 0xcf, 0x69, 0xbf, 0x2c, 0x7e, 0x9b, 0xed, 0x97, 0xa4, 0xc2, 0x6b, 0xe9, 0x5b, 0x2a, 0xbc,
	0xe6, 0xea, 0xef, 0xe5, 0xff, 0xad, 0xfe, 0x7e, 0x1f, 0x6c, 0x18, 0x8e, 0x6a, 0x98, 0xaa, 0x2d,
	0x9e, 0x50, 0x16, 0x79, 0xd7, 0x2a, 0xaf, 0x4f, 0x3c, 0x38, 0xc3, 0x4c, 0x3d, 0xb8, 0xed, 0xb7,
	0x36, 0xa2, 0x38, 0xc2, 0x19, 0xc3, 0xa9, 0x99, 0xfe, 0x1b, 0x2c, 0xee, 0xd4, 0x9f, 0xb2, 0x60,
	0xa5, 0xa1, 0xd9, 0x5a, 0xcf, 0x91, 0x7e, 0x97, 0x02, 0x3b, 0x3d, 0xed, 0x99, 0xea, 0x87, 0x8a,
	0x53, 0x32, 0x72, 0xd4, 0x3e, 0xb1, 0xd5, 0xe0, 0xec, 0xd9, 0xbd, 0xca, 0x56, 0xf6, 0x27, 0x1e,
	0xbc, 0x44, 0x72, 0xea, 0xc1, 0x97, 0xc5, 0x66, 0x5d, 0x28, 0x87, 0x70, 0xb1, 0xa7, 0x3d, 0x13,
	0x95, 0xf5, 0x3e, 0x19, 0x39, 0x0d, 0x62, 0x07, 0x57, 0x5c, 0xea, 0x81, 0x6d, 0x9d, 0x1c, 0x6b,
	0x83, 0xae, 0xab, 0x8a, 0xdd, 0x61, 0x9e, 0xc7, 0x5f, 0xe9, 0x45, 0x1e, 0x8f, 0x12, 0x05, 0xc2,
	0x78, 0x94, 0x48, 0x23, 0x7c, 0x55, 0xe0, 0x0a, 0x83, 0x2b, 0x0c, 0x95, 0x7e, 0x9d, 0x02, 0x37,
	0xe9, 0x85, 0xf4, 0x77, 0x4c, 0xf5, 0xd3, 0x3c, 0x61, 0x75, 0x91, 0x59, 0xa5, 0xb9, 0xc1, 0x45,
	0x62, 0x53, 0x0f, 0x22, 0x6e, 0xfb, 0x02, 0x21, 0x84, 0x0b, 0xa7, 0x61, 0x3e, 0x74, 0xc0, 0x39,
	0xf1, 0x19, 0x1f, 0x82, 0x3c, 0xad, 0x71, 0xe3, 0x4d, 0x28, 0x5e, 0x15, 0x33, 0xcf, 0x9a, 0x23,
	0x43, 0xcf, 0x9a, 0xa3, 0xe8, 0xd5, 0x34, 0x78, 0xdf, 0xce, 0xef, 0x47, 0x7d, 0x0a, 0xf2, 0x5a,
	0xb7, 0x6b, 0x3d, 0x25, 0xba, 0xea, 0x57, 0xf5, 0x3c, 0x47, 0xb8, 0xbc, 0x39, 0xc0, 0xeb, 0xdc,
	0xd9, 0xc9, 0x91, 0x3a, 0x77, 0x96, 0xa2, 0x75, 0x2e, 0xc7, 0x5a, 0xbc, 0x6b, 0xe0, 0x48, 0x87,
	0x60, 0x93, 0xe5, 0x36, 0xaa, 0x6b, 0x75, 0x89, 0xad, 0xd1, 0xd7, 0x65, 0x85, 0xad, 0x8d, 0x37,
	0x3d, 0xe3, 0x54, 0xa4, 0xe9, 0x19, 0x27, 0x10, 0xde, 0x60, 0x48, 0xcb, 0x07, 0xa4, 0x4f, 0xc1,
	0x0d, 0x9b, 0x7c, 0x3c, 0x30, 0x6c, 0xa2, 0xce, 0x77, 0x27, 0x57, 0x99, 0xb3, 0x94, 0x69, 0x0a,
	0x70, 0xae, 0xd0, 0xd4, 0x83, 0xb2, 0x9f, 0x05, 0x9d, 0x23, 0x82, 0xf0, 0x75, 0xc1, 0x95, 0x67,
	0x9b, 0x96, 0x04, 0x5c, 0xa5, 0x37, 0x3d, 0x3a, 0x45, 0xeb, 0x10, 0x96, 0x82, 0x2f, 0xf2, 0x02,
	0x29, 0x81, 0x0e, 0x0b, 0xa4, 0x04, 0x12, 0xe1, 0x7c, 0x4f, 0x7b, 0x16, 0x31, 0x54, 0xee, 0x10,
	0xea, 0x11, 0xc4, 0xd4, 0x8e, 0xba, 0x44, 0x6d, 0x5b, 0xbd, 0x9e, 0xe1, 0xd2, 0x9d, 0x66, 0x7d,
	0xc5, 0x34, 0x5b, 0x21, 0xf3, 0x88, 0x44, 0x81, 0xd0, 0x23, 0x12, 0x69, 0x84, 0xaf, 0x72, 0xbc,
	0xea, 0xc3, 0xac, 0xef, 0xf8, 0x33, 0xb0, 0x11, 0xca, 0x39, 0xc6, 0x27, 0x44, 0xb4, 0x52, 0xe9,
	0x82, 0x0a, 0x71, 0x26, 0x96, 0x4b, 0x6d, 0x07, 0x95, 0x43, 0x44, 0x02, 0xe1, 0x6c, 0x00, 0x34,
	0x8d, 0x4f, 0x88, 0xf4, 0x0b, 0x70, 0x2d, 0x94, 0x60, 0xe5, 0xac, 0xef, 0x69, 0xeb, 0x81, 0xa7,
	0xc9, 0xc9, 0x12, 0x31, 0x6b, 0xb7, 0x67, 0xad, 0x45, 0x25, 0x11, 0xde, 0x0a, 0x08, 0x85, 0xe2,
	0xc2, 0xcb, 0x7e, 0x99, 0x02, 0x45, 0xb1, 0x15, 0xd1, 0x78, 0xde, 0xee, 0x12, 0xcd, 0x1c, 0xf4,
	0x45, 0x9f, 0xb6, 0x3a, 0xf1, 0xe0, 0x05, 0x52, 0x53, 0x0f, 0xbe, 0x10, 0xdb, 0xd4, 0x04, 0x19,
	0x84, 0x0b, 0x9c, 0x8c, 0x24, 0x73, 0x55, 0x4e, 0xb1, 0x80, 0x43, 0x4f, 0x9e, 0xb7, 0x3d, 0x6d,
	0x76, 0xca, 0x3c, 0x40, 0xb2, 0x6f, 0x67, 0x79, 0x49, 0x96, 0x07, 0x9c, 0x0b, 0xc4, 0xc2, 0x80,
	0x73, 0x81, 0x10, 0xc2, 0x85, 0x9e, 0xf6, 0x0c, 0x47, 0xc9, 0x06, 0xb1, 0xd9, 0x5e, 0x48, 0xbf,
	0x4d, 0x81, 0x5b, 0xd1, 0x69, 0x6a, 0xdb, 0xb2, 0xba, 0xba, 0xf5, 0xd4, 0xf4, 0x8f, 0x83, 0x37,
	0x8f, 0xef, 0x4f, 0x3c, 0x78, 0xa1, 0xdc, 0xd4, 0x83, 0x2f, 0x46, 0x7b, 0xbb, 0xc9, 0x52, 0x08,
	0x17, 0xa3, 0x74, 0x55, 0xb0, 0xfc, 0x58, 0xee, 0x22, 0xfa, 0x2a, 0x8d, 0xff, 0xf5, 0xc7, 0xd7,
	0x6e, 0x24, 0xfc, 0xa7, 0x1d, 0x7f, 0xa8, 0x5e, 0xfb, 0x2a, 0x05, 0x56, 0x45, 0x48, 0x92, 0xfe,
	0x0f, 0x6c, 0xb5, 0x14, 0x45, 0x6d, 0x7d, 0xd0, 0x50, 0xd4, 0x47, 0xf5, 0x66, 0x43, 0xa9, 0xd6,
	0xde, 0xad, 0x29, 0xf7, 0x72, 0x57, 0x8a, 0xd7, 0xc6, 0x67, 0xb2, 0x24, 0xc4, 0x1e, 0x99, 0x4e,
	0x9f, 0xb4, 0x8d, 0x63, 0x83, 0xe8, 0x92, 0x0c, 0x32, 0xc1, 0x8c, 0xe6, 0xfd, 0xc7, 0xb9, 0x54,
	0x71, 0x63, 0x7c, 0x26, 0x03, 0x21, 0xd9, 0xbc, 0xff, 0x58, 0x7a, 0x05, 0xe4, 0x42, 0x09, 0xe5,
	0x50, 0x6d, 0xd6, 0x1b, 0xb9, 0x85, 0x62, 0x7e, 0x7c, 0x26, 0x67, 0x7d, 0x29, 0xe5, 0xb0, 0x59,
	0x6f, 0x48, 0x2f, 0x81, 0x8d, 0x40, 0xb0, 0x5e, 0x6b, 0xe1, 0x83, 0xdc, 0x62, 0x31, 0x37, 0x3e,
	0x93, 0x33, 0x42, 0xac, 0x6e, 0xb8, 0xb6, 0x25, 0xbd, 0x01, 0xa4, 0x40, 0xaa, 0x85, 0x1f, 0x35,
	0x5b, 0x4f, 0x0e, 0xea, 0x4a, 0x6e, 0xa9, 0xb8, 0x35, 0x3e, 0x93, 0x73, 0x42, 0xb2, 0x65, 0x0f,
	0x1c, 0xf7, 0x89, 0x65, 0x92, 0xe2, 0xd2, 0x6f, 0x3e, 0xdf, 0xb9, 0xf2, 0xda, 0x5f, 0x16, 0xc1,
	0x76, 0x62, 0xbf, 0x59, 0x7a, 0x08, 0x5e, 0x54, 0xea, 0xd5, 0x07, 0xe5, 0x43, 0x45, 0xad, 0xdd,
	0x53, 0xea, 0xad, 0x5a, 0xeb, 0x03, 0xb5, 0xd9, 0x2a, 0xb7, 0x1e, 0x35, 0x67, 0xd6, 0xff, 0xd2,
	0xf8, 0x4c, 0x96, 0x13, 0x75, 0x44, 0x77, 0xa3, 0x0a, 0x76, 0xce, 0x53, 0x57, 0xae, 0xb6, 0x6a,
	0x87, 0x4a, 0x2e, 0x55, 0x84, 0xe3, 0x33, 0xf9, 0x66, 0xa2, 0xa6, 0x72, 0xdb, 0x35, 0x86, 0x44,
	0x52, 0x00, 0x3c, 0x4f, 0x49, 0x43, 0xa9, 0xdf, 0xab, 0xd5, 0xef, 0xe7, 0x16, 0x8a, 0xf2, 0xf8,
	0x4c, 0xbe, 0x95, 0xa8, 0xa5, 0x41, 0x4c, 0xdd, 0x30, 0x3b, 0x17, 0xa9, 0x51, 0x1e, 0x37, 0x6a,
	0x58, 0xb9, 0x97, 0x5b, 0xbc, 0x40, 0x0d, 0x7b, 0xcb, 0x89, 0x7e, 0x91, 0x1a, 0xac, 0x1c, 0x1e,
	0xec, 0x2b, 0xf7, 0x72, 0x4b, 0x17, 0xa8, 0xc1, 0xa2, 0xfb, 0x79, 0x1f, 0xc8, 0xe7, 0xaa, 0x39,
	0x68, 0x95, 0x5b, 0x74, 0x55, 0xcb, 0xc5, 0x17, 0xc6, 0x67, 0xf2, 0xed, 0x64, 0x3d, 0xec, 0x71,
	0x37, 0x3b, 0xe2, 0x44, 0x9f, 0x2f, 0xc4, 0xfa, 0x8c, 0xe2, 0x34, 0x15, 0x00, 0xf7, 0x95, 0x0f,
	0x84, 0xc2, 0x83, 0x7a, 0xf2, 0x49, 0xb2, 0x6f, 0x9d, 0x9b, 0x1b, 0x3d, 0xc5, 0x1f, 0x83, 0x9b,
	0x49, 0x6a, 0xfc, 0xcd, 0x4f, 0x15, 0x6f, 0x8d, 0xcf, 0xe4, 0xc2, 0x9c, 0x0a, 0x7f, 0xe3, 0x7f,
	0x04, 0x8a, 0x49, 0xd3, 0xc5, 0x05, 0x58, 0x28, 0xde, 0x1c, 0x9f, 0xc9, 0xd7, 0xe7, 0x66, 0x8b,
	0xc3, 0x2f, 0x83, 0xdb, 0x49, 0x93, 0xab, 0x07, 0x0f, 0x1b, 0x0f, 0x94, 0x16, 0x3b, 0xb3, 0x9d,
	0xf1, 0x99, 0x5c, 0x9c, 0x9b, 0x5f, 0xf5, 0x9b, 0x48, 0xe7, 0xaa, 0x28, 0xd7, 0xab, 0xca, 0x83,
	0x07, 0xec, 0xbc, 0xce, 0x51, 0x41, 0x9f, 0xfe, 0x6e, 0x97, 0xe8, 0x7c, 0x93, 0x2b, 0xef, 0x7f,
	0xf1, 0x7c, 0x27, 0xf5, 0xe5, 0xf3, 0x9d, 0xd4, 0x57, 0xcf, 0x77, 0x52, 0x9f, 0x7d, 0xbd, 0x73,
	0xe5, 0xcb, 0xaf, 0x77, 0xae, 0xfc, 0xfd, 0xeb, 0x9d, 0x2b, 0x4f, 0xde, 0xe9, 0x18, 0xee, 0xc9,
	0xe0, 0x68, 0xaf, 0x6d, 0xf5, 0x4a, 0x91, 0xc8, 0x12, 0xf9, 0xe9, 0xe8, 0xa7, 0xa5, 0x8e, 0x55,
	0x32, 0x2d, 0x3d, 0xfa, 0x57, 0x02, 0x47, 0x2b, 0xac, 0x88, 0x7b, 0xfb, 0x3f, 0x01, 0x00, 0x00,
	0xff, 0xff, 0x3a, 0x37, 0x55, 0x4a, 0x45, 0x20, 0x00, 0x00,
}

func (this *EnclaveIdentity) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EnclaveIdentity)
	if !ok {
		that2, ok := that.(EnclaveIdentity)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.TeeType != that1.TeeType {
		return false
	}
	if !bytes.Equal(this.MeasurementHash, that1.MeasurementHash) {
		return false
	}
	if !bytes.Equal(this.SignerHash, that1.SignerHash) {
		return false
	}
	if !bytes.Equal(this.EncryptionPubKey, that1.EncryptionPubKey) {
		return false
	}
	if !bytes.Equal(this.SigningPubKey, that1.SigningPubKey) {
		return false
	}
	if !bytes.Equal(this.AttestationQuote, that1.AttestationQuote) {
		return false
	}
	if len(this.AttestationChain) != len(that1.AttestationChain) {
		return false
	}
	for i := range this.AttestationChain {
		if !bytes.Equal(this.AttestationChain[i], that1.AttestationChain[i]) {
			return false
		}
	}
	if this.IsvProdId != that1.IsvProdId {
		return false
	}
	if this.IsvSvn != that1.IsvSvn {
		return false
	}
	if this.QuoteVersion != that1.QuoteVersion {
		return false
	}
	if this.DebugMode != that1.DebugMode {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.ExpiryHeight != that1.ExpiryHeight {
		return false
	}
	if !this.RegisteredAt.Equal(that1.RegisteredAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *MeasurementRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MeasurementRecord)
	if !ok {
		that2, ok := that.(MeasurementRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.MeasurementHash, that1.MeasurementHash) {
		return false
	}
	if this.TeeType != that1.TeeType {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.MinIsvSvn != that1.MinIsvSvn {
		return false
	}
	if !this.AddedAt.Equal(that1.AddedAt) {
		return false
	}
	if this.AddedByProposal != that1.AddedByProposal {
		return false
	}
	if this.ExpiryHeight != that1.ExpiryHeight {
		return false
	}
	if this.Revoked != that1.Revoked {
		return false
	}
	if that1.RevokedAt == nil {
		if this.RevokedAt != nil {
			return false
		}
	} else if !this.RevokedAt.Equal(*that1.RevokedAt) {
		return false
	}
	if this.RevokedByProposal != that1.RevokedByProposal {
		return false
	}
	return true
}
func (this *KeyRotationRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*KeyRotationRecord)
	if !ok {
		that2, ok := that.(KeyRotationRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.OldKeyFingerprint != that1.OldKeyFingerprint {
		return false
	}
	if this.NewKeyFingerprint != that1.NewKeyFingerprint {
		return false
	}
	if this.OverlapStartHeight != that1.OverlapStartHeight {
		return false
	}
	if this.OverlapEndHeight != that1.OverlapEndHeight {
		return false
	}
	if !this.InitiatedAt.Equal(that1.InitiatedAt) {
		return false
	}
	if that1.CompletedAt == nil {
		if this.CompletedAt != nil {
			return false
		}
	} else if !this.CompletedAt.Equal(*that1.CompletedAt) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *AttestedScoringResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AttestedScoringResult)
	if !ok {
		that2, ok := that.(AttestedScoringResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.ReasonCodes) != len(that1.ReasonCodes) {
		return false
	}
	for i := range this.ReasonCodes {
		if this.ReasonCodes[i] != that1.ReasonCodes[i] {
			return false
		}
	}
	if !bytes.Equal(this.ModelVersionHash, that1.ModelVersionHash) {
		return false
	}
	if !bytes.Equal(this.InputHash, that1.InputHash) {
		return false
	}
	if len(this.EvidenceHashes) != len(that1.EvidenceHashes) {
		return false
	}
	for i := range this.EvidenceHashes {
		if !bytes.Equal(this.EvidenceHashes[i], that1.EvidenceHashes[i]) {
			return false
		}
	}
	if !bytes.Equal(this.EnclaveMeasurementHash, that1.EnclaveMeasurementHash) {
		return false
	}
	if !bytes.Equal(this.EnclaveSignature, that1.EnclaveSignature) {
		return false
	}
	if !bytes.Equal(this.AttestationReference, that1.AttestationReference) {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	return true
}
func (this *ValidatorKeyInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorKeyInfo)
	if !ok {
		that2, ok := that.(ValidatorKeyInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.EncryptionKeyId != that1.EncryptionKeyId {
		return false
	}
	if !bytes.Equal(this.EncryptionPubKey, that1.EncryptionPubKey) {
		return false
	}
	if !bytes.Equal(this.MeasurementHash, that1.MeasurementHash) {
		return false
	}
	if this.ExpiryHeight != that1.ExpiryHeight {
		return false
	}
	if this.IsInRotation != that1.IsInRotation {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxEnclaveKeysPerValidator != that1.MaxEnclaveKeysPerValidator {
		return false
	}
	if this.DefaultExpiryBlocks != that1.DefaultExpiryBlocks {
		return false
	}
	if this.KeyRotationOverlapBlocks != that1.KeyRotationOverlapBlocks {
		return false
	}
	if this.MinQuoteVersion != that1.MinQuoteVersion {
		return false
	}
	if len(this.AllowedTeeTypes) != len(that1.AllowedTeeTypes) {
		return false
	}
	for i := range this.AllowedTeeTypes {
		if this.AllowedTeeTypes[i] != that1.AllowedTeeTypes[i] {
			return false
		}
	}
	if this.ScoreTolerance != that1.ScoreTolerance {
		return false
	}
	if this.RequireAttestationChain != that1.RequireAttestationChain {
		return false
	}
	if this.MaxAttestationAge != that1.MaxAttestationAge {
		return false
	}
	if this.EnableCommitteeMode != that1.EnableCommitteeMode {
		return false
	}
	if this.CommitteeSize != that1.CommitteeSize {
		return false
	}
	if this.CommitteeEpochBlocks != that1.CommitteeEpochBlocks {
		return false
	}
	if this.EnableMeasurementCleanup != that1.EnableMeasurementCleanup {
		return false
	}
	if this.MaxRegistrationsPerBlock != that1.MaxRegistrationsPerBlock {
		return false
	}
	if this.RegistrationCooldownBlocks != that1.RegistrationCooldownBlocks {
		return false
	}
	return true
}
func (m *EnclaveIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EnclaveIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EnclaveIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.RegisteredAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTypes(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x7a
	if m.ExpiryHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x70
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x68
	}
	if m.DebugMode {
		i--
		if m.DebugMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.QuoteVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.QuoteVersion))
		i--
		dAtA[i] = 0x58
	}
	if m.IsvSvn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IsvSvn))
		i--
		dAtA[i] = 0x50
	}
	if m.IsvProdId != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IsvProdId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AttestationChain) > 0 {
		for iNdEx := len(m.AttestationChain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AttestationChain[iNdEx])
			copy(dAtA[i:], m.AttestationChain[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationChain[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AttestationQuote) > 0 {
		i -= len(m.AttestationQuote)
		copy(dAtA[i:], m.AttestationQuote)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationQuote)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SigningPubKey) > 0 {
		i -= len(m.SigningPubKey)
		copy(dAtA[i:], m.SigningPubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SigningPubKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EncryptionPubKey) > 0 {
		i -= len(m.EncryptionPubKey)
		copy(dAtA[i:], m.EncryptionPubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptionPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SignerHash) > 0 {
		i -= len(m.SignerHash)
		copy(dAtA[i:], m.SignerHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SignerHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TeeType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TeeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MeasurementRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MeasurementRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MeasurementRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RevokedByProposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RevokedByProposal))
		i--
		dAtA[i] = 0x50
	}
	if m.RevokedAt != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.RevokedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.RevokedAt):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintTypes(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x4a
	}
	if m.Revoked {
		i--
		if m.Revoked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.AddedByProposal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AddedByProposal))
		i--
		dAtA[i] = 0x30
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.AddedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AddedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTypes(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x2a
	if m.MinIsvSvn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinIsvSvn))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TeeType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TeeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *KeyRotationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRotationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyRotationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if m.CompletedAt != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTypes(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x42
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.InitiatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintTypes(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x3a
	if m.OverlapEndHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OverlapEndHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.OverlapStartHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OverlapStartHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.NewKeyFingerprint) > 0 {
		i -= len(m.NewKeyFingerprint)
		copy(dAtA[i:], m.NewKeyFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NewKeyFingerprint)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldKeyFingerprint) > 0 {
		i -= len(m.OldKeyFingerprint)
		copy(dAtA[i:], m.OldKeyFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OldKeyFingerprint)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Epoch != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AttestedScoringResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AttestedScoringResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AttestedScoringResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintTypes(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x72
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x68
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.AttestationReference) > 0 {
		i -= len(m.AttestationReference)
		copy(dAtA[i:], m.AttestationReference)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationReference)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.EnclaveSignature) > 0 {
		i -= len(m.EnclaveSignature)
		copy(dAtA[i:], m.EnclaveSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EnclaveSignature)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.EnclaveMeasurementHash) > 0 {
		i -= len(m.EnclaveMeasurementHash)
		copy(dAtA[i:], m.EnclaveMeasurementHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EnclaveMeasurementHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.EvidenceHashes) > 0 {
		for iNdEx := len(m.EvidenceHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EvidenceHashes[iNdEx])
			copy(dAtA[i:], m.EvidenceHashes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EvidenceHashes[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.InputHash) > 0 {
		i -= len(m.InputHash)
		copy(dAtA[i:], m.InputHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InputHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ModelVersionHash) > 0 {
		i -= len(m.ModelVersionHash)
		copy(dAtA[i:], m.ModelVersionHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModelVersionHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ReasonCodes) > 0 {
		for iNdEx := len(m.ReasonCodes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReasonCodes[iNdEx])
			copy(dAtA[i:], m.ReasonCodes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ReasonCodes[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.Score != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorKeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsInRotation {
		i--
		if m.IsInRotation {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.ExpiryHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EncryptionPubKey) > 0 {
		i -= len(m.EncryptionPubKey)
		copy(dAtA[i:], m.EncryptionPubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptionPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EncryptionKeyId) > 0 {
		i -= len(m.EncryptionKeyId)
		copy(dAtA[i:], m.EncryptionKeyId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptionKeyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegistrationCooldownBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RegistrationCooldownBlocks))
		i--
		dAtA[i] = 0x70
	}
	if m.MaxRegistrationsPerBlock != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRegistrationsPerBlock))
		i--
		dAtA[i] = 0x68
	}
	if m.EnableMeasurementCleanup {
		i--
		if m.EnableMeasurementCleanup {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.CommitteeEpochBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CommitteeEpochBlocks))
		i--
		dAtA[i] = 0x58
	}
	if m.CommitteeSize != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CommitteeSize))
		i--
		dAtA[i] = 0x50
	}
	if m.EnableCommitteeMode {
		i--
		if m.EnableCommitteeMode {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxAttestationAge != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAttestationAge))
		i--
		dAtA[i] = 0x40
	}
	if m.RequireAttestationChain {
		i--
		if m.RequireAttestationChain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ScoreTolerance != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ScoreTolerance))
		i--
		dAtA[i] = 0x30
	}
	if len(m.AllowedTeeTypes) > 0 {
		dAtA9 := make([]byte, len(m.AllowedTeeTypes)*10)
		var j8 int
		for _, num := range m.AllowedTeeTypes {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintTypes(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x2a
	}
	if m.MinQuoteVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinQuoteVersion))
		i--
		dAtA[i] = 0x20
	}
	if m.KeyRotationOverlapBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.KeyRotationOverlapBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.DefaultExpiryBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultExpiryBlocks))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxEnclaveKeysPerValidator != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxEnclaveKeysPerValidator))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EnclaveIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TeeType != 0 {
		n += 1 + sovTypes(uint64(m.TeeType))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SignerHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptionPubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SigningPubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AttestationQuote)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AttestationChain) > 0 {
		for _, b := range m.AttestationChain {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.IsvProdId != 0 {
		n += 1 + sovTypes(uint64(m.IsvProdId))
	}
	if m.IsvSvn != 0 {
		n += 1 + sovTypes(uint64(m.IsvSvn))
	}
	if m.QuoteVersion != 0 {
		n += 1 + sovTypes(uint64(m.QuoteVersion))
	}
	if m.DebugMode {
		n += 2
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTypes(uint64(m.ExpiryHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.RegisteredAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 2 + l + sovTypes(uint64(l))
	if m.Status != 0 {
		n += 2 + sovTypes(uint64(m.Status))
	}
	return n
}

func (m *MeasurementRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TeeType != 0 {
		n += 1 + sovTypes(uint64(m.TeeType))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MinIsvSvn != 0 {
		n += 1 + sovTypes(uint64(m.MinIsvSvn))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.AddedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.AddedByProposal != 0 {
		n += 1 + sovTypes(uint64(m.AddedByProposal))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTypes(uint64(m.ExpiryHeight))
	}
	if m.Revoked {
		n += 2
	}
	if m.RevokedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.RevokedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RevokedByProposal != 0 {
		n += 1 + sovTypes(uint64(m.RevokedByProposal))
	}
	return n
}

func (m *KeyRotationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTypes(uint64(m.Epoch))
	}
	l = len(m.OldKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NewKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OverlapStartHeight != 0 {
		n += 1 + sovTypes(uint64(m.OverlapStartHeight))
	}
	if m.OverlapEndHeight != 0 {
		n += 1 + sovTypes(uint64(m.OverlapEndHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.InitiatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.CompletedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	return n
}

func (m *AttestedScoringResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovTypes(uint64(m.Score))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ReasonCodes) > 0 {
		for _, s := range m.ReasonCodes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ModelVersionHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.InputHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.EvidenceHashes) > 0 {
		for _, b := range m.EvidenceHashes {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.EnclaveMeasurementHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EnclaveSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AttestationReference)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *ValidatorKeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptionKeyId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptionPubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTypes(uint64(m.ExpiryHeight))
	}
	if m.IsInRotation {
		n += 2
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxEnclaveKeysPerValidator != 0 {
		n += 1 + sovTypes(uint64(m.MaxEnclaveKeysPerValidator))
	}
	if m.DefaultExpiryBlocks != 0 {
		n += 1 + sovTypes(uint64(m.DefaultExpiryBlocks))
	}
	if m.KeyRotationOverlapBlocks != 0 {
		n += 1 + sovTypes(uint64(m.KeyRotationOverlapBlocks))
	}
	if m.MinQuoteVersion != 0 {
		n += 1 + sovTypes(uint64(m.MinQuoteVersion))
	}
	if len(m.AllowedTeeTypes) > 0 {
		l = 0
		for _, e := range m.AllowedTeeTypes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.ScoreTolerance != 0 {
		n += 1 + sovTypes(uint64(m.ScoreTolerance))
	}
	if m.RequireAttestationChain {
		n += 2
	}
	if m.MaxAttestationAge != 0 {
		n += 1 + sovTypes(uint64(m.MaxAttestationAge))
	}
	if m.EnableCommitteeMode {
		n += 2
	}
	if m.CommitteeSize != 0 {
		n += 1 + sovTypes(uint64(m.CommitteeSize))
	}
	if m.CommitteeEpochBlocks != 0 {
		n += 1 + sovTypes(uint64(m.CommitteeEpochBlocks))
	}
	if m.EnableMeasurementCleanup {
		n += 2
	}
	if m.MaxRegistrationsPerBlock != 0 {
		n += 1 + sovTypes(uint64(m.MaxRegistrationsPerBlock))
	}
	if m.RegistrationCooldownBlocks != 0 {
		n += 1 + sovTypes(uint64(m.RegistrationCooldownBlocks))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EnclaveIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EnclaveIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EnclaveIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			m.TeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeeType |= TEEType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerHash = append(m.SignerHash[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerHash == nil {
				m.SignerHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionPubKey = append(m.EncryptionPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionPubKey == nil {
				m.EncryptionPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningPubKey = append(m.SigningPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SigningPubKey == nil {
				m.SigningPubKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationQuote", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationQuote = append(m.AttestationQuote[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationQuote == nil {
				m.AttestationQuote = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationChain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationChain = append(m.AttestationChain, make([]byte, postIndex-iNdEx))
			copy(m.AttestationChain[len(m.AttestationChain)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsvProdId", wireType)
			}
			m.IsvProdId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsvProdId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsvSvn", wireType)
			}
			m.IsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteVersion", wireType)
			}
			m.QuoteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuoteVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DebugMode = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.RegisteredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= EnclaveIdentityStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MeasurementRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MeasurementRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MeasurementRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			m.TeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeeType |= TEEType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIsvSvn", wireType)
			}
			m.MinIsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinIsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.AddedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedByProposal", wireType)
			}
			m.AddedByProposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedByProposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revoked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Revoked = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RevokedAt == nil {
				m.RevokedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.RevokedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedByProposal", wireType)
			}
			m.RevokedByProposal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevokedByProposal |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRotationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRotationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRotationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapStartHeight", wireType)
			}
			m.OverlapStartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapStartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapEndHeight", wireType)
			}
			m.OverlapEndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapEndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.InitiatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= KeyRotationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AttestedScoringResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AttestedScoringResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AttestedScoringResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReasonCodes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReasonCodes = append(m.ReasonCodes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersionHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersionHash = append(m.ModelVersionHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ModelVersionHash == nil {
				m.ModelVersionHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InputHash = append(m.InputHash[:0], dAtA[iNdEx:postIndex]...)
			if m.InputHash == nil {
				m.InputHash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHashes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceHashes = append(m.EvidenceHashes, make([]byte, postIndex-iNdEx))
			copy(m.EvidenceHashes[len(m.EvidenceHashes)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclaveMeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnclaveMeasurementHash = append(m.EnclaveMeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.EnclaveMeasurementHash == nil {
				m.EnclaveMeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnclaveSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnclaveSignature = append(m.EnclaveSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.EnclaveSignature == nil {
				m.EnclaveSignature = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationReference", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationReference = append(m.AttestationReference[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationReference == nil {
				m.AttestationReference = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionPubKey = append(m.EncryptionPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionPubKey == nil {
				m.EncryptionPubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInRotation", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInRotation = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEnclaveKeysPerValidator", wireType)
			}
			m.MaxEnclaveKeysPerValidator = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEnclaveKeysPerValidator |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultExpiryBlocks", wireType)
			}
			m.DefaultExpiryBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultExpiryBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRotationOverlapBlocks", wireType)
			}
			m.KeyRotationOverlapBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyRotationOverlapBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinQuoteVersion", wireType)
			}
			m.MinQuoteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinQuoteVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v TEEType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= TEEType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowedTeeTypes = append(m.AllowedTeeTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AllowedTeeTypes) == 0 {
					m.AllowedTeeTypes = make([]TEEType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v TEEType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= TEEType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowedTeeTypes = append(m.AllowedTeeTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedTeeTypes", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreTolerance", wireType)
			}
			m.ScoreTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreTolerance |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireAttestationChain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireAttestationChain = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttestationAge", wireType)
			}
			m.MaxAttestationAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttestationAge |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableCommitteeMode", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableCommitteeMode = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitteeSize", wireType)
			}
			m.CommitteeSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitteeSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitteeEpochBlocks", wireType)
			}
			m.CommitteeEpochBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitteeEpochBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableMeasurementCleanup", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableMeasurementCleanup = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRegistrationsPerBlock", wireType)
			}
			m.MaxRegistrationsPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRegistrationsPerBlock |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegistrationCooldownBlocks", wireType)
			}
			m.RegistrationCooldownBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegistrationCooldownBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
