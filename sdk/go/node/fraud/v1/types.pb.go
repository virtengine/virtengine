// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/fraud/v1/types.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FraudReportStatus represents the state of a fraud report
type FraudReportStatus int32

const (
	// FRAUD_REPORT_STATUS_UNSPECIFIED represents an unspecified status
	FraudReportStatusUnspecified FraudReportStatus = 0
	// FRAUD_REPORT_STATUS_SUBMITTED indicates the report has been submitted and is awaiting review
	FraudReportStatusSubmitted FraudReportStatus = 1
	// FRAUD_REPORT_STATUS_REVIEWING indicates a moderator is actively reviewing the report
	FraudReportStatusReviewing FraudReportStatus = 2
	// FRAUD_REPORT_STATUS_RESOLVED indicates the report has been resolved (action taken)
	FraudReportStatusResolved FraudReportStatus = 3
	// FRAUD_REPORT_STATUS_REJECTED indicates the report was rejected (no fraud found)
	FraudReportStatusRejected FraudReportStatus = 4
	// FRAUD_REPORT_STATUS_ESCALATED indicates the report has been escalated to admin
	FraudReportStatusEscalated FraudReportStatus = 5
)

var FraudReportStatus_name = map[int32]string{
	0: "FRAUD_REPORT_STATUS_UNSPECIFIED",
	1: "FRAUD_REPORT_STATUS_SUBMITTED",
	2: "FRAUD_REPORT_STATUS_REVIEWING",
	3: "FRAUD_REPORT_STATUS_RESOLVED",
	4: "FRAUD_REPORT_STATUS_REJECTED",
	5: "FRAUD_REPORT_STATUS_ESCALATED",
}

var FraudReportStatus_value = map[string]int32{
	"FRAUD_REPORT_STATUS_UNSPECIFIED": 0,
	"FRAUD_REPORT_STATUS_SUBMITTED":   1,
	"FRAUD_REPORT_STATUS_REVIEWING":   2,
	"FRAUD_REPORT_STATUS_RESOLVED":    3,
	"FRAUD_REPORT_STATUS_REJECTED":    4,
	"FRAUD_REPORT_STATUS_ESCALATED":   5,
}

func (x FraudReportStatus) String() string {
	return proto.EnumName(FraudReportStatus_name, int32(x))
}

func (FraudReportStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{0}
}

// FraudCategory represents the category of fraud being reported
type FraudCategory int32

const (
	// FRAUD_CATEGORY_UNSPECIFIED represents an unspecified category
	FraudCategoryUnspecified FraudCategory = 0
	// FRAUD_CATEGORY_FAKE_IDENTITY indicates fake or stolen identity
	FraudCategoryFakeIdentity FraudCategory = 1
	// FRAUD_CATEGORY_PAYMENT_FRAUD indicates payment-related fraud
	FraudCategoryPaymentFraud FraudCategory = 2
	// FRAUD_CATEGORY_SERVICE_MISREPRESENTATION indicates misrepresented services
	FraudCategoryServiceMisrepresentation FraudCategory = 3
	// FRAUD_CATEGORY_RESOURCE_ABUSE indicates abuse of allocated resources
	FraudCategoryResourceAbuse FraudCategory = 4
	// FRAUD_CATEGORY_SYBIL_ATTACK indicates suspected sybil attack
	FraudCategorySybilAttack FraudCategory = 5
	// FRAUD_CATEGORY_MALICIOUS_CONTENT indicates malicious content or software
	FraudCategoryMaliciousContent FraudCategory = 6
	// FRAUD_CATEGORY_TERMS_VIOLATION indicates terms of service violation
	FraudCategoryTermsViolation FraudCategory = 7
	// FRAUD_CATEGORY_OTHER indicates other fraud types
	FraudCategoryOther FraudCategory = 8
)

var FraudCategory_name = map[int32]string{
	0: "FRAUD_CATEGORY_UNSPECIFIED",
	1: "FRAUD_CATEGORY_FAKE_IDENTITY",
	2: "FRAUD_CATEGORY_PAYMENT_FRAUD",
	3: "FRAUD_CATEGORY_SERVICE_MISREPRESENTATION",
	4: "FRAUD_CATEGORY_RESOURCE_ABUSE",
	5: "FRAUD_CATEGORY_SYBIL_ATTACK",
	6: "FRAUD_CATEGORY_MALICIOUS_CONTENT",
	7: "FRAUD_CATEGORY_TERMS_VIOLATION",
	8: "FRAUD_CATEGORY_OTHER",
}

var FraudCategory_value = map[string]int32{
	"FRAUD_CATEGORY_UNSPECIFIED":               0,
	"FRAUD_CATEGORY_FAKE_IDENTITY":             1,
	"FRAUD_CATEGORY_PAYMENT_FRAUD":             2,
	"FRAUD_CATEGORY_SERVICE_MISREPRESENTATION": 3,
	"FRAUD_CATEGORY_RESOURCE_ABUSE":            4,
	"FRAUD_CATEGORY_SYBIL_ATTACK":              5,
	"FRAUD_CATEGORY_MALICIOUS_CONTENT":         6,
	"FRAUD_CATEGORY_TERMS_VIOLATION":           7,
	"FRAUD_CATEGORY_OTHER":                     8,
}

func (x FraudCategory) String() string {
	return proto.EnumName(FraudCategory_name, int32(x))
}

func (FraudCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{1}
}

// ResolutionType represents the type of resolution for a fraud report
type ResolutionType int32

const (
	// RESOLUTION_TYPE_UNSPECIFIED represents no resolution yet
	ResolutionTypeUnspecified ResolutionType = 0
	// RESOLUTION_TYPE_WARNING indicates a warning was issued
	ResolutionTypeWarning ResolutionType = 1
	// RESOLUTION_TYPE_SUSPENSION indicates account suspension
	ResolutionTypeSuspension ResolutionType = 2
	// RESOLUTION_TYPE_TERMINATION indicates account termination
	ResolutionTypeTermination ResolutionType = 3
	// RESOLUTION_TYPE_REFUND indicates a refund was processed
	ResolutionTypeRefund ResolutionType = 4
	// RESOLUTION_TYPE_NO_ACTION indicates no action taken (rejected)
	ResolutionTypeNoAction ResolutionType = 5
)

var ResolutionType_name = map[int32]string{
	0: "RESOLUTION_TYPE_UNSPECIFIED",
	1: "RESOLUTION_TYPE_WARNING",
	2: "RESOLUTION_TYPE_SUSPENSION",
	3: "RESOLUTION_TYPE_TERMINATION",
	4: "RESOLUTION_TYPE_REFUND",
	5: "RESOLUTION_TYPE_NO_ACTION",
}

var ResolutionType_value = map[string]int32{
	"RESOLUTION_TYPE_UNSPECIFIED": 0,
	"RESOLUTION_TYPE_WARNING":     1,
	"RESOLUTION_TYPE_SUSPENSION":  2,
	"RESOLUTION_TYPE_TERMINATION": 3,
	"RESOLUTION_TYPE_REFUND":      4,
	"RESOLUTION_TYPE_NO_ACTION":   5,
}

func (x ResolutionType) String() string {
	return proto.EnumName(ResolutionType_name, int32(x))
}

func (ResolutionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{2}
}

// AuditAction represents the type of action recorded in the audit log
type AuditAction int32

const (
	// AUDIT_ACTION_UNSPECIFIED represents an unspecified action
	AuditActionUnspecified AuditAction = 0
	// AUDIT_ACTION_SUBMITTED indicates report was submitted
	AuditActionSubmitted AuditAction = 1
	// AUDIT_ACTION_ASSIGNED indicates report was assigned to moderator
	AuditActionAssigned AuditAction = 2
	// AUDIT_ACTION_STATUS_CHANGED indicates status was changed
	AuditActionStatusChanged AuditAction = 3
	// AUDIT_ACTION_EVIDENCE_VIEWED indicates evidence was viewed by moderator
	AuditActionEvidenceViewed AuditAction = 4
	// AUDIT_ACTION_RESOLVED indicates report was resolved
	AuditActionResolved AuditAction = 5
	// AUDIT_ACTION_REJECTED indicates report was rejected
	AuditActionRejected AuditAction = 6
	// AUDIT_ACTION_ESCALATED indicates report was escalated
	AuditActionEscalated AuditAction = 7
	// AUDIT_ACTION_COMMENT_ADDED indicates a comment was added
	AuditActionCommentAdded AuditAction = 8
)

var AuditAction_name = map[int32]string{
	0: "AUDIT_ACTION_UNSPECIFIED",
	1: "AUDIT_ACTION_SUBMITTED",
	2: "AUDIT_ACTION_ASSIGNED",
	3: "AUDIT_ACTION_STATUS_CHANGED",
	4: "AUDIT_ACTION_EVIDENCE_VIEWED",
	5: "AUDIT_ACTION_RESOLVED",
	6: "AUDIT_ACTION_REJECTED",
	7: "AUDIT_ACTION_ESCALATED",
	8: "AUDIT_ACTION_COMMENT_ADDED",
}

var AuditAction_value = map[string]int32{
	"AUDIT_ACTION_UNSPECIFIED":     0,
	"AUDIT_ACTION_SUBMITTED":       1,
	"AUDIT_ACTION_ASSIGNED":        2,
	"AUDIT_ACTION_STATUS_CHANGED":  3,
	"AUDIT_ACTION_EVIDENCE_VIEWED": 4,
	"AUDIT_ACTION_RESOLVED":        5,
	"AUDIT_ACTION_REJECTED":        6,
	"AUDIT_ACTION_ESCALATED":       7,
	"AUDIT_ACTION_COMMENT_ADDED":   8,
}

func (x AuditAction) String() string {
	return proto.EnumName(AuditAction_name, int32(x))
}

func (AuditAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{3}
}

// EncryptedEvidence holds encrypted evidence for a fraud report
type EncryptedEvidence struct {
	// AlgorithmID identifies the encryption algorithm used
	AlgorithmId string `protobuf:"bytes,1,opt,name=algorithm_id,json=algorithmId,proto3" json:"algorithm_id" yaml:"algorithm_id"`
	// RecipientKeyIDs are the fingerprints of moderator public keys
	RecipientKeyIds []string `protobuf:"bytes,2,rep,name=recipient_key_ids,json=recipientKeyIds,proto3" json:"recipient_key_ids" yaml:"recipient_key_ids"`
	// EncryptedKeys contains the data encryption key encrypted for each recipient
	EncryptedKeys [][]byte `protobuf:"bytes,3,rep,name=encrypted_keys,json=encryptedKeys,proto3" json:"encrypted_keys,omitempty" yaml:"encrypted_keys"`
	// Nonce is the initialization vector for encryption
	Nonce []byte `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce" yaml:"nonce"`
	// Ciphertext is the encrypted evidence data
	Ciphertext []byte `protobuf:"bytes,5,opt,name=ciphertext,proto3" json:"ciphertext" yaml:"ciphertext"`
	// SenderSignature is the signature for authenticity verification
	SenderSignature []byte `protobuf:"bytes,6,opt,name=sender_signature,json=senderSignature,proto3" json:"sender_signature" yaml:"sender_signature"`
	// SenderPubKey is the sender's public key
	SenderPubKey []byte `protobuf:"bytes,7,opt,name=sender_pub_key,json=senderPubKey,proto3" json:"sender_pub_key" yaml:"sender_pub_key"`
	// ContentType indicates the type of evidence (e.g., "image/png", "application/json")
	ContentType string `protobuf:"bytes,8,opt,name=content_type,json=contentType,proto3" json:"content_type" yaml:"content_type"`
	// EvidenceHash is SHA256 hash of the original evidence for integrity verification
	EvidenceHash string `protobuf:"bytes,9,opt,name=evidence_hash,json=evidenceHash,proto3" json:"evidence_hash" yaml:"evidence_hash"`
}

func (m *EncryptedEvidence) Reset()         { *m = EncryptedEvidence{} }
func (m *EncryptedEvidence) String() string { return proto.CompactTextString(m) }
func (*EncryptedEvidence) ProtoMessage()    {}
func (*EncryptedEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{0}
}
func (m *EncryptedEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedEvidence.Merge(m, src)
}
func (m *EncryptedEvidence) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedEvidence proto.InternalMessageInfo

func (m *EncryptedEvidence) GetAlgorithmId() string {
	if m != nil {
		return m.AlgorithmId
	}
	return ""
}

func (m *EncryptedEvidence) GetRecipientKeyIds() []string {
	if m != nil {
		return m.RecipientKeyIds
	}
	return nil
}

func (m *EncryptedEvidence) GetEncryptedKeys() [][]byte {
	if m != nil {
		return m.EncryptedKeys
	}
	return nil
}

func (m *EncryptedEvidence) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EncryptedEvidence) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedEvidence) GetSenderSignature() []byte {
	if m != nil {
		return m.SenderSignature
	}
	return nil
}

func (m *EncryptedEvidence) GetSenderPubKey() []byte {
	if m != nil {
		return m.SenderPubKey
	}
	return nil
}

func (m *EncryptedEvidence) GetContentType() string {
	if m != nil {
		return m.ContentType
	}
	return ""
}

func (m *EncryptedEvidence) GetEvidenceHash() string {
	if m != nil {
		return m.EvidenceHash
	}
	return ""
}

// FraudReport represents a fraud report submitted by a provider
type FraudReport struct {
	// ID is the unique identifier for this report
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	// Reporter is the provider address who submitted the report
	Reporter string `protobuf:"bytes,2,opt,name=reporter,proto3" json:"reporter" yaml:"reporter"`
	// ReportedParty is the address of the party being reported
	ReportedParty string `protobuf:"bytes,3,opt,name=reported_party,json=reportedParty,proto3" json:"reported_party" yaml:"reported_party"`
	// Category is the type of fraud being reported
	Category FraudCategory `protobuf:"varint,4,opt,name=category,proto3,enum=virtengine.fraud.v1.FraudCategory" json:"category" yaml:"category"`
	// Description is the detailed description of the fraud
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description" yaml:"description"`
	// Evidence contains the encrypted evidence attachments
	Evidence []EncryptedEvidence `protobuf:"bytes,6,rep,name=evidence,proto3" json:"evidence" yaml:"evidence"`
	// Status is the current status of the report
	Status FraudReportStatus `protobuf:"varint,7,opt,name=status,proto3,enum=virtengine.fraud.v1.FraudReportStatus" json:"status" yaml:"status"`
	// AssignedModerator is the moderator assigned to review this report
	AssignedModerator string `protobuf:"bytes,8,opt,name=assigned_moderator,json=assignedModerator,proto3" json:"assigned_moderator,omitempty" yaml:"assigned_moderator"`
	// Resolution is the resolution type if resolved
	Resolution ResolutionType `protobuf:"varint,9,opt,name=resolution,proto3,enum=virtengine.fraud.v1.ResolutionType" json:"resolution,omitempty" yaml:"resolution"`
	// ResolutionNotes are notes provided by the moderator upon resolution
	ResolutionNotes string `protobuf:"bytes,10,opt,name=resolution_notes,json=resolutionNotes,proto3" json:"resolution_notes,omitempty" yaml:"resolution_notes"`
	// SubmittedAt is when the report was submitted
	SubmittedAt time.Time `protobuf:"bytes,11,opt,name=submitted_at,json=submittedAt,proto3,stdtime" json:"submitted_at" yaml:"submitted_at"`
	// UpdatedAt is when the report was last updated
	UpdatedAt time.Time `protobuf:"bytes,12,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	// ResolvedAt is when the report was resolved (if applicable)
	ResolvedAt *time.Time `protobuf:"bytes,13,opt,name=resolved_at,json=resolvedAt,proto3,stdtime" json:"resolved_at,omitempty" yaml:"resolved_at"`
	// BlockHeight is the block height when submitted
	BlockHeight int64 `protobuf:"varint,14,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
	// ContentHash is SHA256 hash of the report content for integrity
	ContentHash string `protobuf:"bytes,15,opt,name=content_hash,json=contentHash,proto3" json:"content_hash" yaml:"content_hash"`
	// RelatedOrderIDs are order IDs related to this fraud report
	RelatedOrderIds []string `protobuf:"bytes,16,rep,name=related_order_ids,json=relatedOrderIds,proto3" json:"related_order_ids,omitempty" yaml:"related_order_ids"`
}

func (m *FraudReport) Reset()         { *m = FraudReport{} }
func (m *FraudReport) String() string { return proto.CompactTextString(m) }
func (*FraudReport) ProtoMessage()    {}
func (*FraudReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{1}
}
func (m *FraudReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FraudReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FraudReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FraudReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FraudReport.Merge(m, src)
}
func (m *FraudReport) XXX_Size() int {
	return m.Size()
}
func (m *FraudReport) XXX_DiscardUnknown() {
	xxx_messageInfo_FraudReport.DiscardUnknown(m)
}

var xxx_messageInfo_FraudReport proto.InternalMessageInfo

func (m *FraudReport) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FraudReport) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *FraudReport) GetReportedParty() string {
	if m != nil {
		return m.ReportedParty
	}
	return ""
}

func (m *FraudReport) GetCategory() FraudCategory {
	if m != nil {
		return m.Category
	}
	return FraudCategoryUnspecified
}

func (m *FraudReport) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *FraudReport) GetEvidence() []EncryptedEvidence {
	if m != nil {
		return m.Evidence
	}
	return nil
}

func (m *FraudReport) GetStatus() FraudReportStatus {
	if m != nil {
		return m.Status
	}
	return FraudReportStatusUnspecified
}

func (m *FraudReport) GetAssignedModerator() string {
	if m != nil {
		return m.AssignedModerator
	}
	return ""
}

func (m *FraudReport) GetResolution() ResolutionType {
	if m != nil {
		return m.Resolution
	}
	return ResolutionTypeUnspecified
}

func (m *FraudReport) GetResolutionNotes() string {
	if m != nil {
		return m.ResolutionNotes
	}
	return ""
}

func (m *FraudReport) GetSubmittedAt() time.Time {
	if m != nil {
		return m.SubmittedAt
	}
	return time.Time{}
}

func (m *FraudReport) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *FraudReport) GetResolvedAt() *time.Time {
	if m != nil {
		return m.ResolvedAt
	}
	return nil
}

func (m *FraudReport) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *FraudReport) GetContentHash() string {
	if m != nil {
		return m.ContentHash
	}
	return ""
}

func (m *FraudReport) GetRelatedOrderIds() []string {
	if m != nil {
		return m.RelatedOrderIds
	}
	return nil
}

// FraudAuditLog represents an audit log entry for a fraud report
type FraudAuditLog struct {
	// ID is the unique identifier for this log entry
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	// ReportID is the associated fraud report ID
	ReportId string `protobuf:"bytes,2,opt,name=report_id,json=reportId,proto3" json:"report_id" yaml:"report_id"`
	// Action is the type of action performed
	Action AuditAction `protobuf:"varint,3,opt,name=action,proto3,enum=virtengine.fraud.v1.AuditAction" json:"action" yaml:"action"`
	// Actor is the address that performed the action
	Actor string `protobuf:"bytes,4,opt,name=actor,proto3" json:"actor" yaml:"actor"`
	// PreviousStatus is the status before the action (if applicable)
	PreviousStatus FraudReportStatus `protobuf:"varint,5,opt,name=previous_status,json=previousStatus,proto3,enum=virtengine.fraud.v1.FraudReportStatus" json:"previous_status,omitempty" yaml:"previous_status"`
	// NewStatus is the status after the action (if applicable)
	NewStatus FraudReportStatus `protobuf:"varint,6,opt,name=new_status,json=newStatus,proto3,enum=virtengine.fraud.v1.FraudReportStatus" json:"new_status,omitempty" yaml:"new_status"`
	// Details contains additional action-specific details
	Details string `protobuf:"bytes,7,opt,name=details,proto3" json:"details,omitempty" yaml:"details"`
	// Timestamp is when the action was performed
	Timestamp time.Time `protobuf:"bytes,8,opt,name=timestamp,proto3,stdtime" json:"timestamp" yaml:"timestamp"`
	// BlockHeight is the block height when the action occurred
	BlockHeight int64 `protobuf:"varint,9,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
	// TxHash is the transaction hash (if applicable)
	TxHash string `protobuf:"bytes,10,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty" yaml:"tx_hash"`
}

func (m *FraudAuditLog) Reset()         { *m = FraudAuditLog{} }
func (m *FraudAuditLog) String() string { return proto.CompactTextString(m) }
func (*FraudAuditLog) ProtoMessage()    {}
func (*FraudAuditLog) Descriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{2}
}
func (m *FraudAuditLog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FraudAuditLog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FraudAuditLog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FraudAuditLog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FraudAuditLog.Merge(m, src)
}
func (m *FraudAuditLog) XXX_Size() int {
	return m.Size()
}
func (m *FraudAuditLog) XXX_DiscardUnknown() {
	xxx_messageInfo_FraudAuditLog.DiscardUnknown(m)
}

var xxx_messageInfo_FraudAuditLog proto.InternalMessageInfo

func (m *FraudAuditLog) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *FraudAuditLog) GetReportId() string {
	if m != nil {
		return m.ReportId
	}
	return ""
}

func (m *FraudAuditLog) GetAction() AuditAction {
	if m != nil {
		return m.Action
	}
	return AuditActionUnspecified
}

func (m *FraudAuditLog) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *FraudAuditLog) GetPreviousStatus() FraudReportStatus {
	if m != nil {
		return m.PreviousStatus
	}
	return FraudReportStatusUnspecified
}

func (m *FraudAuditLog) GetNewStatus() FraudReportStatus {
	if m != nil {
		return m.NewStatus
	}
	return FraudReportStatusUnspecified
}

func (m *FraudAuditLog) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *FraudAuditLog) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *FraudAuditLog) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *FraudAuditLog) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// ModeratorQueueEntry represents an entry in the moderator queue
type ModeratorQueueEntry struct {
	// ReportID is the fraud report ID
	ReportId string `protobuf:"bytes,1,opt,name=report_id,json=reportId,proto3" json:"report_id" yaml:"report_id"`
	// Priority is the queue priority (higher = more urgent)
	Priority uint32 `protobuf:"varint,2,opt,name=priority,proto3" json:"priority" yaml:"priority"`
	// QueuedAt is when the report was added to the queue
	QueuedAt time.Time `protobuf:"bytes,3,opt,name=queued_at,json=queuedAt,proto3,stdtime" json:"queued_at" yaml:"queued_at"`
	// Category is the fraud category for routing
	Category FraudCategory `protobuf:"varint,4,opt,name=category,proto3,enum=virtengine.fraud.v1.FraudCategory" json:"category" yaml:"category"`
	// AssignedTo is the moderator assigned (empty if unassigned)
	AssignedTo string `protobuf:"bytes,5,opt,name=assigned_to,json=assignedTo,proto3" json:"assigned_to,omitempty" yaml:"assigned_to"`
}

func (m *ModeratorQueueEntry) Reset()         { *m = ModeratorQueueEntry{} }
func (m *ModeratorQueueEntry) String() string { return proto.CompactTextString(m) }
func (*ModeratorQueueEntry) ProtoMessage()    {}
func (*ModeratorQueueEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_ece87b2cf387f05d, []int{3}
}
func (m *ModeratorQueueEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModeratorQueueEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModeratorQueueEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModeratorQueueEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModeratorQueueEntry.Merge(m, src)
}
func (m *ModeratorQueueEntry) XXX_Size() int {
	return m.Size()
}
func (m *ModeratorQueueEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ModeratorQueueEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ModeratorQueueEntry proto.InternalMessageInfo

func (m *ModeratorQueueEntry) GetReportId() string {
	if m != nil {
		return m.ReportId
	}
	return ""
}

func (m *ModeratorQueueEntry) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *ModeratorQueueEntry) GetQueuedAt() time.Time {
	if m != nil {
		return m.QueuedAt
	}
	return time.Time{}
}

func (m *ModeratorQueueEntry) GetCategory() FraudCategory {
	if m != nil {
		return m.Category
	}
	return FraudCategoryUnspecified
}

func (m *ModeratorQueueEntry) GetAssignedTo() string {
	if m != nil {
		return m.AssignedTo
	}
	return ""
}

func init() {
	proto.RegisterEnum("virtengine.fraud.v1.FraudReportStatus", FraudReportStatus_name, FraudReportStatus_value)
	proto.RegisterEnum("virtengine.fraud.v1.FraudCategory", FraudCategory_name, FraudCategory_value)
	proto.RegisterEnum("virtengine.fraud.v1.ResolutionType", ResolutionType_name, ResolutionType_value)
	proto.RegisterEnum("virtengine.fraud.v1.AuditAction", AuditAction_name, AuditAction_value)
	proto.RegisterType((*EncryptedEvidence)(nil), "virtengine.fraud.v1.EncryptedEvidence")
	proto.RegisterType((*FraudReport)(nil), "virtengine.fraud.v1.FraudReport")
	proto.RegisterType((*FraudAuditLog)(nil), "virtengine.fraud.v1.FraudAuditLog")
	proto.RegisterType((*ModeratorQueueEntry)(nil), "virtengine.fraud.v1.ModeratorQueueEntry")
}

func init() { proto.RegisterFile("virtengine/fraud/v1/types.proto", fileDescriptor_ece87b2cf387f05d) }

var fileDescriptor_ece87b2cf387f05d = []byte{
	// 2254 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0x17, 0x45, 0x49, 0x16, 0x87, 0x92, 0x4c, 0x8d, 0x65, 0x9b, 0xa2, 0x6c, 0xed, 0x66, 0x8d,
	0xb4, 0x72, 0xd2, 0x88, 0xb5, 0x93, 0xb4, 0x4d, 0x9c, 0xa6, 0x5d, 0x52, 0x2b, 0x79, 0x63, 0x89,
	0x54, 0x76, 0x97, 0x32, 0x9c, 0xb6, 0x58, 0xac, 0xb8, 0x63, 0x6a, 0x63, 0x71, 0x97, 0xdd, 0x1d,
	0xca, 0xe6, 0xbd, 0x87, 0x80, 0xa7, 0xa0, 0x40, 0x8f, 0x04, 0x0a, 0xf4, 0xd8, 0x6b, 0xff, 0x87,
	0xe6, 0x98, 0xf6, 0xd4, 0xd3, 0xb6, 0xb0, 0x2f, 0x05, 0x4f, 0x05, 0xef, 0x05, 0x8a, 0x99, 0xd9,
	0x6f, 0x52, 0x49, 0x8c, 0x22, 0x17, 0x81, 0xf3, 0x7b, 0x1f, 0x33, 0xf3, 0xe6, 0xbd, 0xdf, 0x7b,
	0x5a, 0xc0, 0x5d, 0x58, 0x2e, 0x46, 0x76, 0xc7, 0xb2, 0x51, 0xf5, 0xa9, 0x6b, 0xf4, 0xcd, 0xea,
	0xc5, 0xbd, 0x2a, 0x1e, 0xf4, 0x90, 0xb7, 0xdb, 0x73, 0x1d, 0xec, 0xc0, 0x6b, 0xb1, 0xc2, 0x2e,
	0x55, 0xd8, 0xbd, 0xb8, 0x57, 0xd9, 0xe8, 0x38, 0x1d, 0x87, 0xca, 0xab, 0xe4, 0x17, 0x53, 0xad,
	0x6c, 0xb6, 0x1d, 0xaf, 0xeb, 0x78, 0x3a, 0x13, 0xb0, 0x45, 0x20, 0x5a, 0x37, 0xba, 0x96, 0xed,
	0x54, 0xe9, 0xdf, 0x00, 0xe2, 0x3a, 0x8e, 0xd3, 0x39, 0x47, 0x55, 0xba, 0x3a, 0xed, 0x3f, 0xad,
	0x62, 0xab, 0x8b, 0x3c, 0x6c, 0x74, 0x7b, 0x4c, 0x41, 0x78, 0xb5, 0x08, 0xd6, 0x25, 0xbb, 0xed,
	0x0e, 0x7a, 0x18, 0x99, 0xd2, 0x85, 0x65, 0x22, 0xbb, 0x8d, 0xe0, 0x27, 0x60, 0xc5, 0x38, 0xef,
	0x38, 0xae, 0x85, 0xcf, 0xba, 0xba, 0x65, 0x96, 0x73, 0x7c, 0x6e, 0xa7, 0x50, 0xfb, 0xe1, 0xd8,
	0xe7, 0x52, 0xf8, 0xc4, 0xe7, 0xae, 0x0d, 0x8c, 0xee, 0xf9, 0x87, 0x42, 0x12, 0x15, 0x94, 0x62,
	0xb4, 0x94, 0x4d, 0xf8, 0x1b, 0xb0, 0xee, 0xa2, 0xb6, 0xd5, 0xb3, 0x90, 0x8d, 0xf5, 0x67, 0x68,
	0xa0, 0x5b, 0xa6, 0x57, 0x9e, 0xe7, 0xf3, 0x3b, 0x85, 0xda, 0xbd, 0xb1, 0xcf, 0x4d, 0x0b, 0x27,
	0x3e, 0x57, 0x66, 0x5e, 0xa7, 0x44, 0x82, 0x72, 0x35, 0xc2, 0x1e, 0xa1, 0x81, 0x6c, 0x7a, 0xf0,
	0xd7, 0x60, 0x0d, 0x85, 0xe7, 0x27, 0x6a, 0x5e, 0x39, 0xcf, 0xe7, 0x77, 0x56, 0x6a, 0xef, 0x8f,
	0x7d, 0xae, 0x9c, 0x96, 0xfc, 0xc8, 0xe9, 0x5a, 0x18, 0x75, 0x7b, 0x78, 0x30, 0xf1, 0xb9, 0xeb,
	0x6c, 0x8b, 0xb4, 0x86, 0xa0, 0xac, 0x46, 0xc0, 0x23, 0x34, 0xf0, 0x60, 0x15, 0x2c, 0xda, 0x8e,
	0xdd, 0x46, 0xe5, 0x05, 0x3e, 0xb7, 0xb3, 0x52, 0xdb, 0x1c, 0xfb, 0x1c, 0x03, 0x26, 0x3e, 0xb7,
	0xc2, 0x3c, 0xd0, 0xa5, 0xa0, 0x30, 0x18, 0xd6, 0x01, 0x68, 0x5b, 0xbd, 0x33, 0xe4, 0x62, 0xf4,
	0x02, 0x97, 0x17, 0xa9, 0xd5, 0x9d, 0xb1, 0xcf, 0x25, 0xd0, 0x89, 0xcf, 0xad, 0x33, 0xd3, 0x18,
	0x13, 0x94, 0x84, 0x02, 0xfc, 0x0c, 0x94, 0x3c, 0x64, 0x9b, 0xc8, 0xd5, 0x3d, 0xab, 0x63, 0x1b,
	0xb8, 0xef, 0xa2, 0xf2, 0x12, 0x75, 0x55, 0x1d, 0xfb, 0xdc, 0x94, 0x6c, 0xe2, 0x73, 0x37, 0x99,
	0xc3, 0xac, 0x44, 0x50, 0xae, 0x32, 0x48, 0x0d, 0x11, 0xf8, 0x29, 0x58, 0x0b, 0xb4, 0x7a, 0xfd,
	0x53, 0x72, 0xe9, 0xf2, 0x15, 0xea, 0xf9, 0xed, 0xb1, 0xcf, 0x65, 0x24, 0x71, 0x94, 0xd2, 0xb8,
	0xa0, 0xac, 0x30, 0xe0, 0xb8, 0x7f, 0xfa, 0x08, 0x0d, 0x48, 0xb6, 0xb4, 0x1d, 0x1b, 0x93, 0x77,
	0x22, 0x49, 0x5d, 0x5e, 0x8e, 0xb3, 0x25, 0x89, 0xc7, 0xd9, 0x92, 0x44, 0x05, 0xa5, 0x18, 0x2c,
	0xb5, 0x41, 0x0f, 0xc1, 0x06, 0x58, 0x45, 0x41, 0x16, 0xea, 0x67, 0x86, 0x77, 0x56, 0x2e, 0x50,
	0x67, 0x77, 0xc7, 0x3e, 0x97, 0x16, 0x4c, 0x7c, 0x6e, 0x23, 0x78, 0xc2, 0x24, 0x2c, 0x28, 0x2b,
	0xe1, 0xfa, 0xa1, 0xe1, 0x9d, 0x7d, 0xb8, 0xf0, 0xef, 0x3f, 0x72, 0x39, 0xe1, 0x0f, 0x2b, 0xa0,
	0xb8, 0x4f, 0xea, 0x4a, 0x41, 0x3d, 0xc7, 0xc5, 0xf0, 0x0e, 0x98, 0x8f, 0xb2, 0xfa, 0xda, 0xd8,
	0xe7, 0xe6, 0x69, 0x2e, 0x17, 0x98, 0x3f, 0x92, 0xc1, 0xf3, 0x96, 0x09, 0x55, 0xb0, 0xec, 0x52,
	0x75, 0xe4, 0x96, 0xe7, 0xa9, 0xea, 0x4f, 0xc7, 0x3e, 0x17, 0x61, 0x13, 0x9f, 0xbb, 0x1a, 0xa6,
	0x29, 0x43, 0x84, 0xbf, 0xff, 0xe5, 0x9d, 0x8d, 0xa0, 0x22, 0x45, 0xd3, 0x74, 0x91, 0xe7, 0xa9,
	0xd8, 0xb5, 0xec, 0x8e, 0x12, 0x19, 0xc1, 0xcf, 0xc1, 0x5a, 0xf0, 0xdb, 0xd4, 0x7b, 0x86, 0x8b,
	0x07, 0xe5, 0x3c, 0x75, 0x5d, 0x27, 0xe1, 0x4f, 0x4b, 0xe2, 0xf0, 0xa7, 0xf1, 0xcb, 0xb7, 0x59,
	0x0d, 0x15, 0x8f, 0x89, 0x1e, 0xd4, 0xc1, 0x72, 0xdb, 0xc0, 0xa8, 0xe3, 0xb8, 0x03, 0x9a, 0xbf,
	0x6b, 0xf7, 0x85, 0xdd, 0x19, 0x44, 0xb3, 0x4b, 0x23, 0x53, 0x0f, 0x34, 0x6b, 0x1c, 0xb9, 0x64,
	0x68, 0x17, 0x5f, 0x32, 0x44, 0x04, 0x25, 0x12, 0xc2, 0x03, 0x50, 0x34, 0x91, 0xd7, 0x76, 0xad,
	0x1e, 0xb6, 0x1c, 0x9b, 0x66, 0x7b, 0xa1, 0xf6, 0xe6, 0xd8, 0xe7, 0x92, 0xf0, 0xc4, 0xe7, 0x20,
	0x73, 0x91, 0x00, 0x05, 0x25, 0xa9, 0x02, 0x3b, 0x60, 0x39, 0x7c, 0xb5, 0xf2, 0x12, 0x9f, 0xdf,
	0x29, 0xde, 0xff, 0xc1, 0xcc, 0x93, 0x4e, 0x31, 0x55, 0xed, 0xce, 0x57, 0x3e, 0x37, 0x47, 0x4e,
	0x1c, 0xda, 0xc7, 0x27, 0x0e, 0x11, 0x41, 0x89, 0x84, 0xf0, 0x57, 0x60, 0xc9, 0xc3, 0x06, 0xee,
	0x7b, 0x34, 0xeb, 0xd7, 0x2e, 0xd9, 0x26, 0x91, 0x2a, 0x2a, 0xd5, 0xae, 0x6d, 0x8d, 0x7d, 0x2e,
	0xb0, 0x9c, 0xf8, 0xdc, 0x6a, 0x50, 0x15, 0x74, 0x2d, 0x28, 0x81, 0x00, 0xfe, 0x2e, 0x07, 0xa0,
	0xe1, 0x91, 0xe2, 0x43, 0xa6, 0xde, 0x75, 0x4c, 0xe4, 0x1a, 0xd8, 0x71, 0x83, 0x72, 0x68, 0x8d,
	0x7d, 0xee, 0xd6, 0xb4, 0x34, 0xc5, 0x49, 0x9b, 0x01, 0x99, 0x4e, 0x69, 0x5d, 0xfe, 0xe4, 0xeb,
	0xa1, 0xf2, 0x51, 0xa8, 0x0b, 0x5d, 0x00, 0x5c, 0xe4, 0x39, 0xe7, 0x7d, 0xfa, 0x28, 0x05, 0x7a,
	0xcf, 0x3b, 0x33, 0xef, 0xa9, 0x44, 0x6a, 0xa4, 0xf6, 0x6a, 0xef, 0x8c, 0x7d, 0x6e, 0x23, 0x36,
	0x4d, 0x1d, 0x6d, 0x3d, 0xcc, 0xc4, 0x50, 0x2a, 0x28, 0x89, 0x5d, 0xa0, 0x09, 0x4a, 0xf1, 0x4a,
	0xb7, 0x1d, 0x8c, 0xbc, 0x32, 0xa0, 0xf7, 0xfe, 0x60, 0xec, 0x73, 0x95, 0xac, 0x2c, 0xe5, 0xfa,
	0x66, 0xd6, 0x35, 0xd3, 0xa1, 0x5c, 0x1f, 0x42, 0x0d, 0x82, 0x40, 0x1b, 0xac, 0x78, 0xfd, 0xd3,
	0xae, 0x85, 0x49, 0x2d, 0x18, 0xb8, 0x5c, 0xe4, 0x73, 0x3b, 0xc5, 0xfb, 0x95, 0x5d, 0xd6, 0xe4,
	0x76, 0xc3, 0x26, 0xb7, 0xab, 0x85, 0x4d, 0xae, 0x56, 0x0d, 0xd2, 0x23, 0x65, 0x17, 0x13, 0x51,
	0x12, 0x15, 0xbe, 0xfc, 0x27, 0x97, 0x53, 0x8a, 0x11, 0x24, 0x62, 0xf8, 0x14, 0x80, 0x7e, 0xcf,
	0x34, 0x82, 0xdd, 0x56, 0xbe, 0x75, 0xb7, 0xb7, 0x83, 0xdd, 0x12, 0x56, 0x71, 0xe8, 0x62, 0x8c,
	0xed, 0x54, 0x08, 0x00, 0x11, 0xc3, 0x1e, 0x28, 0xd2, 0xab, 0x5e, 0xb0, 0x8d, 0x56, 0xbf, 0x75,
	0xa3, 0x77, 0xc7, 0x3e, 0x77, 0x3d, 0x61, 0x92, 0x8a, 0x27, 0x4c, 0xc4, 0xf3, 0x22, 0xb1, 0x21,
	0x08, 0x11, 0x11, 0x13, 0xca, 0x3e, 0x3d, 0x77, 0xda, 0xcf, 0xf4, 0x33, 0x64, 0x75, 0xce, 0x70,
	0x79, 0x8d, 0xcf, 0xed, 0xe4, 0x19, 0x65, 0x27, 0xf1, 0x38, 0x52, 0x49, 0x54, 0x50, 0x8a, 0x74,
	0xf9, 0x90, 0xae, 0x92, 0xf4, 0x4f, 0x19, 0xfb, 0xea, 0x34, 0xfd, 0x07, 0x84, 0x9d, 0xa1, 0x7f,
	0xc6, 0xd7, 0x21, 0xfd, 0x13, 0xba, 0x86, 0x1d, 0x32, 0x2c, 0x9c, 0xd3, 0x38, 0x39, 0x2e, 0x69,
	0x39, 0x64, 0x58, 0x28, 0xd1, 0x61, 0xe1, 0xc1, 0xd8, 0xe7, 0xb6, 0xa6, 0x84, 0xa9, 0x9b, 0x47,
	0x63, 0x43, 0x46, 0x89, 0xa6, 0x12, 0xc5, 0x9a, 0x04, 0x92, 0x4d, 0x2f, 0xe8, 0x0b, 0x7f, 0x5b,
	0x02, 0xab, 0xb4, 0xd8, 0xc5, 0xbe, 0x69, 0xe1, 0x43, 0xa7, 0xf3, 0xdd, 0x3a, 0xc3, 0xc7, 0xa0,
	0xc0, 0x98, 0x96, 0xcc, 0x46, 0xac, 0x35, 0xbc, 0x31, 0xf6, 0xb9, 0x18, 0x9c, 0xf8, 0x5c, 0x29,
	0x49, 0xdd, 0x74, 0x2a, 0x0a, 0x9a, 0x80, 0x6c, 0xc2, 0x16, 0x58, 0x32, 0xda, 0xb4, 0x3a, 0xf3,
	0xb4, 0x3a, 0xf9, 0x99, 0xd5, 0x49, 0xcf, 0x24, 0x52, 0x3d, 0xc6, 0x3f, 0xcc, 0x26, 0xe6, 0x1f,
	0xb6, 0x16, 0x94, 0x40, 0x00, 0x0f, 0xc0, 0xa2, 0xd1, 0x26, 0x8c, 0xb3, 0x40, 0x8f, 0x44, 0xa6,
	0x2b, 0x06, 0xc4, 0xc3, 0x0a, 0x5d, 0x5e, 0xce, 0x26, 0x4c, 0x1d, 0x7e, 0x91, 0x03, 0x57, 0x7b,
	0x2e, 0xba, 0xb0, 0x9c, 0xbe, 0xa7, 0x07, 0x7c, 0xb9, 0xf8, 0x5a, 0x7c, 0x49, 0x3a, 0xe5, 0x66,
	0xc6, 0x45, 0xea, 0xa9, 0x6e, 0xb0, 0xf3, 0x64, 0x54, 0x04, 0x65, 0x2d, 0x44, 0x98, 0x23, 0x88,
	0x01, 0xb0, 0xd1, 0xf3, 0xf0, 0x10, 0x4b, 0xaf, 0x75, 0x08, 0xca, 0x67, 0xb1, 0xf5, 0x2c, 0x3e,
	0x8b, 0xa5, 0x82, 0x52, 0xb0, 0xd1, 0xf3, 0x60, 0x57, 0x11, 0x5c, 0x31, 0x11, 0x36, 0xac, 0x73,
	0xd6, 0x27, 0x58, 0x36, 0xaf, 0x07, 0x50, 0xca, 0xcf, 0x5a, 0xd8, 0xda, 0xa8, 0x48, 0x50, 0x42,
	0x3b, 0xd8, 0x06, 0x85, 0x68, 0xd6, 0xa6, 0x2d, 0xe0, 0x9b, 0x2b, 0xfa, 0x6e, 0x40, 0x1d, 0xb1,
	0x51, 0x9c, 0x43, 0x11, 0x14, 0x10, 0x47, 0xb4, 0x9e, 0x2a, 0xe3, 0xc2, 0xff, 0x51, 0xc6, 0xbf,
	0x04, 0x57, 0xf0, 0x0b, 0x56, 0xc1, 0x20, 0xbe, 0x73, 0x00, 0xcd, 0xba, 0x73, 0x20, 0x12, 0x94,
	0x25, 0xfc, 0x22, 0x31, 0x6b, 0xfd, 0x35, 0x0f, 0xae, 0x45, 0xcd, 0xe8, 0xd3, 0x3e, 0xea, 0x23,
	0xc9, 0xc6, 0xee, 0x20, 0x5d, 0x34, 0xb9, 0xd7, 0x2f, 0x9a, 0x07, 0x60, 0xb9, 0xe7, 0x5a, 0xe4,
	0xdf, 0x8a, 0x01, 0xad, 0xb9, 0x55, 0x36, 0xa9, 0x84, 0x58, 0xdc, 0xf7, 0x43, 0x44, 0x50, 0x22,
	0x21, 0x3c, 0x05, 0x85, 0xdf, 0x92, 0xa3, 0x50, 0x7e, 0xcd, 0x7f, 0xf7, 0xd7, 0x88, 0x8c, 0xe2,
	0xc3, 0x45, 0x10, 0x7b, 0x8d, 0x65, 0xb6, 0x16, 0xf1, 0xf7, 0x3f, 0x6e, 0x9d, 0x81, 0x62, 0x34,
	0x1a, 0x60, 0x27, 0x18, 0xb7, 0x0e, 0x48, 0x2b, 0x48, 0xc0, 0xb3, 0x5a, 0x41, 0x42, 0x7c, 0x79,
	0xed, 0x83, 0x50, 0x4b, 0x73, 0xd8, 0x4b, 0xbe, 0xf5, 0xe7, 0x3c, 0x58, 0x9f, 0xaa, 0x2a, 0x28,
	0x01, 0x6e, 0x5f, 0x11, 0x5b, 0x7b, 0xba, 0x22, 0x1d, 0x37, 0x15, 0x4d, 0x57, 0x35, 0x51, 0x6b,
	0xa9, 0x7a, 0xab, 0xa1, 0x1e, 0x4b, 0x75, 0x79, 0x5f, 0x96, 0xf6, 0x4a, 0x73, 0x15, 0x7e, 0x38,
	0xe2, 0x6f, 0x4d, 0xd9, 0xb6, 0x6c, 0xaf, 0x87, 0xda, 0xd6, 0x53, 0x0b, 0x99, 0x50, 0x04, 0xb7,
	0x67, 0xb9, 0x51, 0x5b, 0xb5, 0x23, 0x59, 0xd3, 0xa4, 0xbd, 0x52, 0xae, 0xb2, 0x3d, 0x1c, 0xf1,
	0x95, 0x29, 0x27, 0x6a, 0xd8, 0xa0, 0x2f, 0x73, 0xa1, 0x48, 0x27, 0xb2, 0xf4, 0x58, 0x6e, 0x1c,
	0x94, 0xe6, 0x2f, 0x71, 0xa1, 0xa0, 0x0b, 0x0b, 0x3d, 0xb7, 0xec, 0x0e, 0xfc, 0x05, 0xb8, 0x35,
	0xdb, 0x85, 0xda, 0x3c, 0x3c, 0x91, 0xf6, 0x4a, 0xf9, 0xca, 0xed, 0xe1, 0x88, 0xdf, 0x9c, 0xe1,
	0x81, 0xb5, 0xd2, 0xcb, 0x1d, 0x7c, 0x22, 0xd5, 0xc9, 0x2d, 0x16, 0x2e, 0x75, 0xf0, 0x39, 0x6a,
	0x7f, 0xc3, 0x25, 0x24, 0xb5, 0x2e, 0x1e, 0x8a, 0xc4, 0xc3, 0xe2, 0x25, 0x97, 0x90, 0xbc, 0xb6,
	0x41, 0x7b, 0x5a, 0x65, 0xe1, 0x8b, 0x3f, 0x6d, 0xcf, 0xbd, 0xf5, 0x9f, 0x85, 0xa0, 0x97, 0x85,
	0xa9, 0x05, 0x3f, 0x02, 0x15, 0xe6, 0xba, 0x2e, 0x6a, 0xd2, 0x41, 0x53, 0x79, 0x92, 0x79, 0xa4,
	0x5b, 0xc3, 0x11, 0x5f, 0x4e, 0x99, 0x24, 0x1f, 0x28, 0xba, 0x59, 0x64, 0xbd, 0x2f, 0x3e, 0x92,
	0x74, 0x79, 0x4f, 0x6a, 0x68, 0xb2, 0xf6, 0xa4, 0x94, 0x4b, 0xdc, 0x2c, 0xb4, 0xdf, 0x37, 0x9e,
	0x21, 0xd9, 0x44, 0x36, 0x26, 0x35, 0x37, 0xed, 0xe0, 0x58, 0x7c, 0x72, 0x24, 0x35, 0x34, 0x9d,
	0xc2, 0xa5, 0xf9, 0x19, 0x0e, 0x8e, 0x8d, 0x41, 0x17, 0xd9, 0x98, 0x62, 0xf0, 0x31, 0xd8, 0xc9,
	0x38, 0x50, 0x25, 0xe5, 0x44, 0xae, 0x4b, 0xfa, 0x91, 0xac, 0x2a, 0xd2, 0xb1, 0x22, 0xa9, 0x52,
	0x43, 0x13, 0x35, 0xb9, 0xd9, 0x28, 0xe5, 0x2b, 0x77, 0x87, 0x23, 0xfe, 0xcd, 0x94, 0x33, 0x15,
	0xb9, 0x17, 0x56, 0x1b, 0x1d, 0x59, 0x9e, 0x8b, 0x7a, 0x2e, 0xf2, 0x90, 0x8d, 0x0d, 0xda, 0x28,
	0xa3, 0x98, 0x47, 0x8e, 0xc9, 0x83, 0xb7, 0x94, 0xba, 0xa4, 0x8b, 0xb5, 0x96, 0x2a, 0x95, 0x16,
	0x12, 0x31, 0x0f, 0xbd, 0x91, 0x27, 0xef, 0xbb, 0x6d, 0x24, 0x9e, 0xf6, 0x3d, 0x04, 0x7f, 0x0e,
	0xb6, 0xb2, 0x67, 0x7b, 0x52, 0x93, 0x0f, 0x75, 0x51, 0xd3, 0xc4, 0xfa, 0xa3, 0xd2, 0xe2, 0x8c,
	0xe0, 0xaa, 0x83, 0x53, 0xeb, 0x5c, 0xc4, 0xd8, 0x68, 0x3f, 0x83, 0x07, 0x80, 0xcf, 0x98, 0x1f,
	0x89, 0x87, 0x72, 0x5d, 0x6e, 0xb6, 0x54, 0xbd, 0xde, 0x6c, 0x68, 0x52, 0x43, 0x2b, 0x2d, 0x55,
	0xde, 0x18, 0x8e, 0xf8, 0xdb, 0x29, 0x1f, 0x47, 0xc6, 0xb9, 0xd5, 0x26, 0xed, 0xb1, 0xce, 0x86,
	0x26, 0x58, 0x07, 0xdb, 0x19, 0x47, 0x9a, 0xa4, 0x1c, 0xa9, 0xfa, 0x89, 0xdc, 0x3c, 0x64, 0x91,
	0xb9, 0x52, 0xe1, 0x86, 0x23, 0x7e, 0x2b, 0xe5, 0x46, 0x43, 0x6e, 0xd7, 0x3b, 0xb1, 0x9c, 0x73,
	0x16, 0x8f, 0x1f, 0x83, 0x8d, 0x8c, 0x93, 0xa6, 0xf6, 0x50, 0x52, 0x4a, 0xcb, 0x95, 0x1b, 0xc3,
	0x11, 0x0f, 0x53, 0xa6, 0x4d, 0x7c, 0x86, 0xdc, 0x20, 0xe5, 0xfe, 0x3b, 0x0f, 0xd6, 0xd2, 0xff,
	0x43, 0xc0, 0x8f, 0xc1, 0x16, 0x2d, 0x9e, 0x16, 0xd9, 0x5b, 0xd7, 0x9e, 0x1c, 0x4b, 0x99, 0xa4,
	0xa3, 0x6f, 0x9e, 0x36, 0x4a, 0x66, 0xdd, 0x4f, 0xc0, 0xcd, 0xac, 0xfd, 0x63, 0x51, 0x69, 0x90,
	0x6a, 0xce, 0x55, 0x36, 0x87, 0x23, 0xfe, 0x7a, 0xda, 0xf6, 0xb1, 0xe1, 0xda, 0xa4, 0x90, 0x3f,
	0x02, 0x95, 0xac, 0x9d, 0xda, 0x52, 0x8f, 0xa5, 0x86, 0x4a, 0x62, 0x30, 0xcf, 0x9e, 0x23, 0x6d,
	0xaa, 0xf6, 0xbd, 0x1e, 0xb2, 0x3d, 0x12, 0x80, 0x19, 0xa7, 0x26, 0x61, 0x94, 0x1b, 0x61, 0x72,
	0xcd, 0x38, 0x35, 0x89, 0xa1, 0x65, 0xb3, 0x00, 0xbe, 0x07, 0x6e, 0x64, 0xed, 0x15, 0x69, 0xbf,
	0xd5, 0x20, 0xf5, 0x5f, 0x1e, 0x8e, 0xf8, 0x8d, 0xb4, 0xa9, 0x82, 0x9e, 0xf6, 0x6d, 0x13, 0x7e,
	0x00, 0x36, 0xb3, 0x56, 0x8d, 0xa6, 0x2e, 0xd6, 0xe9, 0x9e, 0x8b, 0x95, 0xca, 0x70, 0xc4, 0xdf,
	0x48, 0x1b, 0x36, 0x1c, 0x36, 0x0f, 0x06, 0xf1, 0xff, 0xfd, 0x02, 0x28, 0x26, 0xa6, 0x44, 0xf8,
	0x33, 0x50, 0x16, 0x5b, 0x7b, 0xb2, 0x16, 0xf8, 0xc8, 0x44, 0x9e, 0xfa, 0x4b, 0xa8, 0x27, 0xc3,
	0xfe, 0x1e, 0xb8, 0x91, 0xb2, 0x4c, 0xd2, 0x30, 0xbd, 0x40, 0xc2, 0x2e, 0x26, 0xe0, 0xfb, 0xe0,
	0x7a, 0xca, 0x4a, 0x54, 0x55, 0xf9, 0xa0, 0x21, 0x91, 0xd2, 0xbe, 0x39, 0x1c, 0xf1, 0xd7, 0x12,
	0x46, 0x62, 0xd0, 0x5c, 0x48, 0xe1, 0xa4, 0x77, 0x62, 0x7c, 0x57, 0x7f, 0x28, 0x36, 0x0e, 0x28,
	0xe1, 0xd2, 0x97, 0x4a, 0x6e, 0x47, 0xd9, 0xae, 0x7e, 0x66, 0xd8, 0x1d, 0xc6, 0x4a, 0x29, 0x73,
	0xe9, 0x84, 0x10, 0x52, 0x5d, 0xd2, 0x09, 0xe7, 0xc7, 0x7c, 0x9b, 0xb0, 0x0f, 0x3f, 0x15, 0x9c,
	0x58, 0xe8, 0xf9, 0x8c, 0x33, 0x47, 0x54, 0xbf, 0x38, 0x75, 0xe6, 0x88, 0xe4, 0xa7, 0x6d, 0x02,
	0x76, 0x5f, 0x9a, 0x61, 0x13, 0xf0, 0x7a, 0x36, 0xa2, 0x31, 0xa1, 0x5f, 0x99, 0x8a, 0x68, 0x44,
	0xe5, 0xf0, 0x01, 0xa8, 0xa4, 0xac, 0xea, 0xcd, 0x23, 0xca, 0x98, 0xe2, 0xde, 0x9e, 0xb4, 0x57,
	0x5a, 0xae, 0x6c, 0x0d, 0x47, 0xfc, 0xcd, 0x84, 0x65, 0xdd, 0xe9, 0x12, 0xbe, 0x14, 0x4d, 0x33,
	0xec, 0x03, 0xb5, 0xe6, 0x57, 0x2f, 0xb7, 0x73, 0x5f, 0xbf, 0xdc, 0xce, 0xfd, 0xeb, 0xe5, 0x76,
	0xee, 0xcb, 0x57, 0xdb, 0x73, 0x5f, 0xbf, 0xda, 0x9e, 0xfb, 0xc7, 0xab, 0xed, 0xb9, 0xcf, 0xde,
	0xef, 0x58, 0xf8, 0xac, 0x7f, 0xba, 0xdb, 0x76, 0xba, 0xd5, 0xc4, 0x17, 0xe9, 0xc4, 0x4f, 0xcf,
	0x7c, 0x56, 0xed, 0x38, 0x55, 0xdb, 0x31, 0xe3, 0x0f, 0xd5, 0xa7, 0x4b, 0x74, 0x40, 0x7a, 0xf7,
	0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x19, 0xbd, 0x77, 0xb0, 0xc6, 0x16, 0x00, 0x00,
}

func (this *EncryptedEvidence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptedEvidence)
	if !ok {
		that2, ok := that.(EncryptedEvidence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AlgorithmId != that1.AlgorithmId {
		return false
	}
	if len(this.RecipientKeyIds) != len(that1.RecipientKeyIds) {
		return false
	}
	for i := range this.RecipientKeyIds {
		if this.RecipientKeyIds[i] != that1.RecipientKeyIds[i] {
			return false
		}
	}
	if len(this.EncryptedKeys) != len(that1.EncryptedKeys) {
		return false
	}
	for i := range this.EncryptedKeys {
		if !bytes.Equal(this.EncryptedKeys[i], that1.EncryptedKeys[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return false
	}
	if !bytes.Equal(this.SenderSignature, that1.SenderSignature) {
		return false
	}
	if !bytes.Equal(this.SenderPubKey, that1.SenderPubKey) {
		return false
	}
	if this.ContentType != that1.ContentType {
		return false
	}
	if this.EvidenceHash != that1.EvidenceHash {
		return false
	}
	return true
}
func (this *FraudReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FraudReport)
	if !ok {
		that2, ok := that.(FraudReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Reporter != that1.Reporter {
		return false
	}
	if this.ReportedParty != that1.ReportedParty {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if len(this.Evidence) != len(that1.Evidence) {
		return false
	}
	for i := range this.Evidence {
		if !this.Evidence[i].Equal(&that1.Evidence[i]) {
			return false
		}
	}
	if this.Status != that1.Status {
		return false
	}
	if this.AssignedModerator != that1.AssignedModerator {
		return false
	}
	if this.Resolution != that1.Resolution {
		return false
	}
	if this.ResolutionNotes != that1.ResolutionNotes {
		return false
	}
	if !this.SubmittedAt.Equal(that1.SubmittedAt) {
		return false
	}
	if !this.UpdatedAt.Equal(that1.UpdatedAt) {
		return false
	}
	if that1.ResolvedAt == nil {
		if this.ResolvedAt != nil {
			return false
		}
	} else if !this.ResolvedAt.Equal(*that1.ResolvedAt) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.ContentHash != that1.ContentHash {
		return false
	}
	if len(this.RelatedOrderIds) != len(that1.RelatedOrderIds) {
		return false
	}
	for i := range this.RelatedOrderIds {
		if this.RelatedOrderIds[i] != that1.RelatedOrderIds[i] {
			return false
		}
	}
	return true
}
func (this *FraudAuditLog) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FraudAuditLog)
	if !ok {
		that2, ok := that.(FraudAuditLog)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.ReportId != that1.ReportId {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if this.Actor != that1.Actor {
		return false
	}
	if this.PreviousStatus != that1.PreviousStatus {
		return false
	}
	if this.NewStatus != that1.NewStatus {
		return false
	}
	if this.Details != that1.Details {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.TxHash != that1.TxHash {
		return false
	}
	return true
}
func (this *ModeratorQueueEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModeratorQueueEntry)
	if !ok {
		that2, ok := that.(ModeratorQueueEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ReportId != that1.ReportId {
		return false
	}
	if this.Priority != that1.Priority {
		return false
	}
	if !this.QueuedAt.Equal(that1.QueuedAt) {
		return false
	}
	if this.Category != that1.Category {
		return false
	}
	if this.AssignedTo != that1.AssignedTo {
		return false
	}
	return true
}
func (m *EncryptedEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceHash) > 0 {
		i -= len(m.EvidenceHash)
		copy(dAtA[i:], m.EvidenceHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EvidenceHash)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ContentType) > 0 {
		i -= len(m.ContentType)
		copy(dAtA[i:], m.ContentType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentType)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.SenderPubKey) > 0 {
		i -= len(m.SenderPubKey)
		copy(dAtA[i:], m.SenderPubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SenderPubKey)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SenderSignature) > 0 {
		i -= len(m.SenderSignature)
		copy(dAtA[i:], m.SenderSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SenderSignature)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Ciphertext) > 0 {
		i -= len(m.Ciphertext)
		copy(dAtA[i:], m.Ciphertext)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ciphertext)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.EncryptedKeys) > 0 {
		for iNdEx := len(m.EncryptedKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedKeys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedKeys[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RecipientKeyIds) > 0 {
		for iNdEx := len(m.RecipientKeyIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientKeyIds[iNdEx])
			copy(dAtA[i:], m.RecipientKeyIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RecipientKeyIds[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AlgorithmId) > 0 {
		i -= len(m.AlgorithmId)
		copy(dAtA[i:], m.AlgorithmId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AlgorithmId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FraudReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FraudReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FraudReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelatedOrderIds) > 0 {
		for iNdEx := len(m.RelatedOrderIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RelatedOrderIds[iNdEx])
			copy(dAtA[i:], m.RelatedOrderIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RelatedOrderIds[iNdEx])))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if len(m.ContentHash) > 0 {
		i -= len(m.ContentHash)
		copy(dAtA[i:], m.ContentHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContentHash)))
		i--
		dAtA[i] = 0x7a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x70
	}
	if m.ResolvedAt != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ResolvedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ResolvedAt):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTypes(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x6a
	}
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTypes(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x62
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.SubmittedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SubmittedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintTypes(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x5a
	if len(m.ResolutionNotes) > 0 {
		i -= len(m.ResolutionNotes)
		copy(dAtA[i:], m.ResolutionNotes)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResolutionNotes)))
		i--
		dAtA[i] = 0x52
	}
	if m.Resolution != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Resolution))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AssignedModerator) > 0 {
		i -= len(m.AssignedModerator)
		copy(dAtA[i:], m.AssignedModerator)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssignedModerator)))
		i--
		dAtA[i] = 0x42
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Evidence) > 0 {
		for iNdEx := len(m.Evidence) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Evidence[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Category != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ReportedParty) > 0 {
		i -= len(m.ReportedParty)
		copy(dAtA[i:], m.ReportedParty)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReportedParty)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FraudAuditLog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FraudAuditLog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FraudAuditLog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x52
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x48
	}
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintTypes(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x42
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x3a
	}
	if m.NewStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NewStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.PreviousStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PreviousStatus))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x22
	}
	if m.Action != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Action))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ReportId) > 0 {
		i -= len(m.ReportId)
		copy(dAtA[i:], m.ReportId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReportId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModeratorQueueEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModeratorQueueEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModeratorQueueEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssignedTo) > 0 {
		i -= len(m.AssignedTo)
		copy(dAtA[i:], m.AssignedTo)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssignedTo)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Category != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x20
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.QueuedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.QueuedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintTypes(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1a
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ReportId) > 0 {
		i -= len(m.ReportId)
		copy(dAtA[i:], m.ReportId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReportId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EncryptedEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AlgorithmId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RecipientKeyIds) > 0 {
		for _, s := range m.RecipientKeyIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EncryptedKeys) > 0 {
		for _, b := range m.EncryptedKeys {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ciphertext)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SenderSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SenderPubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContentType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EvidenceHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FraudReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReportedParty)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Category != 0 {
		n += 1 + sovTypes(uint64(m.Category))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Evidence) > 0 {
		for _, e := range m.Evidence {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.AssignedModerator)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovTypes(uint64(m.Resolution))
	}
	l = len(m.ResolutionNotes)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.SubmittedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.ResolvedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ResolvedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	l = len(m.ContentHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RelatedOrderIds) > 0 {
		for _, s := range m.RelatedOrderIds {
			l = len(s)
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *FraudAuditLog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReportId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != 0 {
		n += 1 + sovTypes(uint64(m.Action))
	}
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.PreviousStatus != 0 {
		n += 1 + sovTypes(uint64(m.PreviousStatus))
	}
	if m.NewStatus != 0 {
		n += 1 + sovTypes(uint64(m.NewStatus))
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ModeratorQueueEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReportId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.QueuedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.Category != 0 {
		n += 1 + sovTypes(uint64(m.Category))
	}
	l = len(m.AssignedTo)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EncryptedEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlgorithmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientKeyIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientKeyIds = append(m.RecipientKeyIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKeys = append(m.EncryptedKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedKeys[len(m.EncryptedKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertext = append(m.Ciphertext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphertext == nil {
				m.Ciphertext = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderSignature = append(m.SenderSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderSignature == nil {
				m.SenderSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderPubKey = append(m.SenderPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderPubKey == nil {
				m.SenderPubKey = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FraudReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FraudReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FraudReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedParty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportedParty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= FraudCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = append(m.Evidence, EncryptedEvidence{})
			if err := m.Evidence[len(m.Evidence)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FraudReportStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedModerator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedModerator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resolution |= ResolutionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionNotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolutionNotes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.SubmittedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolvedAt == nil {
				m.ResolvedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ResolvedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContentHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContentHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedOrderIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedOrderIds = append(m.RelatedOrderIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FraudAuditLog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FraudAuditLog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FraudAuditLog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			m.Action = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Action |= AuditAction(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousStatus", wireType)
			}
			m.PreviousStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousStatus |= FraudReportStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewStatus", wireType)
			}
			m.NewStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewStatus |= FraudReportStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModeratorQueueEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModeratorQueueEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModeratorQueueEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReportId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.QueuedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= FraudCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedTo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedTo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)

