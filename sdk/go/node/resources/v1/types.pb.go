// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/resources/v1/types.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ResourceClass defines the resource category.
type ResourceClass int32

const (
	ResourceClass_RESOURCE_CLASS_UNSPECIFIED ResourceClass = 0
	ResourceClass_RESOURCE_CLASS_COMPUTE     ResourceClass = 1
	ResourceClass_RESOURCE_CLASS_STORAGE     ResourceClass = 2
	ResourceClass_RESOURCE_CLASS_NETWORK     ResourceClass = 3
)

var ResourceClass_name = map[int32]string{
	0: "RESOURCE_CLASS_UNSPECIFIED",
	1: "RESOURCE_CLASS_COMPUTE",
	2: "RESOURCE_CLASS_STORAGE",
	3: "RESOURCE_CLASS_NETWORK",
}

var ResourceClass_value = map[string]int32{
	"RESOURCE_CLASS_UNSPECIFIED": 0,
	"RESOURCE_CLASS_COMPUTE":     1,
	"RESOURCE_CLASS_STORAGE":     2,
	"RESOURCE_CLASS_NETWORK":     3,
}

func (x ResourceClass) String() string {
	return proto.EnumName(ResourceClass_name, int32(x))
}

func (ResourceClass) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{0}
}

// AllocationState defines the reservation lifecycle state.
type AllocationState int32

const (
	AllocationState_ALLOCATION_STATE_UNSPECIFIED AllocationState = 0
	AllocationState_ALLOCATION_STATE_PENDING     AllocationState = 1
	AllocationState_ALLOCATION_STATE_ACTIVE      AllocationState = 2
	AllocationState_ALLOCATION_STATE_EXPIRED     AllocationState = 3
	AllocationState_ALLOCATION_STATE_RELEASED    AllocationState = 4
)

var AllocationState_name = map[int32]string{
	0: "ALLOCATION_STATE_UNSPECIFIED",
	1: "ALLOCATION_STATE_PENDING",
	2: "ALLOCATION_STATE_ACTIVE",
	3: "ALLOCATION_STATE_EXPIRED",
	4: "ALLOCATION_STATE_RELEASED",
}

var AllocationState_value = map[string]int32{
	"ALLOCATION_STATE_UNSPECIFIED": 0,
	"ALLOCATION_STATE_PENDING":     1,
	"ALLOCATION_STATE_ACTIVE":      2,
	"ALLOCATION_STATE_EXPIRED":     3,
	"ALLOCATION_STATE_RELEASED":    4,
}

func (x AllocationState) String() string {
	return proto.EnumName(AllocationState_name, int32(x))
}

func (AllocationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{1}
}

// Locality captures location information.
type Locality struct {
	Region     string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty" yaml:"region"`
	Zone       string `protobuf:"bytes,2,opt,name=zone,proto3" json:"zone,omitempty" yaml:"zone"`
	Datacenter string `protobuf:"bytes,3,opt,name=datacenter,proto3" json:"datacenter,omitempty" yaml:"datacenter"`
	Country    string `protobuf:"bytes,4,opt,name=country,proto3" json:"country,omitempty" yaml:"country"`
}

func (m *Locality) Reset()         { *m = Locality{} }
func (m *Locality) String() string { return proto.CompactTextString(m) }
func (*Locality) ProtoMessage()    {}
func (*Locality) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{0}
}
func (m *Locality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Locality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Locality.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Locality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Locality.Merge(m, src)
}
func (m *Locality) XXX_Size() int {
	return m.Size()
}
func (m *Locality) XXX_DiscardUnknown() {
	xxx_messageInfo_Locality.DiscardUnknown(m)
}

var xxx_messageInfo_Locality proto.InternalMessageInfo

func (m *Locality) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Locality) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Locality) GetDatacenter() string {
	if m != nil {
		return m.Datacenter
	}
	return ""
}

func (m *Locality) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

// ResourceCapacity describes capacity values.
type ResourceCapacity struct {
	CpuCores    int64  `protobuf:"varint,1,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores,omitempty" yaml:"cpu_cores"`
	MemoryGb    int64  `protobuf:"varint,2,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty" yaml:"memory_gb"`
	StorageGb   int64  `protobuf:"varint,3,opt,name=storage_gb,json=storageGb,proto3" json:"storage_gb,omitempty" yaml:"storage_gb"`
	NetworkMbps int64  `protobuf:"varint,4,opt,name=network_mbps,json=networkMbps,proto3" json:"network_mbps,omitempty" yaml:"network_mbps"`
	Gpus        int64  `protobuf:"varint,5,opt,name=gpus,proto3" json:"gpus,omitempty" yaml:"gpus"`
	GpuType     string `protobuf:"bytes,6,opt,name=gpu_type,json=gpuType,proto3" json:"gpu_type,omitempty" yaml:"gpu_type"`
}

func (m *ResourceCapacity) Reset()         { *m = ResourceCapacity{} }
func (m *ResourceCapacity) String() string { return proto.CompactTextString(m) }
func (*ResourceCapacity) ProtoMessage()    {}
func (*ResourceCapacity) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{1}
}
func (m *ResourceCapacity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceCapacity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceCapacity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceCapacity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceCapacity.Merge(m, src)
}
func (m *ResourceCapacity) XXX_Size() int {
	return m.Size()
}
func (m *ResourceCapacity) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceCapacity.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceCapacity proto.InternalMessageInfo

func (m *ResourceCapacity) GetCpuCores() int64 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *ResourceCapacity) GetMemoryGb() int64 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

func (m *ResourceCapacity) GetStorageGb() int64 {
	if m != nil {
		return m.StorageGb
	}
	return 0
}

func (m *ResourceCapacity) GetNetworkMbps() int64 {
	if m != nil {
		return m.NetworkMbps
	}
	return 0
}

func (m *ResourceCapacity) GetGpus() int64 {
	if m != nil {
		return m.Gpus
	}
	return 0
}

func (m *ResourceCapacity) GetGpuType() string {
	if m != nil {
		return m.GpuType
	}
	return ""
}

// ResourceInventory captures provider availability snapshots.
type ResourceInventory struct {
	InventoryId       string           `protobuf:"bytes,1,opt,name=inventory_id,json=inventoryId,proto3" json:"inventory_id" yaml:"inventory_id"`
	ProviderAddress   string           `protobuf:"bytes,2,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	ResourceClass     ResourceClass    `protobuf:"varint,3,opt,name=resource_class,json=resourceClass,proto3,enum=virtengine.resources.v1.ResourceClass" json:"resource_class" yaml:"resource_class"`
	Total             ResourceCapacity `protobuf:"bytes,4,opt,name=total,proto3" json:"total" yaml:"total"`
	Available         ResourceCapacity `protobuf:"bytes,5,opt,name=available,proto3" json:"available" yaml:"available"`
	Locality          Locality         `protobuf:"bytes,6,opt,name=locality,proto3" json:"locality" yaml:"locality"`
	Active            bool             `protobuf:"varint,7,opt,name=active,proto3" json:"active" yaml:"active"`
	HeartbeatSequence uint64           `protobuf:"varint,8,opt,name=heartbeat_sequence,json=heartbeatSequence,proto3" json:"heartbeat_sequence" yaml:"heartbeat_sequence"`
	LastHeartbeat     time.Time        `protobuf:"bytes,9,opt,name=last_heartbeat,json=lastHeartbeat,proto3,stdtime" json:"last_heartbeat" yaml:"last_heartbeat"`
	UpdatedAt         time.Time        `protobuf:"bytes,10,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
}

func (m *ResourceInventory) Reset()         { *m = ResourceInventory{} }
func (m *ResourceInventory) String() string { return proto.CompactTextString(m) }
func (*ResourceInventory) ProtoMessage()    {}
func (*ResourceInventory) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{2}
}
func (m *ResourceInventory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceInventory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceInventory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceInventory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceInventory.Merge(m, src)
}
func (m *ResourceInventory) XXX_Size() int {
	return m.Size()
}
func (m *ResourceInventory) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceInventory.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceInventory proto.InternalMessageInfo

func (m *ResourceInventory) GetInventoryId() string {
	if m != nil {
		return m.InventoryId
	}
	return ""
}

func (m *ResourceInventory) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *ResourceInventory) GetResourceClass() ResourceClass {
	if m != nil {
		return m.ResourceClass
	}
	return ResourceClass_RESOURCE_CLASS_UNSPECIFIED
}

func (m *ResourceInventory) GetTotal() ResourceCapacity {
	if m != nil {
		return m.Total
	}
	return ResourceCapacity{}
}

func (m *ResourceInventory) GetAvailable() ResourceCapacity {
	if m != nil {
		return m.Available
	}
	return ResourceCapacity{}
}

func (m *ResourceInventory) GetLocality() Locality {
	if m != nil {
		return m.Locality
	}
	return Locality{}
}

func (m *ResourceInventory) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ResourceInventory) GetHeartbeatSequence() uint64 {
	if m != nil {
		return m.HeartbeatSequence
	}
	return 0
}

func (m *ResourceInventory) GetLastHeartbeat() time.Time {
	if m != nil {
		return m.LastHeartbeat
	}
	return time.Time{}
}

func (m *ResourceInventory) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

// ResourceRequest represents an allocation request.
type ResourceRequest struct {
	RequestId        string           `protobuf:"bytes,1,opt,name=request_id,json=requestId,proto3" json:"request_id" yaml:"request_id"`
	RequesterAddress string           `protobuf:"bytes,2,opt,name=requester_address,json=requesterAddress,proto3" json:"requester_address" yaml:"requester_address"`
	ResourceClass    ResourceClass    `protobuf:"varint,3,opt,name=resource_class,json=resourceClass,proto3,enum=virtengine.resources.v1.ResourceClass" json:"resource_class" yaml:"resource_class"`
	Required         ResourceCapacity `protobuf:"bytes,4,opt,name=required,proto3" json:"required" yaml:"required"`
	Locality         Locality         `protobuf:"bytes,5,opt,name=locality,proto3" json:"locality" yaml:"locality"`
	LocalityPolicy   string           `protobuf:"bytes,6,opt,name=locality_policy,json=localityPolicy,proto3" json:"locality_policy,omitempty" yaml:"locality_policy"`
	MaxCandidates    uint64           `protobuf:"varint,7,opt,name=max_candidates,json=maxCandidates,proto3" json:"max_candidates,omitempty" yaml:"max_candidates"`
}

func (m *ResourceRequest) Reset()         { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()    {}
func (*ResourceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{3}
}
func (m *ResourceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceRequest.Merge(m, src)
}
func (m *ResourceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ResourceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceRequest proto.InternalMessageInfo

func (m *ResourceRequest) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ResourceRequest) GetRequesterAddress() string {
	if m != nil {
		return m.RequesterAddress
	}
	return ""
}

func (m *ResourceRequest) GetResourceClass() ResourceClass {
	if m != nil {
		return m.ResourceClass
	}
	return ResourceClass_RESOURCE_CLASS_UNSPECIFIED
}

func (m *ResourceRequest) GetRequired() ResourceCapacity {
	if m != nil {
		return m.Required
	}
	return ResourceCapacity{}
}

func (m *ResourceRequest) GetLocality() Locality {
	if m != nil {
		return m.Locality
	}
	return Locality{}
}

func (m *ResourceRequest) GetLocalityPolicy() string {
	if m != nil {
		return m.LocalityPolicy
	}
	return ""
}

func (m *ResourceRequest) GetMaxCandidates() uint64 {
	if m != nil {
		return m.MaxCandidates
	}
	return 0
}

// ResourceAllocation stores the allocation decision.
type ResourceAllocation struct {
	AllocationId     string           `protobuf:"bytes,1,opt,name=allocation_id,json=allocationId,proto3" json:"allocation_id" yaml:"allocation_id"`
	RequestId        string           `protobuf:"bytes,2,opt,name=request_id,json=requestId,proto3" json:"request_id" yaml:"request_id"`
	RequesterAddress string           `protobuf:"bytes,3,opt,name=requester_address,json=requesterAddress,proto3" json:"requester_address" yaml:"requester_address"`
	ProviderAddress  string           `protobuf:"bytes,4,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	ResourceClass    ResourceClass    `protobuf:"varint,5,opt,name=resource_class,json=resourceClass,proto3,enum=virtengine.resources.v1.ResourceClass" json:"resource_class" yaml:"resource_class"`
	Required         ResourceCapacity `protobuf:"bytes,6,opt,name=required,proto3" json:"required" yaml:"required"`
	Assigned         ResourceCapacity `protobuf:"bytes,7,opt,name=assigned,proto3" json:"assigned" yaml:"assigned"`
	State            AllocationState  `protobuf:"varint,8,opt,name=state,proto3,enum=virtengine.resources.v1.AllocationState" json:"state" yaml:"state"`
	Score            string           `protobuf:"bytes,9,opt,name=score,proto3" json:"score" yaml:"score"`
	Locality         Locality         `protobuf:"bytes,10,opt,name=locality,proto3" json:"locality" yaml:"locality"`
	CreatedAt        time.Time        `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	ExpiresAt        *time.Time       `protobuf:"bytes,12,opt,name=expires_at,json=expiresAt,proto3,stdtime" json:"expires_at,omitempty" yaml:"expires_at"`
	ActivatedAt      *time.Time       `protobuf:"bytes,13,opt,name=activated_at,json=activatedAt,proto3,stdtime" json:"activated_at,omitempty" yaml:"activated_at"`
	UpdatedAt        time.Time        `protobuf:"bytes,14,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	BlockHeight      int64            `protobuf:"varint,15,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *ResourceAllocation) Reset()         { *m = ResourceAllocation{} }
func (m *ResourceAllocation) String() string { return proto.CompactTextString(m) }
func (*ResourceAllocation) ProtoMessage()    {}
func (*ResourceAllocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{4}
}
func (m *ResourceAllocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceAllocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceAllocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceAllocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceAllocation.Merge(m, src)
}
func (m *ResourceAllocation) XXX_Size() int {
	return m.Size()
}
func (m *ResourceAllocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceAllocation.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceAllocation proto.InternalMessageInfo

func (m *ResourceAllocation) GetAllocationId() string {
	if m != nil {
		return m.AllocationId
	}
	return ""
}

func (m *ResourceAllocation) GetRequestId() string {
	if m != nil {
		return m.RequestId
	}
	return ""
}

func (m *ResourceAllocation) GetRequesterAddress() string {
	if m != nil {
		return m.RequesterAddress
	}
	return ""
}

func (m *ResourceAllocation) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *ResourceAllocation) GetResourceClass() ResourceClass {
	if m != nil {
		return m.ResourceClass
	}
	return ResourceClass_RESOURCE_CLASS_UNSPECIFIED
}

func (m *ResourceAllocation) GetRequired() ResourceCapacity {
	if m != nil {
		return m.Required
	}
	return ResourceCapacity{}
}

func (m *ResourceAllocation) GetAssigned() ResourceCapacity {
	if m != nil {
		return m.Assigned
	}
	return ResourceCapacity{}
}

func (m *ResourceAllocation) GetState() AllocationState {
	if m != nil {
		return m.State
	}
	return AllocationState_ALLOCATION_STATE_UNSPECIFIED
}

func (m *ResourceAllocation) GetScore() string {
	if m != nil {
		return m.Score
	}
	return ""
}

func (m *ResourceAllocation) GetLocality() Locality {
	if m != nil {
		return m.Locality
	}
	return Locality{}
}

func (m *ResourceAllocation) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *ResourceAllocation) GetExpiresAt() *time.Time {
	if m != nil {
		return m.ExpiresAt
	}
	return nil
}

func (m *ResourceAllocation) GetActivatedAt() *time.Time {
	if m != nil {
		return m.ActivatedAt
	}
	return nil
}

func (m *ResourceAllocation) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *ResourceAllocation) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// AllocationEvent records allocation lifecycle transitions.
type AllocationEvent struct {
	AllocationId    string          `protobuf:"bytes,1,opt,name=allocation_id,json=allocationId,proto3" json:"allocation_id" yaml:"allocation_id"`
	Sequence        uint64          `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence" yaml:"sequence"`
	State           AllocationState `protobuf:"varint,3,opt,name=state,proto3,enum=virtengine.resources.v1.AllocationState" json:"state" yaml:"state"`
	Reason          string          `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty" yaml:"reason"`
	ProviderAddress string          `protobuf:"bytes,5,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	CreatedAt       time.Time       `protobuf:"bytes,6,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
}

func (m *AllocationEvent) Reset()         { *m = AllocationEvent{} }
func (m *AllocationEvent) String() string { return proto.CompactTextString(m) }
func (*AllocationEvent) ProtoMessage()    {}
func (*AllocationEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{5}
}
func (m *AllocationEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocationEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocationEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocationEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocationEvent.Merge(m, src)
}
func (m *AllocationEvent) XXX_Size() int {
	return m.Size()
}
func (m *AllocationEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocationEvent.DiscardUnknown(m)
}

var xxx_messageInfo_AllocationEvent proto.InternalMessageInfo

func (m *AllocationEvent) GetAllocationId() string {
	if m != nil {
		return m.AllocationId
	}
	return ""
}

func (m *AllocationEvent) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *AllocationEvent) GetState() AllocationState {
	if m != nil {
		return m.State
	}
	return AllocationState_ALLOCATION_STATE_UNSPECIFIED
}

func (m *AllocationEvent) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *AllocationEvent) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *AllocationEvent) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

// SlashingEvent captures non-fulfillment penalties.
type SlashingEvent struct {
	ProviderAddress string    `protobuf:"bytes,1,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	AllocationId    string    `protobuf:"bytes,2,opt,name=allocation_id,json=allocationId,proto3" json:"allocation_id" yaml:"allocation_id"`
	Reason          string    `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	Penalty         string    `protobuf:"bytes,4,opt,name=penalty,proto3" json:"penalty" yaml:"penalty"`
	CreatedAt       time.Time `protobuf:"bytes,5,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
}

func (m *SlashingEvent) Reset()         { *m = SlashingEvent{} }
func (m *SlashingEvent) String() string { return proto.CompactTextString(m) }
func (*SlashingEvent) ProtoMessage()    {}
func (*SlashingEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{6}
}
func (m *SlashingEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashingEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashingEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashingEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashingEvent.Merge(m, src)
}
func (m *SlashingEvent) XXX_Size() int {
	return m.Size()
}
func (m *SlashingEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashingEvent.DiscardUnknown(m)
}

var xxx_messageInfo_SlashingEvent proto.InternalMessageInfo

func (m *SlashingEvent) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *SlashingEvent) GetAllocationId() string {
	if m != nil {
		return m.AllocationId
	}
	return ""
}

func (m *SlashingEvent) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *SlashingEvent) GetPenalty() string {
	if m != nil {
		return m.Penalty
	}
	return ""
}

func (m *SlashingEvent) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

// Params defines module parameters.
type Params struct {
	HeartbeatTimeoutSeconds   uint64 `protobuf:"varint,1,opt,name=heartbeat_timeout_seconds,json=heartbeatTimeoutSeconds,proto3" json:"heartbeat_timeout_seconds" yaml:"heartbeat_timeout_seconds"`
	ReservationTimeoutSeconds uint64 `protobuf:"varint,2,opt,name=reservation_timeout_seconds,json=reservationTimeoutSeconds,proto3" json:"reservation_timeout_seconds" yaml:"reservation_timeout_seconds"`
	MaxCandidates             uint64 `protobuf:"varint,3,opt,name=max_candidates,json=maxCandidates,proto3" json:"max_candidates" yaml:"max_candidates"`
	LocalityWeight            string `protobuf:"bytes,4,opt,name=locality_weight,json=localityWeight,proto3" json:"locality_weight" yaml:"locality_weight"`
	CapacityWeight            string `protobuf:"bytes,5,opt,name=capacity_weight,json=capacityWeight,proto3" json:"capacity_weight" yaml:"capacity_weight"`
	SlashingGraceSeconds      uint64 `protobuf:"varint,6,opt,name=slashing_grace_seconds,json=slashingGraceSeconds,proto3" json:"slashing_grace_seconds" yaml:"slashing_grace_seconds"`
	SlashingPenalty           string `protobuf:"bytes,7,opt,name=slashing_penalty,json=slashingPenalty,proto3" json:"slashing_penalty" yaml:"slashing_penalty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_8e2fabbb30d32154, []int{7}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetHeartbeatTimeoutSeconds() uint64 {
	if m != nil {
		return m.HeartbeatTimeoutSeconds
	}
	return 0
}

func (m *Params) GetReservationTimeoutSeconds() uint64 {
	if m != nil {
		return m.ReservationTimeoutSeconds
	}
	return 0
}

func (m *Params) GetMaxCandidates() uint64 {
	if m != nil {
		return m.MaxCandidates
	}
	return 0
}

func (m *Params) GetLocalityWeight() string {
	if m != nil {
		return m.LocalityWeight
	}
	return ""
}

func (m *Params) GetCapacityWeight() string {
	if m != nil {
		return m.CapacityWeight
	}
	return ""
}

func (m *Params) GetSlashingGraceSeconds() uint64 {
	if m != nil {
		return m.SlashingGraceSeconds
	}
	return 0
}

func (m *Params) GetSlashingPenalty() string {
	if m != nil {
		return m.SlashingPenalty
	}
	return ""
}

func init() {
	proto.RegisterEnum("virtengine.resources.v1.ResourceClass", ResourceClass_name, ResourceClass_value)
	proto.RegisterEnum("virtengine.resources.v1.AllocationState", AllocationState_name, AllocationState_value)
	proto.RegisterType((*Locality)(nil), "virtengine.resources.v1.Locality")
	proto.RegisterType((*ResourceCapacity)(nil), "virtengine.resources.v1.ResourceCapacity")
	proto.RegisterType((*ResourceInventory)(nil), "virtengine.resources.v1.ResourceInventory")
	proto.RegisterType((*ResourceRequest)(nil), "virtengine.resources.v1.ResourceRequest")
	proto.RegisterType((*ResourceAllocation)(nil), "virtengine.resources.v1.ResourceAllocation")
	proto.RegisterType((*AllocationEvent)(nil), "virtengine.resources.v1.AllocationEvent")
	proto.RegisterType((*SlashingEvent)(nil), "virtengine.resources.v1.SlashingEvent")
	proto.RegisterType((*Params)(nil), "virtengine.resources.v1.Params")
}

func init() {
	proto.RegisterFile("virtengine/resources/v1/types.proto", fileDescriptor_8e2fabbb30d32154)
}

var fileDescriptor_8e2fabbb30d32154 = []byte{
	// 1840 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x59, 0x4f, 0x73, 0xdb, 0xc6,
	0x15, 0x37, 0x45, 0x52, 0xa2, 0x96, 0x12, 0x45, 0x6d, 0x54, 0x99, 0x92, 0x63, 0x41, 0x59, 0x4f,
	0x5a, 0x27, 0x69, 0xc8, 0xb1, 0x35, 0x99, 0x4c, 0x9b, 0xe9, 0x81, 0xa4, 0x58, 0x99, 0xad, 0x2c,
	0x69, 0x96, 0x74, 0xd2, 0x66, 0x3a, 0x45, 0x41, 0x70, 0x0d, 0x21, 0x26, 0x01, 0x06, 0x58, 0xd2,
	0x56, 0x66, 0x7a, 0xea, 0xf4, 0x9e, 0xe9, 0xf4, 0x4b, 0x74, 0x7a, 0xed, 0x77, 0x68, 0x8e, 0x99,
	0x9e, 0xd2, 0x0b, 0xda, 0xb1, 0x6f, 0x3c, 0xf2, 0xdc, 0x43, 0x67, 0xff, 0x00, 0x0b, 0x80, 0x54,
	0xed, 0xb4, 0x66, 0xdb, 0x93, 0xf0, 0x7e, 0xbf, 0xf7, 0x87, 0xd8, 0x7d, 0xef, 0xed, 0x5b, 0x08,
	0xdc, 0x99, 0xd8, 0x1e, 0x25, 0x8e, 0x65, 0x3b, 0xa4, 0xe6, 0x11, 0xdf, 0x1d, 0x7b, 0x26, 0xf1,
	0x6b, 0x93, 0x7b, 0x35, 0x7a, 0x35, 0x22, 0x7e, 0x75, 0xe4, 0xb9, 0xd4, 0x85, 0x37, 0x95, 0x52,
	0x35, 0x52, 0xaa, 0x4e, 0xee, 0xed, 0xef, 0x58, 0xae, 0xe5, 0x72, 0x9d, 0x1a, 0x7b, 0x12, 0xea,
	0xfb, 0x9a, 0xe5, 0xba, 0xd6, 0x80, 0xd4, 0xb8, 0xd4, 0x1b, 0x3f, 0xae, 0x51, 0x7b, 0x48, 0x7c,
	0x6a, 0x0c, 0x47, 0x52, 0x61, 0xcf, 0x74, 0xfd, 0xa1, 0xeb, 0xeb, 0xc2, 0x52, 0x08, 0x82, 0x42,
	0xbf, 0x5b, 0x01, 0x85, 0x53, 0xd7, 0x34, 0x06, 0x36, 0xbd, 0x82, 0x3f, 0x02, 0xab, 0x1e, 0xb1,
	0x6c, 0xd7, 0xa9, 0x64, 0x0e, 0x33, 0x77, 0xd7, 0x1b, 0x6f, 0x4f, 0x03, 0xad, 0x2c, 0x90, 0xef,
	0xbb, 0x43, 0x9b, 0x92, 0xe1, 0x88, 0x5e, 0xcd, 0x02, 0x6d, 0xf3, 0xca, 0x18, 0x0e, 0x7e, 0x88,
	0x04, 0x83, 0xb0, 0x34, 0x82, 0x1f, 0x80, 0xdc, 0x17, 0xae, 0x43, 0x2a, 0x2b, 0xdc, 0xf8, 0xad,
	0x69, 0xa0, 0x95, 0x98, 0x9c, 0x30, 0x2d, 0x0a, 0x53, 0x86, 0x23, 0xcc, 0xd5, 0xe1, 0x43, 0x00,
	0xfa, 0x06, 0x35, 0x4c, 0xe2, 0x50, 0xe2, 0x55, 0xb2, 0xdc, 0xf8, 0xfd, 0x69, 0xa0, 0xed, 0x28,
	0x34, 0xe1, 0x62, 0x5b, 0xb8, 0x50, 0x2c, 0xc2, 0x31, 0x07, 0xb0, 0x0e, 0xd6, 0x4c, 0x77, 0xec,
	0x50, 0xef, 0xaa, 0x92, 0xe3, 0xbe, 0xbe, 0x37, 0x0d, 0xb4, 0x6d, 0x09, 0x25, 0x1c, 0x95, 0x84,
	0x23, 0x49, 0x21, 0x1c, 0xda, 0xa1, 0x3f, 0x67, 0x41, 0x19, 0xcb, 0x75, 0x6f, 0x1a, 0x23, 0xc3,
	0x64, 0x8b, 0xf3, 0x00, 0xac, 0x9b, 0xa3, 0xb1, 0x6e, 0xba, 0x1e, 0xf1, 0xf9, 0xfa, 0x64, 0x1b,
	0xef, 0x4d, 0x03, 0xed, 0x8d, 0x08, 0x4c, 0xf8, 0x2e, 0x4b, 0xdf, 0x21, 0x89, 0x70, 0xc1, 0x1c,
	0x8d, 0x9b, 0xec, 0x91, 0x79, 0x1a, 0x92, 0xa1, 0xeb, 0x5d, 0xe9, 0x56, 0x8f, 0x2f, 0x96, 0xf4,
	0x14, 0x81, 0x8b, 0x3c, 0x45, 0x24, 0xc2, 0x05, 0xf1, 0x7c, 0xd2, 0x83, 0xa7, 0x00, 0xf8, 0xd4,
	0xf5, 0x0c, 0x8b, 0x30, 0x57, 0x59, 0xee, 0x8a, 0x2f, 0x9d, 0x42, 0x17, 0x2d, 0x9d, 0x62, 0x11,
	0x5e, 0x97, 0xc2, 0x49, 0x0f, 0x76, 0xc1, 0x86, 0x43, 0xe8, 0x53, 0xd7, 0x7b, 0xa2, 0x0f, 0x7b,
	0x23, 0x9f, 0x2f, 0x5f, 0xb6, 0x71, 0x6f, 0x1a, 0x68, 0xbb, 0x71, 0x3c, 0xe1, 0xf1, 0x0d, 0xe1,
	0x31, 0xce, 0x23, 0x5c, 0x94, 0xe2, 0xc3, 0xde, 0xc8, 0x67, 0x59, 0x61, 0x8d, 0xc6, 0x7e, 0x25,
	0xcf, 0xbd, 0xf1, 0xac, 0x60, 0xf2, 0xa2, 0xac, 0x60, 0x38, 0xc2, 0x5c, 0x1d, 0x1e, 0x83, 0x82,
	0x35, 0x1a, 0xeb, 0xac, 0x2c, 0x2a, 0xab, 0x7c, 0x1f, 0xdf, 0x99, 0x06, 0x1a, 0x0c, 0xb1, 0x84,
	0xf9, 0x56, 0x64, 0xce, 0x39, 0x84, 0xd7, 0xac, 0xd1, 0xb8, 0xcb, 0x9e, 0xfe, 0xb1, 0x06, 0xb6,
	0xc3, 0x9d, 0x6c, 0x3b, 0x13, 0xe2, 0x50, 0xd7, 0xbb, 0x82, 0x3f, 0x01, 0x1b, 0x76, 0x28, 0xe8,
	0x76, 0x5f, 0x66, 0x3b, 0xcb, 0x93, 0x04, 0xae, 0x5e, 0x2f, 0x8e, 0x22, 0x5c, 0x8c, 0xc4, 0x76,
	0x1f, 0x7a, 0xa0, 0x3c, 0xf2, 0xdc, 0x89, 0xdd, 0x27, 0x9e, 0x6e, 0xf4, 0xfb, 0x1e, 0xf1, 0x7d,
	0x59, 0x00, 0x27, 0xac, 0x7a, 0xd2, 0xdc, 0x2c, 0xd0, 0x6e, 0x0a, 0x9f, 0x69, 0x06, 0xfd, 0xe5,
	0x4f, 0xef, 0xef, 0xc8, 0xda, 0xac, 0x0b, 0xa8, 0x43, 0x3d, 0xdb, 0xb1, 0xf0, 0x56, 0xa8, 0x2a,
	0x61, 0xf8, 0x05, 0x28, 0x85, 0x6d, 0x41, 0x37, 0x07, 0x86, 0xef, 0xf3, 0xad, 0x2f, 0xdd, 0xff,
	0x6e, 0xf5, 0x9a, 0xc6, 0x51, 0x8d, 0xb2, 0x99, 0x69, 0xf3, 0x6c, 0x4b, 0x79, 0x98, 0x05, 0xda,
	0x77, 0xc2, 0xaa, 0x8e, 0xe3, 0x08, 0x6f, 0x7a, 0x71, 0x5b, 0xf8, 0x4b, 0x90, 0xa7, 0x2e, 0x35,
	0x06, 0x3c, 0x3b, 0x8a, 0xf7, 0xdf, 0x79, 0x79, 0x48, 0x59, 0x40, 0x8d, 0xdb, 0x5f, 0x05, 0xda,
	0x8d, 0x69, 0xa0, 0x09, 0xfb, 0x59, 0xa0, 0x6d, 0x88, 0x80, 0x5c, 0x44, 0x58, 0xc0, 0xd0, 0x01,
	0xeb, 0xc6, 0xc4, 0xb0, 0x07, 0x46, 0x6f, 0x40, 0x78, 0xce, 0x7c, 0xab, 0x18, 0x6f, 0xcb, 0x18,
	0xca, 0x87, 0xaa, 0xa0, 0x08, 0x42, 0x58, 0xd1, 0xb0, 0x07, 0x0a, 0x03, 0xd9, 0xff, 0x78, 0x9e,
	0x15, 0xef, 0xbf, 0x75, 0x6d, 0xb8, 0xb0, 0x51, 0x36, 0xee, 0xc8, 0x30, 0x91, 0xa9, 0x4a, 0xc2,
	0x10, 0x41, 0x38, 0x22, 0xe1, 0x11, 0x58, 0x35, 0x4c, 0x6a, 0x4f, 0x48, 0x65, 0xed, 0x30, 0x73,
	0xb7, 0xd0, 0xb8, 0x35, 0x0d, 0x34, 0x89, 0xa8, 0x6e, 0x2a, 0x64, 0x84, 0x25, 0x01, 0x7b, 0x00,
	0x5e, 0x12, 0xc3, 0xa3, 0x3d, 0x62, 0x50, 0xdd, 0x27, 0x9f, 0x8f, 0x89, 0x63, 0x92, 0x4a, 0xe1,
	0x30, 0x73, 0x37, 0xd7, 0x38, 0x62, 0xa5, 0x30, 0xcf, 0xce, 0x02, 0x6d, 0x4f, 0x38, 0x9b, 0xe7,
	0x10, 0xde, 0x8e, 0xc0, 0x8e, 0xc4, 0xe0, 0x04, 0x94, 0x06, 0x86, 0x4f, 0xf5, 0x88, 0xa9, 0xac,
	0xf3, 0x25, 0xd8, 0xaf, 0x8a, 0x23, 0xa5, 0x1a, 0x1e, 0x29, 0xd5, 0x6e, 0x78, 0xa4, 0x34, 0x8e,
	0xe4, 0xbb, 0xa7, 0x2c, 0x55, 0x02, 0x25, 0x71, 0xf4, 0xe5, 0xdf, 0xb4, 0x0c, 0xde, 0x64, 0xe0,
	0x83, 0x10, 0x83, 0x8f, 0x01, 0x18, 0x8f, 0xfa, 0x06, 0x25, 0x7d, 0xdd, 0xa0, 0x15, 0xf0, 0xd2,
	0x98, 0xef, 0xc9, 0x98, 0x31, 0x2b, 0xd5, 0xcd, 0x14, 0x26, 0x62, 0xad, 0x4b, 0xa0, 0x4e, 0xd1,
	0x5f, 0xf3, 0x60, 0x2b, 0xcc, 0x11, 0xcc, 0x5e, 0xda, 0xa7, 0xb0, 0x01, 0x80, 0x27, 0x1e, 0x55,
	0xe9, 0xdf, 0x61, 0xbe, 0x15, 0xaa, 0x7c, 0x2b, 0x0c, 0xe1, 0x75, 0x29, 0xb4, 0xfb, 0x70, 0x02,
	0xb6, 0xa5, 0x30, 0x57, 0xf5, 0x6d, 0x76, 0xda, 0xcc, 0x91, 0xb3, 0x40, 0xab, 0x24, 0x3c, 0xbe,
	0x4a, 0xdd, 0x97, 0x23, 0xdd, 0xff, 0x87, 0xc2, 0xff, 0x0c, 0x14, 0xd8, 0xef, 0xb1, 0x3d, 0xd2,
	0xff, 0xf6, 0xb5, 0x1f, 0x15, 0x4c, 0xe8, 0x42, 0x15, 0x4c, 0x88, 0x20, 0x1c, 0x91, 0x89, 0xa2,
	0xcc, 0x2f, 0xa9, 0x28, 0x7f, 0x05, 0xb6, 0xc2, 0x67, 0x7d, 0xe4, 0x0e, 0x6c, 0xf3, 0x4a, 0x9e,
	0x33, 0x1f, 0x4e, 0x03, 0x6d, 0x2f, 0x45, 0x25, 0x8e, 0x9b, 0xdd, 0xa4, 0x53, 0xa9, 0x82, 0x70,
	0x29, 0x44, 0x2e, 0x38, 0x00, 0x7f, 0x01, 0x4a, 0x43, 0xe3, 0x99, 0x6e, 0x1a, 0x4e, 0xdf, 0x66,
	0x19, 0xe9, 0xf3, 0xf2, 0xcf, 0x35, 0x3e, 0x98, 0x06, 0x5a, 0x25, 0xc9, 0x24, 0xfc, 0xcb, 0xfd,
	0x48, 0x6a, 0x20, 0xbc, 0x39, 0x34, 0x9e, 0x35, 0x95, 0xfc, 0x4d, 0x11, 0xc0, 0x70, 0x9d, 0xeb,
	0x03, 0x16, 0x9a, 0xb2, 0x21, 0xec, 0x0c, 0x6c, 0x1a, 0x91, 0xa4, 0x32, 0x9c, 0x1d, 0x9e, 0x49,
	0x62, 0x16, 0x68, 0x3b, 0xb2, 0xf3, 0xc4, 0x61, 0x84, 0x37, 0x94, 0xdc, 0xee, 0xa7, 0xca, 0x65,
	0xe5, 0xf5, 0x95, 0x4b, 0x76, 0xf9, 0xe5, 0xb2, 0xe8, 0x6c, 0xce, 0xfd, 0xd7, 0xcf, 0xe6, 0xfc,
	0xff, 0xa4, 0x44, 0x57, 0x97, 0x5c, 0xa2, 0x9f, 0x81, 0x82, 0xe1, 0xfb, 0xb6, 0xe5, 0x90, 0x3e,
	0x4f, 0xeb, 0x7f, 0x2f, 0x56, 0xe8, 0x42, 0xc5, 0x0a, 0x11, 0x84, 0x23, 0x12, 0xfe, 0x1c, 0xe4,
	0x7d, 0x6a, 0x50, 0x71, 0xfa, 0x95, 0xee, 0xdf, 0xbd, 0x36, 0x90, 0xaa, 0x83, 0x0e, 0xd3, 0x6f,
	0xec, 0xb1, 0x71, 0x83, 0x9b, 0xaa, 0x71, 0x83, 0x8b, 0x08, 0x0b, 0x18, 0xd6, 0x40, 0xde, 0x67,
	0x03, 0x3a, 0x3f, 0xf8, 0xd6, 0xa5, 0x01, 0x03, 0x62, 0x06, 0x4c, 0x64, 0x06, 0xec, 0x6f, 0xa2,
	0x35, 0x81, 0x25, 0xb5, 0xa6, 0xc7, 0x00, 0x98, 0x1e, 0x09, 0x8f, 0xc7, 0xe2, 0xab, 0x1f, 0x8f,
	0xca, 0x4a, 0xd5, 0xa4, 0xc2, 0xe4, 0xf1, 0x28, 0x81, 0x3a, 0x85, 0x03, 0x00, 0xc8, 0xb3, 0x91,
	0xed, 0x11, 0x9f, 0xc5, 0xd9, 0x78, 0x69, 0x1c, 0x76, 0x15, 0xd8, 0x51, 0x16, 0x8b, 0xae, 0x16,
	0x8a, 0x95, 0xd1, 0x24, 0x50, 0xa7, 0x90, 0x82, 0x0d, 0x3e, 0xda, 0x84, 0xef, 0xb5, 0xf9, 0xd2,
	0x78, 0xac, 0x51, 0xee, 0xc6, 0x6d, 0x16, 0x5d, 0x3d, 0xe2, 0xbc, 0x88, 0x59, 0x8c, 0xa0, 0x7a,
	0x7a, 0xd4, 0x28, 0x2d, 0x6b, 0xd4, 0x60, 0x77, 0x8a, 0xde, 0xc0, 0x35, 0x9f, 0xe8, 0x97, 0xc4,
	0xb6, 0x2e, 0x69, 0x65, 0x8b, 0x5f, 0x77, 0xf8, 0x9d, 0x22, 0x8e, 0xab, 0xdf, 0x1d, 0x47, 0x11,
	0x2e, 0x72, 0xf1, 0x81, 0x90, 0x7e, 0x9f, 0x03, 0x5b, 0x2a, 0x95, 0x5b, 0xec, 0xb2, 0xf1, 0xda,
	0xfb, 0xfa, 0x47, 0xa0, 0x10, 0x0d, 0x95, 0x2b, 0xfc, 0x58, 0xd2, 0x58, 0x82, 0xc6, 0x46, 0x49,
	0x99, 0xa0, 0x6a, 0x80, 0x8c, 0x48, 0x55, 0x90, 0xd9, 0xd7, 0x5e, 0x90, 0xfc, 0x1b, 0x84, 0xe1,
	0xbb, 0x8e, 0xec, 0xd4, 0xf2, 0x1b, 0x04, 0x43, 0x16, 0x7f, 0x83, 0x60, 0x0c, 0xff, 0x06, 0xc1,
	0x1e, 0x16, 0xb6, 0xfc, 0xfc, 0x92, 0x5b, 0x7e, 0xb2, 0x5c, 0x57, 0x97, 0x55, 0xae, 0xe8, 0x0f,
	0x59, 0xb0, 0xd9, 0x19, 0x18, 0xfe, 0xa5, 0xed, 0x58, 0x22, 0x29, 0x16, 0xbd, 0x6d, 0x66, 0xc9,
	0x6f, 0x3b, 0x97, 0x88, 0x2b, 0xff, 0x59, 0x22, 0x1e, 0x45, 0x1b, 0x2e, 0x26, 0x02, 0x7e, 0x39,
	0x12, 0xc8, 0xf5, 0xdb, 0xfc, 0x21, 0x58, 0x1b, 0x11, 0xc7, 0x18, 0xd0, 0xf0, 0x23, 0xcf, 0xed,
	0x69, 0xa0, 0x85, 0x90, 0xfa, 0xb4, 0x23, 0x01, 0x84, 0x43, 0x2a, 0xb5, 0x57, 0xf9, 0xa5, 0xed,
	0xd5, 0xf3, 0x3c, 0x58, 0xbd, 0x30, 0x3c, 0x63, 0xe8, 0xc3, 0x5f, 0x83, 0x3d, 0x75, 0x1d, 0xa3,
	0xf6, 0x90, 0xb8, 0x63, 0x76, 0x2d, 0x33, 0x5d, 0xa7, 0x2f, 0x76, 0x2b, 0xd7, 0xa8, 0xb3, 0x91,
	0xf3, 0x5a, 0xa5, 0x59, 0xa0, 0x1d, 0xa6, 0xaf, 0x75, 0x29, 0x15, 0x84, 0x6f, 0x46, 0x5c, 0x57,
	0x50, 0x1d, 0xc1, 0xc0, 0xdf, 0x66, 0xc0, 0x2d, 0x8f, 0xf8, 0xc4, 0x9b, 0x88, 0x1d, 0x48, 0xff,
	0x02, 0x51, 0xfc, 0xad, 0x69, 0xa0, 0xfd, 0x2b, 0xb5, 0x59, 0xa0, 0xa1, 0x68, 0x06, 0xb9, 0x4e,
	0x09, 0xe1, 0xbd, 0x18, 0x9b, 0xfa, 0x1d, 0x78, 0x6e, 0x1a, 0xce, 0xf2, 0xc8, 0x7c, 0xe0, 0x49,
	0x32, 0xaf, 0x3a, 0x03, 0xc3, 0x8f, 0x63, 0x33, 0xfc, 0x53, 0xd1, 0x77, 0x73, 0xd1, 0xf7, 0xc3,
	0x34, 0xb5, 0x60, 0x72, 0x7f, 0x2a, 0xbb, 0x6f, 0x34, 0xb9, 0x7f, 0xc2, 0x01, 0xe6, 0xd7, 0x94,
	0xb3, 0x4a, 0xe8, 0x37, 0xaf, 0xfc, 0xa6, 0x28, 0xe5, 0x37, 0x45, 0x20, 0x5c, 0x0a, 0x11, 0xe9,
	0xf7, 0x73, 0xb0, 0xeb, 0xcb, 0x02, 0xd6, 0x2d, 0xcf, 0x30, 0x49, 0xb4, 0x0b, 0xab, 0x7c, 0x2d,
	0x3e, 0x62, 0x07, 0xde, 0x62, 0x8d, 0x59, 0xa0, 0xdd, 0x96, 0xfd, 0x72, 0x21, 0x8f, 0xf0, 0x4e,
	0x48, 0x9c, 0x30, 0x3c, 0x5c, 0xf6, 0x4f, 0x41, 0x39, 0x32, 0x08, 0x4b, 0x66, 0x8d, 0xbf, 0x4b,
	0x8d, 0xb5, 0x88, 0x34, 0xa7, 0x5a, 0x44, 0x9a, 0x41, 0x78, 0x2b, 0x84, 0x2e, 0x04, 0xf2, 0xee,
	0x6f, 0x32, 0x60, 0x33, 0x31, 0xbd, 0xc2, 0x03, 0xb0, 0x8f, 0x5b, 0x9d, 0xf3, 0x47, 0xb8, 0xd9,
	0xd2, 0x9b, 0xa7, 0xf5, 0x4e, 0x47, 0x7f, 0x74, 0xd6, 0xb9, 0x68, 0x35, 0xdb, 0x3f, 0x6e, 0xb7,
	0x8e, 0xcb, 0x37, 0xe0, 0x3e, 0xd8, 0x4d, 0xf1, 0xcd, 0xf3, 0x87, 0x17, 0x8f, 0xba, 0xad, 0x72,
	0x66, 0x01, 0xd7, 0xe9, 0x9e, 0xe3, 0xfa, 0x49, 0xab, 0xbc, 0xb2, 0x80, 0x3b, 0x6b, 0x75, 0x3f,
	0x39, 0xc7, 0x3f, 0x2d, 0x67, 0xdf, 0xfd, 0x63, 0x26, 0x7e, 0x5a, 0xf2, 0x73, 0x06, 0x1e, 0x82,
	0x37, 0xeb, 0xa7, 0xa7, 0xe7, 0xcd, 0x7a, 0xb7, 0x7d, 0x7e, 0xa6, 0x77, 0xba, 0xf5, 0x6e, 0x2b,
	0xf5, 0x4b, 0xde, 0x04, 0x95, 0x39, 0x8d, 0x8b, 0xd6, 0xd9, 0x71, 0xfb, 0xec, 0xa4, 0x9c, 0x81,
	0xb7, 0xc0, 0xcd, 0x39, 0xb6, 0xde, 0xec, 0xb6, 0x3f, 0x66, 0x3f, 0x66, 0x91, 0x69, 0xeb, 0x67,
	0x17, 0x6d, 0xdc, 0x3a, 0x2e, 0x67, 0xe1, 0x6d, 0xb0, 0x37, 0xc7, 0xe2, 0xd6, 0x69, 0xab, 0xde,
	0x69, 0x1d, 0x97, 0x73, 0x8d, 0xce, 0x57, 0xcf, 0x0f, 0x32, 0x5f, 0x3f, 0x3f, 0xc8, 0xfc, 0xfd,
	0xf9, 0x41, 0xe6, 0xcb, 0x17, 0x07, 0x37, 0xbe, 0x7e, 0x71, 0x70, 0xe3, 0x9b, 0x17, 0x07, 0x37,
	0x3e, 0xfd, 0x81, 0x65, 0xd3, 0xcb, 0x71, 0xaf, 0x6a, 0xba, 0xc3, 0x5a, 0xec, 0xbf, 0x04, 0xb1,
	0x47, 0xbf, 0xff, 0xa4, 0x66, 0xb9, 0x35, 0xc7, 0xed, 0x27, 0xff, 0x79, 0xd0, 0x5b, 0xe5, 0x9d,
	0xeb, 0xe8, 0x9f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xb0, 0x68, 0xb0, 0x8f, 0x5e, 0x18, 0x00, 0x00,
}

func (m *Locality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Locality) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Locality) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Datacenter) > 0 {
		i -= len(m.Datacenter)
		copy(dAtA[i:], m.Datacenter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Datacenter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceCapacity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceCapacity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceCapacity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GpuType) > 0 {
		i -= len(m.GpuType)
		copy(dAtA[i:], m.GpuType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuType)))
		i--
		dAtA[i] = 0x32
	}
	if m.Gpus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Gpus))
		i--
		dAtA[i] = 0x28
	}
	if m.NetworkMbps != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkMbps))
		i--
		dAtA[i] = 0x20
	}
	if m.StorageGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGb))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGb))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuCores != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceInventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceInventory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceInventory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x52
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastHeartbeat, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastHeartbeat):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTypes(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x4a
	if m.HeartbeatSequence != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HeartbeatSequence))
		i--
		dAtA[i] = 0x40
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	{
		size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.Available.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ResourceClass != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResourceClass))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InventoryId) > 0 {
		i -= len(m.InventoryId)
		copy(dAtA[i:], m.InventoryId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InventoryId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxCandidates != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxCandidates))
		i--
		dAtA[i] = 0x38
	}
	if len(m.LocalityPolicy) > 0 {
		i -= len(m.LocalityPolicy)
		copy(dAtA[i:], m.LocalityPolicy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LocalityPolicy)))
		i--
		dAtA[i] = 0x32
	}
	{
		size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Required.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.ResourceClass != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResourceClass))
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequesterAddress) > 0 {
		i -= len(m.RequesterAddress)
		copy(dAtA[i:], m.RequesterAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequesterAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResourceAllocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceAllocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceAllocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x78
	}
	n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err8 != nil {
		return 0, err8
	}
	i -= n8
	i = encodeVarintTypes(dAtA, i, uint64(n8))
	i--
	dAtA[i] = 0x72
	if m.ActivatedAt != nil {
		n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ActivatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ActivatedAt):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintTypes(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x6a
	}
	if m.ExpiresAt != nil {
		n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ExpiresAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintTypes(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x62
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintTypes(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Score) > 0 {
		i -= len(m.Score)
		copy(dAtA[i:], m.Score)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Score)))
		i--
		dAtA[i] = 0x4a
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Assigned.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.Required.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.ResourceClass != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResourceClass))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RequesterAddress) > 0 {
		i -= len(m.RequesterAddress)
		copy(dAtA[i:], m.RequesterAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequesterAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequestId) > 0 {
		i -= len(m.RequestId)
		copy(dAtA[i:], m.RequestId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequestId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AllocationId) > 0 {
		i -= len(m.AllocationId)
		copy(dAtA[i:], m.AllocationId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllocationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocationEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocationEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocationEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n15, err15 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintTypes(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x32
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x18
	}
	if m.Sequence != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AllocationId) > 0 {
		i -= len(m.AllocationId)
		copy(dAtA[i:], m.AllocationId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllocationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashingEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashingEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashingEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n16, err16 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err16 != nil {
		return 0, err16
	}
	i -= n16
	i = encodeVarintTypes(dAtA, i, uint64(n16))
	i--
	dAtA[i] = 0x2a
	if len(m.Penalty) > 0 {
		i -= len(m.Penalty)
		copy(dAtA[i:], m.Penalty)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Penalty)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AllocationId) > 0 {
		i -= len(m.AllocationId)
		copy(dAtA[i:], m.AllocationId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AllocationId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlashingPenalty) > 0 {
		i -= len(m.SlashingPenalty)
		copy(dAtA[i:], m.SlashingPenalty)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlashingPenalty)))
		i--
		dAtA[i] = 0x3a
	}
	if m.SlashingGraceSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlashingGraceSeconds))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CapacityWeight) > 0 {
		i -= len(m.CapacityWeight)
		copy(dAtA[i:], m.CapacityWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CapacityWeight)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LocalityWeight) > 0 {
		i -= len(m.LocalityWeight)
		copy(dAtA[i:], m.LocalityWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LocalityWeight)))
		i--
		dAtA[i] = 0x22
	}
	if m.MaxCandidates != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxCandidates))
		i--
		dAtA[i] = 0x18
	}
	if m.ReservationTimeoutSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ReservationTimeoutSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.HeartbeatTimeoutSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HeartbeatTimeoutSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Locality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResourceCapacity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCores != 0 {
		n += 1 + sovTypes(uint64(m.CpuCores))
	}
	if m.MemoryGb != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGb))
	}
	if m.StorageGb != 0 {
		n += 1 + sovTypes(uint64(m.StorageGb))
	}
	if m.NetworkMbps != 0 {
		n += 1 + sovTypes(uint64(m.NetworkMbps))
	}
	if m.Gpus != 0 {
		n += 1 + sovTypes(uint64(m.Gpus))
	}
	l = len(m.GpuType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ResourceInventory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InventoryId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResourceClass != 0 {
		n += 1 + sovTypes(uint64(m.ResourceClass))
	}
	l = m.Total.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Available.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Locality.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Active {
		n += 2
	}
	if m.HeartbeatSequence != 0 {
		n += 1 + sovTypes(uint64(m.HeartbeatSequence))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastHeartbeat)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *ResourceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RequesterAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResourceClass != 0 {
		n += 1 + sovTypes(uint64(m.ResourceClass))
	}
	l = m.Required.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Locality.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.LocalityPolicy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxCandidates != 0 {
		n += 1 + sovTypes(uint64(m.MaxCandidates))
	}
	return n
}

func (m *ResourceAllocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllocationId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RequestId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RequesterAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ResourceClass != 0 {
		n += 1 + sovTypes(uint64(m.ResourceClass))
	}
	l = m.Required.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Assigned.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = len(m.Score)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Locality.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.ExpiresAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ExpiresAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ActivatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ActivatedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *AllocationEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllocationId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovTypes(uint64(m.Sequence))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *SlashingEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AllocationId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Penalty)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeartbeatTimeoutSeconds != 0 {
		n += 1 + sovTypes(uint64(m.HeartbeatTimeoutSeconds))
	}
	if m.ReservationTimeoutSeconds != 0 {
		n += 1 + sovTypes(uint64(m.ReservationTimeoutSeconds))
	}
	if m.MaxCandidates != 0 {
		n += 1 + sovTypes(uint64(m.MaxCandidates))
	}
	l = len(m.LocalityWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CapacityWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SlashingGraceSeconds != 0 {
		n += 1 + sovTypes(uint64(m.SlashingGraceSeconds))
	}
	l = len(m.SlashingPenalty)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Locality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Locality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Locality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceCapacity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceCapacity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceCapacity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCores", wireType)
			}
			m.CpuCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCores |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			m.MemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGb", wireType)
			}
			m.StorageGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkMbps", wireType)
			}
			m.NetworkMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkMbps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpus", wireType)
			}
			m.Gpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gpus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceInventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceInventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceInventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InventoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceClass", wireType)
			}
			m.ResourceClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceClass |= ResourceClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Available.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatSequence", wireType)
			}
			m.HeartbeatSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastHeartbeat, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceClass", wireType)
			}
			m.ResourceClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceClass |= ResourceClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Required.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityPolicy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityPolicy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCandidates", wireType)
			}
			m.MaxCandidates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCandidates |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceAllocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceAllocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceAllocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequesterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequesterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceClass", wireType)
			}
			m.ResourceClass = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceClass |= ResourceClass(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Required.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Assigned", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Assigned.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AllocationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Score = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExpiresAt == nil {
				m.ExpiresAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ExpiresAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActivatedAt == nil {
				m.ActivatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ActivatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocationEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocationEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocationEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AllocationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashingEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashingEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashingEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Penalty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Penalty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeartbeatTimeoutSeconds", wireType)
			}
			m.HeartbeatTimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HeartbeatTimeoutSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReservationTimeoutSeconds", wireType)
			}
			m.ReservationTimeoutSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReservationTimeoutSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxCandidates", wireType)
			}
			m.MaxCandidates = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxCandidates |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapacityWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingGraceSeconds", wireType)
			}
			m.SlashingGraceSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashingGraceSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashingPenalty", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashingPenalty = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
