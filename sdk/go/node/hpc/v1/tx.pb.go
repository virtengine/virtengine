// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/hpc/v1/tx.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterCluster registers a new HPC cluster
type MsgRegisterCluster struct {
	Owner       string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	Name        string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ClusterType string `protobuf:"bytes,3,opt,name=cluster_type,json=clusterType,proto3" json:"cluster_type,omitempty"`
	Region      string `protobuf:"bytes,4,opt,name=region,proto3" json:"region,omitempty"`
	Endpoint    string `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	TotalNodes  uint64 `protobuf:"varint,6,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	TotalGpus   uint64 `protobuf:"varint,7,opt,name=total_gpus,json=totalGpus,proto3" json:"total_gpus,omitempty"`
}

func (m *MsgRegisterCluster) Reset()         { *m = MsgRegisterCluster{} }
func (m *MsgRegisterCluster) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterCluster) ProtoMessage()    {}
func (*MsgRegisterCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{0}
}
func (m *MsgRegisterCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterCluster.Merge(m, src)
}
func (m *MsgRegisterCluster) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterCluster.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterCluster proto.InternalMessageInfo

func (m *MsgRegisterCluster) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgRegisterCluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgRegisterCluster) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *MsgRegisterCluster) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *MsgRegisterCluster) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *MsgRegisterCluster) GetTotalNodes() uint64 {
	if m != nil {
		return m.TotalNodes
	}
	return 0
}

func (m *MsgRegisterCluster) GetTotalGpus() uint64 {
	if m != nil {
		return m.TotalGpus
	}
	return 0
}

// MsgRegisterClusterResponse is the response for MsgRegisterCluster
type MsgRegisterClusterResponse struct {
	ClusterId string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *MsgRegisterClusterResponse) Reset()         { *m = MsgRegisterClusterResponse{} }
func (m *MsgRegisterClusterResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterClusterResponse) ProtoMessage()    {}
func (*MsgRegisterClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{1}
}
func (m *MsgRegisterClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterClusterResponse.Merge(m, src)
}
func (m *MsgRegisterClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterClusterResponse proto.InternalMessageInfo

func (m *MsgRegisterClusterResponse) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

// MsgUpdateCluster updates cluster information
type MsgUpdateCluster struct {
	Owner      string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClusterId  string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Endpoint   string `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	TotalNodes uint64 `protobuf:"varint,4,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	TotalGpus  uint64 `protobuf:"varint,5,opt,name=total_gpus,json=totalGpus,proto3" json:"total_gpus,omitempty"`
	Active     bool   `protobuf:"varint,6,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *MsgUpdateCluster) Reset()         { *m = MsgUpdateCluster{} }
func (m *MsgUpdateCluster) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateCluster) ProtoMessage()    {}
func (*MsgUpdateCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{2}
}
func (m *MsgUpdateCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateCluster.Merge(m, src)
}
func (m *MsgUpdateCluster) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateCluster.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateCluster proto.InternalMessageInfo

func (m *MsgUpdateCluster) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgUpdateCluster) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *MsgUpdateCluster) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *MsgUpdateCluster) GetTotalNodes() uint64 {
	if m != nil {
		return m.TotalNodes
	}
	return 0
}

func (m *MsgUpdateCluster) GetTotalGpus() uint64 {
	if m != nil {
		return m.TotalGpus
	}
	return 0
}

func (m *MsgUpdateCluster) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// MsgUpdateClusterResponse is the response for MsgUpdateCluster
type MsgUpdateClusterResponse struct {
}

func (m *MsgUpdateClusterResponse) Reset()         { *m = MsgUpdateClusterResponse{} }
func (m *MsgUpdateClusterResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateClusterResponse) ProtoMessage()    {}
func (*MsgUpdateClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{3}
}
func (m *MsgUpdateClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateClusterResponse.Merge(m, src)
}
func (m *MsgUpdateClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateClusterResponse proto.InternalMessageInfo

// MsgDeregisterCluster removes a cluster
type MsgDeregisterCluster struct {
	Owner     string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClusterId string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
}

func (m *MsgDeregisterCluster) Reset()         { *m = MsgDeregisterCluster{} }
func (m *MsgDeregisterCluster) String() string { return proto.CompactTextString(m) }
func (*MsgDeregisterCluster) ProtoMessage()    {}
func (*MsgDeregisterCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{4}
}
func (m *MsgDeregisterCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeregisterCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeregisterCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeregisterCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeregisterCluster.Merge(m, src)
}
func (m *MsgDeregisterCluster) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeregisterCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeregisterCluster.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeregisterCluster proto.InternalMessageInfo

func (m *MsgDeregisterCluster) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgDeregisterCluster) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

// MsgDeregisterClusterResponse is the response for MsgDeregisterCluster
type MsgDeregisterClusterResponse struct {
}

func (m *MsgDeregisterClusterResponse) Reset()         { *m = MsgDeregisterClusterResponse{} }
func (m *MsgDeregisterClusterResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeregisterClusterResponse) ProtoMessage()    {}
func (*MsgDeregisterClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{5}
}
func (m *MsgDeregisterClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeregisterClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeregisterClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeregisterClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeregisterClusterResponse.Merge(m, src)
}
func (m *MsgDeregisterClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeregisterClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeregisterClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeregisterClusterResponse proto.InternalMessageInfo

// MsgCreateOffering creates a new HPC offering
type MsgCreateOffering struct {
	Provider     string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	ClusterId    string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Name         string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	ResourceType string `protobuf:"bytes,4,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	PricePerHour string `protobuf:"bytes,5,opt,name=price_per_hour,json=pricePerHour,proto3" json:"price_per_hour,omitempty"`
	MinDuration  uint64 `protobuf:"varint,6,opt,name=min_duration,json=minDuration,proto3" json:"min_duration,omitempty"`
	MaxDuration  uint64 `protobuf:"varint,7,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
}

func (m *MsgCreateOffering) Reset()         { *m = MsgCreateOffering{} }
func (m *MsgCreateOffering) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOffering) ProtoMessage()    {}
func (*MsgCreateOffering) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{6}
}
func (m *MsgCreateOffering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOffering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOffering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOffering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOffering.Merge(m, src)
}
func (m *MsgCreateOffering) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOffering) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOffering.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOffering proto.InternalMessageInfo

func (m *MsgCreateOffering) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *MsgCreateOffering) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *MsgCreateOffering) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MsgCreateOffering) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *MsgCreateOffering) GetPricePerHour() string {
	if m != nil {
		return m.PricePerHour
	}
	return ""
}

func (m *MsgCreateOffering) GetMinDuration() uint64 {
	if m != nil {
		return m.MinDuration
	}
	return 0
}

func (m *MsgCreateOffering) GetMaxDuration() uint64 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

// MsgCreateOfferingResponse is the response for MsgCreateOffering
type MsgCreateOfferingResponse struct {
	OfferingId string `protobuf:"bytes,1,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
}

func (m *MsgCreateOfferingResponse) Reset()         { *m = MsgCreateOfferingResponse{} }
func (m *MsgCreateOfferingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateOfferingResponse) ProtoMessage()    {}
func (*MsgCreateOfferingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{7}
}
func (m *MsgCreateOfferingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateOfferingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateOfferingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateOfferingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateOfferingResponse.Merge(m, src)
}
func (m *MsgCreateOfferingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateOfferingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateOfferingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateOfferingResponse proto.InternalMessageInfo

func (m *MsgCreateOfferingResponse) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

// MsgUpdateOffering updates an offering
type MsgUpdateOffering struct {
	Provider     string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	OfferingId   string `protobuf:"bytes,2,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
	PricePerHour string `protobuf:"bytes,3,opt,name=price_per_hour,json=pricePerHour,proto3" json:"price_per_hour,omitempty"`
	Active       bool   `protobuf:"varint,4,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *MsgUpdateOffering) Reset()         { *m = MsgUpdateOffering{} }
func (m *MsgUpdateOffering) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOffering) ProtoMessage()    {}
func (*MsgUpdateOffering) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{8}
}
func (m *MsgUpdateOffering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOffering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOffering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOffering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOffering.Merge(m, src)
}
func (m *MsgUpdateOffering) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOffering) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOffering.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOffering proto.InternalMessageInfo

func (m *MsgUpdateOffering) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *MsgUpdateOffering) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *MsgUpdateOffering) GetPricePerHour() string {
	if m != nil {
		return m.PricePerHour
	}
	return ""
}

func (m *MsgUpdateOffering) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// MsgUpdateOfferingResponse is the response for MsgUpdateOffering
type MsgUpdateOfferingResponse struct {
}

func (m *MsgUpdateOfferingResponse) Reset()         { *m = MsgUpdateOfferingResponse{} }
func (m *MsgUpdateOfferingResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateOfferingResponse) ProtoMessage()    {}
func (*MsgUpdateOfferingResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{9}
}
func (m *MsgUpdateOfferingResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateOfferingResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateOfferingResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateOfferingResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateOfferingResponse.Merge(m, src)
}
func (m *MsgUpdateOfferingResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateOfferingResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateOfferingResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateOfferingResponse proto.InternalMessageInfo

// MsgSubmitJob submits a new HPC job
type MsgSubmitJob struct {
	Submitter      string `protobuf:"bytes,1,opt,name=submitter,proto3" json:"submitter,omitempty"`
	OfferingId     string `protobuf:"bytes,2,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
	JobScript      string `protobuf:"bytes,3,opt,name=job_script,json=jobScript,proto3" json:"job_script,omitempty"`
	RequestedNodes uint64 `protobuf:"varint,4,opt,name=requested_nodes,json=requestedNodes,proto3" json:"requested_nodes,omitempty"`
	RequestedGpus  uint64 `protobuf:"varint,5,opt,name=requested_gpus,json=requestedGpus,proto3" json:"requested_gpus,omitempty"`
	MaxDuration    uint64 `protobuf:"varint,6,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	MaxBudget      string `protobuf:"bytes,7,opt,name=max_budget,json=maxBudget,proto3" json:"max_budget,omitempty"`
}

func (m *MsgSubmitJob) Reset()         { *m = MsgSubmitJob{} }
func (m *MsgSubmitJob) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitJob) ProtoMessage()    {}
func (*MsgSubmitJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{10}
}
func (m *MsgSubmitJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitJob.Merge(m, src)
}
func (m *MsgSubmitJob) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitJob) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitJob.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitJob proto.InternalMessageInfo

func (m *MsgSubmitJob) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *MsgSubmitJob) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *MsgSubmitJob) GetJobScript() string {
	if m != nil {
		return m.JobScript
	}
	return ""
}

func (m *MsgSubmitJob) GetRequestedNodes() uint64 {
	if m != nil {
		return m.RequestedNodes
	}
	return 0
}

func (m *MsgSubmitJob) GetRequestedGpus() uint64 {
	if m != nil {
		return m.RequestedGpus
	}
	return 0
}

func (m *MsgSubmitJob) GetMaxDuration() uint64 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *MsgSubmitJob) GetMaxBudget() string {
	if m != nil {
		return m.MaxBudget
	}
	return ""
}

// MsgSubmitJobResponse is the response for MsgSubmitJob
type MsgSubmitJobResponse struct {
	JobId string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
}

func (m *MsgSubmitJobResponse) Reset()         { *m = MsgSubmitJobResponse{} }
func (m *MsgSubmitJobResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitJobResponse) ProtoMessage()    {}
func (*MsgSubmitJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{11}
}
func (m *MsgSubmitJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitJobResponse.Merge(m, src)
}
func (m *MsgSubmitJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitJobResponse proto.InternalMessageInfo

func (m *MsgSubmitJobResponse) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

// MsgCancelJob cancels a job
type MsgCancelJob struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	JobId  string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgCancelJob) Reset()         { *m = MsgCancelJob{} }
func (m *MsgCancelJob) String() string { return proto.CompactTextString(m) }
func (*MsgCancelJob) ProtoMessage()    {}
func (*MsgCancelJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{12}
}
func (m *MsgCancelJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelJob.Merge(m, src)
}
func (m *MsgCancelJob) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelJob) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelJob.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelJob proto.InternalMessageInfo

func (m *MsgCancelJob) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCancelJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *MsgCancelJob) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgCancelJobResponse is the response for MsgCancelJob
type MsgCancelJobResponse struct {
}

func (m *MsgCancelJobResponse) Reset()         { *m = MsgCancelJobResponse{} }
func (m *MsgCancelJobResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCancelJobResponse) ProtoMessage()    {}
func (*MsgCancelJobResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{13}
}
func (m *MsgCancelJobResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCancelJobResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCancelJobResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCancelJobResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCancelJobResponse.Merge(m, src)
}
func (m *MsgCancelJobResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCancelJobResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCancelJobResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCancelJobResponse proto.InternalMessageInfo

// MsgReportJobStatus reports job status
type MsgReportJobStatus struct {
	Reporter        string `protobuf:"bytes,1,opt,name=reporter,proto3" json:"reporter,omitempty"`
	JobId           string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Status          string `protobuf:"bytes,3,opt,name=status,proto3" json:"status,omitempty"`
	ProgressPercent uint64 `protobuf:"varint,4,opt,name=progress_percent,json=progressPercent,proto3" json:"progress_percent,omitempty"`
	OutputLocation  string `protobuf:"bytes,5,opt,name=output_location,json=outputLocation,proto3" json:"output_location,omitempty"`
	ErrorMessage    string `protobuf:"bytes,6,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *MsgReportJobStatus) Reset()         { *m = MsgReportJobStatus{} }
func (m *MsgReportJobStatus) String() string { return proto.CompactTextString(m) }
func (*MsgReportJobStatus) ProtoMessage()    {}
func (*MsgReportJobStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{14}
}
func (m *MsgReportJobStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportJobStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportJobStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportJobStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportJobStatus.Merge(m, src)
}
func (m *MsgReportJobStatus) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportJobStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportJobStatus.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportJobStatus proto.InternalMessageInfo

func (m *MsgReportJobStatus) GetReporter() string {
	if m != nil {
		return m.Reporter
	}
	return ""
}

func (m *MsgReportJobStatus) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *MsgReportJobStatus) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *MsgReportJobStatus) GetProgressPercent() uint64 {
	if m != nil {
		return m.ProgressPercent
	}
	return 0
}

func (m *MsgReportJobStatus) GetOutputLocation() string {
	if m != nil {
		return m.OutputLocation
	}
	return ""
}

func (m *MsgReportJobStatus) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

// MsgReportJobStatusResponse is the response for MsgReportJobStatus
type MsgReportJobStatusResponse struct {
}

func (m *MsgReportJobStatusResponse) Reset()         { *m = MsgReportJobStatusResponse{} }
func (m *MsgReportJobStatusResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReportJobStatusResponse) ProtoMessage()    {}
func (*MsgReportJobStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{15}
}
func (m *MsgReportJobStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportJobStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportJobStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportJobStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportJobStatusResponse.Merge(m, src)
}
func (m *MsgReportJobStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportJobStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportJobStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportJobStatusResponse proto.InternalMessageInfo

// MsgUpdateNodeMetadata updates node metadata
type MsgUpdateNodeMetadata struct {
	Owner       string `protobuf:"bytes,1,opt,name=owner,proto3" json:"owner,omitempty"`
	ClusterId   string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	NodeId      string `protobuf:"bytes,3,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	GpuModel    string `protobuf:"bytes,4,opt,name=gpu_model,json=gpuModel,proto3" json:"gpu_model,omitempty"`
	GpuMemoryGb uint64 `protobuf:"varint,5,opt,name=gpu_memory_gb,json=gpuMemoryGb,proto3" json:"gpu_memory_gb,omitempty"`
	CpuModel    string `protobuf:"bytes,6,opt,name=cpu_model,json=cpuModel,proto3" json:"cpu_model,omitempty"`
	MemoryGb    uint64 `protobuf:"varint,7,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb,omitempty"`
}

func (m *MsgUpdateNodeMetadata) Reset()         { *m = MsgUpdateNodeMetadata{} }
func (m *MsgUpdateNodeMetadata) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNodeMetadata) ProtoMessage()    {}
func (*MsgUpdateNodeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{16}
}
func (m *MsgUpdateNodeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNodeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNodeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNodeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNodeMetadata.Merge(m, src)
}
func (m *MsgUpdateNodeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNodeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNodeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNodeMetadata proto.InternalMessageInfo

func (m *MsgUpdateNodeMetadata) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *MsgUpdateNodeMetadata) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *MsgUpdateNodeMetadata) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *MsgUpdateNodeMetadata) GetGpuModel() string {
	if m != nil {
		return m.GpuModel
	}
	return ""
}

func (m *MsgUpdateNodeMetadata) GetGpuMemoryGb() uint64 {
	if m != nil {
		return m.GpuMemoryGb
	}
	return 0
}

func (m *MsgUpdateNodeMetadata) GetCpuModel() string {
	if m != nil {
		return m.CpuModel
	}
	return ""
}

func (m *MsgUpdateNodeMetadata) GetMemoryGb() uint64 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

// MsgUpdateNodeMetadataResponse is the response for MsgUpdateNodeMetadata
type MsgUpdateNodeMetadataResponse struct {
}

func (m *MsgUpdateNodeMetadataResponse) Reset()         { *m = MsgUpdateNodeMetadataResponse{} }
func (m *MsgUpdateNodeMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateNodeMetadataResponse) ProtoMessage()    {}
func (*MsgUpdateNodeMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{17}
}
func (m *MsgUpdateNodeMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateNodeMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateNodeMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateNodeMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateNodeMetadataResponse.Merge(m, src)
}
func (m *MsgUpdateNodeMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateNodeMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateNodeMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateNodeMetadataResponse proto.InternalMessageInfo

// MsgFlagDispute flags a dispute for a job
type MsgFlagDispute struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	JobId    string `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	Reason   string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Evidence string `protobuf:"bytes,4,opt,name=evidence,proto3" json:"evidence,omitempty"`
}

func (m *MsgFlagDispute) Reset()         { *m = MsgFlagDispute{} }
func (m *MsgFlagDispute) String() string { return proto.CompactTextString(m) }
func (*MsgFlagDispute) ProtoMessage()    {}
func (*MsgFlagDispute) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{18}
}
func (m *MsgFlagDispute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFlagDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFlagDispute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFlagDispute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFlagDispute.Merge(m, src)
}
func (m *MsgFlagDispute) XXX_Size() int {
	return m.Size()
}
func (m *MsgFlagDispute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFlagDispute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFlagDispute proto.InternalMessageInfo

func (m *MsgFlagDispute) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgFlagDispute) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *MsgFlagDispute) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgFlagDispute) GetEvidence() string {
	if m != nil {
		return m.Evidence
	}
	return ""
}

// MsgFlagDisputeResponse is the response for MsgFlagDispute
type MsgFlagDisputeResponse struct {
	DisputeId string `protobuf:"bytes,1,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty"`
}

func (m *MsgFlagDisputeResponse) Reset()         { *m = MsgFlagDisputeResponse{} }
func (m *MsgFlagDisputeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgFlagDisputeResponse) ProtoMessage()    {}
func (*MsgFlagDisputeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{19}
}
func (m *MsgFlagDisputeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgFlagDisputeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgFlagDisputeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgFlagDisputeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgFlagDisputeResponse.Merge(m, src)
}
func (m *MsgFlagDisputeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgFlagDisputeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgFlagDisputeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgFlagDisputeResponse proto.InternalMessageInfo

func (m *MsgFlagDisputeResponse) GetDisputeId() string {
	if m != nil {
		return m.DisputeId
	}
	return ""
}

// MsgResolveDispute resolves a flagged dispute
type MsgResolveDispute struct {
	Authority    string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority,omitempty"`
	DisputeId    string `protobuf:"bytes,2,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty"`
	Resolution   string `protobuf:"bytes,3,opt,name=resolution,proto3" json:"resolution,omitempty"`
	RefundAmount string `protobuf:"bytes,4,opt,name=refund_amount,json=refundAmount,proto3" json:"refund_amount,omitempty"`
}

func (m *MsgResolveDispute) Reset()         { *m = MsgResolveDispute{} }
func (m *MsgResolveDispute) String() string { return proto.CompactTextString(m) }
func (*MsgResolveDispute) ProtoMessage()    {}
func (*MsgResolveDispute) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{20}
}
func (m *MsgResolveDispute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveDispute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveDispute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveDispute.Merge(m, src)
}
func (m *MsgResolveDispute) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveDispute) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveDispute.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveDispute proto.InternalMessageInfo

func (m *MsgResolveDispute) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgResolveDispute) GetDisputeId() string {
	if m != nil {
		return m.DisputeId
	}
	return ""
}

func (m *MsgResolveDispute) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *MsgResolveDispute) GetRefundAmount() string {
	if m != nil {
		return m.RefundAmount
	}
	return ""
}

// MsgResolveDisputeResponse is the response for MsgResolveDispute
type MsgResolveDisputeResponse struct {
}

func (m *MsgResolveDisputeResponse) Reset()         { *m = MsgResolveDisputeResponse{} }
func (m *MsgResolveDisputeResponse) String() string { return proto.CompactTextString(m) }
func (*MsgResolveDisputeResponse) ProtoMessage()    {}
func (*MsgResolveDisputeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{21}
}
func (m *MsgResolveDisputeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveDisputeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveDisputeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveDisputeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveDisputeResponse.Merge(m, src)
}
func (m *MsgResolveDisputeResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveDisputeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveDisputeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveDisputeResponse proto.InternalMessageInfo

// GenesisState is the genesis state for the hpc module
type GenesisState struct {
	Params           Params     `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
	Clusters         []Cluster  `protobuf:"bytes,2,rep,name=clusters,proto3" json:"clusters"`
	Offerings        []Offering `protobuf:"bytes,3,rep,name=offerings,proto3" json:"offerings"`
	Jobs             []Job      `protobuf:"bytes,4,rep,name=jobs,proto3" json:"jobs"`
	ClusterSequence  uint64     `protobuf:"varint,5,opt,name=cluster_sequence,json=clusterSequence,proto3" json:"cluster_sequence,omitempty"`
	OfferingSequence uint64     `protobuf:"varint,6,opt,name=offering_sequence,json=offeringSequence,proto3" json:"offering_sequence,omitempty"`
	JobSequence      uint64     `protobuf:"varint,7,opt,name=job_sequence,json=jobSequence,proto3" json:"job_sequence,omitempty"`
}

func (m *GenesisState) Reset()         { *m = GenesisState{} }
func (m *GenesisState) String() string { return proto.CompactTextString(m) }
func (*GenesisState) ProtoMessage()    {}
func (*GenesisState) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{22}
}
func (m *GenesisState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenesisState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenesisState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenesisState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenesisState.Merge(m, src)
}
func (m *GenesisState) XXX_Size() int {
	return m.Size()
}
func (m *GenesisState) XXX_DiscardUnknown() {
	xxx_messageInfo_GenesisState.DiscardUnknown(m)
}

var xxx_messageInfo_GenesisState proto.InternalMessageInfo

func (m *GenesisState) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

func (m *GenesisState) GetClusters() []Cluster {
	if m != nil {
		return m.Clusters
	}
	return nil
}

func (m *GenesisState) GetOfferings() []Offering {
	if m != nil {
		return m.Offerings
	}
	return nil
}

func (m *GenesisState) GetJobs() []Job {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *GenesisState) GetClusterSequence() uint64 {
	if m != nil {
		return m.ClusterSequence
	}
	return 0
}

func (m *GenesisState) GetOfferingSequence() uint64 {
	if m != nil {
		return m.OfferingSequence
	}
	return 0
}

func (m *GenesisState) GetJobSequence() uint64 {
	if m != nil {
		return m.JobSequence
	}
	return 0
}

// Params defines the parameters for the hpc module
type Params struct {
	MinDeposit              string `protobuf:"bytes,1,opt,name=min_deposit,json=minDeposit,proto3" json:"min_deposit,omitempty"`
	MaxJobDuration          uint64 `protobuf:"varint,2,opt,name=max_job_duration,json=maxJobDuration,proto3" json:"max_job_duration,omitempty"`
	PlatformFeeRate         string `protobuf:"bytes,3,opt,name=platform_fee_rate,json=platformFeeRate,proto3" json:"platform_fee_rate,omitempty"`
	DisputeResolutionPeriod uint64 `protobuf:"varint,4,opt,name=dispute_resolution_period,json=disputeResolutionPeriod,proto3" json:"dispute_resolution_period,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{23}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMinDeposit() string {
	if m != nil {
		return m.MinDeposit
	}
	return ""
}

func (m *Params) GetMaxJobDuration() uint64 {
	if m != nil {
		return m.MaxJobDuration
	}
	return 0
}

func (m *Params) GetPlatformFeeRate() string {
	if m != nil {
		return m.PlatformFeeRate
	}
	return ""
}

func (m *Params) GetDisputeResolutionPeriod() uint64 {
	if m != nil {
		return m.DisputeResolutionPeriod
	}
	return 0
}

// Cluster represents an HPC cluster
type Cluster struct {
	ClusterId    string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Owner        string `protobuf:"bytes,2,opt,name=owner,proto3" json:"owner,omitempty"`
	Name         string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	ClusterType  string `protobuf:"bytes,4,opt,name=cluster_type,json=clusterType,proto3" json:"cluster_type,omitempty"`
	Region       string `protobuf:"bytes,5,opt,name=region,proto3" json:"region,omitempty"`
	Endpoint     string `protobuf:"bytes,6,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	TotalNodes   uint64 `protobuf:"varint,7,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes,omitempty"`
	TotalGpus    uint64 `protobuf:"varint,8,opt,name=total_gpus,json=totalGpus,proto3" json:"total_gpus,omitempty"`
	Active       bool   `protobuf:"varint,9,opt,name=active,proto3" json:"active,omitempty"`
	RegisteredAt int64  `protobuf:"varint,10,opt,name=registered_at,json=registeredAt,proto3" json:"registered_at,omitempty"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{24}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Cluster) GetOwner() string {
	if m != nil {
		return m.Owner
	}
	return ""
}

func (m *Cluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cluster) GetClusterType() string {
	if m != nil {
		return m.ClusterType
	}
	return ""
}

func (m *Cluster) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *Cluster) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Cluster) GetTotalNodes() uint64 {
	if m != nil {
		return m.TotalNodes
	}
	return 0
}

func (m *Cluster) GetTotalGpus() uint64 {
	if m != nil {
		return m.TotalGpus
	}
	return 0
}

func (m *Cluster) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *Cluster) GetRegisteredAt() int64 {
	if m != nil {
		return m.RegisteredAt
	}
	return 0
}

// Offering represents an HPC offering
type Offering struct {
	OfferingId   string `protobuf:"bytes,1,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
	ClusterId    string `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id,omitempty"`
	Provider     string `protobuf:"bytes,3,opt,name=provider,proto3" json:"provider,omitempty"`
	Name         string `protobuf:"bytes,4,opt,name=name,proto3" json:"name,omitempty"`
	ResourceType string `protobuf:"bytes,5,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty"`
	PricePerHour string `protobuf:"bytes,6,opt,name=price_per_hour,json=pricePerHour,proto3" json:"price_per_hour,omitempty"`
	MinDuration  uint64 `protobuf:"varint,7,opt,name=min_duration,json=minDuration,proto3" json:"min_duration,omitempty"`
	MaxDuration  uint64 `protobuf:"varint,8,opt,name=max_duration,json=maxDuration,proto3" json:"max_duration,omitempty"`
	Active       bool   `protobuf:"varint,9,opt,name=active,proto3" json:"active,omitempty"`
}

func (m *Offering) Reset()         { *m = Offering{} }
func (m *Offering) String() string { return proto.CompactTextString(m) }
func (*Offering) ProtoMessage()    {}
func (*Offering) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{25}
}
func (m *Offering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Offering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Offering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Offering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Offering.Merge(m, src)
}
func (m *Offering) XXX_Size() int {
	return m.Size()
}
func (m *Offering) XXX_DiscardUnknown() {
	xxx_messageInfo_Offering.DiscardUnknown(m)
}

var xxx_messageInfo_Offering proto.InternalMessageInfo

func (m *Offering) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *Offering) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *Offering) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *Offering) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Offering) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *Offering) GetPricePerHour() string {
	if m != nil {
		return m.PricePerHour
	}
	return ""
}

func (m *Offering) GetMinDuration() uint64 {
	if m != nil {
		return m.MinDuration
	}
	return 0
}

func (m *Offering) GetMaxDuration() uint64 {
	if m != nil {
		return m.MaxDuration
	}
	return 0
}

func (m *Offering) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

// Job represents an HPC job
type Job struct {
	JobId       string `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id,omitempty"`
	OfferingId  string `protobuf:"bytes,2,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
	Submitter   string `protobuf:"bytes,3,opt,name=submitter,proto3" json:"submitter,omitempty"`
	Status      string `protobuf:"bytes,4,opt,name=status,proto3" json:"status,omitempty"`
	SubmittedAt int64  `protobuf:"varint,5,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	StartedAt   int64  `protobuf:"varint,6,opt,name=started_at,json=startedAt,proto3" json:"started_at,omitempty"`
	CompletedAt int64  `protobuf:"varint,7,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_b4a9c4cd88a01db5, []int{26}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *Job) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *Job) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *Job) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *Job) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

func (m *Job) GetStartedAt() int64 {
	if m != nil {
		return m.StartedAt
	}
	return 0
}

func (m *Job) GetCompletedAt() int64 {
	if m != nil {
		return m.CompletedAt
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgRegisterCluster)(nil), "virtengine.hpc.v1.MsgRegisterCluster")
	proto.RegisterType((*MsgRegisterClusterResponse)(nil), "virtengine.hpc.v1.MsgRegisterClusterResponse")
	proto.RegisterType((*MsgUpdateCluster)(nil), "virtengine.hpc.v1.MsgUpdateCluster")
	proto.RegisterType((*MsgUpdateClusterResponse)(nil), "virtengine.hpc.v1.MsgUpdateClusterResponse")
	proto.RegisterType((*MsgDeregisterCluster)(nil), "virtengine.hpc.v1.MsgDeregisterCluster")
	proto.RegisterType((*MsgDeregisterClusterResponse)(nil), "virtengine.hpc.v1.MsgDeregisterClusterResponse")
	proto.RegisterType((*MsgCreateOffering)(nil), "virtengine.hpc.v1.MsgCreateOffering")
	proto.RegisterType((*MsgCreateOfferingResponse)(nil), "virtengine.hpc.v1.MsgCreateOfferingResponse")
	proto.RegisterType((*MsgUpdateOffering)(nil), "virtengine.hpc.v1.MsgUpdateOffering")
	proto.RegisterType((*MsgUpdateOfferingResponse)(nil), "virtengine.hpc.v1.MsgUpdateOfferingResponse")
	proto.RegisterType((*MsgSubmitJob)(nil), "virtengine.hpc.v1.MsgSubmitJob")
	proto.RegisterType((*MsgSubmitJobResponse)(nil), "virtengine.hpc.v1.MsgSubmitJobResponse")
	proto.RegisterType((*MsgCancelJob)(nil), "virtengine.hpc.v1.MsgCancelJob")
	proto.RegisterType((*MsgCancelJobResponse)(nil), "virtengine.hpc.v1.MsgCancelJobResponse")
	proto.RegisterType((*MsgReportJobStatus)(nil), "virtengine.hpc.v1.MsgReportJobStatus")
	proto.RegisterType((*MsgReportJobStatusResponse)(nil), "virtengine.hpc.v1.MsgReportJobStatusResponse")
	proto.RegisterType((*MsgUpdateNodeMetadata)(nil), "virtengine.hpc.v1.MsgUpdateNodeMetadata")
	proto.RegisterType((*MsgUpdateNodeMetadataResponse)(nil), "virtengine.hpc.v1.MsgUpdateNodeMetadataResponse")
	proto.RegisterType((*MsgFlagDispute)(nil), "virtengine.hpc.v1.MsgFlagDispute")
	proto.RegisterType((*MsgFlagDisputeResponse)(nil), "virtengine.hpc.v1.MsgFlagDisputeResponse")
	proto.RegisterType((*MsgResolveDispute)(nil), "virtengine.hpc.v1.MsgResolveDispute")
	proto.RegisterType((*MsgResolveDisputeResponse)(nil), "virtengine.hpc.v1.MsgResolveDisputeResponse")
	proto.RegisterType((*GenesisState)(nil), "virtengine.hpc.v1.GenesisState")
	proto.RegisterType((*Params)(nil), "virtengine.hpc.v1.Params")
	proto.RegisterType((*Cluster)(nil), "virtengine.hpc.v1.Cluster")
	proto.RegisterType((*Offering)(nil), "virtengine.hpc.v1.Offering")
	proto.RegisterType((*Job)(nil), "virtengine.hpc.v1.Job")
}

func init() { proto.RegisterFile("virtengine/hpc/v1/tx.proto", fileDescriptor_b4a9c4cd88a01db5) }

var fileDescriptor_b4a9c4cd88a01db5 = []byte{
	// 1828 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcd, 0x6f, 0xdb, 0xc8,
	0x15, 0x37, 0x25, 0x59, 0x96, 0x9e, 0x14, 0x7f, 0x10, 0x8e, 0x23, 0x2b, 0x89, 0x9c, 0x70, 0xbd,
	0x8d, 0x93, 0x6c, 0xac, 0x6c, 0xb6, 0xd8, 0x05, 0xd4, 0x05, 0x0a, 0x27, 0xc1, 0xa6, 0x0e, 0xaa,
	0x36, 0x90, 0xbb, 0x97, 0xf6, 0x40, 0x50, 0xe2, 0x98, 0x66, 0x2a, 0x72, 0xd8, 0x99, 0xa1, 0xeb,
	0xdc, 0x8a, 0x1e, 0x7b, 0x2a, 0x0a, 0xf4, 0xd2, 0x53, 0x80, 0x02, 0x45, 0x8f, 0x39, 0xb4, 0x97,
	0xf6, 0xd4, 0xdb, 0x1e, 0x17, 0x05, 0x0a, 0xec, 0xa5, 0x1f, 0x48, 0x0e, 0xd9, 0x7f, 0xa1, 0x97,
	0xa2, 0x98, 0x0f, 0x0e, 0x49, 0x89, 0xfa, 0x40, 0xb7, 0x7b, 0xb1, 0x35, 0xbf, 0xf9, 0xcd, 0xd7,
	0x6f, 0xde, 0x9b, 0xf7, 0x1e, 0xa1, 0x7d, 0xee, 0x13, 0x86, 0x42, 0xcf, 0x0f, 0x51, 0xf7, 0x2c,
	0x1a, 0x75, 0xcf, 0xdf, 0xef, 0xb2, 0x8b, 0xc3, 0x88, 0x60, 0x86, 0xcd, 0xad, 0xb4, 0xef, 0xf0,
	0x2c, 0x1a, 0x1d, 0x9e, 0xbf, 0xdf, 0xde, 0xf6, 0xb0, 0x87, 0x45, 0x6f, 0x97, 0xff, 0x92, 0xc4,
	0xf6, 0xee, 0x08, 0xd3, 0x00, 0x53, 0x5b, 0x76, 0xc8, 0x86, 0xea, 0xba, 0x22, 0x5b, 0xdd, 0x80,
	0x7a, 0x7c, 0xee, 0x80, 0x7a, 0xaa, 0x63, 0xcb, 0x09, 0xfc, 0x10, 0x77, 0xc5, 0x5f, 0x09, 0x59,
	0xbf, 0x29, 0x81, 0xd9, 0xa7, 0xde, 0x00, 0x79, 0x3e, 0x65, 0x88, 0x3c, 0x1a, 0xc7, 0xfc, 0x9f,
	0x79, 0x08, 0xab, 0xf8, 0xa7, 0x21, 0x22, 0x2d, 0xe3, 0x86, 0x71, 0x50, 0x7f, 0xd8, 0xfa, 0xeb,
	0x1f, 0xee, 0x6d, 0xab, 0x35, 0x8e, 0x5c, 0x97, 0x20, 0x4a, 0x4f, 0x18, 0xf1, 0x43, 0x6f, 0x20,
	0x69, 0xa6, 0x09, 0x95, 0xd0, 0x09, 0x50, 0xab, 0xc4, 0xe9, 0x03, 0xf1, 0xdb, 0xbc, 0x09, 0xcd,
	0x91, 0x9c, 0xce, 0x66, 0x2f, 0x22, 0xd4, 0x2a, 0x8b, 0xbe, 0x86, 0xc2, 0x7e, 0xf0, 0x22, 0x42,
	0xe6, 0x0e, 0x54, 0x09, 0xf2, 0x7c, 0x1c, 0xb6, 0x2a, 0xa2, 0x53, 0xb5, 0xcc, 0x36, 0xd4, 0x50,
	0xe8, 0x46, 0xd8, 0x0f, 0x59, 0x6b, 0x55, 0xf4, 0xe8, 0xb6, 0xb9, 0x07, 0x0d, 0x86, 0x99, 0x33,
	0xb6, 0x43, 0xec, 0x22, 0xda, 0xaa, 0xde, 0x30, 0x0e, 0x2a, 0x03, 0x10, 0xd0, 0xf7, 0x38, 0x62,
	0x5e, 0x07, 0xd9, 0xb2, 0xbd, 0x28, 0xa6, 0xad, 0x35, 0xd1, 0x5f, 0x17, 0xc8, 0x93, 0x28, 0xa6,
	0xbd, 0xdb, 0x5f, 0xbe, 0xdc, 0x5b, 0xf9, 0xf9, 0xdb, 0x57, 0x77, 0xe4, 0xd6, 0x7f, 0xf1, 0xf6,
	0xd5, 0x9d, 0x1d, 0x7e, 0x0b, 0xd3, 0x2a, 0x58, 0xdf, 0x82, 0xf6, 0x34, 0x3a, 0x40, 0x34, 0xc2,
	0x21, 0x45, 0x7c, 0x9d, 0xe4, 0x7c, 0xbe, 0x2b, 0x85, 0x1a, 0xd4, 0x15, 0x72, 0xec, 0x5a, 0xff,
	0x31, 0x60, 0xb3, 0x4f, 0xbd, 0x4f, 0x23, 0xd7, 0x61, 0xe8, 0x7f, 0xd5, 0x35, 0xbf, 0x46, 0x69,
	0x62, 0x8d, 0x9c, 0x4e, 0xe5, 0xf9, 0x3a, 0x55, 0x16, 0xe8, 0xb4, 0x3a, 0xa1, 0x13, 0xbf, 0x1b,
	0x67, 0xc4, 0xfc, 0x73, 0x24, 0x24, 0xae, 0x0d, 0x54, 0xab, 0x77, 0x6b, 0x5a, 0xbf, 0x6d, 0xa5,
	0x5f, 0xee, 0xac, 0x56, 0x1b, 0x5a, 0x93, 0x58, 0xa2, 0x9d, 0xf5, 0x2b, 0x03, 0xb6, 0xfb, 0xd4,
	0x7b, 0x8c, 0xc8, 0x57, 0x34, 0xbc, 0xf9, 0x02, 0xf5, 0xee, 0x4e, 0x6f, 0xb6, 0xa5, 0x36, 0x3b,
	0xb5, 0xb6, 0xd5, 0x81, 0x6b, 0x45, 0xb8, 0xde, 0xf4, 0x9f, 0x4a, 0xb0, 0xd5, 0xa7, 0xde, 0x23,
	0x82, 0x1c, 0x86, 0xbe, 0x7f, 0x7a, 0x8a, 0xf8, 0x46, 0xcc, 0x6f, 0x42, 0x2d, 0x22, 0xf8, 0xdc,
	0x77, 0x97, 0xd8, 0xb4, 0x66, 0x2e, 0xba, 0xd8, 0xc4, 0x9f, 0xca, 0x19, 0x7f, 0x7a, 0x07, 0x2e,
	0x11, 0x44, 0x71, 0x4c, 0x46, 0x48, 0x3a, 0x94, 0xf4, 0x99, 0x66, 0x02, 0x0a, 0x8f, 0xda, 0x87,
	0xf5, 0x88, 0xf8, 0x23, 0x64, 0x47, 0x88, 0xd8, 0x67, 0x38, 0x26, 0xca, 0x7f, 0x9a, 0x02, 0x7d,
	0x86, 0xc8, 0x77, 0x70, 0x4c, 0xb8, 0x6b, 0x06, 0x7e, 0x68, 0xbb, 0x31, 0x71, 0x18, 0xf7, 0x3e,
	0xe9, 0x44, 0x8d, 0xc0, 0x0f, 0x1f, 0x2b, 0x48, 0x50, 0x9c, 0x8b, 0x94, 0xb2, 0xa6, 0x28, 0xce,
	0x45, 0x42, 0x49, 0xc5, 0xd5, 0xc7, 0xe2, 0xfa, 0x5e, 0x56, 0xfa, 0xe6, 0x65, 0xb2, 0x3e, 0x86,
	0xdd, 0x29, 0x50, 0xbb, 0xd2, 0x1e, 0x34, 0xb0, 0xc2, 0x52, 0x5f, 0x82, 0x04, 0x3a, 0x76, 0xad,
	0xbf, 0x19, 0x42, 0x7a, 0x69, 0x4c, 0x5f, 0x51, 0xfa, 0x89, 0xc5, 0x4a, 0x93, 0x8b, 0x15, 0x68,
	0x58, 0x2e, 0xd0, 0x30, 0xf5, 0x8f, 0x4a, 0xce, 0x3f, 0xe6, 0xab, 0x92, 0x3f, 0x81, 0x75, 0x55,
	0xa8, 0x92, 0x07, 0xb5, 0xbd, 0xfd, 0xa5, 0x04, 0xcd, 0x3e, 0xf5, 0x4e, 0xe2, 0x61, 0xe0, 0xb3,
	0xa7, 0x78, 0x68, 0x7e, 0x08, 0x75, 0x2a, 0x1a, 0x6c, 0x89, 0x03, 0xa7, 0xd4, 0xc5, 0x27, 0xbe,
	0x0e, 0xf0, 0x1c, 0x0f, 0x6d, 0x3a, 0x22, 0x7e, 0x94, 0xbc, 0x24, 0xf5, 0xe7, 0x78, 0x78, 0x22,
	0x00, 0xf3, 0x16, 0x6c, 0x10, 0xf4, 0x93, 0x18, 0x51, 0x86, 0xdc, 0xdc, 0x73, 0xb2, 0xae, 0x61,
	0xf9, 0xa4, 0xbc, 0x0b, 0x29, 0x92, 0x7d, 0x56, 0x2e, 0x69, 0x54, 0x3c, 0x2d, 0x93, 0xb6, 0x55,
	0x9d, 0xb2, 0x2d, 0xbe, 0x23, 0x4e, 0x19, 0xc6, 0xae, 0x87, 0x98, 0x30, 0xbe, 0xfa, 0xa0, 0x1e,
	0x38, 0x17, 0x0f, 0x05, 0x90, 0x3e, 0x42, 0xe9, 0x29, 0xb9, 0xca, 0x9b, 0x4a, 0x65, 0x2d, 0x99,
	0x75, 0x4f, 0xbc, 0x33, 0xba, 0xad, 0x2d, 0xee, 0x32, 0x54, 0xf9, 0x89, 0xb5, 0xb1, 0xad, 0x3e,
	0xc7, 0xc3, 0x63, 0xd7, 0xfa, 0xb5, 0x21, 0x24, 0x7f, 0xe4, 0x84, 0x23, 0x34, 0xe6, 0x92, 0xdf,
	0x87, 0x2a, 0x45, 0xe1, 0x32, 0x06, 0xa6, 0x78, 0x99, 0x99, 0x4b, 0x99, 0x99, 0x65, 0xa8, 0x73,
	0x28, 0x0e, 0x95, 0xbc, 0xaa, 0xd5, 0xdb, 0x4f, 0x4e, 0xa2, 0xc6, 0x67, 0x8f, 0xa1, 0xb7, 0x61,
	0xed, 0x88, 0x63, 0xe8, 0xb6, 0x36, 0x91, 0x97, 0x49, 0xf8, 0x8e, 0x30, 0xe1, 0xe7, 0x3b, 0x61,
	0x0e, 0x8b, 0x29, 0x77, 0x0c, 0x22, 0xa0, 0x65, 0x1c, 0x23, 0x61, 0xce, 0xd9, 0x39, 0x15, 0xd3,
	0x26, 0x3b, 0x97, 0x2d, 0xf3, 0x36, 0x6c, 0x46, 0x04, 0x7b, 0x7c, 0x2a, 0xee, 0x29, 0x23, 0x14,
	0x32, 0x65, 0x16, 0x1b, 0x09, 0xfe, 0x4c, 0xc2, 0xdc, 0x80, 0x70, 0xcc, 0xa2, 0x98, 0xd9, 0x63,
	0x3c, 0x92, 0x77, 0x2e, 0x9f, 0xa5, 0x75, 0x09, 0x7f, 0x57, 0xa1, 0xfc, 0x8d, 0x43, 0x84, 0x60,
	0x62, 0x07, 0x88, 0x52, 0xc7, 0x93, 0xb1, 0xa7, 0x3e, 0x68, 0x0a, 0xb0, 0x2f, 0xb1, 0xde, 0x7b,
	0xda, 0xc3, 0x92, 0xad, 0xe7, 0x83, 0x78, 0x4e, 0x0b, 0xeb, 0x9a, 0x0a, 0xe2, 0x39, 0x54, 0x0b,
	0xf8, 0xfb, 0x12, 0x5c, 0xd6, 0x1e, 0xc8, 0x8d, 0xb8, 0x8f, 0x98, 0xe3, 0x3a, 0xcc, 0xf9, 0x7f,
	0x87, 0xea, 0x2b, 0xb0, 0xc6, 0x3d, 0x87, 0xf7, 0x29, 0x19, 0x79, 0xf3, 0xd8, 0x35, 0xaf, 0x42,
	0xdd, 0x8b, 0x62, 0x3b, 0xc0, 0x2e, 0x1a, 0xab, 0x27, 0xbd, 0xe6, 0x45, 0x71, 0x9f, 0xb7, 0x4d,
	0x0b, 0x2e, 0x89, 0x4e, 0x14, 0x60, 0xf2, 0xc2, 0xf6, 0x86, 0xca, 0x9f, 0x1a, 0x9c, 0x20, 0xb0,
	0x27, 0x43, 0x3e, 0xc1, 0x48, 0x4f, 0x20, 0xf5, 0xaa, 0x8d, 0x92, 0x09, 0xae, 0x42, 0x3d, 0x1d,
	0x2c, 0xdf, 0xf0, 0x5a, 0xa0, 0x46, 0xa6, 0x42, 0xa6, 0xd1, 0x71, 0x37, 0xf7, 0x4e, 0x65, 0x05,
	0xb1, 0xf6, 0xe0, 0x7a, 0x61, 0x87, 0xd6, 0xf2, 0x8f, 0x06, 0xac, 0xf7, 0xa9, 0xf7, 0xc9, 0xd8,
	0xf1, 0x1e, 0xfb, 0x34, 0x8a, 0x19, 0xfa, 0xda, 0xdd, 0x47, 0x64, 0x40, 0xfc, 0x91, 0x0d, 0x47,
	0x49, 0x3c, 0xd4, 0xed, 0xde, 0x37, 0x0a, 0x5c, 0xcb, 0x54, 0xe7, 0xcb, 0x6c, 0xd2, 0xfa, 0x08,
	0x76, 0xf2, 0x48, 0x36, 0xc5, 0x73, 0x25, 0x94, 0x49, 0xf1, 0x14, 0x72, 0xec, 0x5a, 0x7f, 0x97,
	0x51, 0x69, 0x80, 0x28, 0x1e, 0x9f, 0xa3, 0xe4, 0xcc, 0x1f, 0x42, 0xdd, 0x89, 0xd9, 0x19, 0x26,
	0x3e, 0x7b, 0xb1, 0xf8, 0x95, 0xd6, 0xd4, 0x89, 0xc5, 0x4a, 0x13, 0x8b, 0x99, 0x1d, 0x00, 0x1e,
	0xe9, 0xc7, 0xb1, 0x70, 0x1f, 0xa9, 0x42, 0x06, 0x91, 0xe9, 0xc1, 0x69, 0x1c, 0xba, 0xb6, 0x13,
	0xe0, 0x58, 0xf9, 0xa2, 0x48, 0x0f, 0x38, 0x78, 0x24, 0xb0, 0xf4, 0xc6, 0xd3, 0x75, 0xb3, 0xd1,
	0x29, 0x7f, 0x12, 0x15, 0x9d, 0xf2, 0xa0, 0xbe, 0xed, 0x7f, 0x97, 0xa0, 0xf9, 0x04, 0x85, 0x88,
	0xfa, 0x94, 0xfb, 0x14, 0x32, 0x3f, 0x82, 0x6a, 0xe4, 0x10, 0x27, 0xa0, 0xe2, 0xd0, 0x8d, 0x07,
	0xbb, 0x87, 0x53, 0xb5, 0xcc, 0xe1, 0x33, 0x41, 0x78, 0x58, 0xf9, 0xec, 0x1f, 0x7b, 0x2b, 0x03,
	0x45, 0x37, 0x3f, 0x86, 0x9a, 0xf2, 0x13, 0xda, 0x2a, 0xdd, 0x28, 0x1f, 0x34, 0x1e, 0xb4, 0x0b,
	0x86, 0xaa, 0x6c, 0x4c, 0x8d, 0xd5, 0x23, 0xcc, 0x6f, 0x43, 0x3d, 0x89, 0x64, 0xfc, 0x85, 0xe2,
	0xc3, 0xaf, 0x16, 0x0c, 0x4f, 0xa2, 0xab, 0x1a, 0x9f, 0x8e, 0x31, 0xef, 0x43, 0xe5, 0x39, 0x1e,
	0xf2, 0x90, 0xc6, 0xc7, 0xee, 0x14, 0x8c, 0x7d, 0x8a, 0x87, 0x6a, 0x98, 0x60, 0xf2, 0x97, 0x2f,
	0x71, 0x75, 0xca, 0x03, 0x1b, 0x37, 0x3e, 0xe9, 0x98, 0x1b, 0x0a, 0x3f, 0x51, 0xb0, 0x79, 0x17,
	0xb6, 0x74, 0xe8, 0xd5, 0x5c, 0x19, 0xef, 0x36, 0x93, 0x0e, 0x4d, 0xbe, 0x09, 0x4d, 0x11, 0x86,
	0x13, 0x9e, 0xca, 0xb9, 0x78, 0x20, 0x56, 0x50, 0xaf, 0xf2, 0xe5, 0xcb, 0x3d, 0xc3, 0xfa, 0xb3,
	0x01, 0x55, 0x29, 0x25, 0x8f, 0xed, 0x22, 0x95, 0x43, 0x11, 0xa6, 0x3e, 0x4b, 0x52, 0x27, 0x9e,
	0xc9, 0x49, 0xc4, 0x3c, 0x80, 0x4d, 0x1e, 0x49, 0xf9, 0xc4, 0x3a, 0xe0, 0x96, 0x64, 0xf4, 0x0e,
	0x9c, 0x8b, 0xa7, 0x78, 0xa8, 0x63, 0xee, 0x1d, 0xd8, 0x8a, 0xc6, 0x0e, 0x3b, 0xc5, 0x24, 0xb0,
	0x4f, 0x11, 0xb2, 0x89, 0xc3, 0x92, 0x0c, 0x74, 0x23, 0xe9, 0xf8, 0x04, 0xa1, 0x01, 0xbf, 0xec,
	0x1e, 0xec, 0x26, 0xc6, 0x9a, 0xda, 0x20, 0x0f, 0x03, 0x3e, 0x76, 0x55, 0x14, 0xb8, 0xe2, 0x6a,
	0x8b, 0x51, 0xfd, 0xcf, 0x44, 0xb7, 0xf5, 0xbb, 0x12, 0xac, 0x25, 0xf9, 0xfe, 0xfc, 0x22, 0xca,
	0xdc, 0x4e, 0x1e, 0x61, 0xf5, 0x18, 0xe4, 0xab, 0xcd, 0xf2, 0x9c, 0x6a, 0xb3, 0x32, 0xaf, 0xda,
	0x5c, 0x9d, 0x59, 0x6d, 0x56, 0xe7, 0x57, 0x51, 0x6b, 0x0b, 0xaa, 0xa8, 0xda, 0xec, 0x2a, 0xaa,
	0x9e, 0xcd, 0x12, 0xa5, 0xb7, 0xca, 0x32, 0x03, 0xb9, 0xb6, 0xc3, 0x5a, 0x70, 0xc3, 0x38, 0x28,
	0x73, 0x6f, 0x4d, 0xc0, 0x23, 0x66, 0xfd, 0xb6, 0x04, 0x35, 0x9d, 0xec, 0x2e, 0xca, 0x91, 0x97,
	0xa8, 0x15, 0x75, 0xb2, 0xac, 0x6a, 0x45, 0x9d, 0x12, 0x27, 0x82, 0x56, 0xe6, 0x95, 0x1b, 0xab,
	0x4b, 0x95, 0x1b, 0xd5, 0x25, 0xca, 0x8d, 0xb5, 0xc5, 0xe5, 0x46, 0x6d, 0x3a, 0x25, 0x9c, 0x21,
	0xa5, 0xf5, 0x85, 0x01, 0x65, 0x9e, 0xaa, 0x15, 0xa7, 0x74, 0x8b, 0x93, 0xdf, 0x6b, 0xd9, 0xac,
	0x5a, 0xe5, 0xbe, 0x69, 0xee, 0x9c, 0x66, 0x3f, 0x95, 0x5c, 0xf6, 0x73, 0x13, 0x9a, 0x09, 0x49,
	0xdc, 0xdf, 0xaa, 0xb8, 0xbf, 0x86, 0xc6, 0x8e, 0x18, 0xbf, 0x10, 0xca, 0x1c, 0xa2, 0x08, 0x55,
	0x41, 0xa8, 0x2b, 0xe4, 0x88, 0x09, 0x8b, 0xc5, 0x41, 0x34, 0x46, 0x8a, 0xb0, 0x26, 0x67, 0xd0,
	0xd8, 0x11, 0x7b, 0xf0, 0xcf, 0x1a, 0x94, 0xfb, 0xd4, 0x33, 0x3d, 0xd8, 0x98, 0xfc, 0x42, 0xf3,
	0x6e, 0xc1, 0x3b, 0x35, 0xfd, 0xb1, 0xa2, 0x7d, 0x6f, 0x29, 0x9a, 0x0e, 0x78, 0x0e, 0x5c, 0xca,
	0x7f, 0xb0, 0x78, 0xa7, 0x78, 0x7c, 0x8e, 0xd4, 0xbe, 0xbb, 0x04, 0x49, 0x2f, 0x11, 0xc0, 0xd6,
	0x74, 0xd9, 0x7f, 0xab, 0x78, 0x86, 0x29, 0x62, 0xbb, 0xbb, 0x24, 0x51, 0x2f, 0xe7, 0xc2, 0xfa,
	0x44, 0xc1, 0xbe, 0x5f, 0x3c, 0x45, 0x9e, 0xd5, 0x7e, 0x6f, 0x19, 0x56, 0x76, 0x95, 0x89, 0xda,
	0x74, 0x7f, 0x9e, 0x26, 0x8b, 0x56, 0x29, 0x2e, 0x08, 0xcd, 0x4f, 0xa1, 0x9e, 0x16, 0x83, 0x7b,
	0xc5, 0x43, 0x35, 0xa1, 0x7d, 0x6b, 0x01, 0x21, 0x3b, 0x6d, 0x5a, 0xf0, 0xcc, 0x98, 0x56, 0x13,
	0x66, 0x4d, 0x3b, 0x55, 0x9b, 0x48, 0xa3, 0xcd, 0xd7, 0x25, 0x33, 0x8d, 0x36, 0x47, 0x9b, 0x6d,
	0xb4, 0x85, 0x39, 0xbc, 0x19, 0x81, 0x59, 0x90, 0xbf, 0x1f, 0xcc, 0x93, 0x36, 0xcb, 0x6c, 0xdf,
	0x5f, 0x96, 0xa9, 0x57, 0xfc, 0x11, 0x34, 0xb2, 0x59, 0xee, 0xcd, 0xe2, 0x09, 0x32, 0x94, 0xf6,
	0xed, 0x85, 0x94, 0xac, 0x2d, 0x4d, 0x64, 0x94, 0xfb, 0xb3, 0xf4, 0xc8, 0xb2, 0x66, 0xd9, 0x52,
	0x71, 0xfa, 0xd6, 0x5e, 0xfd, 0xd9, 0xdb, 0x57, 0x77, 0x8c, 0x87, 0xfd, 0xcf, 0x5e, 0x77, 0x8c,
	0xcf, 0x5f, 0x77, 0x8c, 0x7f, 0xbd, 0xee, 0x18, 0xbf, 0x7c, 0xd3, 0x59, 0xf9, 0xfc, 0x4d, 0x67,
	0xe5, 0x8b, 0x37, 0x9d, 0x95, 0x1f, 0x7e, 0xe0, 0xf9, 0xec, 0x2c, 0x1e, 0x1e, 0x8e, 0x70, 0xd0,
	0xcd, 0x7c, 0xb0, 0xce, 0xfc, 0xa4, 0xee, 0x8f, 0xbb, 0x1e, 0xee, 0xf2, 0xc8, 0xa8, 0xbe, 0x63,
	0x0f, 0xab, 0xe2, 0xab, 0xf2, 0x07, 0xff, 0x0d, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x56, 0x10, 0x25,
	0xe3, 0x16, 0x00, 0x00,
}

func (this *GenesisState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GenesisState)
	if !ok {
		that2, ok := that.(GenesisState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Params.Equal(&that1.Params) {
		return false
	}
	if len(this.Clusters) != len(that1.Clusters) {
		return false
	}
	for i := range this.Clusters {
		if !this.Clusters[i].Equal(&that1.Clusters[i]) {
			return false
		}
	}
	if len(this.Offerings) != len(that1.Offerings) {
		return false
	}
	for i := range this.Offerings {
		if !this.Offerings[i].Equal(&that1.Offerings[i]) {
			return false
		}
	}
	if len(this.Jobs) != len(that1.Jobs) {
		return false
	}
	for i := range this.Jobs {
		if !this.Jobs[i].Equal(&that1.Jobs[i]) {
			return false
		}
	}
	if this.ClusterSequence != that1.ClusterSequence {
		return false
	}
	if this.OfferingSequence != that1.OfferingSequence {
		return false
	}
	if this.JobSequence != that1.JobSequence {
		return false
	}
	return true
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterCluster registers a new HPC cluster
	RegisterCluster(ctx context.Context, in *MsgRegisterCluster, opts ...grpc.CallOption) (*MsgRegisterClusterResponse, error)
	// UpdateCluster updates cluster information
	UpdateCluster(ctx context.Context, in *MsgUpdateCluster, opts ...grpc.CallOption) (*MsgUpdateClusterResponse, error)
	// DeregisterCluster removes a cluster
	DeregisterCluster(ctx context.Context, in *MsgDeregisterCluster, opts ...grpc.CallOption) (*MsgDeregisterClusterResponse, error)
	// CreateOffering creates a new HPC offering
	CreateOffering(ctx context.Context, in *MsgCreateOffering, opts ...grpc.CallOption) (*MsgCreateOfferingResponse, error)
	// UpdateOffering updates an offering
	UpdateOffering(ctx context.Context, in *MsgUpdateOffering, opts ...grpc.CallOption) (*MsgUpdateOfferingResponse, error)
	// SubmitJob submits a new HPC job
	SubmitJob(ctx context.Context, in *MsgSubmitJob, opts ...grpc.CallOption) (*MsgSubmitJobResponse, error)
	// CancelJob cancels a job
	CancelJob(ctx context.Context, in *MsgCancelJob, opts ...grpc.CallOption) (*MsgCancelJobResponse, error)
	// ReportJobStatus reports job status
	ReportJobStatus(ctx context.Context, in *MsgReportJobStatus, opts ...grpc.CallOption) (*MsgReportJobStatusResponse, error)
	// UpdateNodeMetadata updates node metadata
	UpdateNodeMetadata(ctx context.Context, in *MsgUpdateNodeMetadata, opts ...grpc.CallOption) (*MsgUpdateNodeMetadataResponse, error)
	// FlagDispute flags a dispute for a job
	FlagDispute(ctx context.Context, in *MsgFlagDispute, opts ...grpc.CallOption) (*MsgFlagDisputeResponse, error)
	// ResolveDispute resolves a flagged dispute
	ResolveDispute(ctx context.Context, in *MsgResolveDispute, opts ...grpc.CallOption) (*MsgResolveDisputeResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterCluster(ctx context.Context, in *MsgRegisterCluster, opts ...grpc.CallOption) (*MsgRegisterClusterResponse, error) {
	out := new(MsgRegisterClusterResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/RegisterCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateCluster(ctx context.Context, in *MsgUpdateCluster, opts ...grpc.CallOption) (*MsgUpdateClusterResponse, error) {
	out := new(MsgUpdateClusterResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/UpdateCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DeregisterCluster(ctx context.Context, in *MsgDeregisterCluster, opts ...grpc.CallOption) (*MsgDeregisterClusterResponse, error) {
	out := new(MsgDeregisterClusterResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/DeregisterCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CreateOffering(ctx context.Context, in *MsgCreateOffering, opts ...grpc.CallOption) (*MsgCreateOfferingResponse, error) {
	out := new(MsgCreateOfferingResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/CreateOffering", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateOffering(ctx context.Context, in *MsgUpdateOffering, opts ...grpc.CallOption) (*MsgUpdateOfferingResponse, error) {
	out := new(MsgUpdateOfferingResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/UpdateOffering", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SubmitJob(ctx context.Context, in *MsgSubmitJob, opts ...grpc.CallOption) (*MsgSubmitJobResponse, error) {
	out := new(MsgSubmitJobResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/SubmitJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) CancelJob(ctx context.Context, in *MsgCancelJob, opts ...grpc.CallOption) (*MsgCancelJobResponse, error) {
	out := new(MsgCancelJobResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/CancelJob", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReportJobStatus(ctx context.Context, in *MsgReportJobStatus, opts ...grpc.CallOption) (*MsgReportJobStatusResponse, error) {
	out := new(MsgReportJobStatusResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/ReportJobStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateNodeMetadata(ctx context.Context, in *MsgUpdateNodeMetadata, opts ...grpc.CallOption) (*MsgUpdateNodeMetadataResponse, error) {
	out := new(MsgUpdateNodeMetadataResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/UpdateNodeMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) FlagDispute(ctx context.Context, in *MsgFlagDispute, opts ...grpc.CallOption) (*MsgFlagDisputeResponse, error) {
	out := new(MsgFlagDisputeResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/FlagDispute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ResolveDispute(ctx context.Context, in *MsgResolveDispute, opts ...grpc.CallOption) (*MsgResolveDisputeResponse, error) {
	out := new(MsgResolveDisputeResponse)
	err := c.cc.Invoke(ctx, "/virtengine.hpc.v1.Msg/ResolveDispute", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterCluster registers a new HPC cluster
	RegisterCluster(context.Context, *MsgRegisterCluster) (*MsgRegisterClusterResponse, error)
	// UpdateCluster updates cluster information
	UpdateCluster(context.Context, *MsgUpdateCluster) (*MsgUpdateClusterResponse, error)
	// DeregisterCluster removes a cluster
	DeregisterCluster(context.Context, *MsgDeregisterCluster) (*MsgDeregisterClusterResponse, error)
	// CreateOffering creates a new HPC offering
	CreateOffering(context.Context, *MsgCreateOffering) (*MsgCreateOfferingResponse, error)
	// UpdateOffering updates an offering
	UpdateOffering(context.Context, *MsgUpdateOffering) (*MsgUpdateOfferingResponse, error)
	// SubmitJob submits a new HPC job
	SubmitJob(context.Context, *MsgSubmitJob) (*MsgSubmitJobResponse, error)
	// CancelJob cancels a job
	CancelJob(context.Context, *MsgCancelJob) (*MsgCancelJobResponse, error)
	// ReportJobStatus reports job status
	ReportJobStatus(context.Context, *MsgReportJobStatus) (*MsgReportJobStatusResponse, error)
	// UpdateNodeMetadata updates node metadata
	UpdateNodeMetadata(context.Context, *MsgUpdateNodeMetadata) (*MsgUpdateNodeMetadataResponse, error)
	// FlagDispute flags a dispute for a job
	FlagDispute(context.Context, *MsgFlagDispute) (*MsgFlagDisputeResponse, error)
	// ResolveDispute resolves a flagged dispute
	ResolveDispute(context.Context, *MsgResolveDispute) (*MsgResolveDisputeResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterCluster(ctx context.Context, req *MsgRegisterCluster) (*MsgRegisterClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterCluster not implemented")
}
func (*UnimplementedMsgServer) UpdateCluster(ctx context.Context, req *MsgUpdateCluster) (*MsgUpdateClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCluster not implemented")
}
func (*UnimplementedMsgServer) DeregisterCluster(ctx context.Context, req *MsgDeregisterCluster) (*MsgDeregisterClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterCluster not implemented")
}
func (*UnimplementedMsgServer) CreateOffering(ctx context.Context, req *MsgCreateOffering) (*MsgCreateOfferingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateOffering not implemented")
}
func (*UnimplementedMsgServer) UpdateOffering(ctx context.Context, req *MsgUpdateOffering) (*MsgUpdateOfferingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateOffering not implemented")
}
func (*UnimplementedMsgServer) SubmitJob(ctx context.Context, req *MsgSubmitJob) (*MsgSubmitJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SubmitJob not implemented")
}
func (*UnimplementedMsgServer) CancelJob(ctx context.Context, req *MsgCancelJob) (*MsgCancelJobResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelJob not implemented")
}
func (*UnimplementedMsgServer) ReportJobStatus(ctx context.Context, req *MsgReportJobStatus) (*MsgReportJobStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportJobStatus not implemented")
}
func (*UnimplementedMsgServer) UpdateNodeMetadata(ctx context.Context, req *MsgUpdateNodeMetadata) (*MsgUpdateNodeMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNodeMetadata not implemented")
}
func (*UnimplementedMsgServer) FlagDispute(ctx context.Context, req *MsgFlagDispute) (*MsgFlagDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FlagDispute not implemented")
}
func (*UnimplementedMsgServer) ResolveDispute(ctx context.Context, req *MsgResolveDispute) (*MsgResolveDisputeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveDispute not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/RegisterCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterCluster(ctx, req.(*MsgRegisterCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/UpdateCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateCluster(ctx, req.(*MsgUpdateCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DeregisterCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDeregisterCluster)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DeregisterCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/DeregisterCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DeregisterCluster(ctx, req.(*MsgDeregisterCluster))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CreateOffering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateOffering)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateOffering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/CreateOffering",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateOffering(ctx, req.(*MsgCreateOffering))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateOffering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateOffering)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateOffering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/UpdateOffering",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateOffering(ctx, req.(*MsgUpdateOffering))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SubmitJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSubmitJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SubmitJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/SubmitJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SubmitJob(ctx, req.(*MsgSubmitJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_CancelJob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCancelJob)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CancelJob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/CancelJob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CancelJob(ctx, req.(*MsgCancelJob))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReportJobStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReportJobStatus)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReportJobStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/ReportJobStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReportJobStatus(ctx, req.(*MsgReportJobStatus))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateNodeMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateNodeMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateNodeMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/UpdateNodeMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateNodeMetadata(ctx, req.(*MsgUpdateNodeMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_FlagDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgFlagDispute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).FlagDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/FlagDispute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).FlagDispute(ctx, req.(*MsgFlagDispute))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ResolveDispute_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgResolveDispute)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ResolveDispute(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.hpc.v1.Msg/ResolveDispute",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ResolveDispute(ctx, req.(*MsgResolveDispute))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.hpc.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterCluster",
			Handler:    _Msg_RegisterCluster_Handler,
		},
		{
			MethodName: "UpdateCluster",
			Handler:    _Msg_UpdateCluster_Handler,
		},
		{
			MethodName: "DeregisterCluster",
			Handler:    _Msg_DeregisterCluster_Handler,
		},
		{
			MethodName: "CreateOffering",
			Handler:    _Msg_CreateOffering_Handler,
		},
		{
			MethodName: "UpdateOffering",
			Handler:    _Msg_UpdateOffering_Handler,
		},
		{
			MethodName: "SubmitJob",
			Handler:    _Msg_SubmitJob_Handler,
		},
		{
			MethodName: "CancelJob",
			Handler:    _Msg_CancelJob_Handler,
		},
		{
			MethodName: "ReportJobStatus",
			Handler:    _Msg_ReportJobStatus_Handler,
		},
		{
			MethodName: "UpdateNodeMetadata",
			Handler:    _Msg_UpdateNodeMetadata_Handler,
		},
		{
			MethodName: "FlagDispute",
			Handler:    _Msg_FlagDispute_Handler,
		},
		{
			MethodName: "ResolveDispute",
			Handler:    _Msg_ResolveDispute_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/hpc/v1/tx.proto",
}

func (m *MsgRegisterCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalGpus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalGpus))
		i--
		dAtA[i] = 0x38
	}
	if m.TotalNodes != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalNodes))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterType) > 0 {
		i -= len(m.ClusterType)
		copy(dAtA[i:], m.ClusterType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.TotalGpus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalGpus))
		i--
		dAtA[i] = 0x28
	}
	if m.TotalNodes != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalNodes))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgDeregisterCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeregisterCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeregisterCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeregisterClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeregisterClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeregisterClusterResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgCreateOffering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOffering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOffering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x38
	}
	if m.MinDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinDuration))
		i--
		dAtA[i] = 0x30
	}
	if len(m.PricePerHour) > 0 {
		i -= len(m.PricePerHour)
		copy(dAtA[i:], m.PricePerHour)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PricePerHour)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateOfferingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateOfferingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateOfferingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOffering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOffering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOffering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PricePerHour) > 0 {
		i -= len(m.PricePerHour)
		copy(dAtA[i:], m.PricePerHour)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PricePerHour)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateOfferingResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateOfferingResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateOfferingResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgSubmitJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MaxBudget) > 0 {
		i -= len(m.MaxBudget)
		copy(dAtA[i:], m.MaxBudget)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MaxBudget)))
		i--
		dAtA[i] = 0x3a
	}
	if m.MaxDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x30
	}
	if m.RequestedGpus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestedGpus))
		i--
		dAtA[i] = 0x28
	}
	if m.RequestedNodes != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RequestedNodes))
		i--
		dAtA[i] = 0x20
	}
	if len(m.JobScript) > 0 {
		i -= len(m.JobScript)
		copy(dAtA[i:], m.JobScript)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobScript)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCancelJobResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCancelJobResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCancelJobResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgReportJobStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportJobStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportJobStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OutputLocation) > 0 {
		i -= len(m.OutputLocation)
		copy(dAtA[i:], m.OutputLocation)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OutputLocation)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ProgressPercent != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ProgressPercent))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reporter) > 0 {
		i -= len(m.Reporter)
		copy(dAtA[i:], m.Reporter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reporter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportJobStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportJobStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportJobStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNodeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNodeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNodeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MemoryGb != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MemoryGb))
		i--
		dAtA[i] = 0x38
	}
	if len(m.CpuModel) > 0 {
		i -= len(m.CpuModel)
		copy(dAtA[i:], m.CpuModel)
		i = encodeVarintTx(dAtA, i, uint64(len(m.CpuModel)))
		i--
		dAtA[i] = 0x32
	}
	if m.GpuMemoryGb != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.GpuMemoryGb))
		i--
		dAtA[i] = 0x28
	}
	if len(m.GpuModel) > 0 {
		i -= len(m.GpuModel)
		copy(dAtA[i:], m.GpuModel)
		i = encodeVarintTx(dAtA, i, uint64(len(m.GpuModel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateNodeMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateNodeMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateNodeMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgFlagDispute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFlagDispute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFlagDispute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Evidence) > 0 {
		i -= len(m.Evidence)
		copy(dAtA[i:], m.Evidence)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Evidence)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgFlagDisputeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgFlagDisputeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgFlagDisputeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DisputeId) > 0 {
		i -= len(m.DisputeId)
		copy(dAtA[i:], m.DisputeId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DisputeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveDispute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveDispute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveDispute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefundAmount) > 0 {
		i -= len(m.RefundAmount)
		copy(dAtA[i:], m.RefundAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RefundAmount)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Resolution) > 0 {
		i -= len(m.Resolution)
		copy(dAtA[i:], m.Resolution)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Resolution)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DisputeId) > 0 {
		i -= len(m.DisputeId)
		copy(dAtA[i:], m.DisputeId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.DisputeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveDisputeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveDisputeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveDisputeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GenesisState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenesisState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenesisState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JobSequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.JobSequence))
		i--
		dAtA[i] = 0x38
	}
	if m.OfferingSequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OfferingSequence))
		i--
		dAtA[i] = 0x30
	}
	if m.ClusterSequence != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ClusterSequence))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Offerings) > 0 {
		for iNdEx := len(m.Offerings) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Offerings[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Clusters) > 0 {
		for iNdEx := len(m.Clusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisputeResolutionPeriod != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DisputeResolutionPeriod))
		i--
		dAtA[i] = 0x20
	}
	if len(m.PlatformFeeRate) > 0 {
		i -= len(m.PlatformFeeRate)
		copy(dAtA[i:], m.PlatformFeeRate)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PlatformFeeRate)))
		i--
		dAtA[i] = 0x1a
	}
	if m.MaxJobDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxJobDuration))
		i--
		dAtA[i] = 0x10
	}
	if len(m.MinDeposit) > 0 {
		i -= len(m.MinDeposit)
		copy(dAtA[i:], m.MinDeposit)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MinDeposit)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegisteredAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RegisteredAt))
		i--
		dAtA[i] = 0x50
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.TotalGpus != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalGpus))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalNodes != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TotalNodes))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClusterType) > 0 {
		i -= len(m.ClusterType)
		copy(dAtA[i:], m.ClusterType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Owner) > 0 {
		i -= len(m.Owner)
		copy(dAtA[i:], m.Owner)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Owner)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Offering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Offering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.MaxDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MaxDuration))
		i--
		dAtA[i] = 0x40
	}
	if m.MinDuration != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinDuration))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PricePerHour) > 0 {
		i -= len(m.PricePerHour)
		copy(dAtA[i:], m.PricePerHour)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PricePerHour)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Job) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CompletedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CompletedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.StartedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.StartedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.SubmittedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TotalNodes != 0 {
		n += 1 + sovTx(uint64(m.TotalNodes))
	}
	if m.TotalGpus != 0 {
		n += 1 + sovTx(uint64(m.TotalGpus))
	}
	return n
}

func (m *MsgRegisterClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TotalNodes != 0 {
		n += 1 + sovTx(uint64(m.TotalNodes))
	}
	if m.TotalGpus != 0 {
		n += 1 + sovTx(uint64(m.TotalGpus))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *MsgUpdateClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgDeregisterCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDeregisterClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgCreateOffering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PricePerHour)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinDuration != 0 {
		n += 1 + sovTx(uint64(m.MinDuration))
	}
	if m.MaxDuration != 0 {
		n += 1 + sovTx(uint64(m.MaxDuration))
	}
	return n
}

func (m *MsgCreateOfferingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgUpdateOffering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PricePerHour)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *MsgUpdateOfferingResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgSubmitJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.JobScript)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RequestedNodes != 0 {
		n += 1 + sovTx(uint64(m.RequestedNodes))
	}
	if m.RequestedGpus != 0 {
		n += 1 + sovTx(uint64(m.RequestedGpus))
	}
	if m.MaxDuration != 0 {
		n += 1 + sovTx(uint64(m.MaxDuration))
	}
	l = len(m.MaxBudget)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgSubmitJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgCancelJobResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgReportJobStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reporter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ProgressPercent != 0 {
		n += 1 + sovTx(uint64(m.ProgressPercent))
	}
	l = len(m.OutputLocation)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReportJobStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateNodeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.GpuModel)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.GpuMemoryGb != 0 {
		n += 1 + sovTx(uint64(m.GpuMemoryGb))
	}
	l = len(m.CpuModel)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MemoryGb != 0 {
		n += 1 + sovTx(uint64(m.MemoryGb))
	}
	return n
}

func (m *MsgUpdateNodeMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgFlagDispute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Evidence)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgFlagDisputeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisputeId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgResolveDispute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.DisputeId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.RefundAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgResolveDisputeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GenesisState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	if len(m.Clusters) > 0 {
		for _, e := range m.Clusters {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Offerings) > 0 {
		for _, e := range m.Offerings {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.ClusterSequence != 0 {
		n += 1 + sovTx(uint64(m.ClusterSequence))
	}
	if m.OfferingSequence != 0 {
		n += 1 + sovTx(uint64(m.OfferingSequence))
	}
	if m.JobSequence != 0 {
		n += 1 + sovTx(uint64(m.JobSequence))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MinDeposit)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MaxJobDuration != 0 {
		n += 1 + sovTx(uint64(m.MaxJobDuration))
	}
	l = len(m.PlatformFeeRate)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.DisputeResolutionPeriod != 0 {
		n += 1 + sovTx(uint64(m.DisputeResolutionPeriod))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Owner)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TotalNodes != 0 {
		n += 1 + sovTx(uint64(m.TotalNodes))
	}
	if m.TotalGpus != 0 {
		n += 1 + sovTx(uint64(m.TotalGpus))
	}
	if m.Active {
		n += 2
	}
	if m.RegisteredAt != 0 {
		n += 1 + sovTx(uint64(m.RegisteredAt))
	}
	return n
}

func (m *Offering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PricePerHour)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinDuration != 0 {
		n += 1 + sovTx(uint64(m.MinDuration))
	}
	if m.MaxDuration != 0 {
		n += 1 + sovTx(uint64(m.MaxDuration))
	}
	if m.Active {
		n += 2
	}
	return n
}

func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SubmittedAt != 0 {
		n += 1 + sovTx(uint64(m.SubmittedAt))
	}
	if m.StartedAt != 0 {
		n += 1 + sovTx(uint64(m.StartedAt))
	}
	if m.CompletedAt != 0 {
		n += 1 + sovTx(uint64(m.CompletedAt))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			m.TotalNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGpus", wireType)
			}
			m.TotalGpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			m.TotalNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGpus", wireType)
			}
			m.TotalGpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeregisterCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeregisterCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeregisterCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeregisterClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeregisterClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeregisterClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOffering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOffering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOffering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerHour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricePerHour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDuration", wireType)
			}
			m.MinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateOfferingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateOfferingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateOfferingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOffering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOffering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOffering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerHour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricePerHour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateOfferingResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateOfferingResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateOfferingResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobScript", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobScript = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedNodes", wireType)
			}
			m.RequestedNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedGpus", wireType)
			}
			m.RequestedGpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedGpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBudget", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MaxBudget = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCancelJobResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCancelJobResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCancelJobResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportJobStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportJobStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportJobStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reporter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reporter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProgressPercent", wireType)
			}
			m.ProgressPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProgressPercent |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputLocation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputLocation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportJobStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportJobStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportJobStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNodeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNodeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNodeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuMemoryGb", wireType)
			}
			m.GpuMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuMemoryGb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			m.MemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGb |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateNodeMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateNodeMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateNodeMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFlagDispute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFlagDispute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFlagDispute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgFlagDisputeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgFlagDisputeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgFlagDisputeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveDispute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveDispute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveDispute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefundAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveDisputeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveDisputeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveDisputeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenesisState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenesisState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenesisState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clusters = append(m.Clusters, Cluster{})
			if err := m.Clusters[len(m.Clusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offerings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Offerings = append(m.Offerings, Offering{})
			if err := m.Offerings[len(m.Offerings)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, Job{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterSequence", wireType)
			}
			m.ClusterSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingSequence", wireType)
			}
			m.OfferingSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OfferingSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSequence", wireType)
			}
			m.JobSequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobSequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDeposit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinDeposit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxJobDuration", wireType)
			}
			m.MaxJobDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxJobDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeResolutionPeriod", wireType)
			}
			m.DisputeResolutionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputeResolutionPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Owner", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Owner = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			m.TotalNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGpus", wireType)
			}
			m.TotalGpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGpus |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			m.RegisteredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Offering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Offering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PricePerHour", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PricePerHour = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinDuration", wireType)
			}
			m.MinDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDuration", wireType)
			}
			m.MaxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			m.StartedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			m.CompletedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
