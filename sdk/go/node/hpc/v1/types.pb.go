// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/hpc/v1/types.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ClusterState represents the state of an HPC cluster
type ClusterState int32

const (
	// CLUSTER_STATE_UNSPECIFIED represents an unspecified cluster state
	ClusterStateUnspecified ClusterState = 0
	// CLUSTER_STATE_PENDING indicates the cluster is pending registration
	ClusterStatePending ClusterState = 1
	// CLUSTER_STATE_ACTIVE indicates the cluster is active and accepting jobs
	ClusterStateActive ClusterState = 2
	// CLUSTER_STATE_DRAINING indicates the cluster is draining (not accepting new jobs)
	ClusterStateDraining ClusterState = 3
	// CLUSTER_STATE_OFFLINE indicates the cluster is offline
	ClusterStateOffline ClusterState = 4
	// CLUSTER_STATE_DEREGISTERED indicates the cluster has been deregistered
	ClusterStateDeregistered ClusterState = 5
)

var ClusterState_name = map[int32]string{
	0: "CLUSTER_STATE_UNSPECIFIED",
	1: "CLUSTER_STATE_PENDING",
	2: "CLUSTER_STATE_ACTIVE",
	3: "CLUSTER_STATE_DRAINING",
	4: "CLUSTER_STATE_OFFLINE",
	5: "CLUSTER_STATE_DEREGISTERED",
}

var ClusterState_value = map[string]int32{
	"CLUSTER_STATE_UNSPECIFIED":  0,
	"CLUSTER_STATE_PENDING":      1,
	"CLUSTER_STATE_ACTIVE":       2,
	"CLUSTER_STATE_DRAINING":     3,
	"CLUSTER_STATE_OFFLINE":      4,
	"CLUSTER_STATE_DEREGISTERED": 5,
}

func (x ClusterState) String() string {
	return proto.EnumName(ClusterState_name, int32(x))
}

func (ClusterState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{0}
}

// JobState represents the state of an HPC job
type JobState int32

const (
	// JOB_STATE_UNSPECIFIED represents an unspecified job state
	JobStateUnspecified JobState = 0
	// JOB_STATE_PENDING indicates the job is pending
	JobStatePending JobState = 1
	// JOB_STATE_QUEUED indicates the job is queued in SLURM
	JobStateQueued JobState = 2
	// JOB_STATE_RUNNING indicates the job is running
	JobStateRunning JobState = 3
	// JOB_STATE_COMPLETED indicates the job completed successfully
	JobStateCompleted JobState = 4
	// JOB_STATE_FAILED indicates the job failed
	JobStateFailed JobState = 5
	// JOB_STATE_CANCELLED indicates the job was cancelled
	JobStateCancelled JobState = 6
	// JOB_STATE_TIMEOUT indicates the job timed out
	JobStateTimeout JobState = 7
)

var JobState_name = map[int32]string{
	0: "JOB_STATE_UNSPECIFIED",
	1: "JOB_STATE_PENDING",
	2: "JOB_STATE_QUEUED",
	3: "JOB_STATE_RUNNING",
	4: "JOB_STATE_COMPLETED",
	5: "JOB_STATE_FAILED",
	6: "JOB_STATE_CANCELLED",
	7: "JOB_STATE_TIMEOUT",
}

var JobState_value = map[string]int32{
	"JOB_STATE_UNSPECIFIED": 0,
	"JOB_STATE_PENDING":     1,
	"JOB_STATE_QUEUED":      2,
	"JOB_STATE_RUNNING":     3,
	"JOB_STATE_COMPLETED":   4,
	"JOB_STATE_FAILED":      5,
	"JOB_STATE_CANCELLED":   6,
	"JOB_STATE_TIMEOUT":     7,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{1}
}

// NodeState represents the state of a compute node
type NodeState int32

const (
	// NODE_STATE_UNSPECIFIED represents an unspecified node state
	NodeStateUnspecified NodeState = 0
	// NODE_STATE_UNKNOWN indicates unknown node state
	NodeStateUnknown NodeState = 1
	// NODE_STATE_PENDING indicates the node is pending registration
	NodeStatePending NodeState = 2
	// NODE_STATE_ACTIVE indicates the node is active
	NodeStateActive NodeState = 3
	// NODE_STATE_STALE indicates the node has missed heartbeats
	NodeStateStale NodeState = 4
	// NODE_STATE_DRAINING indicates the node is draining
	NodeStateDraining NodeState = 5
	// NODE_STATE_DRAINED indicates the node is drained
	NodeStateDrained NodeState = 6
	// NODE_STATE_OFFLINE indicates the node is offline
	NodeStateOffline NodeState = 7
	// NODE_STATE_DEREGISTERED indicates the node is deregistered
	NodeStateDeregistered NodeState = 8
)

var NodeState_name = map[int32]string{
	0: "NODE_STATE_UNSPECIFIED",
	1: "NODE_STATE_UNKNOWN",
	2: "NODE_STATE_PENDING",
	3: "NODE_STATE_ACTIVE",
	4: "NODE_STATE_STALE",
	5: "NODE_STATE_DRAINING",
	6: "NODE_STATE_DRAINED",
	7: "NODE_STATE_OFFLINE",
	8: "NODE_STATE_DEREGISTERED",
}

var NodeState_value = map[string]int32{
	"NODE_STATE_UNSPECIFIED":  0,
	"NODE_STATE_UNKNOWN":      1,
	"NODE_STATE_PENDING":      2,
	"NODE_STATE_ACTIVE":       3,
	"NODE_STATE_STALE":        4,
	"NODE_STATE_DRAINING":     5,
	"NODE_STATE_DRAINED":      6,
	"NODE_STATE_OFFLINE":      7,
	"NODE_STATE_DEREGISTERED": 8,
}

func (x NodeState) String() string {
	return proto.EnumName(NodeState_name, int32(x))
}

func (NodeState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{2}
}

// HealthStatus represents the health status of a node
type HealthStatus int32

const (
	// HEALTH_STATUS_UNSPECIFIED represents an unspecified health status
	HealthStatusUnspecified HealthStatus = 0
	// HEALTH_STATUS_HEALTHY indicates healthy
	HealthStatusHealthy HealthStatus = 1
	// HEALTH_STATUS_DEGRADED indicates degraded
	HealthStatusDegraded HealthStatus = 2
	// HEALTH_STATUS_UNHEALTHY indicates unhealthy
	HealthStatusUnhealthy HealthStatus = 3
	// HEALTH_STATUS_DRAINING indicates draining
	HealthStatusDraining HealthStatus = 4
	// HEALTH_STATUS_OFFLINE indicates offline
	HealthStatusOffline HealthStatus = 5
)

var HealthStatus_name = map[int32]string{
	0: "HEALTH_STATUS_UNSPECIFIED",
	1: "HEALTH_STATUS_HEALTHY",
	2: "HEALTH_STATUS_DEGRADED",
	3: "HEALTH_STATUS_UNHEALTHY",
	4: "HEALTH_STATUS_DRAINING",
	5: "HEALTH_STATUS_OFFLINE",
}

var HealthStatus_value = map[string]int32{
	"HEALTH_STATUS_UNSPECIFIED": 0,
	"HEALTH_STATUS_HEALTHY":     1,
	"HEALTH_STATUS_DEGRADED":    2,
	"HEALTH_STATUS_UNHEALTHY":   3,
	"HEALTH_STATUS_DRAINING":    4,
	"HEALTH_STATUS_OFFLINE":     5,
}

func (x HealthStatus) String() string {
	return proto.EnumName(HealthStatus_name, int32(x))
}

func (HealthStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{3}
}

// HPCRewardSource indicates the source of HPC rewards
type HPCRewardSource int32

const (
	// HPC_REWARD_SOURCE_UNSPECIFIED represents an unspecified reward source
	HPCRewardSourceUnspecified HPCRewardSource = 0
	// HPC_REWARD_SOURCE_JOB_COMPLETION is for completed job rewards
	HPCRewardSourceJobCompletion HPCRewardSource = 1
	// HPC_REWARD_SOURCE_USAGE is for usage-based rewards
	HPCRewardSourceUsage HPCRewardSource = 2
	// HPC_REWARD_SOURCE_BONUS is for bonus rewards
	HPCRewardSourceBonus HPCRewardSource = 3
)

var HPCRewardSource_name = map[int32]string{
	0: "HPC_REWARD_SOURCE_UNSPECIFIED",
	1: "HPC_REWARD_SOURCE_JOB_COMPLETION",
	2: "HPC_REWARD_SOURCE_USAGE",
	3: "HPC_REWARD_SOURCE_BONUS",
}

var HPCRewardSource_value = map[string]int32{
	"HPC_REWARD_SOURCE_UNSPECIFIED":    0,
	"HPC_REWARD_SOURCE_JOB_COMPLETION": 1,
	"HPC_REWARD_SOURCE_USAGE":          2,
	"HPC_REWARD_SOURCE_BONUS":          3,
}

func (x HPCRewardSource) String() string {
	return proto.EnumName(HPCRewardSource_name, int32(x))
}

func (HPCRewardSource) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{4}
}

// DisputeStatus indicates the status of a dispute
type DisputeStatus int32

const (
	// DISPUTE_STATUS_UNSPECIFIED represents an unspecified dispute status
	DisputeStatusUnspecified DisputeStatus = 0
	// DISPUTE_STATUS_PENDING indicates the dispute is pending
	DisputeStatusPending DisputeStatus = 1
	// DISPUTE_STATUS_UNDER_REVIEW indicates the dispute is under review
	DisputeStatusUnderReview DisputeStatus = 2
	// DISPUTE_STATUS_RESOLVED indicates the dispute is resolved
	DisputeStatusResolved DisputeStatus = 3
	// DISPUTE_STATUS_REJECTED indicates the dispute was rejected
	DisputeStatusRejected DisputeStatus = 4
)

var DisputeStatus_name = map[int32]string{
	0: "DISPUTE_STATUS_UNSPECIFIED",
	1: "DISPUTE_STATUS_PENDING",
	2: "DISPUTE_STATUS_UNDER_REVIEW",
	3: "DISPUTE_STATUS_RESOLVED",
	4: "DISPUTE_STATUS_REJECTED",
}

var DisputeStatus_value = map[string]int32{
	"DISPUTE_STATUS_UNSPECIFIED":  0,
	"DISPUTE_STATUS_PENDING":      1,
	"DISPUTE_STATUS_UNDER_REVIEW": 2,
	"DISPUTE_STATUS_RESOLVED":     3,
	"DISPUTE_STATUS_REJECTED":     4,
}

func (x DisputeStatus) String() string {
	return proto.EnumName(DisputeStatus_name, int32(x))
}

func (DisputeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{5}
}

// Partition represents a SLURM partition/queue
type Partition struct {
	Name           string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name" yaml:"name"`
	Nodes          int32    `protobuf:"varint,2,opt,name=nodes,proto3" json:"nodes" yaml:"nodes"`
	MaxRuntime     int64    `protobuf:"varint,3,opt,name=max_runtime,json=maxRuntime,proto3" json:"max_runtime" yaml:"max_runtime"`
	DefaultRuntime int64    `protobuf:"varint,4,opt,name=default_runtime,json=defaultRuntime,proto3" json:"default_runtime" yaml:"default_runtime"`
	MaxNodes       int32    `protobuf:"varint,5,opt,name=max_nodes,json=maxNodes,proto3" json:"max_nodes" yaml:"max_nodes"`
	Features       []string `protobuf:"bytes,6,rep,name=features,proto3" json:"features,omitempty" yaml:"features"`
	Priority       int32    `protobuf:"varint,7,opt,name=priority,proto3" json:"priority" yaml:"priority"`
	State          string   `protobuf:"bytes,8,opt,name=state,proto3" json:"state" yaml:"state"`
}

func (m *Partition) Reset()         { *m = Partition{} }
func (m *Partition) String() string { return proto.CompactTextString(m) }
func (*Partition) ProtoMessage()    {}
func (*Partition) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{0}
}
func (m *Partition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Partition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Partition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Partition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Partition.Merge(m, src)
}
func (m *Partition) XXX_Size() int {
	return m.Size()
}
func (m *Partition) XXX_DiscardUnknown() {
	xxx_messageInfo_Partition.DiscardUnknown(m)
}

var xxx_messageInfo_Partition proto.InternalMessageInfo

func (m *Partition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Partition) GetNodes() int32 {
	if m != nil {
		return m.Nodes
	}
	return 0
}

func (m *Partition) GetMaxRuntime() int64 {
	if m != nil {
		return m.MaxRuntime
	}
	return 0
}

func (m *Partition) GetDefaultRuntime() int64 {
	if m != nil {
		return m.DefaultRuntime
	}
	return 0
}

func (m *Partition) GetMaxNodes() int32 {
	if m != nil {
		return m.MaxNodes
	}
	return 0
}

func (m *Partition) GetFeatures() []string {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *Partition) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Partition) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// ClusterMetadata contains additional cluster metadata
type ClusterMetadata struct {
	TotalCpuCores    int64    `protobuf:"varint,1,opt,name=total_cpu_cores,json=totalCpuCores,proto3" json:"total_cpu_cores" yaml:"total_cpu_cores"`
	TotalMemoryGb    int64    `protobuf:"varint,2,opt,name=total_memory_gb,json=totalMemoryGb,proto3" json:"total_memory_gb" yaml:"total_memory_gb"`
	TotalGpus        int64    `protobuf:"varint,3,opt,name=total_gpus,json=totalGpus,proto3" json:"total_gpus,omitempty" yaml:"total_gpus"`
	GpuTypes         []string `protobuf:"bytes,4,rep,name=gpu_types,json=gpuTypes,proto3" json:"gpu_types,omitempty" yaml:"gpu_types"`
	InterconnectType string   `protobuf:"bytes,5,opt,name=interconnect_type,json=interconnectType,proto3" json:"interconnect_type" yaml:"interconnect_type"`
	StorageType      string   `protobuf:"bytes,6,opt,name=storage_type,json=storageType,proto3" json:"storage_type" yaml:"storage_type"`
	TotalStorageGb   int64    `protobuf:"varint,7,opt,name=total_storage_gb,json=totalStorageGb,proto3" json:"total_storage_gb" yaml:"total_storage_gb"`
}

func (m *ClusterMetadata) Reset()         { *m = ClusterMetadata{} }
func (m *ClusterMetadata) String() string { return proto.CompactTextString(m) }
func (*ClusterMetadata) ProtoMessage()    {}
func (*ClusterMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{1}
}
func (m *ClusterMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterMetadata.Merge(m, src)
}
func (m *ClusterMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ClusterMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterMetadata proto.InternalMessageInfo

func (m *ClusterMetadata) GetTotalCpuCores() int64 {
	if m != nil {
		return m.TotalCpuCores
	}
	return 0
}

func (m *ClusterMetadata) GetTotalMemoryGb() int64 {
	if m != nil {
		return m.TotalMemoryGb
	}
	return 0
}

func (m *ClusterMetadata) GetTotalGpus() int64 {
	if m != nil {
		return m.TotalGpus
	}
	return 0
}

func (m *ClusterMetadata) GetGpuTypes() []string {
	if m != nil {
		return m.GpuTypes
	}
	return nil
}

func (m *ClusterMetadata) GetInterconnectType() string {
	if m != nil {
		return m.InterconnectType
	}
	return ""
}

func (m *ClusterMetadata) GetStorageType() string {
	if m != nil {
		return m.StorageType
	}
	return ""
}

func (m *ClusterMetadata) GetTotalStorageGb() int64 {
	if m != nil {
		return m.TotalStorageGb
	}
	return 0
}

// HPCCluster represents a SLURM cluster registered on-chain
type HPCCluster struct {
	ClusterId           string          `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	ProviderAddress     string          `protobuf:"bytes,2,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Name                string          `protobuf:"bytes,3,opt,name=name,proto3" json:"name" yaml:"name"`
	Description         string          `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	State               ClusterState    `protobuf:"varint,5,opt,name=state,proto3,enum=virtengine.hpc.v1.ClusterState" json:"state" yaml:"state"`
	Partitions          []Partition     `protobuf:"bytes,6,rep,name=partitions,proto3" json:"partitions" yaml:"partitions"`
	TotalNodes          int32           `protobuf:"varint,7,opt,name=total_nodes,json=totalNodes,proto3" json:"total_nodes" yaml:"total_nodes"`
	AvailableNodes      int32           `protobuf:"varint,8,opt,name=available_nodes,json=availableNodes,proto3" json:"available_nodes" yaml:"available_nodes"`
	Region              string          `protobuf:"bytes,9,opt,name=region,proto3" json:"region" yaml:"region"`
	ClusterMetadata     ClusterMetadata `protobuf:"bytes,10,opt,name=cluster_metadata,json=clusterMetadata,proto3" json:"cluster_metadata" yaml:"cluster_metadata"`
	SlurmVersion        string          `protobuf:"bytes,11,opt,name=slurm_version,json=slurmVersion,proto3" json:"slurm_version" yaml:"slurm_version"`
	KubernetesClusterId string          `protobuf:"bytes,12,opt,name=kubernetes_cluster_id,json=kubernetesClusterId,proto3" json:"kubernetes_cluster_id,omitempty" yaml:"kubernetes_cluster_id"`
	CreatedAt           time.Time       `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	UpdatedAt           time.Time       `protobuf:"bytes,14,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	BlockHeight         int64           `protobuf:"varint,15,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *HPCCluster) Reset()         { *m = HPCCluster{} }
func (m *HPCCluster) String() string { return proto.CompactTextString(m) }
func (*HPCCluster) ProtoMessage()    {}
func (*HPCCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{2}
}
func (m *HPCCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCCluster.Merge(m, src)
}
func (m *HPCCluster) XXX_Size() int {
	return m.Size()
}
func (m *HPCCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCCluster.DiscardUnknown(m)
}

var xxx_messageInfo_HPCCluster proto.InternalMessageInfo

func (m *HPCCluster) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *HPCCluster) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *HPCCluster) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HPCCluster) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *HPCCluster) GetState() ClusterState {
	if m != nil {
		return m.State
	}
	return ClusterStateUnspecified
}

func (m *HPCCluster) GetPartitions() []Partition {
	if m != nil {
		return m.Partitions
	}
	return nil
}

func (m *HPCCluster) GetTotalNodes() int32 {
	if m != nil {
		return m.TotalNodes
	}
	return 0
}

func (m *HPCCluster) GetAvailableNodes() int32 {
	if m != nil {
		return m.AvailableNodes
	}
	return 0
}

func (m *HPCCluster) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *HPCCluster) GetClusterMetadata() ClusterMetadata {
	if m != nil {
		return m.ClusterMetadata
	}
	return ClusterMetadata{}
}

func (m *HPCCluster) GetSlurmVersion() string {
	if m != nil {
		return m.SlurmVersion
	}
	return ""
}

func (m *HPCCluster) GetKubernetesClusterId() string {
	if m != nil {
		return m.KubernetesClusterId
	}
	return ""
}

func (m *HPCCluster) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *HPCCluster) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *HPCCluster) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// QueueOption represents a queue/partition option in an offering
type QueueOption struct {
	PartitionName   string   `protobuf:"bytes,1,opt,name=partition_name,json=partitionName,proto3" json:"partition_name" yaml:"partition_name"`
	DisplayName     string   `protobuf:"bytes,2,opt,name=display_name,json=displayName,proto3" json:"display_name" yaml:"display_name"`
	MaxNodes        int32    `protobuf:"varint,3,opt,name=max_nodes,json=maxNodes,proto3" json:"max_nodes" yaml:"max_nodes"`
	MaxRuntime      int64    `protobuf:"varint,4,opt,name=max_runtime,json=maxRuntime,proto3" json:"max_runtime" yaml:"max_runtime"`
	Features        []string `protobuf:"bytes,5,rep,name=features,proto3" json:"features,omitempty" yaml:"features"`
	PriceMultiplier string   `protobuf:"bytes,6,opt,name=price_multiplier,json=priceMultiplier,proto3" json:"price_multiplier" yaml:"price_multiplier"`
}

func (m *QueueOption) Reset()         { *m = QueueOption{} }
func (m *QueueOption) String() string { return proto.CompactTextString(m) }
func (*QueueOption) ProtoMessage()    {}
func (*QueueOption) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{3}
}
func (m *QueueOption) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueueOption) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueueOption.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueueOption) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueueOption.Merge(m, src)
}
func (m *QueueOption) XXX_Size() int {
	return m.Size()
}
func (m *QueueOption) XXX_DiscardUnknown() {
	xxx_messageInfo_QueueOption.DiscardUnknown(m)
}

var xxx_messageInfo_QueueOption proto.InternalMessageInfo

func (m *QueueOption) GetPartitionName() string {
	if m != nil {
		return m.PartitionName
	}
	return ""
}

func (m *QueueOption) GetDisplayName() string {
	if m != nil {
		return m.DisplayName
	}
	return ""
}

func (m *QueueOption) GetMaxNodes() int32 {
	if m != nil {
		return m.MaxNodes
	}
	return 0
}

func (m *QueueOption) GetMaxRuntime() int64 {
	if m != nil {
		return m.MaxRuntime
	}
	return 0
}

func (m *QueueOption) GetFeatures() []string {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *QueueOption) GetPriceMultiplier() string {
	if m != nil {
		return m.PriceMultiplier
	}
	return ""
}

// HPCPricing contains HPC pricing information
type HPCPricing struct {
	BaseNodeHourPrice string `protobuf:"bytes,1,opt,name=base_node_hour_price,json=baseNodeHourPrice,proto3" json:"base_node_hour_price" yaml:"base_node_hour_price"`
	CpuCoreHourPrice  string `protobuf:"bytes,2,opt,name=cpu_core_hour_price,json=cpuCoreHourPrice,proto3" json:"cpu_core_hour_price" yaml:"cpu_core_hour_price"`
	GpuHourPrice      string `protobuf:"bytes,3,opt,name=gpu_hour_price,json=gpuHourPrice,proto3" json:"gpu_hour_price,omitempty" yaml:"gpu_hour_price"`
	MemoryGbHourPrice string `protobuf:"bytes,4,opt,name=memory_gb_hour_price,json=memoryGbHourPrice,proto3" json:"memory_gb_hour_price" yaml:"memory_gb_hour_price"`
	StorageGbPrice    string `protobuf:"bytes,5,opt,name=storage_gb_price,json=storageGbPrice,proto3" json:"storage_gb_price" yaml:"storage_gb_price"`
	NetworkGbPrice    string `protobuf:"bytes,6,opt,name=network_gb_price,json=networkGbPrice,proto3" json:"network_gb_price" yaml:"network_gb_price"`
	Currency          string `protobuf:"bytes,7,opt,name=currency,proto3" json:"currency" yaml:"currency"`
	MinimumCharge     string `protobuf:"bytes,8,opt,name=minimum_charge,json=minimumCharge,proto3" json:"minimum_charge" yaml:"minimum_charge"`
}

func (m *HPCPricing) Reset()         { *m = HPCPricing{} }
func (m *HPCPricing) String() string { return proto.CompactTextString(m) }
func (*HPCPricing) ProtoMessage()    {}
func (*HPCPricing) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{4}
}
func (m *HPCPricing) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCPricing) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCPricing.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCPricing) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCPricing.Merge(m, src)
}
func (m *HPCPricing) XXX_Size() int {
	return m.Size()
}
func (m *HPCPricing) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCPricing.DiscardUnknown(m)
}

var xxx_messageInfo_HPCPricing proto.InternalMessageInfo

func (m *HPCPricing) GetBaseNodeHourPrice() string {
	if m != nil {
		return m.BaseNodeHourPrice
	}
	return ""
}

func (m *HPCPricing) GetCpuCoreHourPrice() string {
	if m != nil {
		return m.CpuCoreHourPrice
	}
	return ""
}

func (m *HPCPricing) GetGpuHourPrice() string {
	if m != nil {
		return m.GpuHourPrice
	}
	return ""
}

func (m *HPCPricing) GetMemoryGbHourPrice() string {
	if m != nil {
		return m.MemoryGbHourPrice
	}
	return ""
}

func (m *HPCPricing) GetStorageGbPrice() string {
	if m != nil {
		return m.StorageGbPrice
	}
	return ""
}

func (m *HPCPricing) GetNetworkGbPrice() string {
	if m != nil {
		return m.NetworkGbPrice
	}
	return ""
}

func (m *HPCPricing) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *HPCPricing) GetMinimumCharge() string {
	if m != nil {
		return m.MinimumCharge
	}
	return ""
}

// JobResources defines resource requirements for an HPC job
type JobResources struct {
	Nodes           int32  `protobuf:"varint,1,opt,name=nodes,proto3" json:"nodes" yaml:"nodes"`
	CpuCoresPerNode int32  `protobuf:"varint,2,opt,name=cpu_cores_per_node,json=cpuCoresPerNode,proto3" json:"cpu_cores_per_node" yaml:"cpu_cores_per_node"`
	MemoryGbPerNode int32  `protobuf:"varint,3,opt,name=memory_gb_per_node,json=memoryGbPerNode,proto3" json:"memory_gb_per_node" yaml:"memory_gb_per_node"`
	GpusPerNode     int32  `protobuf:"varint,4,opt,name=gpus_per_node,json=gpusPerNode,proto3" json:"gpus_per_node,omitempty" yaml:"gpus_per_node"`
	StorageGb       int32  `protobuf:"varint,5,opt,name=storage_gb,json=storageGb,proto3" json:"storage_gb" yaml:"storage_gb"`
	GpuType         string `protobuf:"bytes,6,opt,name=gpu_type,json=gpuType,proto3" json:"gpu_type,omitempty" yaml:"gpu_type"`
}

func (m *JobResources) Reset()         { *m = JobResources{} }
func (m *JobResources) String() string { return proto.CompactTextString(m) }
func (*JobResources) ProtoMessage()    {}
func (*JobResources) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{5}
}
func (m *JobResources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobResources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobResources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobResources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobResources.Merge(m, src)
}
func (m *JobResources) XXX_Size() int {
	return m.Size()
}
func (m *JobResources) XXX_DiscardUnknown() {
	xxx_messageInfo_JobResources.DiscardUnknown(m)
}

var xxx_messageInfo_JobResources proto.InternalMessageInfo

func (m *JobResources) GetNodes() int32 {
	if m != nil {
		return m.Nodes
	}
	return 0
}

func (m *JobResources) GetCpuCoresPerNode() int32 {
	if m != nil {
		return m.CpuCoresPerNode
	}
	return 0
}

func (m *JobResources) GetMemoryGbPerNode() int32 {
	if m != nil {
		return m.MemoryGbPerNode
	}
	return 0
}

func (m *JobResources) GetGpusPerNode() int32 {
	if m != nil {
		return m.GpusPerNode
	}
	return 0
}

func (m *JobResources) GetStorageGb() int32 {
	if m != nil {
		return m.StorageGb
	}
	return 0
}

func (m *JobResources) GetGpuType() string {
	if m != nil {
		return m.GpuType
	}
	return ""
}

// PreconfiguredWorkload represents a pre-approved workload
type PreconfiguredWorkload struct {
	WorkloadId        string       `protobuf:"bytes,1,opt,name=workload_id,json=workloadId,proto3" json:"workload_id" yaml:"workload_id"`
	Name              string       `protobuf:"bytes,2,opt,name=name,proto3" json:"name" yaml:"name"`
	Description       string       `protobuf:"bytes,3,opt,name=description,proto3" json:"description" yaml:"description"`
	ContainerImage    string       `protobuf:"bytes,4,opt,name=container_image,json=containerImage,proto3" json:"container_image" yaml:"container_image"`
	DefaultCommand    string       `protobuf:"bytes,5,opt,name=default_command,json=defaultCommand,proto3" json:"default_command,omitempty" yaml:"default_command"`
	RequiredResources JobResources `protobuf:"bytes,6,opt,name=required_resources,json=requiredResources,proto3" json:"required_resources" yaml:"required_resources"`
	Category          string       `protobuf:"bytes,7,opt,name=category,proto3" json:"category" yaml:"category"`
	Version           string       `protobuf:"bytes,8,opt,name=version,proto3" json:"version" yaml:"version"`
}

func (m *PreconfiguredWorkload) Reset()         { *m = PreconfiguredWorkload{} }
func (m *PreconfiguredWorkload) String() string { return proto.CompactTextString(m) }
func (*PreconfiguredWorkload) ProtoMessage()    {}
func (*PreconfiguredWorkload) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{6}
}
func (m *PreconfiguredWorkload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreconfiguredWorkload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreconfiguredWorkload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreconfiguredWorkload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreconfiguredWorkload.Merge(m, src)
}
func (m *PreconfiguredWorkload) XXX_Size() int {
	return m.Size()
}
func (m *PreconfiguredWorkload) XXX_DiscardUnknown() {
	xxx_messageInfo_PreconfiguredWorkload.DiscardUnknown(m)
}

var xxx_messageInfo_PreconfiguredWorkload proto.InternalMessageInfo

func (m *PreconfiguredWorkload) GetWorkloadId() string {
	if m != nil {
		return m.WorkloadId
	}
	return ""
}

func (m *PreconfiguredWorkload) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PreconfiguredWorkload) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *PreconfiguredWorkload) GetContainerImage() string {
	if m != nil {
		return m.ContainerImage
	}
	return ""
}

func (m *PreconfiguredWorkload) GetDefaultCommand() string {
	if m != nil {
		return m.DefaultCommand
	}
	return ""
}

func (m *PreconfiguredWorkload) GetRequiredResources() JobResources {
	if m != nil {
		return m.RequiredResources
	}
	return JobResources{}
}

func (m *PreconfiguredWorkload) GetCategory() string {
	if m != nil {
		return m.Category
	}
	return ""
}

func (m *PreconfiguredWorkload) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

// HPCOffering represents an HPC service offering
type HPCOffering struct {
	OfferingId                string                  `protobuf:"bytes,1,opt,name=offering_id,json=offeringId,proto3" json:"offering_id" yaml:"offering_id"`
	ClusterId                 string                  `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	ProviderAddress           string                  `protobuf:"bytes,3,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Name                      string                  `protobuf:"bytes,4,opt,name=name,proto3" json:"name" yaml:"name"`
	Description               string                  `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	QueueOptions              []QueueOption           `protobuf:"bytes,6,rep,name=queue_options,json=queueOptions,proto3" json:"queue_options" yaml:"queue_options"`
	Pricing                   HPCPricing              `protobuf:"bytes,7,opt,name=pricing,proto3" json:"pricing" yaml:"pricing"`
	RequiredIdentityThreshold int32                   `protobuf:"varint,8,opt,name=required_identity_threshold,json=requiredIdentityThreshold,proto3" json:"required_identity_threshold" yaml:"required_identity_threshold"`
	MaxRuntimeSeconds         int64                   `protobuf:"varint,9,opt,name=max_runtime_seconds,json=maxRuntimeSeconds,proto3" json:"max_runtime_seconds" yaml:"max_runtime_seconds"`
	PreconfiguredWorkloads    []PreconfiguredWorkload `protobuf:"bytes,10,rep,name=preconfigured_workloads,json=preconfiguredWorkloads,proto3" json:"preconfigured_workloads,omitempty" yaml:"preconfigured_workloads"`
	SupportsCustomWorkloads   bool                    `protobuf:"varint,11,opt,name=supports_custom_workloads,json=supportsCustomWorkloads,proto3" json:"supports_custom_workloads" yaml:"supports_custom_workloads"`
	Active                    bool                    `protobuf:"varint,12,opt,name=active,proto3" json:"active" yaml:"active"`
	CreatedAt                 time.Time               `protobuf:"bytes,13,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	UpdatedAt                 time.Time               `protobuf:"bytes,14,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	BlockHeight               int64                   `protobuf:"varint,15,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *HPCOffering) Reset()         { *m = HPCOffering{} }
func (m *HPCOffering) String() string { return proto.CompactTextString(m) }
func (*HPCOffering) ProtoMessage()    {}
func (*HPCOffering) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{7}
}
func (m *HPCOffering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCOffering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCOffering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCOffering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCOffering.Merge(m, src)
}
func (m *HPCOffering) XXX_Size() int {
	return m.Size()
}
func (m *HPCOffering) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCOffering.DiscardUnknown(m)
}

var xxx_messageInfo_HPCOffering proto.InternalMessageInfo

func (m *HPCOffering) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *HPCOffering) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *HPCOffering) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *HPCOffering) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HPCOffering) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *HPCOffering) GetQueueOptions() []QueueOption {
	if m != nil {
		return m.QueueOptions
	}
	return nil
}

func (m *HPCOffering) GetPricing() HPCPricing {
	if m != nil {
		return m.Pricing
	}
	return HPCPricing{}
}

func (m *HPCOffering) GetRequiredIdentityThreshold() int32 {
	if m != nil {
		return m.RequiredIdentityThreshold
	}
	return 0
}

func (m *HPCOffering) GetMaxRuntimeSeconds() int64 {
	if m != nil {
		return m.MaxRuntimeSeconds
	}
	return 0
}

func (m *HPCOffering) GetPreconfiguredWorkloads() []PreconfiguredWorkload {
	if m != nil {
		return m.PreconfiguredWorkloads
	}
	return nil
}

func (m *HPCOffering) GetSupportsCustomWorkloads() bool {
	if m != nil {
		return m.SupportsCustomWorkloads
	}
	return false
}

func (m *HPCOffering) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *HPCOffering) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *HPCOffering) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *HPCOffering) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// JobWorkloadSpec defines the workload for an HPC job
type JobWorkloadSpec struct {
	ContainerImage          string            `protobuf:"bytes,1,opt,name=container_image,json=containerImage,proto3" json:"container_image" yaml:"container_image"`
	Command                 string            `protobuf:"bytes,2,opt,name=command,proto3" json:"command" yaml:"command"`
	Arguments               []string          `protobuf:"bytes,3,rep,name=arguments,proto3" json:"arguments,omitempty" yaml:"arguments"`
	Environment             map[string]string `protobuf:"bytes,4,rep,name=environment,proto3" json:"environment,omitempty" yaml:"environment" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	WorkingDirectory        string            `protobuf:"bytes,5,opt,name=working_directory,json=workingDirectory,proto3" json:"working_directory,omitempty" yaml:"working_directory"`
	PreconfiguredWorkloadId string            `protobuf:"bytes,6,opt,name=preconfigured_workload_id,json=preconfiguredWorkloadId,proto3" json:"preconfigured_workload_id,omitempty" yaml:"preconfigured_workload_id"`
	IsPreconfigured         bool              `protobuf:"varint,7,opt,name=is_preconfigured,json=isPreconfigured,proto3" json:"is_preconfigured" yaml:"is_preconfigured"`
}

func (m *JobWorkloadSpec) Reset()         { *m = JobWorkloadSpec{} }
func (m *JobWorkloadSpec) String() string { return proto.CompactTextString(m) }
func (*JobWorkloadSpec) ProtoMessage()    {}
func (*JobWorkloadSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{8}
}
func (m *JobWorkloadSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobWorkloadSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobWorkloadSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobWorkloadSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobWorkloadSpec.Merge(m, src)
}
func (m *JobWorkloadSpec) XXX_Size() int {
	return m.Size()
}
func (m *JobWorkloadSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_JobWorkloadSpec.DiscardUnknown(m)
}

var xxx_messageInfo_JobWorkloadSpec proto.InternalMessageInfo

func (m *JobWorkloadSpec) GetContainerImage() string {
	if m != nil {
		return m.ContainerImage
	}
	return ""
}

func (m *JobWorkloadSpec) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *JobWorkloadSpec) GetArguments() []string {
	if m != nil {
		return m.Arguments
	}
	return nil
}

func (m *JobWorkloadSpec) GetEnvironment() map[string]string {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *JobWorkloadSpec) GetWorkingDirectory() string {
	if m != nil {
		return m.WorkingDirectory
	}
	return ""
}

func (m *JobWorkloadSpec) GetPreconfiguredWorkloadId() string {
	if m != nil {
		return m.PreconfiguredWorkloadId
	}
	return ""
}

func (m *JobWorkloadSpec) GetIsPreconfigured() bool {
	if m != nil {
		return m.IsPreconfigured
	}
	return false
}

// DataReference references external data
type DataReference struct {
	ReferenceId string `protobuf:"bytes,1,opt,name=reference_id,json=referenceId,proto3" json:"reference_id" yaml:"reference_id"`
	Type        string `protobuf:"bytes,2,opt,name=type,proto3" json:"type" yaml:"type"`
	Uri         string `protobuf:"bytes,3,opt,name=uri,proto3" json:"uri" yaml:"uri"`
	Encrypted   bool   `protobuf:"varint,4,opt,name=encrypted,proto3" json:"encrypted" yaml:"encrypted"`
	Checksum    string `protobuf:"bytes,5,opt,name=checksum,proto3" json:"checksum,omitempty" yaml:"checksum"`
	SizeBytes   int64  `protobuf:"varint,6,opt,name=size_bytes,json=sizeBytes,proto3" json:"size_bytes,omitempty" yaml:"size_bytes"`
}

func (m *DataReference) Reset()         { *m = DataReference{} }
func (m *DataReference) String() string { return proto.CompactTextString(m) }
func (*DataReference) ProtoMessage()    {}
func (*DataReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{9}
}
func (m *DataReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataReference.Merge(m, src)
}
func (m *DataReference) XXX_Size() int {
	return m.Size()
}
func (m *DataReference) XXX_DiscardUnknown() {
	xxx_messageInfo_DataReference.DiscardUnknown(m)
}

var xxx_messageInfo_DataReference proto.InternalMessageInfo

func (m *DataReference) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *DataReference) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *DataReference) GetUri() string {
	if m != nil {
		return m.Uri
	}
	return ""
}

func (m *DataReference) GetEncrypted() bool {
	if m != nil {
		return m.Encrypted
	}
	return false
}

func (m *DataReference) GetChecksum() string {
	if m != nil {
		return m.Checksum
	}
	return ""
}

func (m *DataReference) GetSizeBytes() int64 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

// HPCUsageMetrics contains usage metrics for an HPC job
type HPCUsageMetrics struct {
	WallClockSeconds int64 `protobuf:"varint,1,opt,name=wall_clock_seconds,json=wallClockSeconds,proto3" json:"wall_clock_seconds" yaml:"wall_clock_seconds"`
	CpuCoreSeconds   int64 `protobuf:"varint,2,opt,name=cpu_core_seconds,json=cpuCoreSeconds,proto3" json:"cpu_core_seconds" yaml:"cpu_core_seconds"`
	MemoryGbSeconds  int64 `protobuf:"varint,3,opt,name=memory_gb_seconds,json=memoryGbSeconds,proto3" json:"memory_gb_seconds" yaml:"memory_gb_seconds"`
	GpuSeconds       int64 `protobuf:"varint,4,opt,name=gpu_seconds,json=gpuSeconds,proto3" json:"gpu_seconds,omitempty" yaml:"gpu_seconds"`
	StorageGbHours   int64 `protobuf:"varint,5,opt,name=storage_gb_hours,json=storageGbHours,proto3" json:"storage_gb_hours" yaml:"storage_gb_hours"`
	NetworkBytesIn   int64 `protobuf:"varint,6,opt,name=network_bytes_in,json=networkBytesIn,proto3" json:"network_bytes_in" yaml:"network_bytes_in"`
	NetworkBytesOut  int64 `protobuf:"varint,7,opt,name=network_bytes_out,json=networkBytesOut,proto3" json:"network_bytes_out" yaml:"network_bytes_out"`
	NodeHours        int64 `protobuf:"varint,8,opt,name=node_hours,json=nodeHours,proto3" json:"node_hours" yaml:"node_hours"`
	NodesUsed        int32 `protobuf:"varint,9,opt,name=nodes_used,json=nodesUsed,proto3" json:"nodes_used" yaml:"nodes_used"`
}

func (m *HPCUsageMetrics) Reset()         { *m = HPCUsageMetrics{} }
func (m *HPCUsageMetrics) String() string { return proto.CompactTextString(m) }
func (*HPCUsageMetrics) ProtoMessage()    {}
func (*HPCUsageMetrics) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{10}
}
func (m *HPCUsageMetrics) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCUsageMetrics) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCUsageMetrics.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCUsageMetrics) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCUsageMetrics.Merge(m, src)
}
func (m *HPCUsageMetrics) XXX_Size() int {
	return m.Size()
}
func (m *HPCUsageMetrics) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCUsageMetrics.DiscardUnknown(m)
}

var xxx_messageInfo_HPCUsageMetrics proto.InternalMessageInfo

func (m *HPCUsageMetrics) GetWallClockSeconds() int64 {
	if m != nil {
		return m.WallClockSeconds
	}
	return 0
}

func (m *HPCUsageMetrics) GetCpuCoreSeconds() int64 {
	if m != nil {
		return m.CpuCoreSeconds
	}
	return 0
}

func (m *HPCUsageMetrics) GetMemoryGbSeconds() int64 {
	if m != nil {
		return m.MemoryGbSeconds
	}
	return 0
}

func (m *HPCUsageMetrics) GetGpuSeconds() int64 {
	if m != nil {
		return m.GpuSeconds
	}
	return 0
}

func (m *HPCUsageMetrics) GetStorageGbHours() int64 {
	if m != nil {
		return m.StorageGbHours
	}
	return 0
}

func (m *HPCUsageMetrics) GetNetworkBytesIn() int64 {
	if m != nil {
		return m.NetworkBytesIn
	}
	return 0
}

func (m *HPCUsageMetrics) GetNetworkBytesOut() int64 {
	if m != nil {
		return m.NetworkBytesOut
	}
	return 0
}

func (m *HPCUsageMetrics) GetNodeHours() int64 {
	if m != nil {
		return m.NodeHours
	}
	return 0
}

func (m *HPCUsageMetrics) GetNodesUsed() int32 {
	if m != nil {
		return m.NodesUsed
	}
	return 0
}

// HPCJob represents an HPC job request
type HPCJob struct {
	JobId                   string                                   `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id" yaml:"job_id"`
	OfferingId              string                                   `protobuf:"bytes,2,opt,name=offering_id,json=offeringId,proto3" json:"offering_id" yaml:"offering_id"`
	ClusterId               string                                   `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	ProviderAddress         string                                   `protobuf:"bytes,4,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	CustomerAddress         string                                   `protobuf:"bytes,5,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address" yaml:"customer_address"`
	SlurmJobId              string                                   `protobuf:"bytes,6,opt,name=slurm_job_id,json=slurmJobId,proto3" json:"slurm_job_id,omitempty" yaml:"slurm_job_id"`
	State                   JobState                                 `protobuf:"varint,7,opt,name=state,proto3,enum=virtengine.hpc.v1.JobState" json:"state" yaml:"state"`
	QueueName               string                                   `protobuf:"bytes,8,opt,name=queue_name,json=queueName,proto3" json:"queue_name" yaml:"queue_name"`
	WorkloadSpec            JobWorkloadSpec                          `protobuf:"bytes,9,opt,name=workload_spec,json=workloadSpec,proto3" json:"workload_spec" yaml:"workload_spec"`
	Resources               JobResources                             `protobuf:"bytes,10,opt,name=resources,proto3" json:"resources" yaml:"resources"`
	DataReferences          []DataReference                          `protobuf:"bytes,11,rep,name=data_references,json=dataReferences,proto3" json:"data_references,omitempty" yaml:"data_references"`
	EncryptedInputsPointer  string                                   `protobuf:"bytes,12,opt,name=encrypted_inputs_pointer,json=encryptedInputsPointer,proto3" json:"encrypted_inputs_pointer,omitempty" yaml:"encrypted_inputs_pointer"`
	EncryptedOutputsPointer string                                   `protobuf:"bytes,13,opt,name=encrypted_outputs_pointer,json=encryptedOutputsPointer,proto3" json:"encrypted_outputs_pointer,omitempty" yaml:"encrypted_outputs_pointer"`
	MaxRuntimeSeconds       int64                                    `protobuf:"varint,14,opt,name=max_runtime_seconds,json=maxRuntimeSeconds,proto3" json:"max_runtime_seconds" yaml:"max_runtime_seconds"`
	AgreedPrice             github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,15,rep,name=agreed_price,json=agreedPrice,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"agreed_price" yaml:"agreed_price"`
	EscrowId                string                                   `protobuf:"bytes,16,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty" yaml:"escrow_id"`
	SchedulingDecisionId    string                                   `protobuf:"bytes,17,opt,name=scheduling_decision_id,json=schedulingDecisionId,proto3" json:"scheduling_decision_id,omitempty" yaml:"scheduling_decision_id"`
	StatusMessage           string                                   `protobuf:"bytes,18,opt,name=status_message,json=statusMessage,proto3" json:"status_message,omitempty" yaml:"status_message"`
	ExitCode                int32                                    `protobuf:"varint,19,opt,name=exit_code,json=exitCode,proto3" json:"exit_code,omitempty" yaml:"exit_code"`
	CreatedAt               time.Time                                `protobuf:"bytes,20,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	QueuedAt                *time.Time                               `protobuf:"bytes,21,opt,name=queued_at,json=queuedAt,proto3,stdtime" json:"queued_at,omitempty" yaml:"queued_at"`
	StartedAt               *time.Time                               `protobuf:"bytes,22,opt,name=started_at,json=startedAt,proto3,stdtime" json:"started_at,omitempty" yaml:"started_at"`
	CompletedAt             *time.Time                               `protobuf:"bytes,23,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at,omitempty" yaml:"completed_at"`
	BlockHeight             int64                                    `protobuf:"varint,24,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *HPCJob) Reset()         { *m = HPCJob{} }
func (m *HPCJob) String() string { return proto.CompactTextString(m) }
func (*HPCJob) ProtoMessage()    {}
func (*HPCJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{11}
}
func (m *HPCJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCJob.Merge(m, src)
}
func (m *HPCJob) XXX_Size() int {
	return m.Size()
}
func (m *HPCJob) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCJob.DiscardUnknown(m)
}

var xxx_messageInfo_HPCJob proto.InternalMessageInfo

func (m *HPCJob) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *HPCJob) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *HPCJob) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *HPCJob) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *HPCJob) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *HPCJob) GetSlurmJobId() string {
	if m != nil {
		return m.SlurmJobId
	}
	return ""
}

func (m *HPCJob) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobStateUnspecified
}

func (m *HPCJob) GetQueueName() string {
	if m != nil {
		return m.QueueName
	}
	return ""
}

func (m *HPCJob) GetWorkloadSpec() JobWorkloadSpec {
	if m != nil {
		return m.WorkloadSpec
	}
	return JobWorkloadSpec{}
}

func (m *HPCJob) GetResources() JobResources {
	if m != nil {
		return m.Resources
	}
	return JobResources{}
}

func (m *HPCJob) GetDataReferences() []DataReference {
	if m != nil {
		return m.DataReferences
	}
	return nil
}

func (m *HPCJob) GetEncryptedInputsPointer() string {
	if m != nil {
		return m.EncryptedInputsPointer
	}
	return ""
}

func (m *HPCJob) GetEncryptedOutputsPointer() string {
	if m != nil {
		return m.EncryptedOutputsPointer
	}
	return ""
}

func (m *HPCJob) GetMaxRuntimeSeconds() int64 {
	if m != nil {
		return m.MaxRuntimeSeconds
	}
	return 0
}

func (m *HPCJob) GetAgreedPrice() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.AgreedPrice
	}
	return nil
}

func (m *HPCJob) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *HPCJob) GetSchedulingDecisionId() string {
	if m != nil {
		return m.SchedulingDecisionId
	}
	return ""
}

func (m *HPCJob) GetStatusMessage() string {
	if m != nil {
		return m.StatusMessage
	}
	return ""
}

func (m *HPCJob) GetExitCode() int32 {
	if m != nil {
		return m.ExitCode
	}
	return 0
}

func (m *HPCJob) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *HPCJob) GetQueuedAt() *time.Time {
	if m != nil {
		return m.QueuedAt
	}
	return nil
}

func (m *HPCJob) GetStartedAt() *time.Time {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *HPCJob) GetCompletedAt() *time.Time {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

func (m *HPCJob) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// NodeReward represents a reward for a specific node
type NodeReward struct {
	NodeId             string                                   `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id" yaml:"node_id"`
	ProviderAddress    string                                   `protobuf:"bytes,2,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Amount             github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount" yaml:"amount"`
	ContributionWeight string                                   `protobuf:"bytes,4,opt,name=contribution_weight,json=contributionWeight,proto3" json:"contribution_weight" yaml:"contribution_weight"`
	UsageSeconds       int64                                    `protobuf:"varint,5,opt,name=usage_seconds,json=usageSeconds,proto3" json:"usage_seconds" yaml:"usage_seconds"`
}

func (m *NodeReward) Reset()         { *m = NodeReward{} }
func (m *NodeReward) String() string { return proto.CompactTextString(m) }
func (*NodeReward) ProtoMessage()    {}
func (*NodeReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{12}
}
func (m *NodeReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeReward.Merge(m, src)
}
func (m *NodeReward) XXX_Size() int {
	return m.Size()
}
func (m *NodeReward) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeReward.DiscardUnknown(m)
}

var xxx_messageInfo_NodeReward proto.InternalMessageInfo

func (m *NodeReward) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodeReward) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *NodeReward) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *NodeReward) GetContributionWeight() string {
	if m != nil {
		return m.ContributionWeight
	}
	return ""
}

func (m *NodeReward) GetUsageSeconds() int64 {
	if m != nil {
		return m.UsageSeconds
	}
	return 0
}

// JobAccounting represents accounting data for an HPC job
type JobAccounting struct {
	JobId                string                                   `protobuf:"bytes,1,opt,name=job_id,json=jobId,proto3" json:"job_id" yaml:"job_id"`
	ClusterId            string                                   `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	ProviderAddress      string                                   `protobuf:"bytes,3,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	CustomerAddress      string                                   `protobuf:"bytes,4,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address" yaml:"customer_address"`
	UsageMetrics         HPCUsageMetrics                          `protobuf:"bytes,5,opt,name=usage_metrics,json=usageMetrics,proto3" json:"usage_metrics" yaml:"usage_metrics"`
	TotalCost            github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=total_cost,json=totalCost,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_cost" yaml:"total_cost"`
	ProviderReward       github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=provider_reward,json=providerReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"provider_reward" yaml:"provider_reward"`
	NodeRewards          []NodeReward                             `protobuf:"bytes,8,rep,name=node_rewards,json=nodeRewards,proto3" json:"node_rewards,omitempty" yaml:"node_rewards"`
	PlatformFee          github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=platform_fee,json=platformFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"platform_fee" yaml:"platform_fee"`
	SettlementStatus     string                                   `protobuf:"bytes,10,opt,name=settlement_status,json=settlementStatus,proto3" json:"settlement_status" yaml:"settlement_status"`
	SettlementId         string                                   `protobuf:"bytes,11,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty" yaml:"settlement_id"`
	SignedUsageRecordIds []string                                 `protobuf:"bytes,12,rep,name=signed_usage_record_ids,json=signedUsageRecordIds,proto3" json:"signed_usage_record_ids" yaml:"signed_usage_record_ids"`
	JobCompletionStatus  JobState                                 `protobuf:"varint,13,opt,name=job_completion_status,json=jobCompletionStatus,proto3,enum=virtengine.hpc.v1.JobState" json:"job_completion_status" yaml:"job_completion_status"`
	CreatedAt            time.Time                                `protobuf:"bytes,14,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	FinalizedAt          *time.Time                               `protobuf:"bytes,15,opt,name=finalized_at,json=finalizedAt,proto3,stdtime" json:"finalized_at,omitempty" yaml:"finalized_at"`
	BlockHeight          int64                                    `protobuf:"varint,16,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *JobAccounting) Reset()         { *m = JobAccounting{} }
func (m *JobAccounting) String() string { return proto.CompactTextString(m) }
func (*JobAccounting) ProtoMessage()    {}
func (*JobAccounting) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{13}
}
func (m *JobAccounting) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JobAccounting) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JobAccounting.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JobAccounting) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JobAccounting.Merge(m, src)
}
func (m *JobAccounting) XXX_Size() int {
	return m.Size()
}
func (m *JobAccounting) XXX_DiscardUnknown() {
	xxx_messageInfo_JobAccounting.DiscardUnknown(m)
}

var xxx_messageInfo_JobAccounting proto.InternalMessageInfo

func (m *JobAccounting) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *JobAccounting) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *JobAccounting) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *JobAccounting) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *JobAccounting) GetUsageMetrics() HPCUsageMetrics {
	if m != nil {
		return m.UsageMetrics
	}
	return HPCUsageMetrics{}
}

func (m *JobAccounting) GetTotalCost() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalCost
	}
	return nil
}

func (m *JobAccounting) GetProviderReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ProviderReward
	}
	return nil
}

func (m *JobAccounting) GetNodeRewards() []NodeReward {
	if m != nil {
		return m.NodeRewards
	}
	return nil
}

func (m *JobAccounting) GetPlatformFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.PlatformFee
	}
	return nil
}

func (m *JobAccounting) GetSettlementStatus() string {
	if m != nil {
		return m.SettlementStatus
	}
	return ""
}

func (m *JobAccounting) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *JobAccounting) GetSignedUsageRecordIds() []string {
	if m != nil {
		return m.SignedUsageRecordIds
	}
	return nil
}

func (m *JobAccounting) GetJobCompletionStatus() JobState {
	if m != nil {
		return m.JobCompletionStatus
	}
	return JobStateUnspecified
}

func (m *JobAccounting) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *JobAccounting) GetFinalizedAt() *time.Time {
	if m != nil {
		return m.FinalizedAt
	}
	return nil
}

func (m *JobAccounting) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// LatencyMeasurement contains latency measurement to another node
type LatencyMeasurement struct {
	TargetNodeId string    `protobuf:"bytes,1,opt,name=target_node_id,json=targetNodeId,proto3" json:"target_node_id" yaml:"target_node_id"`
	LatencyMs    int64     `protobuf:"varint,2,opt,name=latency_ms,json=latencyMs,proto3" json:"latency_ms" yaml:"latency_ms"`
	MeasuredAt   time.Time `protobuf:"bytes,3,opt,name=measured_at,json=measuredAt,proto3,stdtime" json:"measured_at" yaml:"measured_at"`
}

func (m *LatencyMeasurement) Reset()         { *m = LatencyMeasurement{} }
func (m *LatencyMeasurement) String() string { return proto.CompactTextString(m) }
func (*LatencyMeasurement) ProtoMessage()    {}
func (*LatencyMeasurement) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{14}
}
func (m *LatencyMeasurement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LatencyMeasurement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LatencyMeasurement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LatencyMeasurement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LatencyMeasurement.Merge(m, src)
}
func (m *LatencyMeasurement) XXX_Size() int {
	return m.Size()
}
func (m *LatencyMeasurement) XXX_DiscardUnknown() {
	xxx_messageInfo_LatencyMeasurement.DiscardUnknown(m)
}

var xxx_messageInfo_LatencyMeasurement proto.InternalMessageInfo

func (m *LatencyMeasurement) GetTargetNodeId() string {
	if m != nil {
		return m.TargetNodeId
	}
	return ""
}

func (m *LatencyMeasurement) GetLatencyMs() int64 {
	if m != nil {
		return m.LatencyMs
	}
	return 0
}

func (m *LatencyMeasurement) GetMeasuredAt() time.Time {
	if m != nil {
		return m.MeasuredAt
	}
	return time.Time{}
}

// NodeResources contains node resource capacity
type NodeResources struct {
	CpuCores  int32  `protobuf:"varint,1,opt,name=cpu_cores,json=cpuCores,proto3" json:"cpu_cores" yaml:"cpu_cores"`
	MemoryGb  int32  `protobuf:"varint,2,opt,name=memory_gb,json=memoryGb,proto3" json:"memory_gb" yaml:"memory_gb"`
	Gpus      int32  `protobuf:"varint,3,opt,name=gpus,proto3" json:"gpus,omitempty" yaml:"gpus"`
	GpuType   string `protobuf:"bytes,4,opt,name=gpu_type,json=gpuType,proto3" json:"gpu_type,omitempty" yaml:"gpu_type"`
	StorageGb int32  `protobuf:"varint,5,opt,name=storage_gb,json=storageGb,proto3" json:"storage_gb" yaml:"storage_gb"`
}

func (m *NodeResources) Reset()         { *m = NodeResources{} }
func (m *NodeResources) String() string { return proto.CompactTextString(m) }
func (*NodeResources) ProtoMessage()    {}
func (*NodeResources) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{15}
}
func (m *NodeResources) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeResources) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeResources.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeResources) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeResources.Merge(m, src)
}
func (m *NodeResources) XXX_Size() int {
	return m.Size()
}
func (m *NodeResources) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeResources.DiscardUnknown(m)
}

var xxx_messageInfo_NodeResources proto.InternalMessageInfo

func (m *NodeResources) GetCpuCores() int32 {
	if m != nil {
		return m.CpuCores
	}
	return 0
}

func (m *NodeResources) GetMemoryGb() int32 {
	if m != nil {
		return m.MemoryGb
	}
	return 0
}

func (m *NodeResources) GetGpus() int32 {
	if m != nil {
		return m.Gpus
	}
	return 0
}

func (m *NodeResources) GetGpuType() string {
	if m != nil {
		return m.GpuType
	}
	return ""
}

func (m *NodeResources) GetStorageGb() int32 {
	if m != nil {
		return m.StorageGb
	}
	return 0
}

// NodeCapacity contains node capacity information
type NodeCapacity struct {
	CpuCoresTotal      int32  `protobuf:"varint,1,opt,name=cpu_cores_total,json=cpuCoresTotal,proto3" json:"cpu_cores_total" yaml:"cpu_cores_total"`
	CpuCoresAvailable  int32  `protobuf:"varint,2,opt,name=cpu_cores_available,json=cpuCoresAvailable,proto3" json:"cpu_cores_available" yaml:"cpu_cores_available"`
	CpuCoresAllocated  int32  `protobuf:"varint,3,opt,name=cpu_cores_allocated,json=cpuCoresAllocated,proto3" json:"cpu_cores_allocated" yaml:"cpu_cores_allocated"`
	MemoryGbTotal      int32  `protobuf:"varint,4,opt,name=memory_gb_total,json=memoryGbTotal,proto3" json:"memory_gb_total" yaml:"memory_gb_total"`
	MemoryGbAvailable  int32  `protobuf:"varint,5,opt,name=memory_gb_available,json=memoryGbAvailable,proto3" json:"memory_gb_available" yaml:"memory_gb_available"`
	MemoryGbAllocated  int32  `protobuf:"varint,6,opt,name=memory_gb_allocated,json=memoryGbAllocated,proto3" json:"memory_gb_allocated" yaml:"memory_gb_allocated"`
	GpusTotal          int32  `protobuf:"varint,7,opt,name=gpus_total,json=gpusTotal,proto3" json:"gpus_total" yaml:"gpus_total"`
	GpusAvailable      int32  `protobuf:"varint,8,opt,name=gpus_available,json=gpusAvailable,proto3" json:"gpus_available" yaml:"gpus_available"`
	GpusAllocated      int32  `protobuf:"varint,9,opt,name=gpus_allocated,json=gpusAllocated,proto3" json:"gpus_allocated" yaml:"gpus_allocated"`
	GpuType            string `protobuf:"bytes,10,opt,name=gpu_type,json=gpuType,proto3" json:"gpu_type,omitempty" yaml:"gpu_type"`
	StorageGbTotal     int32  `protobuf:"varint,11,opt,name=storage_gb_total,json=storageGbTotal,proto3" json:"storage_gb_total" yaml:"storage_gb_total"`
	StorageGbAvailable int32  `protobuf:"varint,12,opt,name=storage_gb_available,json=storageGbAvailable,proto3" json:"storage_gb_available" yaml:"storage_gb_available"`
	StorageGbAllocated int32  `protobuf:"varint,13,opt,name=storage_gb_allocated,json=storageGbAllocated,proto3" json:"storage_gb_allocated" yaml:"storage_gb_allocated"`
}

func (m *NodeCapacity) Reset()         { *m = NodeCapacity{} }
func (m *NodeCapacity) String() string { return proto.CompactTextString(m) }
func (*NodeCapacity) ProtoMessage()    {}
func (*NodeCapacity) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{16}
}
func (m *NodeCapacity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeCapacity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeCapacity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeCapacity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeCapacity.Merge(m, src)
}
func (m *NodeCapacity) XXX_Size() int {
	return m.Size()
}
func (m *NodeCapacity) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeCapacity.DiscardUnknown(m)
}

var xxx_messageInfo_NodeCapacity proto.InternalMessageInfo

func (m *NodeCapacity) GetCpuCoresTotal() int32 {
	if m != nil {
		return m.CpuCoresTotal
	}
	return 0
}

func (m *NodeCapacity) GetCpuCoresAvailable() int32 {
	if m != nil {
		return m.CpuCoresAvailable
	}
	return 0
}

func (m *NodeCapacity) GetCpuCoresAllocated() int32 {
	if m != nil {
		return m.CpuCoresAllocated
	}
	return 0
}

func (m *NodeCapacity) GetMemoryGbTotal() int32 {
	if m != nil {
		return m.MemoryGbTotal
	}
	return 0
}

func (m *NodeCapacity) GetMemoryGbAvailable() int32 {
	if m != nil {
		return m.MemoryGbAvailable
	}
	return 0
}

func (m *NodeCapacity) GetMemoryGbAllocated() int32 {
	if m != nil {
		return m.MemoryGbAllocated
	}
	return 0
}

func (m *NodeCapacity) GetGpusTotal() int32 {
	if m != nil {
		return m.GpusTotal
	}
	return 0
}

func (m *NodeCapacity) GetGpusAvailable() int32 {
	if m != nil {
		return m.GpusAvailable
	}
	return 0
}

func (m *NodeCapacity) GetGpusAllocated() int32 {
	if m != nil {
		return m.GpusAllocated
	}
	return 0
}

func (m *NodeCapacity) GetGpuType() string {
	if m != nil {
		return m.GpuType
	}
	return ""
}

func (m *NodeCapacity) GetStorageGbTotal() int32 {
	if m != nil {
		return m.StorageGbTotal
	}
	return 0
}

func (m *NodeCapacity) GetStorageGbAvailable() int32 {
	if m != nil {
		return m.StorageGbAvailable
	}
	return 0
}

func (m *NodeCapacity) GetStorageGbAllocated() int32 {
	if m != nil {
		return m.StorageGbAllocated
	}
	return 0
}

// NodeHealth contains node health information
type NodeHealth struct {
	Status                      HealthStatus `protobuf:"varint,1,opt,name=status,proto3,enum=virtengine.hpc.v1.HealthStatus" json:"status" yaml:"status"`
	UptimeSeconds               int64        `protobuf:"varint,2,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds" yaml:"uptime_seconds"`
	LoadAverage_1M              string       `protobuf:"bytes,3,opt,name=load_average_1m,json=loadAverage1m,proto3" json:"load_average_1m" yaml:"load_average_1m"`
	LoadAverage_5M              string       `protobuf:"bytes,4,opt,name=load_average_5m,json=loadAverage5m,proto3" json:"load_average_5m" yaml:"load_average_5m"`
	LoadAverage_15M             string       `protobuf:"bytes,5,opt,name=load_average_15m,json=loadAverage15m,proto3" json:"load_average_15m" yaml:"load_average_15m"`
	CpuUtilizationPercent       int32        `protobuf:"varint,6,opt,name=cpu_utilization_percent,json=cpuUtilizationPercent,proto3" json:"cpu_utilization_percent" yaml:"cpu_utilization_percent"`
	MemoryUtilizationPercent    int32        `protobuf:"varint,7,opt,name=memory_utilization_percent,json=memoryUtilizationPercent,proto3" json:"memory_utilization_percent" yaml:"memory_utilization_percent"`
	GpuUtilizationPercent       int32        `protobuf:"varint,8,opt,name=gpu_utilization_percent,json=gpuUtilizationPercent,proto3" json:"gpu_utilization_percent,omitempty" yaml:"gpu_utilization_percent"`
	GpuMemoryUtilizationPercent int32        `protobuf:"varint,9,opt,name=gpu_memory_utilization_percent,json=gpuMemoryUtilizationPercent,proto3" json:"gpu_memory_utilization_percent,omitempty" yaml:"gpu_memory_utilization_percent"`
	DiskIoUtilizationPercent    int32        `protobuf:"varint,10,opt,name=disk_io_utilization_percent,json=diskIoUtilizationPercent,proto3" json:"disk_io_utilization_percent" yaml:"disk_io_utilization_percent"`
	NetworkUtilizationPercent   int32        `protobuf:"varint,11,opt,name=network_utilization_percent,json=networkUtilizationPercent,proto3" json:"network_utilization_percent" yaml:"network_utilization_percent"`
	TemperatureCelsius          int32        `protobuf:"varint,12,opt,name=temperature_celsius,json=temperatureCelsius,proto3" json:"temperature_celsius,omitempty" yaml:"temperature_celsius"`
	GpuTemperatureCelsius       int32        `protobuf:"varint,13,opt,name=gpu_temperature_celsius,json=gpuTemperatureCelsius,proto3" json:"gpu_temperature_celsius,omitempty" yaml:"gpu_temperature_celsius"`
	ErrorCount_24H              int32        `protobuf:"varint,14,opt,name=error_count_24h,json=errorCount24h,proto3" json:"error_count_24h" yaml:"error_count_24h"`
	WarningCount_24H            int32        `protobuf:"varint,15,opt,name=warning_count_24h,json=warningCount24h,proto3" json:"warning_count_24h" yaml:"warning_count_24h"`
	LastErrorMessage            string       `protobuf:"bytes,16,opt,name=last_error_message,json=lastErrorMessage,proto3" json:"last_error_message,omitempty" yaml:"last_error_message"`
	SlurmState                  string       `protobuf:"bytes,17,opt,name=slurm_state,json=slurmState,proto3" json:"slurm_state,omitempty" yaml:"slurm_state"`
}

func (m *NodeHealth) Reset()         { *m = NodeHealth{} }
func (m *NodeHealth) String() string { return proto.CompactTextString(m) }
func (*NodeHealth) ProtoMessage()    {}
func (*NodeHealth) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{17}
}
func (m *NodeHealth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeHealth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeHealth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeHealth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeHealth.Merge(m, src)
}
func (m *NodeHealth) XXX_Size() int {
	return m.Size()
}
func (m *NodeHealth) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeHealth.DiscardUnknown(m)
}

var xxx_messageInfo_NodeHealth proto.InternalMessageInfo

func (m *NodeHealth) GetStatus() HealthStatus {
	if m != nil {
		return m.Status
	}
	return HealthStatusUnspecified
}

func (m *NodeHealth) GetUptimeSeconds() int64 {
	if m != nil {
		return m.UptimeSeconds
	}
	return 0
}

func (m *NodeHealth) GetLoadAverage_1M() string {
	if m != nil {
		return m.LoadAverage_1M
	}
	return ""
}

func (m *NodeHealth) GetLoadAverage_5M() string {
	if m != nil {
		return m.LoadAverage_5M
	}
	return ""
}

func (m *NodeHealth) GetLoadAverage_15M() string {
	if m != nil {
		return m.LoadAverage_15M
	}
	return ""
}

func (m *NodeHealth) GetCpuUtilizationPercent() int32 {
	if m != nil {
		return m.CpuUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetMemoryUtilizationPercent() int32 {
	if m != nil {
		return m.MemoryUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetGpuUtilizationPercent() int32 {
	if m != nil {
		return m.GpuUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetGpuMemoryUtilizationPercent() int32 {
	if m != nil {
		return m.GpuMemoryUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetDiskIoUtilizationPercent() int32 {
	if m != nil {
		return m.DiskIoUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetNetworkUtilizationPercent() int32 {
	if m != nil {
		return m.NetworkUtilizationPercent
	}
	return 0
}

func (m *NodeHealth) GetTemperatureCelsius() int32 {
	if m != nil {
		return m.TemperatureCelsius
	}
	return 0
}

func (m *NodeHealth) GetGpuTemperatureCelsius() int32 {
	if m != nil {
		return m.GpuTemperatureCelsius
	}
	return 0
}

func (m *NodeHealth) GetErrorCount_24H() int32 {
	if m != nil {
		return m.ErrorCount_24H
	}
	return 0
}

func (m *NodeHealth) GetWarningCount_24H() int32 {
	if m != nil {
		return m.WarningCount_24H
	}
	return 0
}

func (m *NodeHealth) GetLastErrorMessage() string {
	if m != nil {
		return m.LastErrorMessage
	}
	return ""
}

func (m *NodeHealth) GetSlurmState() string {
	if m != nil {
		return m.SlurmState
	}
	return ""
}

// NodeHardware contains node hardware details
type NodeHardware struct {
	CpuModel       string   `protobuf:"bytes,1,opt,name=cpu_model,json=cpuModel,proto3" json:"cpu_model,omitempty" yaml:"cpu_model"`
	CpuVendor      string   `protobuf:"bytes,2,opt,name=cpu_vendor,json=cpuVendor,proto3" json:"cpu_vendor,omitempty" yaml:"cpu_vendor"`
	CpuArch        string   `protobuf:"bytes,3,opt,name=cpu_arch,json=cpuArch,proto3" json:"cpu_arch,omitempty" yaml:"cpu_arch"`
	Sockets        int32    `protobuf:"varint,4,opt,name=sockets,proto3" json:"sockets,omitempty" yaml:"sockets"`
	CoresPerSocket int32    `protobuf:"varint,5,opt,name=cores_per_socket,json=coresPerSocket,proto3" json:"cores_per_socket,omitempty" yaml:"cores_per_socket"`
	ThreadsPerCore int32    `protobuf:"varint,6,opt,name=threads_per_core,json=threadsPerCore,proto3" json:"threads_per_core,omitempty" yaml:"threads_per_core"`
	MemoryType     string   `protobuf:"bytes,7,opt,name=memory_type,json=memoryType,proto3" json:"memory_type,omitempty" yaml:"memory_type"`
	MemorySpeedMhz int32    `protobuf:"varint,8,opt,name=memory_speed_mhz,json=memorySpeedMhz,proto3" json:"memory_speed_mhz,omitempty" yaml:"memory_speed_mhz"`
	GpuModel       string   `protobuf:"bytes,9,opt,name=gpu_model,json=gpuModel,proto3" json:"gpu_model,omitempty" yaml:"gpu_model"`
	GpuMemoryGb    int32    `protobuf:"varint,10,opt,name=gpu_memory_gb,json=gpuMemoryGb,proto3" json:"gpu_memory_gb,omitempty" yaml:"gpu_memory_gb"`
	StorageType    string   `protobuf:"bytes,11,opt,name=storage_type,json=storageType,proto3" json:"storage_type,omitempty" yaml:"storage_type"`
	Features       []string `protobuf:"bytes,12,rep,name=features,proto3" json:"features,omitempty" yaml:"features"`
}

func (m *NodeHardware) Reset()         { *m = NodeHardware{} }
func (m *NodeHardware) String() string { return proto.CompactTextString(m) }
func (*NodeHardware) ProtoMessage()    {}
func (*NodeHardware) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{18}
}
func (m *NodeHardware) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeHardware) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeHardware.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeHardware) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeHardware.Merge(m, src)
}
func (m *NodeHardware) XXX_Size() int {
	return m.Size()
}
func (m *NodeHardware) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeHardware.DiscardUnknown(m)
}

var xxx_messageInfo_NodeHardware proto.InternalMessageInfo

func (m *NodeHardware) GetCpuModel() string {
	if m != nil {
		return m.CpuModel
	}
	return ""
}

func (m *NodeHardware) GetCpuVendor() string {
	if m != nil {
		return m.CpuVendor
	}
	return ""
}

func (m *NodeHardware) GetCpuArch() string {
	if m != nil {
		return m.CpuArch
	}
	return ""
}

func (m *NodeHardware) GetSockets() int32 {
	if m != nil {
		return m.Sockets
	}
	return 0
}

func (m *NodeHardware) GetCoresPerSocket() int32 {
	if m != nil {
		return m.CoresPerSocket
	}
	return 0
}

func (m *NodeHardware) GetThreadsPerCore() int32 {
	if m != nil {
		return m.ThreadsPerCore
	}
	return 0
}

func (m *NodeHardware) GetMemoryType() string {
	if m != nil {
		return m.MemoryType
	}
	return ""
}

func (m *NodeHardware) GetMemorySpeedMhz() int32 {
	if m != nil {
		return m.MemorySpeedMhz
	}
	return 0
}

func (m *NodeHardware) GetGpuModel() string {
	if m != nil {
		return m.GpuModel
	}
	return ""
}

func (m *NodeHardware) GetGpuMemoryGb() int32 {
	if m != nil {
		return m.GpuMemoryGb
	}
	return 0
}

func (m *NodeHardware) GetStorageType() string {
	if m != nil {
		return m.StorageType
	}
	return ""
}

func (m *NodeHardware) GetFeatures() []string {
	if m != nil {
		return m.Features
	}
	return nil
}

// NodeTopology describes node topology
type NodeTopology struct {
	NumaNodes     int32  `protobuf:"varint,1,opt,name=numa_nodes,json=numaNodes,proto3" json:"numa_nodes,omitempty" yaml:"numa_nodes"`
	NumaMemoryGb  int32  `protobuf:"varint,2,opt,name=numa_memory_gb,json=numaMemoryGb,proto3" json:"numa_memory_gb,omitempty" yaml:"numa_memory_gb"`
	Interconnect  string `protobuf:"bytes,3,opt,name=interconnect,proto3" json:"interconnect,omitempty" yaml:"interconnect"`
	NetworkFabric string `protobuf:"bytes,4,opt,name=network_fabric,json=networkFabric,proto3" json:"network_fabric,omitempty" yaml:"network_fabric"`
	TopologyHint  string `protobuf:"bytes,5,opt,name=topology_hint,json=topologyHint,proto3" json:"topology_hint,omitempty" yaml:"topology_hint"`
}

func (m *NodeTopology) Reset()         { *m = NodeTopology{} }
func (m *NodeTopology) String() string { return proto.CompactTextString(m) }
func (*NodeTopology) ProtoMessage()    {}
func (*NodeTopology) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{19}
}
func (m *NodeTopology) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeTopology) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeTopology.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeTopology) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeTopology.Merge(m, src)
}
func (m *NodeTopology) XXX_Size() int {
	return m.Size()
}
func (m *NodeTopology) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeTopology.DiscardUnknown(m)
}

var xxx_messageInfo_NodeTopology proto.InternalMessageInfo

func (m *NodeTopology) GetNumaNodes() int32 {
	if m != nil {
		return m.NumaNodes
	}
	return 0
}

func (m *NodeTopology) GetNumaMemoryGb() int32 {
	if m != nil {
		return m.NumaMemoryGb
	}
	return 0
}

func (m *NodeTopology) GetInterconnect() string {
	if m != nil {
		return m.Interconnect
	}
	return ""
}

func (m *NodeTopology) GetNetworkFabric() string {
	if m != nil {
		return m.NetworkFabric
	}
	return ""
}

func (m *NodeTopology) GetTopologyHint() string {
	if m != nil {
		return m.TopologyHint
	}
	return ""
}

// NodeLocality describes node locality
type NodeLocality struct {
	Region     string `protobuf:"bytes,1,opt,name=region,proto3" json:"region,omitempty" yaml:"region"`
	Datacenter string `protobuf:"bytes,2,opt,name=datacenter,proto3" json:"datacenter,omitempty" yaml:"datacenter"`
	Zone       string `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty" yaml:"zone"`
	Rack       string `protobuf:"bytes,4,opt,name=rack,proto3" json:"rack,omitempty" yaml:"rack"`
	Row        string `protobuf:"bytes,5,opt,name=row,proto3" json:"row,omitempty" yaml:"row"`
	Position   string `protobuf:"bytes,6,opt,name=position,proto3" json:"position,omitempty" yaml:"position"`
}

func (m *NodeLocality) Reset()         { *m = NodeLocality{} }
func (m *NodeLocality) String() string { return proto.CompactTextString(m) }
func (*NodeLocality) ProtoMessage()    {}
func (*NodeLocality) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{20}
}
func (m *NodeLocality) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeLocality) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeLocality.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeLocality) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeLocality.Merge(m, src)
}
func (m *NodeLocality) XXX_Size() int {
	return m.Size()
}
func (m *NodeLocality) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeLocality.DiscardUnknown(m)
}

var xxx_messageInfo_NodeLocality proto.InternalMessageInfo

func (m *NodeLocality) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *NodeLocality) GetDatacenter() string {
	if m != nil {
		return m.Datacenter
	}
	return ""
}

func (m *NodeLocality) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *NodeLocality) GetRack() string {
	if m != nil {
		return m.Rack
	}
	return ""
}

func (m *NodeLocality) GetRow() string {
	if m != nil {
		return m.Row
	}
	return ""
}

func (m *NodeLocality) GetPosition() string {
	if m != nil {
		return m.Position
	}
	return ""
}

// NodeMetadata contains metadata about a compute node
type NodeMetadata struct {
	NodeId               string               `protobuf:"bytes,1,opt,name=node_id,json=nodeId,proto3" json:"node_id" yaml:"node_id"`
	ClusterId            string               `protobuf:"bytes,2,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	ProviderAddress      string               `protobuf:"bytes,3,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Region               string               `protobuf:"bytes,4,opt,name=region,proto3" json:"region" yaml:"region"`
	Datacenter           string               `protobuf:"bytes,5,opt,name=datacenter,proto3" json:"datacenter,omitempty" yaml:"datacenter"`
	LatencyMeasurements  []LatencyMeasurement `protobuf:"bytes,6,rep,name=latency_measurements,json=latencyMeasurements,proto3" json:"latency_measurements,omitempty" yaml:"latency_measurements"`
	AvgLatencyMs         int64                `protobuf:"varint,7,opt,name=avg_latency_ms,json=avgLatencyMs,proto3" json:"avg_latency_ms" yaml:"avg_latency_ms"`
	NetworkBandwidthMbps int64                `protobuf:"varint,8,opt,name=network_bandwidth_mbps,json=networkBandwidthMbps,proto3" json:"network_bandwidth_mbps" yaml:"network_bandwidth_mbps"`
	Resources            NodeResources        `protobuf:"bytes,9,opt,name=resources,proto3" json:"resources" yaml:"resources"`
	Active               bool                 `protobuf:"varint,10,opt,name=active,proto3" json:"active" yaml:"active"`
	LastHeartbeat        time.Time            `protobuf:"bytes,11,opt,name=last_heartbeat,json=lastHeartbeat,proto3,stdtime" json:"last_heartbeat" yaml:"last_heartbeat"`
	JoinedAt             time.Time            `protobuf:"bytes,12,opt,name=joined_at,json=joinedAt,proto3,stdtime" json:"joined_at" yaml:"joined_at"`
	UpdatedAt            time.Time            `protobuf:"bytes,13,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	BlockHeight          int64                `protobuf:"varint,14,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
	State                NodeState            `protobuf:"varint,15,opt,name=state,proto3,enum=virtengine.hpc.v1.NodeState" json:"state,omitempty" yaml:"state"`
	HealthStatus         HealthStatus         `protobuf:"varint,16,opt,name=health_status,json=healthStatus,proto3,enum=virtengine.hpc.v1.HealthStatus" json:"health_status,omitempty" yaml:"health_status"`
	AgentPubkey          string               `protobuf:"bytes,17,opt,name=agent_pubkey,json=agentPubkey,proto3" json:"agent_pubkey,omitempty" yaml:"agent_pubkey"`
	HardwareFingerprint  string               `protobuf:"bytes,18,opt,name=hardware_fingerprint,json=hardwareFingerprint,proto3" json:"hardware_fingerprint,omitempty" yaml:"hardware_fingerprint"`
	AgentVersion         string               `protobuf:"bytes,19,opt,name=agent_version,json=agentVersion,proto3" json:"agent_version,omitempty" yaml:"agent_version"`
	LastSequenceNumber   uint64               `protobuf:"varint,20,opt,name=last_sequence_number,json=lastSequenceNumber,proto3" json:"last_sequence_number,omitempty" yaml:"last_sequence_number"`
	Capacity             *NodeCapacity        `protobuf:"bytes,21,opt,name=capacity,proto3" json:"capacity,omitempty" yaml:"capacity"`
	Health               *NodeHealth          `protobuf:"bytes,22,opt,name=health,proto3" json:"health,omitempty" yaml:"health"`
	Hardware             *NodeHardware        `protobuf:"bytes,23,opt,name=hardware,proto3" json:"hardware,omitempty" yaml:"hardware"`
	Topology             *NodeTopology        `protobuf:"bytes,24,opt,name=topology,proto3" json:"topology,omitempty" yaml:"topology"`
	Locality             *NodeLocality        `protobuf:"bytes,25,opt,name=locality,proto3" json:"locality,omitempty" yaml:"locality"`
}

func (m *NodeMetadata) Reset()         { *m = NodeMetadata{} }
func (m *NodeMetadata) String() string { return proto.CompactTextString(m) }
func (*NodeMetadata) ProtoMessage()    {}
func (*NodeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{21}
}
func (m *NodeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NodeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NodeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NodeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeMetadata.Merge(m, src)
}
func (m *NodeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *NodeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_NodeMetadata proto.InternalMessageInfo

func (m *NodeMetadata) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *NodeMetadata) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *NodeMetadata) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *NodeMetadata) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *NodeMetadata) GetDatacenter() string {
	if m != nil {
		return m.Datacenter
	}
	return ""
}

func (m *NodeMetadata) GetLatencyMeasurements() []LatencyMeasurement {
	if m != nil {
		return m.LatencyMeasurements
	}
	return nil
}

func (m *NodeMetadata) GetAvgLatencyMs() int64 {
	if m != nil {
		return m.AvgLatencyMs
	}
	return 0
}

func (m *NodeMetadata) GetNetworkBandwidthMbps() int64 {
	if m != nil {
		return m.NetworkBandwidthMbps
	}
	return 0
}

func (m *NodeMetadata) GetResources() NodeResources {
	if m != nil {
		return m.Resources
	}
	return NodeResources{}
}

func (m *NodeMetadata) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *NodeMetadata) GetLastHeartbeat() time.Time {
	if m != nil {
		return m.LastHeartbeat
	}
	return time.Time{}
}

func (m *NodeMetadata) GetJoinedAt() time.Time {
	if m != nil {
		return m.JoinedAt
	}
	return time.Time{}
}

func (m *NodeMetadata) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *NodeMetadata) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *NodeMetadata) GetState() NodeState {
	if m != nil {
		return m.State
	}
	return NodeStateUnspecified
}

func (m *NodeMetadata) GetHealthStatus() HealthStatus {
	if m != nil {
		return m.HealthStatus
	}
	return HealthStatusUnspecified
}

func (m *NodeMetadata) GetAgentPubkey() string {
	if m != nil {
		return m.AgentPubkey
	}
	return ""
}

func (m *NodeMetadata) GetHardwareFingerprint() string {
	if m != nil {
		return m.HardwareFingerprint
	}
	return ""
}

func (m *NodeMetadata) GetAgentVersion() string {
	if m != nil {
		return m.AgentVersion
	}
	return ""
}

func (m *NodeMetadata) GetLastSequenceNumber() uint64 {
	if m != nil {
		return m.LastSequenceNumber
	}
	return 0
}

func (m *NodeMetadata) GetCapacity() *NodeCapacity {
	if m != nil {
		return m.Capacity
	}
	return nil
}

func (m *NodeMetadata) GetHealth() *NodeHealth {
	if m != nil {
		return m.Health
	}
	return nil
}

func (m *NodeMetadata) GetHardware() *NodeHardware {
	if m != nil {
		return m.Hardware
	}
	return nil
}

func (m *NodeMetadata) GetTopology() *NodeTopology {
	if m != nil {
		return m.Topology
	}
	return nil
}

func (m *NodeMetadata) GetLocality() *NodeLocality {
	if m != nil {
		return m.Locality
	}
	return nil
}

// ClusterCandidate represents a candidate cluster for scheduling
type ClusterCandidate struct {
	ClusterId           string `protobuf:"bytes,1,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	Region              string `protobuf:"bytes,2,opt,name=region,proto3" json:"region" yaml:"region"`
	AvgLatencyMs        int64  `protobuf:"varint,3,opt,name=avg_latency_ms,json=avgLatencyMs,proto3" json:"avg_latency_ms" yaml:"avg_latency_ms"`
	AvailableNodes      int32  `protobuf:"varint,4,opt,name=available_nodes,json=availableNodes,proto3" json:"available_nodes" yaml:"available_nodes"`
	LatencyScore        string `protobuf:"bytes,5,opt,name=latency_score,json=latencyScore,proto3" json:"latency_score" yaml:"latency_score"`
	CapacityScore       string `protobuf:"bytes,6,opt,name=capacity_score,json=capacityScore,proto3" json:"capacity_score" yaml:"capacity_score"`
	CombinedScore       string `protobuf:"bytes,7,opt,name=combined_score,json=combinedScore,proto3" json:"combined_score" yaml:"combined_score"`
	Eligible            bool   `protobuf:"varint,8,opt,name=eligible,proto3" json:"eligible" yaml:"eligible"`
	IneligibilityReason string `protobuf:"bytes,9,opt,name=ineligibility_reason,json=ineligibilityReason,proto3" json:"ineligibility_reason,omitempty" yaml:"ineligibility_reason"`
}

func (m *ClusterCandidate) Reset()         { *m = ClusterCandidate{} }
func (m *ClusterCandidate) String() string { return proto.CompactTextString(m) }
func (*ClusterCandidate) ProtoMessage()    {}
func (*ClusterCandidate) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{22}
}
func (m *ClusterCandidate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClusterCandidate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClusterCandidate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClusterCandidate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClusterCandidate.Merge(m, src)
}
func (m *ClusterCandidate) XXX_Size() int {
	return m.Size()
}
func (m *ClusterCandidate) XXX_DiscardUnknown() {
	xxx_messageInfo_ClusterCandidate.DiscardUnknown(m)
}

var xxx_messageInfo_ClusterCandidate proto.InternalMessageInfo

func (m *ClusterCandidate) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *ClusterCandidate) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *ClusterCandidate) GetAvgLatencyMs() int64 {
	if m != nil {
		return m.AvgLatencyMs
	}
	return 0
}

func (m *ClusterCandidate) GetAvailableNodes() int32 {
	if m != nil {
		return m.AvailableNodes
	}
	return 0
}

func (m *ClusterCandidate) GetLatencyScore() string {
	if m != nil {
		return m.LatencyScore
	}
	return ""
}

func (m *ClusterCandidate) GetCapacityScore() string {
	if m != nil {
		return m.CapacityScore
	}
	return ""
}

func (m *ClusterCandidate) GetCombinedScore() string {
	if m != nil {
		return m.CombinedScore
	}
	return ""
}

func (m *ClusterCandidate) GetEligible() bool {
	if m != nil {
		return m.Eligible
	}
	return false
}

func (m *ClusterCandidate) GetIneligibilityReason() string {
	if m != nil {
		return m.IneligibilityReason
	}
	return ""
}

// SchedulingDecision records the decision trail for job scheduling
type SchedulingDecision struct {
	DecisionId        string             `protobuf:"bytes,1,opt,name=decision_id,json=decisionId,proto3" json:"decision_id" yaml:"decision_id"`
	JobId             string             `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id" yaml:"job_id"`
	SelectedClusterId string             `protobuf:"bytes,3,opt,name=selected_cluster_id,json=selectedClusterId,proto3" json:"selected_cluster_id" yaml:"selected_cluster_id"`
	CandidateClusters []ClusterCandidate `protobuf:"bytes,4,rep,name=candidate_clusters,json=candidateClusters,proto3" json:"candidate_clusters" yaml:"candidate_clusters"`
	DecisionReason    string             `protobuf:"bytes,5,opt,name=decision_reason,json=decisionReason,proto3" json:"decision_reason" yaml:"decision_reason"`
	IsFallback        bool               `protobuf:"varint,6,opt,name=is_fallback,json=isFallback,proto3" json:"is_fallback" yaml:"is_fallback"`
	FallbackReason    string             `protobuf:"bytes,7,opt,name=fallback_reason,json=fallbackReason,proto3" json:"fallback_reason,omitempty" yaml:"fallback_reason"`
	LatencyScore      string             `protobuf:"bytes,8,opt,name=latency_score,json=latencyScore,proto3" json:"latency_score" yaml:"latency_score"`
	CapacityScore     string             `protobuf:"bytes,9,opt,name=capacity_score,json=capacityScore,proto3" json:"capacity_score" yaml:"capacity_score"`
	CombinedScore     string             `protobuf:"bytes,10,opt,name=combined_score,json=combinedScore,proto3" json:"combined_score" yaml:"combined_score"`
	CreatedAt         time.Time          `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	BlockHeight       int64              `protobuf:"varint,12,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *SchedulingDecision) Reset()         { *m = SchedulingDecision{} }
func (m *SchedulingDecision) String() string { return proto.CompactTextString(m) }
func (*SchedulingDecision) ProtoMessage()    {}
func (*SchedulingDecision) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{23}
}
func (m *SchedulingDecision) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SchedulingDecision) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SchedulingDecision.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SchedulingDecision) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SchedulingDecision.Merge(m, src)
}
func (m *SchedulingDecision) XXX_Size() int {
	return m.Size()
}
func (m *SchedulingDecision) XXX_DiscardUnknown() {
	xxx_messageInfo_SchedulingDecision.DiscardUnknown(m)
}

var xxx_messageInfo_SchedulingDecision proto.InternalMessageInfo

func (m *SchedulingDecision) GetDecisionId() string {
	if m != nil {
		return m.DecisionId
	}
	return ""
}

func (m *SchedulingDecision) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *SchedulingDecision) GetSelectedClusterId() string {
	if m != nil {
		return m.SelectedClusterId
	}
	return ""
}

func (m *SchedulingDecision) GetCandidateClusters() []ClusterCandidate {
	if m != nil {
		return m.CandidateClusters
	}
	return nil
}

func (m *SchedulingDecision) GetDecisionReason() string {
	if m != nil {
		return m.DecisionReason
	}
	return ""
}

func (m *SchedulingDecision) GetIsFallback() bool {
	if m != nil {
		return m.IsFallback
	}
	return false
}

func (m *SchedulingDecision) GetFallbackReason() string {
	if m != nil {
		return m.FallbackReason
	}
	return ""
}

func (m *SchedulingDecision) GetLatencyScore() string {
	if m != nil {
		return m.LatencyScore
	}
	return ""
}

func (m *SchedulingDecision) GetCapacityScore() string {
	if m != nil {
		return m.CapacityScore
	}
	return ""
}

func (m *SchedulingDecision) GetCombinedScore() string {
	if m != nil {
		return m.CombinedScore
	}
	return ""
}

func (m *SchedulingDecision) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *SchedulingDecision) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// HPCRewardRecipient represents a recipient of HPC rewards
type HPCRewardRecipient struct {
	Address            string                                   `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	Amount             github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount" yaml:"amount"`
	RecipientType      string                                   `protobuf:"bytes,3,opt,name=recipient_type,json=recipientType,proto3" json:"recipient_type" yaml:"recipient_type"`
	NodeId             string                                   `protobuf:"bytes,4,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty" yaml:"node_id"`
	ContributionWeight string                                   `protobuf:"bytes,5,opt,name=contribution_weight,json=contributionWeight,proto3" json:"contribution_weight" yaml:"contribution_weight"`
	Reason             string                                   `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *HPCRewardRecipient) Reset()         { *m = HPCRewardRecipient{} }
func (m *HPCRewardRecipient) String() string { return proto.CompactTextString(m) }
func (*HPCRewardRecipient) ProtoMessage()    {}
func (*HPCRewardRecipient) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{24}
}
func (m *HPCRewardRecipient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCRewardRecipient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCRewardRecipient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCRewardRecipient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCRewardRecipient.Merge(m, src)
}
func (m *HPCRewardRecipient) XXX_Size() int {
	return m.Size()
}
func (m *HPCRewardRecipient) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCRewardRecipient.DiscardUnknown(m)
}

var xxx_messageInfo_HPCRewardRecipient proto.InternalMessageInfo

func (m *HPCRewardRecipient) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *HPCRewardRecipient) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *HPCRewardRecipient) GetRecipientType() string {
	if m != nil {
		return m.RecipientType
	}
	return ""
}

func (m *HPCRewardRecipient) GetNodeId() string {
	if m != nil {
		return m.NodeId
	}
	return ""
}

func (m *HPCRewardRecipient) GetContributionWeight() string {
	if m != nil {
		return m.ContributionWeight
	}
	return ""
}

func (m *HPCRewardRecipient) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// RewardCalculationDetails contains transparency data for reward calculation
type RewardCalculationDetails struct {
	TotalUsageValue         string            `protobuf:"bytes,1,opt,name=total_usage_value,json=totalUsageValue,proto3" json:"total_usage_value" yaml:"total_usage_value"`
	RewardPoolContribution  string            `protobuf:"bytes,2,opt,name=reward_pool_contribution,json=rewardPoolContribution,proto3" json:"reward_pool_contribution" yaml:"reward_pool_contribution"`
	PlatformFeeRate         string            `protobuf:"bytes,3,opt,name=platform_fee_rate,json=platformFeeRate,proto3" json:"platform_fee_rate" yaml:"platform_fee_rate"`
	NodeContributionFormula string            `protobuf:"bytes,4,opt,name=node_contribution_formula,json=nodeContributionFormula,proto3" json:"node_contribution_formula" yaml:"node_contribution_formula"`
	InputMetrics            map[string]string `protobuf:"bytes,5,rep,name=input_metrics,json=inputMetrics,proto3" json:"input_metrics" yaml:"input_metrics" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RewardCalculationDetails) Reset()         { *m = RewardCalculationDetails{} }
func (m *RewardCalculationDetails) String() string { return proto.CompactTextString(m) }
func (*RewardCalculationDetails) ProtoMessage()    {}
func (*RewardCalculationDetails) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{25}
}
func (m *RewardCalculationDetails) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardCalculationDetails) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardCalculationDetails.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardCalculationDetails) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardCalculationDetails.Merge(m, src)
}
func (m *RewardCalculationDetails) XXX_Size() int {
	return m.Size()
}
func (m *RewardCalculationDetails) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardCalculationDetails.DiscardUnknown(m)
}

var xxx_messageInfo_RewardCalculationDetails proto.InternalMessageInfo

func (m *RewardCalculationDetails) GetTotalUsageValue() string {
	if m != nil {
		return m.TotalUsageValue
	}
	return ""
}

func (m *RewardCalculationDetails) GetRewardPoolContribution() string {
	if m != nil {
		return m.RewardPoolContribution
	}
	return ""
}

func (m *RewardCalculationDetails) GetPlatformFeeRate() string {
	if m != nil {
		return m.PlatformFeeRate
	}
	return ""
}

func (m *RewardCalculationDetails) GetNodeContributionFormula() string {
	if m != nil {
		return m.NodeContributionFormula
	}
	return ""
}

func (m *RewardCalculationDetails) GetInputMetrics() map[string]string {
	if m != nil {
		return m.InputMetrics
	}
	return nil
}

// HPCRewardRecord represents a reward distribution for HPC contribution
type HPCRewardRecord struct {
	RewardId               string                                   `protobuf:"bytes,1,opt,name=reward_id,json=rewardId,proto3" json:"reward_id" yaml:"reward_id"`
	JobId                  string                                   `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id" yaml:"job_id"`
	ClusterId              string                                   `protobuf:"bytes,3,opt,name=cluster_id,json=clusterId,proto3" json:"cluster_id" yaml:"cluster_id"`
	Source                 HPCRewardSource                          `protobuf:"varint,4,opt,name=source,proto3,enum=virtengine.hpc.v1.HPCRewardSource" json:"source" yaml:"source"`
	TotalReward            github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=total_reward,json=totalReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_reward" yaml:"total_reward"`
	Recipients             []HPCRewardRecipient                     `protobuf:"bytes,6,rep,name=recipients,proto3" json:"recipients" yaml:"recipients"`
	ReferencedUsageRecords []string                                 `protobuf:"bytes,7,rep,name=referenced_usage_records,json=referencedUsageRecords,proto3" json:"referenced_usage_records" yaml:"referenced_usage_records"`
	JobCompletionStatus    JobState                                 `protobuf:"varint,8,opt,name=job_completion_status,json=jobCompletionStatus,proto3,enum=virtengine.hpc.v1.JobState" json:"job_completion_status" yaml:"job_completion_status"`
	FormulaVersion         string                                   `protobuf:"bytes,9,opt,name=formula_version,json=formulaVersion,proto3" json:"formula_version" yaml:"formula_version"`
	CalculationDetails     RewardCalculationDetails                 `protobuf:"bytes,10,opt,name=calculation_details,json=calculationDetails,proto3" json:"calculation_details" yaml:"calculation_details"`
	Disputed               bool                                     `protobuf:"varint,11,opt,name=disputed,proto3" json:"disputed" yaml:"disputed"`
	DisputeId              string                                   `protobuf:"bytes,12,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty" yaml:"dispute_id"`
	IssuedAt               time.Time                                `protobuf:"bytes,13,opt,name=issued_at,json=issuedAt,proto3,stdtime" json:"issued_at" yaml:"issued_at"`
	BlockHeight            int64                                    `protobuf:"varint,14,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *HPCRewardRecord) Reset()         { *m = HPCRewardRecord{} }
func (m *HPCRewardRecord) String() string { return proto.CompactTextString(m) }
func (*HPCRewardRecord) ProtoMessage()    {}
func (*HPCRewardRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{26}
}
func (m *HPCRewardRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCRewardRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCRewardRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCRewardRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCRewardRecord.Merge(m, src)
}
func (m *HPCRewardRecord) XXX_Size() int {
	return m.Size()
}
func (m *HPCRewardRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCRewardRecord.DiscardUnknown(m)
}

var xxx_messageInfo_HPCRewardRecord proto.InternalMessageInfo

func (m *HPCRewardRecord) GetRewardId() string {
	if m != nil {
		return m.RewardId
	}
	return ""
}

func (m *HPCRewardRecord) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *HPCRewardRecord) GetClusterId() string {
	if m != nil {
		return m.ClusterId
	}
	return ""
}

func (m *HPCRewardRecord) GetSource() HPCRewardSource {
	if m != nil {
		return m.Source
	}
	return HPCRewardSourceUnspecified
}

func (m *HPCRewardRecord) GetTotalReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalReward
	}
	return nil
}

func (m *HPCRewardRecord) GetRecipients() []HPCRewardRecipient {
	if m != nil {
		return m.Recipients
	}
	return nil
}

func (m *HPCRewardRecord) GetReferencedUsageRecords() []string {
	if m != nil {
		return m.ReferencedUsageRecords
	}
	return nil
}

func (m *HPCRewardRecord) GetJobCompletionStatus() JobState {
	if m != nil {
		return m.JobCompletionStatus
	}
	return JobStateUnspecified
}

func (m *HPCRewardRecord) GetFormulaVersion() string {
	if m != nil {
		return m.FormulaVersion
	}
	return ""
}

func (m *HPCRewardRecord) GetCalculationDetails() RewardCalculationDetails {
	if m != nil {
		return m.CalculationDetails
	}
	return RewardCalculationDetails{}
}

func (m *HPCRewardRecord) GetDisputed() bool {
	if m != nil {
		return m.Disputed
	}
	return false
}

func (m *HPCRewardRecord) GetDisputeId() string {
	if m != nil {
		return m.DisputeId
	}
	return ""
}

func (m *HPCRewardRecord) GetIssuedAt() time.Time {
	if m != nil {
		return m.IssuedAt
	}
	return time.Time{}
}

func (m *HPCRewardRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// HPCDispute represents a dispute for HPC rewards/usage
type HPCDispute struct {
	DisputeId       string        `protobuf:"bytes,1,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id" yaml:"dispute_id"`
	JobId           string        `protobuf:"bytes,2,opt,name=job_id,json=jobId,proto3" json:"job_id" yaml:"job_id"`
	RewardId        string        `protobuf:"bytes,3,opt,name=reward_id,json=rewardId,proto3" json:"reward_id,omitempty" yaml:"reward_id"`
	DisputerAddress string        `protobuf:"bytes,4,opt,name=disputer_address,json=disputerAddress,proto3" json:"disputer_address" yaml:"disputer_address"`
	DisputeType     string        `protobuf:"bytes,5,opt,name=dispute_type,json=disputeType,proto3" json:"dispute_type" yaml:"dispute_type"`
	Reason          string        `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	Evidence        string        `protobuf:"bytes,7,opt,name=evidence,proto3" json:"evidence,omitempty" yaml:"evidence"`
	Status          DisputeStatus `protobuf:"varint,8,opt,name=status,proto3,enum=virtengine.hpc.v1.DisputeStatus" json:"status" yaml:"status"`
	Resolution      string        `protobuf:"bytes,9,opt,name=resolution,proto3" json:"resolution,omitempty" yaml:"resolution"`
	ResolverAddress string        `protobuf:"bytes,10,opt,name=resolver_address,json=resolverAddress,proto3" json:"resolver_address,omitempty" yaml:"resolver_address"`
	CreatedAt       time.Time     `protobuf:"bytes,11,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	ResolvedAt      *time.Time    `protobuf:"bytes,12,opt,name=resolved_at,json=resolvedAt,proto3,stdtime" json:"resolved_at,omitempty" yaml:"resolved_at"`
	BlockHeight     int64         `protobuf:"varint,13,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *HPCDispute) Reset()         { *m = HPCDispute{} }
func (m *HPCDispute) String() string { return proto.CompactTextString(m) }
func (*HPCDispute) ProtoMessage()    {}
func (*HPCDispute) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{27}
}
func (m *HPCDispute) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HPCDispute) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HPCDispute.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HPCDispute) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HPCDispute.Merge(m, src)
}
func (m *HPCDispute) XXX_Size() int {
	return m.Size()
}
func (m *HPCDispute) XXX_DiscardUnknown() {
	xxx_messageInfo_HPCDispute.DiscardUnknown(m)
}

var xxx_messageInfo_HPCDispute proto.InternalMessageInfo

func (m *HPCDispute) GetDisputeId() string {
	if m != nil {
		return m.DisputeId
	}
	return ""
}

func (m *HPCDispute) GetJobId() string {
	if m != nil {
		return m.JobId
	}
	return ""
}

func (m *HPCDispute) GetRewardId() string {
	if m != nil {
		return m.RewardId
	}
	return ""
}

func (m *HPCDispute) GetDisputerAddress() string {
	if m != nil {
		return m.DisputerAddress
	}
	return ""
}

func (m *HPCDispute) GetDisputeType() string {
	if m != nil {
		return m.DisputeType
	}
	return ""
}

func (m *HPCDispute) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *HPCDispute) GetEvidence() string {
	if m != nil {
		return m.Evidence
	}
	return ""
}

func (m *HPCDispute) GetStatus() DisputeStatus {
	if m != nil {
		return m.Status
	}
	return DisputeStatusUnspecified
}

func (m *HPCDispute) GetResolution() string {
	if m != nil {
		return m.Resolution
	}
	return ""
}

func (m *HPCDispute) GetResolverAddress() string {
	if m != nil {
		return m.ResolverAddress
	}
	return ""
}

func (m *HPCDispute) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *HPCDispute) GetResolvedAt() *time.Time {
	if m != nil {
		return m.ResolvedAt
	}
	return nil
}

func (m *HPCDispute) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// Params defines the parameters for the HPC module
type Params struct {
	PlatformFeeRate           string `protobuf:"bytes,1,opt,name=platform_fee_rate,json=platformFeeRate,proto3" json:"platform_fee_rate" yaml:"platform_fee_rate"`
	ProviderRewardRate        string `protobuf:"bytes,2,opt,name=provider_reward_rate,json=providerRewardRate,proto3" json:"provider_reward_rate" yaml:"provider_reward_rate"`
	NodeRewardRate            string `protobuf:"bytes,3,opt,name=node_reward_rate,json=nodeRewardRate,proto3" json:"node_reward_rate" yaml:"node_reward_rate"`
	MinJobDurationSeconds     int64  `protobuf:"varint,4,opt,name=min_job_duration_seconds,json=minJobDurationSeconds,proto3" json:"min_job_duration_seconds" yaml:"min_job_duration_seconds"`
	MaxJobDurationSeconds     int64  `protobuf:"varint,5,opt,name=max_job_duration_seconds,json=maxJobDurationSeconds,proto3" json:"max_job_duration_seconds" yaml:"max_job_duration_seconds"`
	DefaultIdentityThreshold  int32  `protobuf:"varint,6,opt,name=default_identity_threshold,json=defaultIdentityThreshold,proto3" json:"default_identity_threshold" yaml:"default_identity_threshold"`
	ClusterHeartbeatTimeout   int64  `protobuf:"varint,7,opt,name=cluster_heartbeat_timeout,json=clusterHeartbeatTimeout,proto3" json:"cluster_heartbeat_timeout" yaml:"cluster_heartbeat_timeout"`
	NodeHeartbeatTimeout      int64  `protobuf:"varint,8,opt,name=node_heartbeat_timeout,json=nodeHeartbeatTimeout,proto3" json:"node_heartbeat_timeout" yaml:"node_heartbeat_timeout"`
	LatencyWeightFactor       string `protobuf:"bytes,9,opt,name=latency_weight_factor,json=latencyWeightFactor,proto3" json:"latency_weight_factor" yaml:"latency_weight_factor"`
	CapacityWeightFactor      string `protobuf:"bytes,10,opt,name=capacity_weight_factor,json=capacityWeightFactor,proto3" json:"capacity_weight_factor" yaml:"capacity_weight_factor"`
	MaxLatencyMs              int64  `protobuf:"varint,11,opt,name=max_latency_ms,json=maxLatencyMs,proto3" json:"max_latency_ms" yaml:"max_latency_ms"`
	DisputeResolutionPeriod   int64  `protobuf:"varint,12,opt,name=dispute_resolution_period,json=disputeResolutionPeriod,proto3" json:"dispute_resolution_period" yaml:"dispute_resolution_period"`
	RewardFormulaVersion      string `protobuf:"bytes,13,opt,name=reward_formula_version,json=rewardFormulaVersion,proto3" json:"reward_formula_version" yaml:"reward_formula_version"`
	EnableProximityClustering bool   `protobuf:"varint,14,opt,name=enable_proximity_clustering,json=enableProximityClustering,proto3" json:"enable_proximity_clustering" yaml:"enable_proximity_clustering"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_fa86d97942c2f91a, []int{28}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetPlatformFeeRate() string {
	if m != nil {
		return m.PlatformFeeRate
	}
	return ""
}

func (m *Params) GetProviderRewardRate() string {
	if m != nil {
		return m.ProviderRewardRate
	}
	return ""
}

func (m *Params) GetNodeRewardRate() string {
	if m != nil {
		return m.NodeRewardRate
	}
	return ""
}

func (m *Params) GetMinJobDurationSeconds() int64 {
	if m != nil {
		return m.MinJobDurationSeconds
	}
	return 0
}

func (m *Params) GetMaxJobDurationSeconds() int64 {
	if m != nil {
		return m.MaxJobDurationSeconds
	}
	return 0
}

func (m *Params) GetDefaultIdentityThreshold() int32 {
	if m != nil {
		return m.DefaultIdentityThreshold
	}
	return 0
}

func (m *Params) GetClusterHeartbeatTimeout() int64 {
	if m != nil {
		return m.ClusterHeartbeatTimeout
	}
	return 0
}

func (m *Params) GetNodeHeartbeatTimeout() int64 {
	if m != nil {
		return m.NodeHeartbeatTimeout
	}
	return 0
}

func (m *Params) GetLatencyWeightFactor() string {
	if m != nil {
		return m.LatencyWeightFactor
	}
	return ""
}

func (m *Params) GetCapacityWeightFactor() string {
	if m != nil {
		return m.CapacityWeightFactor
	}
	return ""
}

func (m *Params) GetMaxLatencyMs() int64 {
	if m != nil {
		return m.MaxLatencyMs
	}
	return 0
}

func (m *Params) GetDisputeResolutionPeriod() int64 {
	if m != nil {
		return m.DisputeResolutionPeriod
	}
	return 0
}

func (m *Params) GetRewardFormulaVersion() string {
	if m != nil {
		return m.RewardFormulaVersion
	}
	return ""
}

func (m *Params) GetEnableProximityClustering() bool {
	if m != nil {
		return m.EnableProximityClustering
	}
	return false
}

func init() {
	proto.RegisterEnum("virtengine.hpc.v1.ClusterState", ClusterState_name, ClusterState_value)
	proto.RegisterEnum("virtengine.hpc.v1.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("virtengine.hpc.v1.NodeState", NodeState_name, NodeState_value)
	proto.RegisterEnum("virtengine.hpc.v1.HealthStatus", HealthStatus_name, HealthStatus_value)
	proto.RegisterEnum("virtengine.hpc.v1.HPCRewardSource", HPCRewardSource_name, HPCRewardSource_value)
	proto.RegisterEnum("virtengine.hpc.v1.DisputeStatus", DisputeStatus_name, DisputeStatus_value)
	proto.RegisterType((*Partition)(nil), "virtengine.hpc.v1.Partition")
	proto.RegisterType((*ClusterMetadata)(nil), "virtengine.hpc.v1.ClusterMetadata")
	proto.RegisterType((*HPCCluster)(nil), "virtengine.hpc.v1.HPCCluster")
	proto.RegisterType((*QueueOption)(nil), "virtengine.hpc.v1.QueueOption")
	proto.RegisterType((*HPCPricing)(nil), "virtengine.hpc.v1.HPCPricing")
	proto.RegisterType((*JobResources)(nil), "virtengine.hpc.v1.JobResources")
	proto.RegisterType((*PreconfiguredWorkload)(nil), "virtengine.hpc.v1.PreconfiguredWorkload")
	proto.RegisterType((*HPCOffering)(nil), "virtengine.hpc.v1.HPCOffering")
	proto.RegisterType((*JobWorkloadSpec)(nil), "virtengine.hpc.v1.JobWorkloadSpec")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.hpc.v1.JobWorkloadSpec.EnvironmentEntry")
	proto.RegisterType((*DataReference)(nil), "virtengine.hpc.v1.DataReference")
	proto.RegisterType((*HPCUsageMetrics)(nil), "virtengine.hpc.v1.HPCUsageMetrics")
	proto.RegisterType((*HPCJob)(nil), "virtengine.hpc.v1.HPCJob")
	proto.RegisterType((*NodeReward)(nil), "virtengine.hpc.v1.NodeReward")
	proto.RegisterType((*JobAccounting)(nil), "virtengine.hpc.v1.JobAccounting")
	proto.RegisterType((*LatencyMeasurement)(nil), "virtengine.hpc.v1.LatencyMeasurement")
	proto.RegisterType((*NodeResources)(nil), "virtengine.hpc.v1.NodeResources")
	proto.RegisterType((*NodeCapacity)(nil), "virtengine.hpc.v1.NodeCapacity")
	proto.RegisterType((*NodeHealth)(nil), "virtengine.hpc.v1.NodeHealth")
	proto.RegisterType((*NodeHardware)(nil), "virtengine.hpc.v1.NodeHardware")
	proto.RegisterType((*NodeTopology)(nil), "virtengine.hpc.v1.NodeTopology")
	proto.RegisterType((*NodeLocality)(nil), "virtengine.hpc.v1.NodeLocality")
	proto.RegisterType((*NodeMetadata)(nil), "virtengine.hpc.v1.NodeMetadata")
	proto.RegisterType((*ClusterCandidate)(nil), "virtengine.hpc.v1.ClusterCandidate")
	proto.RegisterType((*SchedulingDecision)(nil), "virtengine.hpc.v1.SchedulingDecision")
	proto.RegisterType((*HPCRewardRecipient)(nil), "virtengine.hpc.v1.HPCRewardRecipient")
	proto.RegisterType((*RewardCalculationDetails)(nil), "virtengine.hpc.v1.RewardCalculationDetails")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.hpc.v1.RewardCalculationDetails.InputMetricsEntry")
	proto.RegisterType((*HPCRewardRecord)(nil), "virtengine.hpc.v1.HPCRewardRecord")
	proto.RegisterType((*HPCDispute)(nil), "virtengine.hpc.v1.HPCDispute")
	proto.RegisterType((*Params)(nil), "virtengine.hpc.v1.Params")
}

func init() { proto.RegisterFile("virtengine/hpc/v1/types.proto", fileDescriptor_fa86d97942c2f91a) }

var fileDescriptor_fa86d97942c2f91a = []byte{
	// 8229 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x7d, 0x5b, 0x6c, 0x5c, 0xc9,
	0x99, 0xde, 0x34, 0xef, 0x5d, 0xec, 0x6e, 0x36, 0x0f, 0x29, 0xf1, 0xa2, 0x19, 0x35, 0xa7, 0x0c,
	0xc3, 0xb2, 0xbd, 0x96, 0xa2, 0x19, 0x6b, 0x27, 0xf6, 0xc4, 0x76, 0xc8, 0x66, 0x4b, 0xa4, 0x2c,
	0x51, 0x9c, 0x22, 0x29, 0xed, 0x78, 0xed, 0x3d, 0x3e, 0x7d, 0x4e, 0xb1, 0x79, 0x46, 0xdd, 0xe7,
	0xf4, 0x9c, 0x0b, 0x29, 0x4e, 0xe2, 0x04, 0x9b, 0xd8, 0xb9, 0x28, 0x31, 0xe0, 0x97, 0x45, 0x90,
	0x00, 0xca, 0x05, 0xfb, 0x94, 0x3c, 0xe4, 0x29, 0x0f, 0xc9, 0x43, 0x1e, 0x92, 0xa7, 0x7d, 0x08,
	0x82, 0x45, 0x82, 0x04, 0x41, 0x10, 0xf4, 0x06, 0x76, 0x82, 0x04, 0x44, 0x1e, 0x02, 0x3e, 0xec,
	0x53, 0x1e, 0x82, 0xba, 0x57, 0x9d, 0xae, 0xa6, 0x38, 0x92, 0xc6, 0x8b, 0x05, 0xf6, 0x89, 0x5d,
	0xff, 0xf7, 0x57, 0xfd, 0x75, 0xea, 0xf2, 0xd7, 0x5f, 0x7f, 0xfd, 0x55, 0x04, 0xef, 0x1c, 0x87,
	0x49, 0x86, 0xa3, 0x4e, 0x18, 0xe1, 0x5b, 0x47, 0x7d, 0xff, 0xd6, 0xf1, 0xed, 0x5b, 0xd9, 0x69,
	0x1f, 0xa7, 0x37, 0xfb, 0x49, 0x9c, 0xc5, 0xce, 0xbc, 0x82, 0x6f, 0x1e, 0xf5, 0xfd, 0x9b, 0xc7,
	0xb7, 0x57, 0x17, 0x3b, 0x71, 0x27, 0xa6, 0xe8, 0x2d, 0xf2, 0x8b, 0x31, 0xae, 0xae, 0xf8, 0x71,
	0xda, 0x8b, 0x53, 0x97, 0x01, 0x2c, 0xc1, 0xa1, 0xeb, 0x2c, 0x75, 0xab, 0xed, 0xa5, 0xf8, 0xd6,
	0xf1, 0xed, 0x36, 0xce, 0xbc, 0xdb, 0xb7, 0xfc, 0x38, 0x8c, 0x38, 0xde, 0xe8, 0xc4, 0x71, 0xa7,
	0x8b, 0x6f, 0xd1, 0x54, 0x3b, 0x3f, 0xbc, 0x95, 0x85, 0x3d, 0x9c, 0x66, 0x5e, 0xaf, 0xcf, 0x18,
	0xe0, 0x4f, 0x27, 0x40, 0x79, 0xd7, 0x4b, 0xb2, 0x30, 0x0b, 0xe3, 0xc8, 0xf9, 0x3a, 0x98, 0x88,
	0xbc, 0x1e, 0x5e, 0x2e, 0xad, 0x95, 0x6e, 0x94, 0x37, 0x96, 0xce, 0x06, 0x0d, 0x9a, 0x3e, 0x1f,
	0x34, 0x66, 0x4f, 0xbd, 0x5e, 0xf7, 0xdb, 0x90, 0xa4, 0x20, 0xa2, 0x44, 0xe7, 0x16, 0x98, 0x8c,
	0xe2, 0x00, 0xa7, 0xcb, 0x63, 0x6b, 0xa5, 0x1b, 0x93, 0x1b, 0x2b, 0x67, 0x83, 0x06, 0x23, 0x9c,
	0x0f, 0x1a, 0x15, 0xce, 0x4e, 0x92, 0x10, 0x31, 0xb2, 0x73, 0x17, 0xcc, 0xf6, 0xbc, 0x67, 0x6e,
	0x92, 0x47, 0xa4, 0x16, 0xcb, 0xe3, 0x6b, 0xa5, 0x1b, 0xe3, 0x1b, 0x5f, 0x3e, 0x1b, 0x34, 0x74,
	0xf2, 0xf9, 0xa0, 0xe1, 0xb0, 0xcc, 0x1a, 0x11, 0x22, 0xd0, 0xf3, 0x9e, 0x21, 0x96, 0x70, 0x1e,
	0x83, 0xb9, 0x00, 0x1f, 0x7a, 0x79, 0x37, 0x93, 0x65, 0x4d, 0xd0, 0xb2, 0xbe, 0x71, 0x36, 0x68,
	0x14, 0xa1, 0xf3, 0x41, 0xe3, 0x2a, 0x2b, 0xaf, 0x00, 0x40, 0x54, 0xe3, 0x14, 0x51, 0xee, 0x77,
	0x41, 0x99, 0xc8, 0x64, 0x1f, 0x35, 0x49, 0x3f, 0xea, 0xdd, 0xb3, 0x41, 0x43, 0x11, 0xcf, 0x07,
	0x8d, 0xba, 0xaa, 0x1b, 0xff, 0xb8, 0x99, 0x9e, 0xf7, 0x6c, 0x87, 0x7e, 0x5f, 0x0b, 0xcc, 0x1c,
	0x62, 0x2f, 0xcb, 0x13, 0x9c, 0x2e, 0x4f, 0xad, 0x8d, 0xdf, 0x28, 0x6f, 0x7c, 0xf5, 0x6c, 0xd0,
	0x70, 0x04, 0xed, 0x37, 0xe2, 0x5e, 0x98, 0xe1, 0x5e, 0x3f, 0x3b, 0x3d, 0x1f, 0x34, 0xe6, 0x58,
	0x39, 0x02, 0x83, 0x48, 0x66, 0x75, 0x3e, 0x04, 0x33, 0xfd, 0x24, 0x8c, 0x93, 0x30, 0x3b, 0x5d,
	0x9e, 0xa6, 0xb5, 0x68, 0x9c, 0x0d, 0x1a, 0x92, 0xa6, 0x32, 0x0b, 0x0a, 0x44, 0x12, 0x24, 0x9d,
	0x92, 0x66, 0x5e, 0x86, 0x97, 0x67, 0x68, 0x17, 0xd2, 0x4e, 0xa1, 0x04, 0xd5, 0x29, 0x34, 0x09,
	0x11, 0x23, 0x7f, 0x7b, 0xe2, 0x7f, 0xff, 0xe3, 0xc6, 0x5b, 0xf0, 0x7f, 0x4c, 0x80, 0xb9, 0x66,
	0x37, 0x4f, 0x33, 0x9c, 0x3c, 0xc4, 0x99, 0x17, 0x78, 0x99, 0xe7, 0x1c, 0x80, 0xb9, 0x2c, 0xce,
	0xbc, 0xae, 0xeb, 0xf7, 0x73, 0xd7, 0x8f, 0xc9, 0x57, 0x95, 0x54, 0x33, 0x17, 0x20, 0xd5, 0xcc,
	0x05, 0x00, 0xa2, 0x2a, 0xa5, 0x34, 0xfb, 0x79, 0x93, 0xa4, 0x55, 0xb1, 0x3d, 0xdc, 0x8b, 0x93,
	0x53, 0xb7, 0xd3, 0xa6, 0x03, 0xc8, 0x28, 0x56, 0x42, 0xc5, 0x62, 0x25, 0x20, 0x8a, 0x7d, 0x48,
	0x09, 0xf7, 0xda, 0xce, 0x03, 0x00, 0x18, 0x4b, 0xa7, 0x9f, 0xa7, 0x7c, 0x6c, 0x91, 0x12, 0x17,
	0x15, 0xd5, 0xe8, 0x80, 0x79, 0xbd, 0x58, 0x82, 0x42, 0x54, 0xa6, 0x89, 0x7b, 0xfd, 0x3c, 0x75,
	0xb6, 0x40, 0xb9, 0xd3, 0xcf, 0x5d, 0x3a, 0x5d, 0x97, 0x27, 0x68, 0x5f, 0x7e, 0xfd, 0x6c, 0xd0,
	0x58, 0x90, 0x44, 0xa3, 0x2c, 0x3e, 0x28, 0x24, 0x08, 0xd1, 0x4c, 0xa7, 0x9f, 0xef, 0x93, 0x9f,
	0xce, 0xef, 0x80, 0xf9, 0x30, 0xca, 0x70, 0xe2, 0xc7, 0x51, 0x84, 0xfd, 0x8c, 0x32, 0xd0, 0xc1,
	0x55, 0xde, 0xb8, 0x7d, 0x36, 0x68, 0x0c, 0x83, 0xe7, 0x83, 0xc6, 0x32, 0x2b, 0x6f, 0x08, 0x82,
	0xa8, 0xae, 0xd3, 0x88, 0x00, 0xe7, 0x3e, 0xa8, 0xa4, 0x59, 0x9c, 0x78, 0x1d, 0xcc, 0x8a, 0x9e,
	0xa2, 0x45, 0x7f, 0xe5, 0x6c, 0xd0, 0x30, 0xe8, 0xe7, 0x83, 0xc6, 0x82, 0xe8, 0x7e, 0x45, 0x85,
	0x68, 0x96, 0x27, 0x69, 0x59, 0x1f, 0x83, 0x3a, 0x6b, 0x0f, 0xc1, 0xd3, 0x69, 0xd3, 0x11, 0x38,
	0xbe, 0x71, 0xeb, 0x6c, 0xd0, 0x18, 0xc2, 0xce, 0x07, 0x8d, 0x25, 0xbd, 0x15, 0x15, 0x02, 0x51,
	0x8d, 0x92, 0xf6, 0x18, 0xe5, 0x5e, 0x9b, 0x0f, 0xb3, 0x7f, 0x0b, 0x00, 0xd8, 0xda, 0x6d, 0xf2,
	0x91, 0xe6, 0x6c, 0x00, 0xe0, 0xb3, 0x9f, 0x6e, 0x18, 0x70, 0xa5, 0xf3, 0xa5, 0xb3, 0x41, 0x43,
	0xa3, 0xaa, 0x9e, 0x52, 0x34, 0x88, 0xca, 0x3c, 0xb1, 0x1d, 0x38, 0x09, 0xa8, 0xf7, 0x93, 0xf8,
	0x38, 0x0c, 0x70, 0xe2, 0x7a, 0x41, 0x90, 0xe0, 0x94, 0x29, 0xa4, 0xf2, 0xc6, 0x3d, 0x52, 0xe7,
	0x22, 0xa6, 0xea, 0x5c, 0x44, 0xe0, 0x7f, 0xf8, 0x17, 0xdf, 0x58, 0xe4, 0xca, 0x75, 0x9d, 0x91,
	0xf6, 0xb2, 0x24, 0x8c, 0x3a, 0x68, 0x4e, 0xb0, 0x72, 0xb2, 0x54, 0x93, 0xe3, 0x97, 0x51, 0x93,
	0x1f, 0x81, 0xd9, 0x00, 0xa7, 0x7e, 0x12, 0xf6, 0x89, 0x8a, 0xa5, 0x9a, 0xaa, 0x4c, 0xdb, 0xf3,
	0x8a, 0x46, 0x36, 0x86, 0x93, 0x23, 0xf4, 0x95, 0x84, 0x21, 0xd2, 0xcb, 0x70, 0x76, 0xc5, 0x24,
	0x27, 0xe3, 0xa8, 0xf6, 0x5e, 0xe3, 0xe6, 0xd0, 0x4a, 0x72, 0x93, 0x37, 0xf1, 0x1e, 0x61, 0x7b,
	0xb9, 0x16, 0x70, 0x30, 0x00, 0x7d, 0xb1, 0x0a, 0x30, 0xe5, 0x35, 0xfb, 0xde, 0xdb, 0x96, 0x62,
	0xe5, 0x52, 0xb1, 0xf1, 0x95, 0x3f, 0x18, 0x34, 0xde, 0x22, 0x7d, 0xa5, 0xf2, 0xa9, 0xbe, 0x52,
	0x34, 0x88, 0x34, 0x06, 0xb2, 0x02, 0xb0, 0xa1, 0xc2, 0x74, 0x2c, 0xd3, 0x6e, 0x74, 0x05, 0xd0,
	0xc8, 0xaa, 0x05, 0x34, 0x22, 0x44, 0x6c, 0x7a, 0x33, 0x4d, 0xfb, 0x18, 0xcc, 0x79, 0xc7, 0x5e,
	0xd8, 0xf5, 0xda, 0x5d, 0xcc, 0xcb, 0x9a, 0xa1, 0x65, 0x51, 0x1d, 0x52, 0x80, 0x94, 0x0e, 0x29,
	0x00, 0x10, 0xd5, 0x24, 0x85, 0x95, 0xfb, 0x3e, 0x98, 0x4a, 0x70, 0x87, 0x74, 0x53, 0x99, 0x76,
	0xd3, 0xb5, 0xb3, 0x41, 0x83, 0x53, 0xce, 0x07, 0x8d, 0x2a, 0x2b, 0x85, 0xa5, 0x21, 0xe2, 0x80,
	0xf3, 0xd7, 0x4a, 0xa0, 0x2e, 0x06, 0x67, 0x8f, 0x2b, 0xcf, 0x65, 0xb0, 0x56, 0xba, 0x31, 0xfb,
	0x1e, 0x1c, 0xdd, 0x33, 0x42, 0xcd, 0x6e, 0xbc, 0xcf, 0x1b, 0x72, 0xa8, 0x0c, 0x35, 0x54, 0x8b,
	0x08, 0x44, 0x73, 0x7e, 0x41, 0x59, 0xef, 0x80, 0x6a, 0xda, 0xcd, 0x93, 0x9e, 0x7b, 0x8c, 0x93,
	0x94, 0x7c, 0xc0, 0x2c, 0xfd, 0x00, 0xb2, 0x00, 0x99, 0xc0, 0xf9, 0xa0, 0xb1, 0xc8, 0x47, 0x80,
	0x4e, 0x86, 0xa8, 0x42, 0xd3, 0x8f, 0x59, 0xd2, 0x39, 0x01, 0x57, 0x9e, 0xe6, 0x6d, 0x9c, 0x44,
	0x38, 0xc3, 0xa9, 0xab, 0xcd, 0xd2, 0x0a, 0x2d, 0xb7, 0x79, 0x36, 0x68, 0x34, 0xac, 0x0c, 0xc6,
	0x48, 0x7e, 0x9b, 0x49, 0xb2, 0x32, 0x42, 0xb4, 0xa0, 0xe8, 0x4d, 0x39, 0x9f, 0x0f, 0x01, 0xf0,
	0x13, 0xec, 0x65, 0x38, 0x70, 0xbd, 0x6c, 0xb9, 0x4a, 0x9b, 0x71, 0xf5, 0x26, 0x33, 0x63, 0x6e,
	0x0a, 0x33, 0xe6, 0xe6, 0xbe, 0x30, 0x63, 0x36, 0xbe, 0x2e, 0xc6, 0xa1, 0xca, 0xa5, 0xe9, 0x0c,
	0x49, 0x83, 0xbf, 0xf8, 0xa3, 0x46, 0x09, 0x95, 0x39, 0x61, 0x3d, 0x23, 0x72, 0xf2, 0x7e, 0x20,
	0xe4, 0xd4, 0x2e, 0x2f, 0x47, 0xe5, 0x52, 0x72, 0x14, 0x8d, 0xcb, 0xe1, 0x84, 0xf5, 0x8c, 0xe8,
	0xe7, 0x76, 0x37, 0xf6, 0x9f, 0xba, 0x47, 0x38, 0xec, 0x1c, 0x65, 0xcb, 0x73, 0x54, 0x9f, 0x52,
	0xfd, 0xac, 0xd3, 0x95, 0x7e, 0xd6, 0xa9, 0x10, 0xcd, 0xd2, 0xe4, 0x16, 0x4d, 0x71, 0x25, 0x3a,
	0x18, 0x07, 0xb3, 0x1f, 0xe5, 0x38, 0xc7, 0x8f, 0x98, 0x36, 0x40, 0xa0, 0x26, 0xa7, 0x98, 0xab,
	0x99, 0x6f, 0x64, 0xc1, 0x2a, 0x20, 0xe7, 0x83, 0xc6, 0x95, 0xc2, 0x0c, 0x75, 0x99, 0xae, 0xaa,
	0x4a, 0xc2, 0x0e, 0x51, 0x5a, 0xf7, 0x41, 0x25, 0x08, 0xd3, 0x7e, 0xd7, 0x3b, 0x65, 0x25, 0x8e,
	0xa9, 0x55, 0x45, 0xa7, 0xab, 0x5a, 0xeb, 0x54, 0xa2, 0xad, 0x58, 0x92, 0x96, 0x65, 0x98, 0x55,
	0xe3, 0x9f, 0xdf, 0xac, 0x2a, 0x98, 0x8d, 0x13, 0xaf, 0x6a, 0x36, 0xea, 0xe6, 0xd9, 0xe4, 0xab,
	0x9b, 0x67, 0x3f, 0x20, 0x0b, 0x4e, 0xe8, 0x63, 0xb7, 0x97, 0x77, 0xb3, 0xb0, 0xdf, 0x0d, 0x71,
	0xc2, 0x17, 0xdd, 0x5b, 0x6c, 0xc1, 0x31, 0x31, 0x7d, 0xc1, 0x31, 0x11, 0x48, 0x16, 0x96, 0xd0,
	0xc7, 0x0f, 0x25, 0x85, 0x77, 0xf0, 0xff, 0x9d, 0xa4, 0xab, 0xe4, 0x6e, 0x12, 0xfa, 0x61, 0xd4,
	0x71, 0x8e, 0xc0, 0x22, 0x31, 0xef, 0x69, 0xc3, 0xb8, 0x47, 0x71, 0x9e, 0xb8, 0x34, 0x1b, 0xef,
	0xe5, 0x0f, 0x88, 0x8d, 0x63, 0xc3, 0xcf, 0x07, 0x8d, 0x6b, 0x7c, 0x44, 0x59, 0x50, 0x88, 0xe6,
	0x09, 0x99, 0xb4, 0xf0, 0x56, 0x9c, 0x27, 0x44, 0x16, 0x76, 0x02, 0xb0, 0x20, 0xec, 0x36, 0x5d,
	0x10, 0xeb, 0xfc, 0x3b, 0xc4, 0xfe, 0xb1, 0xc0, 0xe7, 0x83, 0xc6, 0x2a, 0x9f, 0x6d, 0xc3, 0x20,
	0x44, 0x75, 0x9f, 0x19, 0x7e, 0x4a, 0xca, 0x6f, 0x83, 0x1a, 0xb1, 0x94, 0x34, 0x01, 0xe3, 0x52,
	0xc0, 0xb2, 0x89, 0x18, 0x7d, 0x72, 0x45, 0x59, 0x59, 0xba, 0x80, 0x4a, 0xa7, 0x9f, 0xab, 0xc2,
	0x8f, 0xc0, 0xa2, 0xb4, 0x11, 0x75, 0x11, 0x13, 0xaa, 0xb1, 0x6c, 0xb8, 0x6a, 0x2c, 0x1b, 0x0a,
	0xd1, 0x7c, 0x8f, 0xdb, 0x99, 0x4a, 0xd2, 0xc7, 0xa0, 0xae, 0x0c, 0x1e, 0x2e, 0x65, 0x52, 0x8d,
	0x83, 0x22, 0xa6, 0xc6, 0x41, 0x11, 0x81, 0xa8, 0x96, 0x0a, 0x3b, 0x49, 0x16, 0x1d, 0xe1, 0xec,
	0x24, 0x4e, 0x9e, 0xaa, 0xa2, 0xb5, 0x21, 0x56, 0xc4, 0x54, 0xd1, 0x45, 0x04, 0xa2, 0x1a, 0x27,
	0x89, 0xa2, 0x3f, 0x04, 0x33, 0x7e, 0x9e, 0x24, 0x38, 0xf2, 0xd9, 0xe6, 0xa2, 0xcc, 0x36, 0x17,
	0x82, 0xa6, 0x86, 0xbe, 0xa0, 0x40, 0x24, 0x41, 0xa2, 0x69, 0x7a, 0x61, 0x14, 0xf6, 0xf2, 0x9e,
	0xeb, 0x1f, 0x79, 0x49, 0x47, 0xec, 0x32, 0xa8, 0xa6, 0x31, 0x11, 0xd5, 0x5f, 0x26, 0x1d, 0xa2,
	0x2a, 0x27, 0x34, 0x69, 0x9a, 0x0f, 0xf9, 0xff, 0x33, 0x0e, 0x2a, 0xf7, 0xe3, 0x36, 0xc2, 0x69,
	0x9c, 0x27, 0x3e, 0x4e, 0xd5, 0xe6, 0xb2, 0x74, 0xc9, 0xcd, 0xe5, 0x8f, 0x81, 0x23, 0xf7, 0x1c,
	0x6e, 0x1f, 0x27, 0x74, 0xc0, 0xf3, 0xad, 0xe9, 0xfb, 0x64, 0x9e, 0x0f, 0xa3, 0xe7, 0x83, 0xc6,
	0x8a, 0x39, 0x72, 0x15, 0x46, 0x96, 0x58, 0xbe, 0x63, 0xd9, 0xc5, 0x09, 0x99, 0x26, 0x44, 0x82,
	0x1a, 0x1c, 0x52, 0xc2, 0xb8, 0x92, 0x30, 0x8c, 0x2a, 0x09, 0xc3, 0x18, 0x44, 0x73, 0x62, 0x50,
	0x09, 0x09, 0x4f, 0x40, 0x95, 0xec, 0x44, 0x54, 0xe1, 0x13, 0xb2, 0xf0, 0x25, 0x03, 0x30, 0xe6,
	0xc5, 0xa2, 0x9c, 0x17, 0x7a, 0xf5, 0x67, 0x49, 0x5a, 0x14, 0xbc, 0x01, 0x80, 0x66, 0xd2, 0xb3,
	0xad, 0x2d, 0x35, 0xb4, 0x0d, 0x63, 0x7e, 0xbe, 0x38, 0x3e, 0x21, 0x2a, 0xcb, 0x91, 0xe9, 0x6c,
	0x82, 0x19, 0xb1, 0xc1, 0xe1, 0x83, 0x91, 0xaa, 0x4f, 0x41, 0xb3, 0xa9, 0x4f, 0x81, 0x41, 0x34,
	0xcd, 0xf7, 0x43, 0xbc, 0xbb, 0x7f, 0x6f, 0x12, 0x5c, 0xd9, 0x4d, 0xb0, 0x1f, 0x47, 0x87, 0x61,
	0x27, 0x4f, 0x70, 0xf0, 0x24, 0x4e, 0x9e, 0x76, 0x63, 0x2f, 0x20, 0xca, 0xfe, 0x84, 0xff, 0x56,
	0x7b, 0x02, 0xaa, 0xec, 0x35, 0xb2, 0x52, 0xf6, 0x1a, 0x11, 0x22, 0x20, 0x52, 0xdb, 0x81, 0x34,
	0xd1, 0xc7, 0x2e, 0x63, 0xa2, 0xdf, 0x33, 0x4d, 0xf4, 0x71, 0x25, 0x54, 0x23, 0x5f, 0xc6, 0x30,
	0x7f, 0x0c, 0xe6, 0xfc, 0x38, 0xca, 0xbc, 0x30, 0x22, 0x26, 0x4e, 0xcf, 0xeb, 0x08, 0xc5, 0x43,
	0xed, 0xd2, 0x02, 0xa4, 0xec, 0xd2, 0x02, 0x00, 0x51, 0x4d, 0x52, 0xb6, 0x09, 0xc1, 0xf9, 0xb1,
	0xf2, 0x78, 0xf8, 0x71, 0xaf, 0xe7, 0x45, 0x01, 0x57, 0x35, 0x44, 0xa1, 0xad, 0x14, 0x20, 0xa3,
	0x27, 0x0a, 0xbe, 0x0f, 0xce, 0xa2, 0x7c, 0x1f, 0x4d, 0x46, 0x70, 0xfe, 0x66, 0x09, 0x38, 0x09,
	0xfe, 0x34, 0x0f, 0x13, 0x1c, 0xb8, 0x89, 0x98, 0x86, 0xb4, 0xa3, 0x67, 0xad, 0x1b, 0x0c, 0x7d,
	0xb6, 0x6e, 0x7c, 0xc0, 0x8d, 0x23, 0x4b, 0x11, 0x6a, 0x0a, 0x0c, 0x63, 0x10, 0xcd, 0x0b, 0xa2,
	0x9a, 0xf9, 0x44, 0x43, 0x79, 0x19, 0xee, 0xc4, 0x89, 0xa9, 0xa1, 0x38, 0x4d, 0xd3, 0x50, 0x9c,
	0x42, 0x34, 0x14, 0xff, 0xe9, 0x7c, 0x00, 0xa6, 0x85, 0x01, 0xcc, 0x54, 0xd3, 0x3b, 0x67, 0x83,
	0xc6, 0xb4, 0x32, 0x7d, 0x6b, 0x2c, 0xab, 0x34, 0x7a, 0x05, 0xc4, 0xc7, 0xe5, 0x7f, 0x9c, 0x05,
	0xb3, 0x5b, 0xbb, 0xcd, 0x47, 0x87, 0x87, 0x98, 0xec, 0xfc, 0xc8, 0x68, 0x8c, 0xf9, 0xef, 0xc2,
	0x68, 0xd4, 0xc8, 0x6a, 0x60, 0x68, 0x44, 0x88, 0x80, 0x48, 0x6d, 0x07, 0x85, 0x8d, 0xee, 0xd8,
	0x1b, 0xdb, 0xe8, 0x8e, 0xff, 0x9a, 0x36, 0xba, 0x13, 0xaf, 0xb0, 0xd1, 0x9d, 0x7c, 0x03, 0x1b,
	0xdd, 0x04, 0x54, 0x3f, 0x25, 0x96, 0xae, 0x1b, 0xf7, 0xf5, 0x9d, 0xe9, 0x75, 0xcb, 0x78, 0xd4,
	0x2c, 0xe2, 0x8d, 0x6f, 0xf0, 0xe1, 0x68, 0x66, 0x56, 0xaa, 0xd2, 0x20, 0x43, 0x54, 0xf9, 0x54,
	0xe5, 0x25, 0xf6, 0xdd, 0x74, 0x9f, 0x59, 0x5e, 0x74, 0xf8, 0xcd, 0xbe, 0xf7, 0x8e, 0x45, 0x9a,
	0x32, 0xcf, 0x36, 0xde, 0xe5, 0xc2, 0x44, 0x2e, 0x35, 0xca, 0x38, 0x01, 0x22, 0x01, 0x39, 0x3f,
	0x2b, 0x81, 0x6b, 0x72, 0x1a, 0x84, 0x01, 0x8e, 0xb2, 0x30, 0x3b, 0x75, 0xb3, 0xa3, 0x04, 0xa7,
	0x47, 0x71, 0x37, 0xe0, 0x9b, 0xd8, 0xd6, 0xd9, 0xa0, 0x71, 0x11, 0xdb, 0xf9, 0xa0, 0x01, 0x0b,
	0x53, 0x6a, 0x98, 0x09, 0xa2, 0x15, 0x81, 0x6e, 0x73, 0x70, 0x5f, 0x60, 0x0e, 0x06, 0x0b, 0x9a,
	0x99, 0xec, 0xa6, 0x44, 0x13, 0x07, 0x29, 0xdd, 0xf4, 0x8e, 0x33, 0x43, 0xcf, 0x02, 0x2b, 0x43,
	0xcf, 0x02, 0x12, 0x13, 0x49, 0x9a, 0xda, 0x7b, 0x8c, 0xe6, 0xfc, 0xf3, 0x12, 0x58, 0xea, 0xeb,
	0x6a, 0xde, 0x15, 0x1a, 0x3a, 0x5d, 0x06, 0xb4, 0x27, 0x6f, 0xd8, 0x7c, 0x0c, 0xb6, 0x85, 0x61,
	0xe3, 0xfb, 0xbc, 0x99, 0xdf, 0x1d, 0x51, 0xa0, 0x31, 0xb0, 0xae, 0x8b, 0x0e, 0xb0, 0xb2, 0x42,
	0x74, 0xb5, 0x6f, 0x93, 0x91, 0x3a, 0x3f, 0x01, 0x2b, 0x69, 0xde, 0xef, 0xc7, 0x49, 0x96, 0xba,
	0x7e, 0x9e, 0x66, 0x71, 0x4f, 0xab, 0x31, 0xd9, 0x51, 0xcf, 0x6c, 0xac, 0x13, 0x8d, 0x3b, 0x92,
	0xe9, 0x7c, 0xd0, 0x58, 0xe3, 0xab, 0xe8, 0x28, 0x16, 0x88, 0x96, 0x04, 0xd6, 0xa4, 0x90, 0x12,
	0xff, 0x3e, 0x98, 0xf2, 0xfc, 0x2c, 0x3c, 0xc6, 0x74, 0x97, 0x3d, 0xc3, 0xdc, 0x0f, 0x8c, 0xa2,
	0xdc, 0x0f, 0x2c, 0x0d, 0x11, 0x07, 0xfe, 0x6c, 0xc3, 0xfc, 0xd2, 0x0d, 0xf3, 0xdf, 0x9d, 0x02,
	0x73, 0xf7, 0xe3, 0xb6, 0x68, 0xe7, 0xbd, 0x3e, 0xf6, 0x6d, 0x2b, 0x75, 0xe9, 0x4d, 0xac, 0xd4,
	0x1f, 0x80, 0x69, 0xb1, 0x42, 0x8f, 0xa9, 0x05, 0x88, 0x93, 0x94, 0x6a, 0x90, 0xeb, 0xb0, 0x80,
	0x9c, 0x6d, 0x50, 0xf6, 0x92, 0x4e, 0xde, 0xc3, 0x51, 0x46, 0xf4, 0xba, 0xf4, 0x38, 0x4b, 0xa2,
	0xcd, 0xe3, 0x2c, 0x41, 0x88, 0x54, 0x6e, 0xe7, 0x6f, 0x94, 0xc0, 0x2c, 0x8e, 0x8e, 0xc3, 0x24,
	0x8e, 0x08, 0x81, 0xfa, 0xaf, 0x67, 0xdf, 0x7b, 0xdf, 0xbe, 0x88, 0xeb, 0xad, 0x72, 0xb3, 0xa5,
	0x72, 0xb5, 0xa2, 0x2c, 0x39, 0x65, 0xea, 0x5b, 0x2b, 0xcb, 0xa6, 0xbe, 0x35, 0x18, 0x22, 0x5d,
	0xb0, 0x73, 0x04, 0xe6, 0xc9, 0xb0, 0x27, 0x2b, 0x62, 0x10, 0x26, 0xd8, 0xcf, 0xc8, 0x9a, 0xce,
	0xd6, 0x85, 0x0f, 0x89, 0x8e, 0x1b, 0x02, 0x8d, 0xe2, 0x97, 0x95, 0x89, 0x67, 0x30, 0x41, 0x54,
	0xe7, 0xb4, 0x4d, 0x41, 0x22, 0xe6, 0xcb, 0x8a, 0x7d, 0xb6, 0x93, 0x05, 0x97, 0x99, 0xab, 0xdf,
	0x3f, 0x1b, 0x34, 0xbe, 0x34, 0x92, 0xc9, 0x10, 0xbd, 0x76, 0x91, 0xfe, 0xa0, 0x0b, 0xf3, 0x92,
	0x55, 0x83, 0x6c, 0x07, 0xce, 0x0f, 0x40, 0x3d, 0x4c, 0x5d, 0x03, 0xa5, 0xeb, 0xc8, 0x0c, 0xdb,
	0xbb, 0x15, 0x31, 0xb5, 0x4c, 0x17, 0x11, 0x88, 0xe6, 0xc2, 0xd4, 0xd0, 0x85, 0xab, 0xdf, 0x05,
	0xf5, 0x62, 0x0f, 0x39, 0x75, 0x30, 0xfe, 0x14, 0x9f, 0xb2, 0xc1, 0x8b, 0xc8, 0x4f, 0x67, 0x11,
	0x4c, 0x1e, 0x7b, 0xdd, 0x9c, 0xdb, 0xbe, 0x88, 0x25, 0xbe, 0x3d, 0xf6, 0xe7, 0x4b, 0x7c, 0x3a,
	0xfc, 0x7c, 0x1c, 0x54, 0x37, 0xbd, 0xcc, 0x43, 0xf8, 0x10, 0x93, 0x7d, 0x1d, 0xf5, 0xf6, 0x24,
	0x22, 0xa1, 0xec, 0x1c, 0x3a, 0xe5, 0x74, 0xba, 0x9a, 0x72, 0x3a, 0x15, 0xa2, 0x59, 0x99, 0x64,
	0x86, 0x37, 0xdd, 0x22, 0x68, 0x86, 0x37, 0x3f, 0x7f, 0xe0, 0x26, 0x03, 0xdb, 0x10, 0x50, 0xa2,
	0xf3, 0x15, 0x30, 0x9e, 0x27, 0x21, 0x37, 0x63, 0xae, 0x9c, 0x0d, 0x1a, 0x24, 0x79, 0x3e, 0x68,
	0x00, 0xae, 0x25, 0x92, 0x10, 0x22, 0x42, 0x72, 0xbe, 0x07, 0xca, 0x38, 0xf2, 0x93, 0xd3, 0x7e,
	0x86, 0x03, 0x6a, 0x8d, 0xcc, 0x30, 0x1f, 0x92, 0x24, 0xaa, 0x39, 0x21, 0x49, 0x10, 0x29, 0xd8,
	0x69, 0x81, 0x19, 0xff, 0x08, 0xfb, 0x4f, 0xd3, 0xbc, 0xc7, 0x47, 0x20, 0xdd, 0xbd, 0x08, 0x9a,
	0x6d, 0xf7, 0x22, 0x30, 0x62, 0x5f, 0xf2, 0x9f, 0xce, 0x03, 0x00, 0xd2, 0xf0, 0x33, 0xec, 0xb6,
	0x4f, 0x33, 0x6e, 0x1d, 0xf3, 0x53, 0x26, 0x45, 0xb5, 0x9d, 0x32, 0x29, 0x94, 0x6c, 0xa9, 0xc2,
	0xcf, 0xf0, 0x06, 0xf9, 0xcd, 0xfb, 0xe3, 0xf7, 0xa7, 0xc0, 0xdc, 0xd6, 0x6e, 0xf3, 0x20, 0xf5,
	0x3a, 0xf8, 0x21, 0xce, 0x92, 0xd0, 0x4f, 0x1d, 0x0f, 0x38, 0x27, 0x5e, 0xb7, 0xeb, 0xfa, 0x54,
	0xb7, 0x89, 0xf5, 0x99, 0x1d, 0xbf, 0xd1, 0xbd, 0xe6, 0x30, 0xaa, 0x0c, 0xed, 0x61, 0x8c, 0x4c,
	0x19, 0xaf, 0xdb, 0x6d, 0x12, 0x9a, 0x58, 0x9c, 0x3f, 0x06, 0x75, 0xe9, 0xb0, 0x11, 0x02, 0xc6,
	0xd4, 0x61, 0x4f, 0x11, 0xd3, 0xbc, 0xd1, 0x05, 0x84, 0x28, 0x41, 0xb6, 0x55, 0x16, 0x45, 0xff,
	0x08, 0xcc, 0xab, 0xfd, 0xae, 0x28, 0x9b, 0x1d, 0xc9, 0xd1, 0x33, 0xaf, 0x21, 0x50, 0xcd, 0xf6,
	0x21, 0x48, 0xdb, 0x26, 0x8b, 0xe2, 0x77, 0x01, 0xd9, 0xdc, 0xca, 0x82, 0x27, 0x64, 0xa5, 0xaf,
	0x68, 0x64, 0x9b, 0xa6, 0xd2, 0x60, 0x88, 0x40, 0xa7, 0x9f, 0x6b, 0x6d, 0xa1, 0x79, 0x65, 0x8e,
	0xe2, 0x3c, 0x61, 0x07, 0xc0, 0xe3, 0x43, 0xbe, 0x1c, 0x8a, 0x59, 0x7d, 0x39, 0x14, 0xd1, 0x7d,
	0x39, 0x5b, 0x84, 0xa0, 0xfb, 0x72, 0xe8, 0x00, 0x70, 0xc3, 0x88, 0x8f, 0x1b, 0xc3, 0x97, 0x23,
	0xb0, 0x61, 0x5f, 0x8e, 0x40, 0x94, 0x2f, 0x87, 0x0e, 0x9e, 0xed, 0x88, 0x34, 0xb3, 0xc9, 0x14,
	0xe7, 0x19, 0x3f, 0xaf, 0xa3, 0xcd, 0x3c, 0x04, 0xaa, 0x66, 0x1e, 0x82, 0x20, 0x9a, 0xd3, 0x4b,
	0x7f, 0x94, 0x67, 0x64, 0xd3, 0x22, 0x9d, 0x86, 0xec, 0x7c, 0x65, 0x9c, 0x6d, 0x5a, 0x14, 0x55,
	0x8d, 0x70, 0x45, 0x83, 0xa8, 0x1c, 0x71, 0xaf, 0x62, 0x2a, 0xca, 0x48, 0xdd, 0x3c, 0xc5, 0x01,
	0xb5, 0x2f, 0x27, 0x55, 0x19, 0x8c, 0x6a, 0x96, 0xc1, 0x68, 0xbc, 0x8c, 0xf4, 0x20, 0xc5, 0x01,
	0x9f, 0x25, 0x3f, 0x5d, 0x00, 0x53, 0x5b, 0xbb, 0xcd, 0xfb, 0x71, 0xdb, 0x79, 0x0f, 0x4c, 0x7d,
	0x12, 0xb7, 0x95, 0xa2, 0xa2, 0x66, 0x12, 0xa3, 0x28, 0x33, 0x89, 0xa5, 0x21, 0x9a, 0xfc, 0x24,
	0x6e, 0x6f, 0x07, 0xc5, 0x9d, 0xdc, 0xd8, 0x9b, 0xd9, 0xc9, 0x8d, 0xbf, 0xb1, 0x9d, 0xdc, 0xc4,
	0x17, 0xbc, 0x93, 0x4b, 0x40, 0x9d, 0x19, 0xa2, 0x9a, 0xcc, 0x49, 0x25, 0xb3, 0x88, 0x69, 0xb3,
	0xbd, 0x80, 0x5c, 0x20, 0x53, 0xb0, 0x0a, 0x99, 0x7b, 0x80, 0x9d, 0x29, 0xb9, 0xbc, 0xb7, 0xa6,
	0xe4, 0xa9, 0xf7, 0x55, 0x9d, 0x6e, 0xcc, 0xd4, 0x05, 0xfd, 0x6c, 0x4a, 0xf4, 0x21, 0xa0, 0xc9,
	0xfb, 0xb4, 0x23, 0x1f, 0x88, 0xb3, 0xcf, 0x69, 0x7a, 0xf6, 0x79, 0xcd, 0x6e, 0xd5, 0x5c, 0xf6,
	0xdc, 0x73, 0x03, 0x00, 0xb6, 0x19, 0xa4, 0xdb, 0xdc, 0x19, 0xd5, 0x9d, 0x8a, 0xaa, 0xba, 0x53,
	0xd1, 0x20, 0x2a, 0xd3, 0x04, 0x3d, 0xdf, 0x38, 0x06, 0x55, 0x69, 0x1a, 0xa4, 0x7d, 0xec, 0xd3,
	0x61, 0x6e, 0x3f, 0xfb, 0x2b, 0xd8, 0x5b, 0x6a, 0xa3, 0x6a, 0x14, 0xa0, 0x36, 0xaa, 0x06, 0x19,
	0xa2, 0xca, 0x89, 0x6e, 0xc2, 0x06, 0xa0, 0xac, 0x1c, 0x35, 0xe0, 0x72, 0x8e, 0x9a, 0x2f, 0x73,
	0x81, 0x65, 0xdd, 0x3f, 0x53, 0x17, 0x8b, 0xba, 0x74, 0xcb, 0x28, 0x98, 0x18, 0x93, 0x73, 0x81,
	0x97, 0x79, 0xae, 0x5c, 0xe4, 0xc9, 0x4e, 0x88, 0x18, 0x94, 0x6b, 0x16, 0x61, 0x86, 0x5d, 0xb1,
	0xf1, 0x21, 0x97, 0xb6, 0x52, 0x28, 0xc0, 0xea, 0xa1, 0x32, 0x59, 0x20, 0xaa, 0x05, 0x7a, 0x59,
	0xa9, 0xf3, 0xd7, 0x4b, 0x60, 0x59, 0xae, 0xe7, 0x6e, 0x18, 0xf5, 0xf3, 0x2c, 0x75, 0xfb, 0x31,
	0x0d, 0x88, 0xe0, 0xa7, 0x92, 0xdb, 0x67, 0x83, 0x06, 0x1c, 0xc5, 0x63, 0x08, 0x6d, 0x14, 0x6c,
	0x85, 0x02, 0x2f, 0x44, 0x57, 0x25, 0xb4, 0x4d, 0x91, 0x5d, 0x06, 0x50, 0x43, 0x53, 0xe5, 0x8a,
	0xf3, 0xcc, 0xa8, 0x46, 0x55, 0x19, 0x9a, 0x23, 0x99, 0x6c, 0x86, 0xe6, 0x48, 0x66, 0x88, 0x96,
	0x24, 0xf6, 0x88, 0x41, 0xa2, 0x26, 0x23, 0xf6, 0xf0, 0xb5, 0x37, 0xbc, 0x87, 0xff, 0xbd, 0x12,
	0xa8, 0x78, 0x9d, 0x04, 0xe3, 0x80, 0x1f, 0x44, 0xcc, 0xd1, 0xce, 0x5f, 0xb9, 0xc9, 0x75, 0x40,
	0xdb, 0x4b, 0xf1, 0x4d, 0x1e, 0x79, 0x76, 0xb3, 0x19, 0x87, 0xd1, 0xc6, 0x13, 0xde, 0xeb, 0x46,
	0x36, 0x35, 0xb5, 0x75, 0x2a, 0xfc, 0x67, 0x7f, 0xd4, 0xb8, 0xd1, 0x09, 0xb3, 0xa3, 0xbc, 0x7d,
	0xd3, 0x8f, 0x7b, 0x3c, 0xb6, 0x8d, 0xff, 0xf9, 0x46, 0x1a, 0x3c, 0xe5, 0x01, 0x73, 0xa4, 0xdc,
	0x14, 0xcd, 0xb2, 0xac, 0xec, 0x20, 0x63, 0x0b, 0x94, 0x71, 0xea, 0x27, 0xf1, 0x09, 0xd1, 0x2c,
	0x75, 0x79, 0x0c, 0xb1, 0x20, 0x89, 0xb6, 0xfd, 0x92, 0x04, 0x21, 0x9a, 0x61, 0xbf, 0xb7, 0x03,
	0xe7, 0x2f, 0x81, 0xab, 0xa9, 0x7f, 0x84, 0x83, 0xbc, 0x4b, 0xb7, 0x19, 0xd8, 0x0f, 0xd3, 0x30,
	0x8e, 0x48, 0xb1, 0xf3, 0xb4, 0xd8, 0xd6, 0xd9, 0xa0, 0xb1, 0x66, 0xe7, 0x30, 0x64, 0xbc, 0xc3,
	0x15, 0x8c, 0x95, 0x13, 0xa2, 0x45, 0x05, 0x6c, 0x72, 0xfa, 0x76, 0xe0, 0xfc, 0x10, 0xd4, 0x88,
	0x26, 0xca, 0x53, 0xb7, 0x87, 0x53, 0x62, 0x01, 0x2e, 0x3b, 0xea, 0x30, 0xcc, 0x44, 0x6c, 0x87,
	0x61, 0x26, 0x07, 0x44, 0x55, 0x46, 0x78, 0xc8, 0xd2, 0xb4, 0x91, 0x9e, 0x85, 0x99, 0xeb, 0xc7,
	0x01, 0x5e, 0x5e, 0xa0, 0xab, 0x2f, 0x6b, 0x24, 0x41, 0xb4, 0x36, 0x92, 0x00, 0x49, 0x23, 0x3d,
	0x0b, 0xb3, 0x66, 0x1c, 0x14, 0xbd, 0x0c, 0x8b, 0x5f, 0x98, 0x97, 0xe1, 0x08, 0x30, 0xcd, 0x4a,
	0xc5, 0x5c, 0x79, 0xa9, 0x18, 0x62, 0x43, 0x2d, 0xc8, 0x0c, 0xb6, 0xaf, 0x91, 0x20, 0x13, 0x35,
	0xc3, 0xd2, 0xeb, 0x99, 0xd3, 0x05, 0x20, 0xcd, 0xbc, 0x84, 0x7f, 0xd1, 0xd5, 0x97, 0x8a, 0xba,
	0x4d, 0xcd, 0x7c, 0x99, 0xc3, 0x6a, 0xe6, 0x4b, 0x94, 0x7f, 0x17, 0x27, 0xac, 0x67, 0x4e, 0x06,
	0x2a, 0x7e, 0xdc, 0xeb, 0x77, 0x31, 0x97, 0xb7, 0xf4, 0x52, 0x79, 0x64, 0x04, 0x5c, 0xd5, 0xf3,
	0xd8, 0xd6, 0x49, 0x1d, 0x67, 0x32, 0x67, 0x25, 0xc9, 0xe2, 0x4b, 0x59, 0x7e, 0x6d, 0x5f, 0xca,
	0x1f, 0x8f, 0x03, 0xb0, 0x13, 0x07, 0x18, 0xe1, 0x13, 0x2f, 0x09, 0x9c, 0xdf, 0x04, 0xd3, 0xd4,
	0xf2, 0x93, 0xb6, 0x18, 0x75, 0x77, 0x70, 0x92, 0x72, 0x77, 0x70, 0x02, 0x44, 0x53, 0xe4, 0xd7,
	0x9f, 0x50, 0xd4, 0xd6, 0x5f, 0x01, 0x53, 0x5e, 0x2f, 0xce, 0xa3, 0x8c, 0xba, 0x57, 0x2e, 0x54,
	0x61, 0xc2, 0xd9, 0xc8, 0x33, 0x68, 0xce, 0x37, 0x9a, 0xfe, 0x7c, 0x6a, 0x8b, 0x17, 0xe2, 0x1c,
	0x82, 0x05, 0x3f, 0x8e, 0xb2, 0x24, 0x6c, 0xe7, 0x34, 0xf0, 0xe2, 0x84, 0xf5, 0xc9, 0x84, 0x76,
	0xba, 0x3e, 0x0c, 0x6b, 0xa7, 0xeb, 0xc3, 0x20, 0x44, 0x8e, 0x4e, 0x7d, 0x42, 0x89, 0xce, 0x0e,
	0xa8, 0xe6, 0x64, 0xf6, 0xcb, 0x25, 0x81, 0xed, 0x64, 0x68, 0x28, 0x90, 0x01, 0x28, 0x3b, 0xc3,
	0x20, 0x43, 0x54, 0xa1, 0x69, 0xbe, 0x02, 0xf0, 0x8e, 0xff, 0xfb, 0x35, 0x50, 0xbd, 0x1f, 0xb7,
	0xd7, 0x7d, 0x9f, 0x7c, 0x4c, 0x18, 0x75, 0x5e, 0xc9, 0x0c, 0xff, 0xd3, 0x7a, 0x10, 0x62, 0x33,
	0x9f, 0x27, 0xbe, 0x60, 0xf3, 0xf9, 0x58, 0xf4, 0x63, 0x8f, 0x39, 0x05, 0x68, 0x3f, 0xda, 0xed,
	0xca, 0x82, 0xfb, 0x40, 0xd9, 0x95, 0x46, 0x01, 0xc5, 0xfe, 0xe6, 0x64, 0xd1, 0xdf, 0xc2, 0xf7,
	0xf0, 0xf3, 0x92, 0x08, 0xa5, 0xf5, 0xe3, 0x34, 0xe3, 0x47, 0x2e, 0x17, 0x4c, 0x96, 0x3d, 0xa1,
	0xea, 0x55, 0xa6, 0x62, 0x7c, 0x2d, 0xa1, 0x7d, 0xbe, 0x49, 0xc3, 0x62, 0x71, 0x9b, 0x71, 0x9a,
	0x39, 0xff, 0xa4, 0x04, 0x64, 0x7f, 0xb8, 0x09, 0xd5, 0x3b, 0xcb, 0xd3, 0x2f, 0xab, 0xd4, 0x8f,
	0x78, 0xa5, 0x8a, 0x39, 0x95, 0xc1, 0x59, 0x00, 0x3e, 0x5f, 0xf5, 0x6a, 0x22, 0x37, 0xd7, 0x83,
	0x27, 0xa0, 0x42, 0x75, 0x1c, 0x2b, 0x8b, 0xec, 0x96, 0xc7, 0x47, 0x9c, 0x1c, 0x29, 0xe5, 0xb9,
	0x71, 0x87, 0xd7, 0xf1, 0xaa, 0x9e, 0xd5, 0xa6, 0xe5, 0x75, 0x1c, 0xa2, 0xd9, 0x48, 0x16, 0xc1,
	0xcc, 0xb3, 0x7e, 0xd7, 0xcb, 0x0e, 0xe3, 0xa4, 0xe7, 0x1e, 0x62, 0xbc, 0x5c, 0xbe, 0xb4, 0x79,
	0xa6, 0x67, 0x53, 0xb2, 0x74, 0xea, 0xe7, 0x34, 0xcf, 0x44, 0xd6, 0xbb, 0x18, 0x3b, 0xbf, 0x03,
	0xe6, 0x53, 0x9c, 0x65, 0x5d, 0xdc, 0xc3, 0x51, 0xe6, 0x32, 0xab, 0x84, 0x6e, 0x52, 0x78, 0xd8,
	0xf3, 0x10, 0xa8, 0x7c, 0x13, 0x43, 0x10, 0x44, 0x75, 0x45, 0xdb, 0xa3, 0x24, 0xe7, 0xb7, 0x40,
	0x55, 0xe3, 0x0b, 0x03, 0x1e, 0xef, 0x48, 0x43, 0x25, 0x0c, 0xc0, 0x16, 0x2a, 0x61, 0x30, 0x40,
	0x54, 0x51, 0xe9, 0xed, 0xc0, 0xc9, 0xc0, 0x52, 0x1a, 0x76, 0x22, 0x1c, 0xb8, 0x6c, 0x96, 0x24,
	0xd8, 0x8f, 0x93, 0xc0, 0x0d, 0x83, 0x74, 0xb9, 0x42, 0xdd, 0xf2, 0xdf, 0xa1, 0x32, 0xec, 0x2c,
	0xea, 0xec, 0x69, 0x04, 0x03, 0xb1, 0x03, 0x29, 0x42, 0xe7, 0x2b, 0xa2, 0xf4, 0xed, 0x20, 0x75,
	0x9e, 0x97, 0xc0, 0x15, 0xa2, 0x2b, 0xf9, 0xea, 0x4d, 0x74, 0x3c, 0x6f, 0xb4, 0xea, 0xcb, 0xf7,
	0xb9, 0xdf, 0x3a, 0x1b, 0x34, 0xec, 0xb9, 0x55, 0x0c, 0xa6, 0x15, 0x86, 0x68, 0xe1, 0x93, 0xb8,
	0xdd, 0x94, 0x64, 0xde, 0xb8, 0xa6, 0xb1, 0x57, 0xfb, 0xc2, 0x8c, 0xbd, 0x0c, 0x54, 0x0e, 0xc3,
	0xc8, 0xeb, 0x86, 0x9f, 0x31, 0x49, 0x73, 0x97, 0x33, 0x8a, 0xf4, 0x3c, 0xb6, 0xe9, 0xa2, 0xe3,
	0xdc, 0x28, 0x92, 0x24, 0x8b, 0x51, 0x54, 0x7f, 0x6d, 0xa3, 0xe8, 0xc5, 0x18, 0x70, 0x1e, 0x78,
	0x19, 0x8e, 0xfc, 0xd3, 0x87, 0xd8, 0x4b, 0xf3, 0x84, 0x8e, 0x25, 0xe7, 0x23, 0x50, 0xcb, 0xbc,
	0xa4, 0x83, 0x33, 0xd7, 0xb4, 0x91, 0x68, 0xb8, 0x94, 0x89, 0x28, 0x8b, 0xde, 0xa4, 0x43, 0x54,
	0x61, 0x84, 0x1d, 0x66, 0x37, 0x6d, 0x00, 0xd0, 0x65, 0x82, 0xdc, 0x9e, 0x70, 0xd7, 0xd2, 0xf5,
	0x53, 0x51, 0x55, 0xcb, 0x2b, 0x1a, 0x44, 0x65, 0x9e, 0x78, 0x98, 0x3a, 0x9f, 0x80, 0xd9, 0x1e,
	0xab, 0x25, 0x6d, 0xf4, 0xf1, 0x97, 0x36, 0xba, 0x58, 0x4d, 0xf4, 0x6c, 0x5a, 0xbc, 0xa5, 0x22,
	0xb2, 0xc6, 0x06, 0x82, 0xb2, 0x2e, 0xda, 0xe7, 0x3f, 0x8f, 0x81, 0x2a, 0xd3, 0x7b, 0xc2, 0xab,
	0xf0, 0x5d, 0x50, 0x36, 0x6f, 0x95, 0xf0, 0x98, 0x50, 0xfd, 0x3e, 0x49, 0xbd, 0x10, 0x9b, 0x05,
	0xd1, 0x8c, 0x08, 0xc9, 0xa2, 0x31, 0xa5, 0xc6, 0xf5, 0x11, 0x11, 0x53, 0xaa, 0x5d, 0x1c, 0xa9,
	0x17, 0x3c, 0xca, 0x10, 0xcd, 0x08, 0x4f, 0xb2, 0x73, 0x07, 0x4c, 0xc8, 0x7b, 0x22, 0x2c, 0x6b,
	0x6d, 0xe8, 0x86, 0xc8, 0xac, 0x8a, 0xab, 0x82, 0x88, 0xb2, 0x1b, 0x31, 0x50, 0x13, 0xaf, 0x1a,
	0x03, 0xf5, 0x26, 0xa2, 0xb1, 0x78, 0xc3, 0xfe, 0x9b, 0x32, 0xa8, 0x90, 0x86, 0x6d, 0x7a, 0x7d,
	0xcf, 0x0f, 0xb3, 0x53, 0xe7, 0x00, 0xcc, 0xa9, 0x58, 0x36, 0xba, 0x84, 0xf2, 0xd6, 0x65, 0xc7,
	0x9a, 0x26, 0xa4, 0x1d, 0x6b, 0x9a, 0x00, 0x44, 0x55, 0xd1, 0xd2, 0xfb, 0x24, 0xed, 0x60, 0x15,
	0x18, 0x9a, 0xba, 0x32, 0x66, 0x9e, 0x37, 0xbc, 0x11, 0x18, 0xaa, 0xc1, 0xc3, 0x81, 0xa1, 0x1a,
	0x08, 0xd1, 0xbc, 0x10, 0xb1, 0x2e, 0x68, 0x05, 0x31, 0xdd, 0x6e, 0xec, 0x13, 0x45, 0xc1, 0x3b,
	0xa9, 0x28, 0x46, 0xc0, 0x56, 0x31, 0x02, 0xd4, 0xc5, 0x08, 0x1a, 0x69, 0x24, 0x75, 0xcc, 0xc0,
	0x1a, 0x69, 0x42, 0x35, 0x52, 0x01, 0x52, 0x8d, 0x54, 0x00, 0x20, 0xaa, 0x8a, 0xe1, 0x24, 0x1b,
	0x49, 0xb1, 0xa8, 0x46, 0x9a, 0x54, 0xb5, 0xb7, 0xc0, 0x9a, 0x43, 0x66, 0x18, 0xd4, 0xe2, 0x4e,
	0x8d, 0x46, 0xd2, 0x58, 0x65, 0x23, 0x4d, 0x59, 0xc5, 0x0c, 0x37, 0x92, 0x05, 0xd4, 0xc5, 0xc8,
	0x46, 0xda, 0x00, 0x80, 0x46, 0x14, 0xb2, 0xf6, 0x99, 0x56, 0x83, 0x54, 0x51, 0xd5, 0x20, 0x55,
	0x34, 0x88, 0xca, 0x24, 0xc1, 0x5a, 0x04, 0xd1, 0x48, 0x5f, 0x7d, 0xc4, 0xcc, 0x48, 0x1f, 0x44,
	0x01, 0x31, 0xe2, 0x7b, 0x8d, 0x71, 0x42, 0x43, 0x22, 0xd5, 0xe7, 0xcb, 0x32, 0xe5, 0x97, 0x97,
	0x8b, 0x65, 0x6a, 0x1f, 0x6d, 0x94, 0xa9, 0xbe, 0x97, 0x95, 0x29, 0xbf, 0x55, 0x9f, 0xd6, 0xe0,
	0x95, 0xa7, 0xb5, 0x79, 0x88, 0xc4, 0xda, 0x6d, 0x96, 0xd6, 0xad, 0x78, 0x88, 0x24, 0x5a, 0x6f,
	0xf8, 0x10, 0x89, 0xb7, 0xa1, 0x3a, 0x44, 0x62, 0x0d, 0x19, 0x82, 0x45, 0x8d, 0x49, 0x35, 0x67,
	0x85, 0x16, 0xff, 0x01, 0xf3, 0x4c, 0x0c, 0xe3, 0x2a, 0xaa, 0xd9, 0x86, 0x42, 0xe4, 0x48, 0x31,
	0xaa, 0x7d, 0x0b, 0xa2, 0x64, 0x2b, 0x57, 0xed, 0xa2, 0xb4, 0xb6, 0xb6, 0x88, 0x52, 0x2d, 0xae,
	0x89, 0x12, 0x44, 0xae, 0xc3, 0xfe, 0x53, 0x8d, 0x79, 0x14, 0xb6, 0xb0, 0xd7, 0xcd, 0x8e, 0x9c,
	0x7d, 0x30, 0xc5, 0x0d, 0x9f, 0xd2, 0xc8, 0xcb, 0x4d, 0x8c, 0x95, 0x19, 0x2b, 0x6c, 0xdb, 0x29,
	0xad, 0x9d, 0xaa, 0xee, 0x17, 0x83, 0x88, 0x03, 0x64, 0xd4, 0xe4, 0x7d, 0xc3, 0x4f, 0xca, 0xd6,
	0x4e, 0x3a, 0x6a, 0x4c, 0x44, 0x8d, 0x1a, 0x93, 0x0e, 0x51, 0x95, 0x11, 0x84, 0x67, 0xf4, 0x00,
	0xcc, 0x51, 0xdf, 0xbc, 0x77, 0x8c, 0xe9, 0x07, 0xdf, 0xee, 0xf1, 0x6d, 0x28, 0x55, 0x23, 0x05,
	0x48, 0xa9, 0x91, 0x02, 0x00, 0x51, 0x95, 0x50, 0xd6, 0x19, 0xe1, 0x76, 0x6f, 0xa8, 0xd8, 0x3b,
	0x3d, 0x3d, 0x86, 0xb4, 0x00, 0x8d, 0x28, 0xf6, 0x4e, 0xa1, 0xd8, 0x3b, 0x3d, 0x32, 0x3a, 0x4d,
	0xc9, 0x77, 0x7a, 0x7a, 0xb8, 0x7a, 0x11, 0x53, 0xa3, 0xb3, 0x88, 0x40, 0x54, 0xd3, 0x2b, 0x7c,
	0xa7, 0xe7, 0xe4, 0x60, 0x89, 0xa8, 0xde, 0x3c, 0x0b, 0xbb, 0xe1, 0x67, 0x1e, 0x35, 0x2f, 0xfb,
	0x38, 0xf1, 0x71, 0x94, 0x71, 0xad, 0x44, 0x2d, 0xe6, 0x11, 0x2c, 0xca, 0x62, 0x1e, 0xc1, 0x00,
	0xd1, 0x15, 0xbf, 0x9f, 0x1f, 0x28, 0x60, 0x97, 0xd1, 0x9d, 0xdf, 0x2d, 0x81, 0x55, 0xae, 0xcd,
	0x6c, 0xa2, 0x99, 0xca, 0x6a, 0x9e, 0x0d, 0x1a, 0x17, 0x70, 0x9d, 0x0f, 0x1a, 0xef, 0x1a, 0x7a,
	0xd1, 0x5a, 0x81, 0x65, 0x06, 0x5a, 0xea, 0xf0, 0x57, 0xc1, 0x52, 0x67, 0xc4, 0xa7, 0x33, 0x55,
	0x77, 0xef, 0x6c, 0xd0, 0x78, 0x77, 0x04, 0x8b, 0x2d, 0x64, 0xad, 0x33, 0xb2, 0x11, 0x3a, 0xd6,
	0x46, 0xf8, 0x07, 0x25, 0x70, 0x9d, 0xe4, 0xb9, 0xa0, 0x21, 0x98, 0x7e, 0x3c, 0x38, 0x1b, 0x34,
	0x6e, 0x5c, 0xcc, 0x69, 0xd4, 0xe7, 0xcb, 0xaa, 0x3e, 0x17, 0x35, 0xcd, 0xb5, 0x4e, 0x3f, 0x7f,
	0x38, 0xaa, 0x75, 0x7e, 0x5a, 0x02, 0xd7, 0x82, 0x30, 0x7d, 0xea, 0x86, 0xb1, 0xb5, 0x66, 0x40,
	0x85, 0x3b, 0x5e, 0xc0, 0xa6, 0xc2, 0x1d, 0x2f, 0x60, 0x82, 0x68, 0x99, 0xa0, 0xdb, 0xb1, 0xa5,
	0x1a, 0x3f, 0x2b, 0x81, 0x6b, 0xe2, 0xc0, 0xdb, 0x56, 0x8d, 0x59, 0x55, 0x8d, 0x0b, 0xd8, 0x54,
	0x35, 0x2e, 0x60, 0x82, 0x68, 0x85, 0xa3, 0x96, 0x7a, 0xf4, 0xc1, 0x02, 0x69, 0x5e, 0x9c, 0xd0,
	0x9b, 0x44, 0xae, 0x8f, 0xbb, 0x69, 0x98, 0xa7, 0x5c, 0x89, 0x7f, 0xef, 0x6c, 0xd0, 0x78, 0xc7,
	0x02, 0x1b, 0x9d, 0xc2, 0xd7, 0x70, 0x0b, 0x1b, 0x44, 0x8e, 0x46, 0x6d, 0x32, 0xa2, 0x18, 0x9e,
	0x36, 0xa9, 0x55, 0x73, 0x78, 0xbe, 0x4c, 0xb2, 0x36, 0x3c, 0xad, 0xd2, 0xc9, 0xf0, 0xdc, 0x1f,
	0xae, 0xc0, 0x01, 0x98, 0xc3, 0x49, 0x12, 0x27, 0x2e, 0xf5, 0x1a, 0xba, 0xef, 0x7d, 0xf3, 0x88,
	0x6e, 0x27, 0xb9, 0xa9, 0x55, 0x80, 0x94, 0x32, 0x2b, 0x00, 0x10, 0x55, 0x29, 0xa5, 0x49, 0x08,
	0xef, 0x7d, 0xf3, 0xc8, 0xf9, 0x11, 0x98, 0x3f, 0xf1, 0x92, 0x28, 0x8c, 0x3a, 0x5a, 0xc1, 0x73,
	0xb4, 0x60, 0xea, 0x5d, 0x18, 0x02, 0xb5, 0x70, 0xb2, 0x22, 0x04, 0xd1, 0x1c, 0xa7, 0xc9, 0xe2,
	0x9f, 0x02, 0xa7, 0xeb, 0xa5, 0x99, 0xcb, 0xaa, 0x21, 0x0e, 0x66, 0xd8, 0x21, 0x13, 0xd1, 0x65,
	0x6f, 0x0f, 0xa3, 0x46, 0x63, 0xad, 0x88, 0xfd, 0x57, 0x91, 0x0b, 0xa2, 0x3a, 0x21, 0xb6, 0x08,
	0x4d, 0x9c, 0xd1, 0xec, 0x82, 0x59, 0x76, 0xda, 0xcd, 0x8e, 0xb5, 0xe7, 0x55, 0xd8, 0xb4, 0x46,
	0xb6, 0x45, 0xb3, 0x68, 0xb0, 0x38, 0x22, 0xdf, 0xd3, 0xae, 0xf4, 0xff, 0xf1, 0x34, 0xdb, 0x1b,
	0x6c, 0x79, 0x49, 0x70, 0xe2, 0x25, 0xf4, 0x30, 0x88, 0xa8, 0xd8, 0x5e, 0x1c, 0xe0, 0xae, 0xb6,
	0x13, 0x5d, 0x90, 0x44, 0xdb, 0xf1, 0x89, 0x04, 0xd9, 0xee, 0xeb, 0x21, 0xf9, 0xe9, 0x3c, 0x00,
	0x80, 0xd0, 0x8f, 0x71, 0x14, 0xc4, 0x09, 0xf7, 0xe2, 0xd2, 0x28, 0x28, 0x45, 0xb5, 0x1d, 0x8f,
	0x28, 0x14, 0x22, 0x52, 0x95, 0xc7, 0xf4, 0x37, 0xb1, 0xbe, 0x08, 0xe2, 0x25, 0xfe, 0x11, 0x5f,
	0x40, 0xbf, 0x2a, 0xee, 0xeb, 0x10, 0x9a, 0x35, 0x34, 0x8b, 0x63, 0x10, 0x4d, 0xfb, 0xfd, 0x7c,
	0x3d, 0xf1, 0x8f, 0x9c, 0x75, 0x30, 0x9d, 0xc6, 0xfe, 0x53, 0x9c, 0xa5, 0xdc, 0x98, 0xff, 0x0a,
	0x75, 0x33, 0x31, 0x92, 0x51, 0x06, 0x3f, 0x93, 0xe0, 0x10, 0x44, 0x22, 0x9f, 0xe3, 0x83, 0xba,
	0xba, 0x04, 0xc4, 0x88, 0xdc, 0x7a, 0xff, 0x16, 0x59, 0x45, 0x8a, 0x98, 0x51, 0xa8, 0x70, 0xf7,
	0x16, 0x78, 0x68, 0x80, 0x28, 0xbb, 0x43, 0xb4, 0x47, 0x09, 0x44, 0x48, 0x76, 0x94, 0x60, 0x2f,
	0x60, 0x6c, 0x04, 0xe5, 0xab, 0x24, 0x15, 0x52, 0xc4, 0x6c, 0x42, 0x8a, 0x3c, 0x10, 0xd5, 0x38,
	0x69, 0x17, 0x27, 0x64, 0xaf, 0x43, 0xc6, 0x14, 0x57, 0xda, 0xd4, 0xa6, 0x9d, 0x56, 0x63, 0x4a,
	0x23, 0xdb, 0xc6, 0x94, 0x06, 0x43, 0xb2, 0x91, 0x27, 0x29, 0x6a, 0xdc, 0xfa, 0xa0, 0xce, 0xb1,
	0xb4, 0x8f, 0x71, 0xe0, 0xf6, 0x8e, 0x3e, 0xe3, 0x2b, 0xdc, 0xb7, 0xb4, 0x15, 0x56, 0x62, 0xb6,
	0x6a, 0x17, 0x79, 0x20, 0xaa, 0x31, 0xd2, 0x1e, 0xa1, 0x3c, 0x3c, 0xfa, 0x4c, 0xbc, 0xba, 0xc0,
	0x46, 0x68, 0x59, 0x8d, 0xd0, 0xce, 0x45, 0x23, 0xb4, 0xa3, 0x8d, 0xd0, 0x8e, 0x18, 0xa1, 0xec,
	0x26, 0x95, 0xf6, 0xc4, 0x04, 0x30, 0x6e, 0x52, 0x29, 0x60, 0xc4, 0x4d, 0x2a, 0xfd, 0xa1, 0x89,
	0x59, 0xb9, 0xc4, 0xdd, 0x6b, 0x3b, 0xfb, 0x85, 0xe7, 0x16, 0x66, 0xb5, 0x98, 0x16, 0x8d, 0x6e,
	0x8d, 0x69, 0x19, 0xfd, 0xf0, 0x82, 0x7e, 0x35, 0xb5, 0xf2, 0xca, 0x57, 0x53, 0xf9, 0xc4, 0xff,
	0xf7, 0xe3, 0x6c, 0xe2, 0xef, 0xc7, 0xfd, 0xb8, 0x1b, 0x77, 0x4e, 0xc9, 0x74, 0x8d, 0xf2, 0x9e,
	0xe7, 0xea, 0x17, 0xea, 0xe8, 0x74, 0x55, 0x54, 0xdb, 0x74, 0x55, 0x28, 0x44, 0x65, 0x92, 0x60,
	0xd7, 0x71, 0x7f, 0x1b, 0xd4, 0x28, 0x52, 0xf4, 0xbf, 0xd0, 0x13, 0x6b, 0x13, 0xb1, 0x9d, 0x58,
	0x9b, 0x1c, 0x10, 0x55, 0x08, 0x41, 0x36, 0xef, 0x01, 0xa8, 0xe8, 0x2f, 0x5c, 0x70, 0x7d, 0x40,
	0x9b, 0x57, 0xa7, 0xdb, 0x9a, 0x57, 0xc7, 0x21, 0x32, 0x8a, 0x71, 0x7e, 0x08, 0x44, 0xec, 0x9c,
	0x7b, 0xe8, 0xb5, 0x93, 0xd0, 0xd7, 0x4e, 0xdd, 0x96, 0x4d, 0xc4, 0x5a, 0x67, 0x83, 0x03, 0xa2,
	0x2a, 0x27, 0xdc, 0xa5, 0x69, 0xe7, 0xb7, 0x40, 0x35, 0xe3, 0x6d, 0xed, 0x1e, 0x85, 0x51, 0xc6,
	0xed, 0x6a, 0x3a, 0xd8, 0x0c, 0xc0, 0x36, 0xd8, 0x0c, 0x06, 0x88, 0x2a, 0x22, 0xbd, 0x15, 0x46,
	0xc2, 0x7d, 0xf6, 0x9c, 0x77, 0xe8, 0x83, 0xd8, 0xf7, 0xba, 0x61, 0x76, 0xea, 0x7c, 0x47, 0x3e,
	0x53, 0xa0, 0x6e, 0x24, 0xd5, 0x19, 0xc5, 0x10, 0x31, 0xe2, 0xc1, 0x82, 0x87, 0x00, 0x04, 0x5e,
	0xe6, 0x11, 0x9b, 0x04, 0x1b, 0xea, 0x5b, 0x51, 0x6d, 0xe3, 0x41, 0xa1, 0x10, 0x69, 0x05, 0x38,
	0x77, 0xc0, 0xc4, 0x67, 0x71, 0x24, 0x6e, 0xf1, 0x52, 0x5f, 0x1a, 0x49, 0xdb, 0x7c, 0x69, 0x84,
	0x0e, 0x11, 0x65, 0x27, 0xd9, 0x12, 0xcf, 0x7f, 0xca, 0x7b, 0x82, 0x66, 0x23, 0x69, 0x5b, 0x36,
	0x42, 0x87, 0x88, 0xb2, 0x3b, 0xb7, 0xc1, 0x78, 0x12, 0x9f, 0xf0, 0x26, 0x6e, 0x9c, 0x0d, 0x1a,
	0xd5, 0x24, 0x3e, 0x31, 0x32, 0xf1, 0xe0, 0xe1, 0x24, 0x3e, 0x81, 0x88, 0xf0, 0x92, 0xd9, 0xd5,
	0x8f, 0x53, 0x7a, 0xb9, 0x5d, 0xbf, 0xb9, 0x28, 0x68, 0xb6, 0xd9, 0x25, 0x30, 0x88, 0x64, 0x56,
	0xde, 0x19, 0x7f, 0x7b, 0x81, 0x75, 0x86, 0x7c, 0x79, 0xe1, 0x55, 0x8f, 0xc0, 0xff, 0xb4, 0x1e,
	0x85, 0xaa, 0x37, 0x32, 0x26, 0x2e, 0xff, 0x46, 0x86, 0x39, 0xe4, 0x26, 0x5f, 0x77, 0xc8, 0xfd,
	0xa3, 0x12, 0x58, 0x94, 0xde, 0x6d, 0xe5, 0x71, 0x17, 0xf7, 0xc3, 0xbe, 0x6c, 0xf1, 0x19, 0x0c,
	0xfb, 0xe7, 0x37, 0x5a, 0xdc, 0xaf, 0x7d, 0xdd, 0x56, 0x94, 0x51, 0x9d, 0x6b, 0x05, 0x87, 0xba,
	0xc6, 0x07, 0xd1, 0x42, 0x77, 0xa8, 0xe8, 0xd4, 0xf9, 0x08, 0xd4, 0xbc, 0xe3, 0x8e, 0xab, 0x39,
	0xeb, 0xa7, 0x95, 0xc3, 0xc1, 0x44, 0x94, 0x9e, 0x31, 0xe9, 0x10, 0x55, 0xbc, 0xe3, 0xce, 0x03,
	0xe9, 0xb7, 0xff, 0x14, 0x5c, 0x95, 0x61, 0xbb, 0x5e, 0x14, 0x9c, 0x84, 0x41, 0x76, 0xe4, 0xf6,
	0xda, 0x7d, 0x11, 0x9b, 0xfb, 0x21, 0x3d, 0x4a, 0xb4, 0x72, 0xa8, 0xe8, 0x24, 0x3b, 0x0e, 0xd1,
	0xa2, 0x88, 0xfe, 0x15, 0xf4, 0x87, 0xed, 0x7e, 0xea, 0x60, 0x3d, 0xc4, 0x90, 0x85, 0x35, 0xae,
	0x8d, 0x3c, 0xd3, 0x7c, 0xf5, 0x18, 0x43, 0x75, 0xef, 0x09, 0x5c, 0xfe, 0xde, 0xd3, 0x31, 0xa8,
	0x51, 0x03, 0xfb, 0x08, 0x7b, 0x49, 0xd6, 0xc6, 0x1e, 0xdb, 0xc7, 0x5d, 0x7c, 0x92, 0x21, 0xde,
	0x5a, 0x29, 0xe4, 0x54, 0x3d, 0x60, 0xd2, 0xd9, 0x79, 0x46, 0x95, 0x10, 0xb7, 0x04, 0xcd, 0x69,
	0x83, 0xf2, 0x27, 0x71, 0x18, 0xb1, 0xc3, 0x93, 0xca, 0x4b, 0x45, 0x7e, 0x55, 0xb4, 0x86, 0xcc,
	0xa4, 0x5a, 0x43, 0x92, 0x78, 0x6c, 0x12, 0x4b, 0x0f, 0xdd, 0xb5, 0xaa, 0xfe, 0xda, 0xee, 0x5a,
	0xd5, 0x5e, 0xfd, 0x28, 0xcc, 0x79, 0x22, 0x02, 0x73, 0xe7, 0xa8, 0xdf, 0xee, 0xed, 0x11, 0xe3,
	0x84, 0x9d, 0x58, 0x12, 0x45, 0x37, 0x37, 0xbc, 0xb3, 0xb1, 0xc6, 0xe8, 0x9e, 0x82, 0xea, 0x11,
	0x75, 0xf8, 0x89, 0x13, 0xd1, 0xfa, 0xe5, 0x1c, 0x83, 0x74, 0xfd, 0x35, 0x72, 0xda, 0xd6, 0x5f,
	0x83, 0x01, 0xa2, 0xca, 0x91, 0x56, 0x04, 0xb1, 0xf6, 0xbc, 0x0e, 0x8e, 0x32, 0xb7, 0x9f, 0xb7,
	0x9f, 0xe2, 0x53, 0xbe, 0x39, 0xa3, 0xe6, 0x88, 0x4e, 0xb7, 0x99, 0x23, 0x3a, 0x0e, 0xd1, 0x2c,
	0x4d, 0xee, 0xd2, 0x94, 0x93, 0x81, 0xc5, 0x23, 0xbe, 0x29, 0x73, 0x0f, 0xc3, 0xa8, 0x83, 0x93,
	0x7e, 0x42, 0xcc, 0x06, 0x16, 0xf9, 0xb7, 0x4e, 0x34, 0x92, 0x0d, 0xb7, 0x69, 0x24, 0x1b, 0x1f,
	0x44, 0x0b, 0x82, 0x7c, 0x57, 0x51, 0x89, 0x95, 0xc2, 0xea, 0x24, 0x2e, 0x48, 0x2f, 0x28, 0x2b,
	0xc5, 0x00, 0x6c, 0xad, 0x64, 0x30, 0x10, 0xc5, 0x44, 0xd2, 0xe2, 0xad, 0xa0, 0x94, 0x28, 0xe3,
	0x34, 0x73, 0x53, 0xfc, 0x69, 0x4e, 0x2f, 0x05, 0x45, 0x79, 0xaf, 0x8d, 0x13, 0x1a, 0x25, 0x38,
	0xc1, 0xbe, 0xc7, 0x86, 0xdb, 0x35, 0xec, 0x30, 0x1f, 0x44, 0x74, 0x37, 0xbe, 0xc7, 0xa9, 0x3b,
	0x94, 0xe8, 0x1c, 0x82, 0x19, 0x9f, 0x9f, 0x7a, 0xf1, 0x38, 0xc1, 0xc6, 0x88, 0x11, 0x27, 0x0e,
	0xc7, 0xf8, 0xb6, 0x92, 0xa7, 0xac, 0xdb, 0x4a, 0x8e, 0xd1, 0x1b, 0xe5, 0xfc, 0x44, 0xed, 0x87,
	0x60, 0x8a, 0x0d, 0x09, 0x1e, 0x22, 0x38, 0x2a, 0xa6, 0x83, 0x0d, 0x3d, 0x66, 0x8a, 0xb1, 0x0c,
	0x36, 0x53, 0x8c, 0x21, 0x10, 0xf1, 0x32, 0xc9, 0x57, 0x88, 0xbe, 0xe2, 0x21, 0x81, 0xa3, 0xbe,
	0x42, 0x6c, 0xe3, 0xd9, 0x57, 0x88, 0x4c, 0xb6, 0xaf, 0x10, 0x18, 0x44, 0xb2, 0x6c, 0x22, 0x47,
	0x18, 0x96, 0x34, 0x08, 0x70, 0xb4, 0x1c, 0xb1, 0x6b, 0x60, 0x72, 0x44, 0x26, 0x9b, 0x1c, 0x81,
	0x41, 0x24, 0xcb, 0x26, 0x72, 0xba, 0xdc, 0x4a, 0x5d, 0x5e, 0xb9, 0x50, 0x8e, 0x30, 0x66, 0x99,
	0x1c, 0x91, 0xc9, 0x26, 0x47, 0x60, 0x10, 0xc9, 0xb2, 0xb9, 0x2d, 0xf6, 0xbf, 0x26, 0x41, 0x9d,
	0xbf, 0x1c, 0xd5, 0xf4, 0xa2, 0x20, 0x0c, 0x78, 0x48, 0xff, 0x6b, 0x3f, 0x2a, 0xa7, 0x6c, 0x9c,
	0xb1, 0xcb, 0xdb, 0x38, 0xc3, 0x4b, 0xfe, 0xf8, 0xeb, 0x2e, 0xf9, 0x96, 0x77, 0xce, 0x26, 0xde,
	0xc4, 0x3b, 0x67, 0x3b, 0xa0, 0x2a, 0x84, 0xa6, 0xd4, 0x03, 0xa1, 0xae, 0xc4, 0x99, 0x80, 0xd2,
	0x00, 0x06, 0x19, 0xa2, 0x0a, 0x4f, 0xef, 0x91, 0xa4, 0x83, 0x40, 0x4d, 0x4c, 0x18, 0x5e, 0xe0,
	0x94, 0x8a, 0x74, 0x30, 0x11, 0xf5, 0xe9, 0x26, 0x1d, 0xa2, 0xaa, 0x20, 0xa8, 0x32, 0xe3, 0x5e,
	0x9b, 0xae, 0x90, 0xac, 0xcc, 0x69, 0xad, 0x4c, 0x03, 0xd1, 0xca, 0x34, 0xe8, 0xa4, 0x4c, 0x4e,
	0x60, 0x65, 0x7e, 0x08, 0x66, 0x70, 0x37, 0xec, 0x84, 0xe2, 0x28, 0x72, 0x86, 0xbd, 0x2d, 0x21,
	0x68, 0x6a, 0xcc, 0x09, 0x0a, 0x44, 0x12, 0x24, 0x6a, 0x3b, 0x8c, 0x58, 0x2a, 0x24, 0x83, 0xd0,
	0x4d, 0xb0, 0x97, 0xca, 0xa7, 0xe2, 0xa8, 0x9a, 0xb3, 0xe1, 0x36, 0x35, 0x67, 0xe3, 0x83, 0x68,
	0xc1, 0x20, 0x23, 0x4a, 0xe5, 0x23, 0xfd, 0x5f, 0xcd, 0x00, 0x67, 0x6f, 0x28, 0x7e, 0xdc, 0xb9,
	0x0b, 0x66, 0xf5, 0x78, 0xf5, 0x92, 0xfe, 0x70, 0x89, 0x24, 0xeb, 0x0f, 0x2d, 0x68, 0xf1, 0xe8,
	0x20, 0x50, 0x51, 0xe8, 0x2a, 0x94, 0x73, 0xec, 0xd2, 0xa1, 0x9c, 0x18, 0x2c, 0xa4, 0xb8, 0x8b,
	0x7d, 0x62, 0x5a, 0x0c, 0x5d, 0x89, 0xa2, 0xe7, 0xd0, 0x16, 0x58, 0xf9, 0xb0, 0x2d, 0x20, 0x44,
	0xf3, 0x82, 0xaa, 0xde, 0x83, 0xfb, 0x3b, 0x25, 0xe0, 0xf8, 0x62, 0x72, 0x0b, 0xe6, 0x94, 0xdf,
	0x69, 0xfe, 0xd2, 0xe8, 0xf7, 0xf5, 0xa4, 0x42, 0x50, 0x8f, 0x93, 0x0c, 0x17, 0xa3, 0xbd, 0x00,
	0x34, 0x84, 0x41, 0x34, 0x2f, 0x89, 0xbc, 0xcc, 0x94, 0x3d, 0x3d, 0xcb, 0x1b, 0x91, 0x77, 0xbf,
	0xda, 0xcc, 0x14, 0x21, 0xfd, 0xf9, 0x15, 0x03, 0xa0, 0xcf, 0xaf, 0x30, 0x0a, 0xeb, 0x65, 0xd2,
	0x91, 0x61, 0xea, 0x1e, 0x7a, 0xdd, 0x6e, 0x9b, 0xec, 0x89, 0xa7, 0xe8, 0xd8, 0xa4, 0x1d, 0xa9,
	0x91, 0x55, 0x47, 0x6a, 0x44, 0x88, 0x40, 0x98, 0xde, 0xe5, 0x09, 0xe7, 0xc7, 0x60, 0x4e, 0x00,
	0xa2, 0x7e, 0xd3, 0xea, 0xa1, 0x98, 0x02, 0x64, 0xbb, 0x86, 0x53, 0x60, 0x81, 0xa8, 0x26, 0x28,
	0xbc, 0xa6, 0x43, 0xaa, 0x63, 0xe6, 0x4d, 0xab, 0x8e, 0xf2, 0x17, 0xa0, 0x3a, 0xc0, 0x6b, 0xab,
	0x0e, 0x33, 0x26, 0x6e, 0xf6, 0x0b, 0x8b, 0x89, 0x2b, 0x9a, 0xe4, 0x95, 0xd7, 0x8e, 0x4e, 0xfb,
	0x87, 0x13, 0xc0, 0xd9, 0xda, 0x6d, 0xb2, 0x88, 0x51, 0x84, 0xfd, 0xb0, 0x1f, 0xe2, 0x28, 0x73,
	0x1e, 0x81, 0x69, 0xe1, 0x32, 0x28, 0xc9, 0x39, 0x3b, 0xad, 0x3c, 0x05, 0xdc, 0x6f, 0xf1, 0x52,
	0x07, 0x81, 0xc8, 0xa2, 0xc5, 0xd7, 0x8f, 0xfd, 0x89, 0xc4, 0xd7, 0x23, 0x50, 0x4b, 0xc4, 0xd7,
	0x31, 0xe7, 0xec, 0xb8, 0xea, 0x75, 0x13, 0x51, 0xbd, 0x6e, 0xd2, 0x21, 0xaa, 0x4a, 0x02, 0x75,
	0xcc, 0xfe, 0x45, 0xe5, 0xdc, 0x99, 0x90, 0x97, 0xe2, 0xe7, 0x39, 0xc9, 0x76, 0xaa, 0x30, 0xe4,
	0xe6, 0x19, 0x11, 0xf5, 0x3f, 0xf9, 0xa6, 0xa3, 0xfe, 0xa9, 0xc9, 0x42, 0x27, 0xfc, 0x94, 0x6e,
	0xb2, 0x70, 0x3d, 0x24, 0x4d, 0x16, 0x36, 0xa9, 0x39, 0xc0, 0x07, 0xc8, 0x3f, 0x9d, 0x04, 0xcb,
	0x6c, 0x74, 0x34, 0xbd, 0xae, 0x9f, 0x77, 0xe9, 0xa1, 0xe5, 0x26, 0xce, 0xbc, 0xb0, 0x4b, 0xef,
	0x72, 0xb3, 0x18, 0x6e, 0x16, 0xc9, 0xca, 0x5e, 0x16, 0x28, 0xa9, 0x40, 0xde, 0x21, 0x50, 0x1d,
	0xb5, 0x0d, 0x41, 0x10, 0xb1, 0xf7, 0x9d, 0x69, 0xec, 0xeb, 0x63, 0x42, 0x71, 0x4e, 0xc1, 0x32,
	0x0b, 0x6c, 0x76, 0xfb, 0x71, 0xdc, 0x75, 0xf5, 0x0f, 0xe3, 0x6b, 0xd1, 0xf7, 0xce, 0x06, 0x8d,
	0x91, 0x3c, 0xea, 0x2a, 0xdf, 0x28, 0x0e, 0x88, 0xae, 0x32, 0x68, 0x37, 0x8e, 0xbb, 0x4d, 0x0d,
	0x20, 0x5f, 0xa6, 0x07, 0x3b, 0xbb, 0x09, 0xd9, 0xbc, 0x2a, 0x87, 0xf3, 0x30, 0xa8, 0xbe, 0x6c,
	0x08, 0x82, 0x68, 0x4e, 0x8b, 0x7e, 0x46, 0xc4, 0x0e, 0xfd, 0x09, 0x58, 0xa1, 0x83, 0xc1, 0xe8,
	0x41, 0xc2, 0x90, 0x77, 0x3d, 0x3e, 0x98, 0xe8, 0x5b, 0x32, 0x23, 0x99, 0xd4, 0xf5, 0xc0, 0x91,
	0x2c, 0x10, 0x2d, 0x11, 0x4c, 0xff, 0xac, 0xbb, 0x0c, 0x71, 0x7e, 0x5e, 0x02, 0x55, 0x7a, 0xa9,
	0x51, 0xbb, 0x3e, 0x40, 0x66, 0xe5, 0x77, 0x2c, 0x4b, 0xe6, 0xa8, 0xce, 0xbf, 0x49, 0xef, 0x3e,
	0xf2, 0x7b, 0x01, 0xec, 0x41, 0x10, 0xaa, 0xe7, 0x8d, 0x72, 0x95, 0x9e, 0x37, 0xc8, 0xd4, 0x05,
	0xaf, 0x72, 0xaf, 0x7e, 0x0f, 0xcc, 0x0f, 0x95, 0xf6, 0x0a, 0x8f, 0x57, 0xfc, 0x4f, 0x40, 0x1f,
	0x4b, 0x90, 0xca, 0x2c, 0x4e, 0x02, 0xe7, 0xbb, 0xa0, 0xcc, 0x7b, 0x5f, 0xda, 0x40, 0xef, 0x32,
	0xff, 0x13, 0x27, 0xea, 0xfe, 0x27, 0x4e, 0x82, 0x68, 0x86, 0xfd, 0x7e, 0x45, 0xeb, 0xe7, 0x4d,
	0xdc, 0x03, 0x7f, 0x02, 0xa6, 0x98, 0x07, 0x8c, 0x0e, 0x87, 0xda, 0xa8, 0x9b, 0x1d, 0xec, 0x5b,
	0xf7, 0x28, 0x27, 0x8f, 0x76, 0xa2, 0xbf, 0xb5, 0x68, 0x27, 0x9a, 0x86, 0x88, 0x03, 0xf4, 0x52,
	0x00, 0x9b, 0x7c, 0xfc, 0xba, 0xc4, 0xe4, 0xa5, 0x2f, 0x05, 0xe8, 0xd9, 0xd4, 0x1a, 0xa3, 0x53,
	0x3f, 0xe7, 0xa5, 0x00, 0x9a, 0x95, 0xdf, 0x92, 0x88, 0x00, 0x90, 0xea, 0xf5, 0x22, 0x5f, 0xed,
	0xf0, 0x6a, 0xa5, 0x9e, 0x9b, 0x56, 0x05, 0xa8, 0xf6, 0x55, 0x34, 0x88, 0x34, 0x06, 0xa6, 0x5c,
	0xf8, 0x05, 0x62, 0x33, 0x14, 0x3f, 0xa5, 0x37, 0x48, 0xa4, 0x72, 0xb1, 0xf3, 0xe8, 0xca, 0xc5,
	0xce, 0x41, 0x95, 0x8b, 0x80, 0xb4, 0x88, 0xfe, 0x8b, 0xe2, 0xf9, 0x67, 0x7e, 0xfd, 0xf1, 0xfc,
	0x8f, 0xc1, 0x1c, 0x57, 0x18, 0xd2, 0xf9, 0x53, 0x56, 0x56, 0x6b, 0x01, 0xd2, 0x6c, 0x41, 0x13,
	0x20, 0xb6, 0x20, 0xa3, 0x08, 0xc7, 0xcf, 0xdf, 0x2b, 0x81, 0x05, 0x5f, 0x69, 0x0d, 0x37, 0x60,
	0x6a, 0x83, 0x5f, 0x46, 0xff, 0xfa, 0xe7, 0xd0, 0x34, 0x1b, 0xdf, 0xe2, 0xfd, 0x6b, 0x2b, 0x4f,
	0x5b, 0x0d, 0x87, 0x41, 0xb2, 0x1a, 0x0e, 0xaf, 0x5a, 0x1f, 0x82, 0x99, 0x20, 0x4c, 0xfb, 0x79,
	0x86, 0x03, 0xfe, 0x6e, 0x17, 0xdd, 0xe8, 0x09, 0x9a, 0xda, 0xe8, 0x09, 0x0a, 0x44, 0x12, 0x74,
	0x1e, 0x00, 0xc0, 0x7f, 0xab, 0x07, 0xaf, 0xd9, 0x61, 0x85, 0xa4, 0x5a, 0x0f, 0x2b, 0x24, 0x0a,
	0x51, 0x99, 0x27, 0xb6, 0x03, 0xa7, 0x0d, 0xca, 0x61, 0x9a, 0xe6, 0x97, 0x75, 0xe5, 0x4a, 0x7f,
	0xb1, 0xcc, 0xa4, 0xb4, 0x97, 0x24, 0x71, 0x7f, 0x31, 0x4b, 0xbf, 0x59, 0x3f, 0x2e, 0xd7, 0xb3,
	0xff, 0x75, 0x86, 0xbe, 0x41, 0xbc, 0xc9, 0x3e, 0x83, 0xa8, 0x3b, 0xad, 0x49, 0x34, 0xa7, 0x8a,
	0xa2, 0xbe, 0xb4, 0x21, 0x5e, 0x45, 0xcd, 0x6e, 0xe9, 0xaa, 0x5d, 0x99, 0x73, 0x0b, 0x92, 0x68,
	0x8b, 0x08, 0xb0, 0x2a, 0xf9, 0x04, 0xd4, 0x79, 0x55, 0xac, 0x37, 0xf8, 0x8a, 0x98, 0x3a, 0x2a,
	0x2b, 0x22, 0x17, 0x1c, 0x95, 0x09, 0x56, 0x71, 0x54, 0xc6, 0x5f, 0xd1, 0x26, 0x6d, 0xa1, 0xfd,
	0xdb, 0x07, 0xf9, 0x8a, 0xb6, 0xa0, 0x9b, 0xaf, 0x68, 0x0b, 0x2a, 0x7f, 0x45, 0x3b, 0xcf, 0x58,
	0x88, 0xc0, 0xab, 0xd8, 0x77, 0x4e, 0x0b, 0xcc, 0xe0, 0xe3, 0x30, 0x20, 0xea, 0x89, 0xef, 0x03,
	0xa9, 0xb7, 0x4d, 0xd0, 0x6c, 0xde, 0x36, 0x81, 0x41, 0x24, 0xb3, 0x3a, 0x07, 0x32, 0x26, 0x97,
	0x29, 0x2f, 0xeb, 0xcb, 0x0f, 0xac, 0xae, 0x9f, 0x27, 0x28, 0xf7, 0x21, 0x59, 0x0e, 0xd2, 0xb8,
	0xcb, 0xac, 0x3d, 0xa5, 0x91, 0x16, 0x15, 0xd5, 0x36, 0xcf, 0x14, 0x4a, 0xb5, 0xbd, 0x48, 0x38,
	0x7f, 0x19, 0xd4, 0x69, 0xea, 0x58, 0xeb, 0x61, 0xb6, 0xef, 0xfb, 0xe8, 0x6c, 0xd0, 0x58, 0x2d,
	0x62, 0xb6, 0x10, 0x95, 0x22, 0xcf, 0x05, 0x7d, 0x2d, 0x58, 0x45, 0x5f, 0xff, 0xba, 0xf6, 0x87,
	0x7d, 0x30, 0xcb, 0x45, 0x5f, 0xf2, 0x00, 0xea, 0x7d, 0xb2, 0x98, 0x68, 0x59, 0x6c, 0x61, 0x3f,
	0x1a, 0xcc, 0xef, 0xf0, 0x08, 0x8a, 0x45, 0xb9, 0x54, 0x5f, 0x5b, 0xb9, 0xfc, 0xbb, 0x0a, 0x98,
	0xda, 0xf5, 0x12, 0xaf, 0x97, 0xda, 0x8d, 0xf0, 0xd2, 0x1b, 0x33, 0xc2, 0x43, 0xb0, 0x58, 0xb8,
	0xe7, 0xc9, 0x24, 0x8c, 0xa9, 0xe7, 0xc0, 0x6d, 0xb8, 0xf2, 0xd4, 0xd9, 0x50, 0x88, 0x1c, 0xf3,
	0xfa, 0x27, 0x15, 0xf5, 0x31, 0xa8, 0x6b, 0xf7, 0x34, 0xf5, 0xdd, 0x04, 0x7b, 0xe8, 0xa9, 0x80,
	0x69, 0x0f, 0x3d, 0x15, 0x10, 0x88, 0x6a, 0xea, 0x86, 0x27, 0x2d, 0xfa, 0x19, 0x58, 0xee, 0x85,
	0x11, 0x7d, 0x0e, 0x27, 0xc8, 0x13, 0xb6, 0xfc, 0x99, 0xaf, 0x5f, 0x51, 0x3b, 0x66, 0x14, 0x8f,
	0xb2, 0x63, 0x46, 0x71, 0x40, 0x74, 0xa5, 0x17, 0x46, 0xf7, 0xe3, 0xf6, 0x26, 0x07, 0x44, 0x8c,
	0x3b, 0x91, 0xec, 0x3d, 0xb3, 0x4b, 0x9e, 0xd4, 0x24, 0x8f, 0xe0, 0xd1, 0x24, 0x8f, 0xe0, 0x20,
	0x92, 0xbd, 0x67, 0x16, 0xc9, 0xbf, 0x5b, 0x02, 0xab, 0xe2, 0xd5, 0x62, 0xcb, 0x4b, 0xa9, 0x53,
	0x2a, 0xba, 0x7b, 0x34, 0x97, 0x8a, 0xee, 0x1e, 0xcd, 0x03, 0xd1, 0x32, 0x07, 0x87, 0x9f, 0x49,
	0xfd, 0x09, 0x58, 0x11, 0xa6, 0xbb, 0x3c, 0x13, 0x76, 0xb3, 0xb0, 0x87, 0xd5, 0x43, 0x5b, 0x74,
	0x0b, 0x37, 0x92, 0x49, 0x6d, 0xe1, 0x46, 0xb2, 0x40, 0xb4, 0xc4, 0x31, 0x79, 0xc4, 0xbc, 0xcf,
	0x10, 0x7a, 0xe0, 0x4f, 0x9f, 0xd5, 0x1a, 0x92, 0xad, 0x1f, 0xf8, 0x5b, 0x39, 0xb4, 0x03, 0x7f,
	0x2b, 0x0e, 0xd1, 0x62, 0xc4, 0x0e, 0xad, 0x4c, 0x91, 0x3d, 0x70, 0x45, 0x78, 0xeb, 0x98, 0xb3,
	0xc1, 0x3d, 0xf4, 0xfc, 0x2c, 0x4e, 0xb8, 0x76, 0xa6, 0x86, 0xa9, 0x95, 0x41, 0x19, 0xa6, 0x56,
	0x58, 0x45, 0x49, 0x30, 0x77, 0xc5, 0x5d, 0x4a, 0x25, 0x5f, 0x28, 0x5d, 0x79, 0xa6, 0x3c, 0x20,
	0x5f, 0x89, 0x1c, 0xc1, 0xa1, 0xbe, 0xd0, 0x8e, 0x43, 0xb4, 0x28, 0x00, 0x43, 0xe4, 0x47, 0xa0,
	0x46, 0xc6, 0xa2, 0x76, 0x4a, 0x33, 0xab, 0x4e, 0x69, 0x4c, 0x44, 0x7b, 0xc3, 0xde, 0xa0, 0x43,
	0x54, 0xe9, 0x79, 0xcf, 0xd4, 0x29, 0xcd, 0x4f, 0xc0, 0x8a, 0x58, 0xb8, 0xd5, 0x72, 0xe4, 0xf6,
	0x71, 0x12, 0xc6, 0x01, 0xf7, 0xdf, 0xd1, 0x61, 0x32, 0x92, 0x49, 0x0d, 0x93, 0x91, 0x2c, 0x10,
	0x2d, 0x71, 0x0c, 0x49, 0x68, 0x97, 0x22, 0xa4, 0x11, 0xb9, 0xf6, 0x28, 0x1a, 0xf9, 0x55, 0xd5,
	0x88, 0x76, 0x0e, 0xd5, 0x88, 0x76, 0x1c, 0xa2, 0x45, 0x06, 0xdc, 0x35, 0x0d, 0xff, 0x9f, 0x95,
	0xc0, 0x35, 0x1c, 0xd1, 0x13, 0xa6, 0x7e, 0x12, 0x3f, 0x0b, 0x7b, 0xa4, 0xf9, 0xf9, 0x30, 0x0e,
	0xa3, 0x0e, 0xb5, 0x3f, 0x67, 0x58, 0x44, 0xfd, 0x05, 0x6c, 0x2a, 0xa2, 0xfe, 0x02, 0x26, 0x88,
	0x56, 0x18, 0xba, 0x2b, 0xc0, 0xa6, 0xc4, 0xd8, 0x72, 0xf2, 0xb5, 0xc1, 0x18, 0xa8, 0xe8, 0xff,
	0xef, 0xc8, 0xf9, 0x36, 0x58, 0x69, 0x3e, 0x38, 0xd8, 0xdb, 0x6f, 0x21, 0x77, 0x6f, 0x7f, 0x7d,
	0xbf, 0xe5, 0x1e, 0xec, 0xec, 0xed, 0xb6, 0x9a, 0xdb, 0x77, 0xb7, 0x5b, 0x9b, 0xf5, 0xb7, 0x56,
	0xaf, 0x3d, 0x7f, 0xb1, 0xb6, 0xa4, 0x67, 0x38, 0x88, 0xd2, 0x3e, 0xf6, 0xc3, 0xc3, 0x10, 0x13,
	0x2b, 0xf5, 0x8a, 0x99, 0x77, 0xb7, 0xb5, 0xb3, 0xb9, 0xbd, 0x73, 0xaf, 0x5e, 0x5a, 0x5d, 0x7a,
	0xfe, 0x62, 0x6d, 0x41, 0xcf, 0xb7, 0x8b, 0xa3, 0x20, 0x8c, 0x3a, 0xce, 0x9f, 0x03, 0x8b, 0x66,
	0x9e, 0xf5, 0xe6, 0xfe, 0xf6, 0xe3, 0x56, 0x7d, 0x6c, 0xf5, 0xea, 0xf3, 0x17, 0x6b, 0x8e, 0x9e,
	0x65, 0x9d, 0x05, 0xaf, 0x7c, 0x13, 0x5c, 0x35, 0x73, 0x6c, 0xa2, 0xf5, 0xed, 0x1d, 0x22, 0x66,
	0x7c, 0x75, 0xf9, 0xf9, 0x8b, 0xb5, 0x45, 0x3d, 0xcf, 0x66, 0xe2, 0x85, 0x11, 0x7b, 0x71, 0xa3,
	0x50, 0xb7, 0x47, 0x77, 0xef, 0x3e, 0xd8, 0xde, 0x69, 0xd5, 0x27, 0x86, 0xeb, 0xf6, 0xe8, 0xf0,
	0xb0, 0x1b, 0x46, 0xd8, 0xf9, 0x0b, 0x60, 0xb5, 0x20, 0xa9, 0x85, 0x5a, 0xf7, 0xb6, 0x09, 0xa1,
	0xb5, 0x59, 0x9f, 0x5c, 0x7d, 0xfb, 0xf9, 0x8b, 0xb5, 0x65, 0x43, 0x1a, 0x4e, 0x70, 0x27, 0x24,
	0x49, 0x1c, 0xac, 0x4e, 0xfc, 0xad, 0xdf, 0xbf, 0xfe, 0xd6, 0xd7, 0xfe, 0xdf, 0x18, 0x98, 0x11,
	0x9b, 0x53, 0x52, 0x89, 0xfb, 0x8f, 0x36, 0xac, 0x0d, 0x4b, 0x2b, 0x21, 0x18, 0xf5, 0x46, 0xfd,
	0x1a, 0x98, 0x57, 0x79, 0x54, 0x83, 0x2e, 0x3c, 0x7f, 0xb1, 0x36, 0x27, 0xf8, 0x45, 0x63, 0xde,
	0x00, 0x75, 0xc5, 0xfb, 0xd1, 0x41, 0xeb, 0xa0, 0xb5, 0x59, 0x1f, 0x5b, 0x75, 0x9e, 0xbf, 0x58,
	0xab, 0x09, 0x56, 0xfa, 0xd6, 0x77, 0xa1, 0x54, 0x74, 0xb0, 0xc3, 0xdb, 0xcf, 0x28, 0x15, 0xe5,
	0x11, 0x6d, 0xba, 0x9b, 0x60, 0x41, 0xf1, 0x36, 0x1f, 0x3d, 0xdc, 0x7d, 0xd0, 0xda, 0x6f, 0x6d,
	0xd6, 0x27, 0x56, 0xaf, 0x3c, 0x7f, 0xb1, 0x36, 0x2f, 0xb8, 0x9b, 0xe2, 0xed, 0x1c, 0xb3, 0x16,
	0x77, 0xd7, 0xb7, 0x1f, 0xd0, 0xc6, 0x32, 0x6a, 0x71, 0xd7, 0x0b, 0xbb, 0x38, 0x28, 0x94, 0xbc,
	0xbe, 0xd3, 0x6c, 0x3d, 0x20, 0xcc, 0x53, 0x85, 0x92, 0xbd, 0xc8, 0xc7, 0xdd, 0x6e, 0xb1, 0xd6,
	0xfb, 0xdb, 0x0f, 0x5b, 0x8f, 0x0e, 0xf6, 0xeb, 0xd3, 0x66, 0xad, 0xb9, 0x3a, 0xe6, 0xcd, 0xff,
	0xaf, 0xc7, 0x41, 0x59, 0x86, 0xce, 0x90, 0xa1, 0xb3, 0xf3, 0x68, 0xb3, 0x65, 0xed, 0x00, 0x3a,
	0x74, 0x24, 0xab, 0xde, 0x03, 0xbf, 0x01, 0x1c, 0x23, 0xd7, 0xf7, 0x77, 0x1e, 0x3d, 0xd9, 0xa9,
	0x97, 0x56, 0x17, 0x9f, 0xbf, 0x58, 0xab, 0x6b, 0x39, 0x9e, 0x46, 0xf1, 0x49, 0x54, 0xe0, 0x16,
	0x1d, 0x36, 0x56, 0xe0, 0x16, 0x3d, 0xf6, 0x35, 0x30, 0xaf, 0x71, 0xf3, 0xb1, 0xcf, 0xfb, 0x41,
	0x32, 0xf3, 0x81, 0x7f, 0x03, 0xd4, 0x35, 0xde, 0xbd, 0xfd, 0xf5, 0x07, 0x64, 0xf4, 0xd2, 0x76,
	0x95, 0xac, 0x7b, 0x99, 0xd7, 0xc5, 0xa4, 0x5d, 0x35, 0x4e, 0x39, 0x3f, 0x26, 0x59, 0xbb, 0x4a,
	0x66, 0x39, 0x39, 0xcc, 0x3a, 0x53, 0x7e, 0xda, 0x0d, 0x66, 0x9d, 0x29, 0xfb, 0x50, 0x7b, 0x88,
	0x79, 0x34, 0x5d, 0xe0, 0x16, 0x93, 0xe8, 0x37, 0xc1, 0x92, 0x5e, 0xb6, 0x3e, 0x83, 0x66, 0x56,
	0x57, 0x9e, 0xbf, 0x58, 0xbb, 0xa2, 0x04, 0x0c, 0x4f, 0x9f, 0xff, 0x36, 0x06, 0x2a, 0x7a, 0x64,
	0x12, 0xd1, 0x4f, 0x5b, 0xad, 0xf5, 0x07, 0xfb, 0x5b, 0xb4, 0xc0, 0x83, 0x3d, 0x9b, 0x7e, 0xd2,
	0x33, 0x14, 0xf4, 0x93, 0x99, 0x97, 0xa5, 0x3e, 0x16, 0xfa, 0x49, 0xcf, 0xc7, 0x7e, 0x9f, 0x92,
	0x21, 0x63, 0xe6, 0xd9, 0x6c, 0xdd, 0x43, 0xeb, 0x9b, 0x74, 0x62, 0xd1, 0x21, 0xa3, 0x67, 0xda,
	0xc4, 0x9d, 0xc4, 0x0b, 0x70, 0x40, 0x3e, 0xba, 0x58, 0x4b, 0x21, 0x6b, 0x9c, 0x7d, 0xb4, 0x59,
	0xc7, 0xa3, 0x91, 0xd2, 0x44, 0xdf, 0x4d, 0x58, 0xa4, 0x69, 0xba, 0xcd, 0xcc, 0x25, 0xfa, 0x64,
	0x72, 0xf8, 0xbb, 0x78, 0xb7, 0xf0, 0xe6, 0xfd, 0xc5, 0x98, 0xe6, 0x12, 0x66, 0x6e, 0x52, 0x67,
	0x1d, 0xbc, 0xb3, 0xb5, 0xdb, 0x74, 0x51, 0xeb, 0xc9, 0x3a, 0xda, 0x74, 0xf7, 0x1e, 0x1d, 0xa0,
	0x66, 0x71, 0xae, 0x5c, 0x7f, 0xfe, 0x62, 0x6d, 0xb5, 0x90, 0x4f, 0x6f, 0xe8, 0xbb, 0x60, 0x6d,
	0xb8, 0x08, 0x32, 0x73, 0xb9, 0xf6, 0xd8, 0x7e, 0x44, 0xe6, 0xcf, 0xda, 0xf3, 0x17, 0x6b, 0x6f,
	0x17, 0x4a, 0xb9, 0xaf, 0xbb, 0xe0, 0x9c, 0x3b, 0x60, 0xc9, 0x52, 0x95, 0xbd, 0xf5, 0x7b, 0x2d,
	0xd9, 0xfa, 0x85, 0x4a, 0xd0, 0x6b, 0x41, 0xd6, 0x6c, 0x1b, 0x8f, 0x76, 0x0e, 0xf6, 0xc4, 0x12,
	0x51, 0x74, 0x0d, 0xc7, 0x51, 0x9e, 0xf2, 0x26, 0xf9, 0x97, 0x63, 0xa0, 0x6a, 0x6c, 0xc8, 0xc9,
	0x32, 0xb0, 0xb9, 0xbd, 0xb7, 0x7b, 0xc0, 0x26, 0xdd, 0xf0, 0x98, 0xa3, 0xcb, 0x80, 0x91, 0x45,
	0x6f, 0x8b, 0x6f, 0x82, 0xab, 0x85, 0xdc, 0x4a, 0x89, 0xd3, 0xba, 0x18, 0x39, 0x85, 0x5e, 0xf8,
	0x0e, 0xb8, 0x36, 0x24, 0x73, 0xb3, 0x85, 0x5c, 0xd4, 0x7a, 0xbc, 0xdd, 0x7a, 0x52, 0x1f, 0xb3,
	0x0a, 0xa5, 0x9b, 0xaa, 0xe3, 0x10, 0x9f, 0x90, 0xf1, 0x57, 0xc8, 0x8e, 0x5a, 0x7b, 0x8f, 0x1e,
	0x3c, 0x6e, 0x6d, 0x8a, 0xf1, 0x67, 0x64, 0x45, 0x7c, 0xc7, 0x6a, 0xcd, 0x77, 0xbf, 0xd5, 0x64,
	0xea, 0xde, 0x96, 0xef, 0x13, 0x1a, 0x72, 0xc0, 0x9a, 0x6e, 0xe3, 0xe1, 0x1f, 0xfc, 0xf2, 0x7a,
	0xe9, 0x0f, 0x7f, 0x79, 0xbd, 0xf4, 0xdf, 0x7f, 0x79, 0xbd, 0xf4, 0x8b, 0x5f, 0x5d, 0x7f, 0xeb,
	0x0f, 0x7f, 0x75, 0xfd, 0xad, 0xff, 0xf2, 0xab, 0xeb, 0x6f, 0xfd, 0xe0, 0x7d, 0xcd, 0xe9, 0xad,
	0xfd, 0x67, 0x5f, 0xed, 0x67, 0x1a, 0x3c, 0xbd, 0xd5, 0x89, 0x6f, 0x11, 0xcb, 0x9a, 0xff, 0xc3,
	0xdf, 0xf6, 0x14, 0xdd, 0x91, 0xbf, 0xff, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x91, 0x46, 0xb6,
	0x5b, 0x0c, 0x78, 0x00, 0x00,
}

func (m *Partition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Partition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Partition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x42
	}
	if m.Priority != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Priority))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Features[iNdEx])
			copy(dAtA[i:], m.Features[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Features[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.MaxNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxNodes))
		i--
		dAtA[i] = 0x28
	}
	if m.DefaultRuntime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultRuntime))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxRuntime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRuntime))
		i--
		dAtA[i] = 0x18
	}
	if m.Nodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nodes))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalStorageGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalStorageGb))
		i--
		dAtA[i] = 0x38
	}
	if len(m.StorageType) > 0 {
		i -= len(m.StorageType)
		copy(dAtA[i:], m.StorageType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageType)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.InterconnectType) > 0 {
		i -= len(m.InterconnectType)
		copy(dAtA[i:], m.InterconnectType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.InterconnectType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GpuTypes) > 0 {
		for iNdEx := len(m.GpuTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.GpuTypes[iNdEx])
			copy(dAtA[i:], m.GpuTypes[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuTypes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TotalGpus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalGpus))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalMemoryGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalMemoryGb))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalCpuCores != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalCpuCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HPCCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCCluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCCluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x78
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintTypes(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x72
	n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err2 != nil {
		return 0, err2
	}
	i -= n2
	i = encodeVarintTypes(dAtA, i, uint64(n2))
	i--
	dAtA[i] = 0x6a
	if len(m.KubernetesClusterId) > 0 {
		i -= len(m.KubernetesClusterId)
		copy(dAtA[i:], m.KubernetesClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KubernetesClusterId)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.SlurmVersion) > 0 {
		i -= len(m.SlurmVersion)
		copy(dAtA[i:], m.SlurmVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlurmVersion)))
		i--
		dAtA[i] = 0x5a
	}
	{
		size, err := m.ClusterMetadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x4a
	}
	if m.AvailableNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AvailableNodes))
		i--
		dAtA[i] = 0x40
	}
	if m.TotalNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalNodes))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Partitions) > 0 {
		for iNdEx := len(m.Partitions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Partitions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueueOption) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueueOption) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueueOption) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PriceMultiplier) > 0 {
		i -= len(m.PriceMultiplier)
		copy(dAtA[i:], m.PriceMultiplier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PriceMultiplier)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Features[iNdEx])
			copy(dAtA[i:], m.Features[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Features[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.MaxRuntime != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRuntime))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxNodes))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DisplayName) > 0 {
		i -= len(m.DisplayName)
		copy(dAtA[i:], m.DisplayName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisplayName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PartitionName) > 0 {
		i -= len(m.PartitionName)
		copy(dAtA[i:], m.PartitionName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PartitionName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCPricing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCPricing) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCPricing) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MinimumCharge) > 0 {
		i -= len(m.MinimumCharge)
		copy(dAtA[i:], m.MinimumCharge)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MinimumCharge)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NetworkGbPrice) > 0 {
		i -= len(m.NetworkGbPrice)
		copy(dAtA[i:], m.NetworkGbPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkGbPrice)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StorageGbPrice) > 0 {
		i -= len(m.StorageGbPrice)
		copy(dAtA[i:], m.StorageGbPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageGbPrice)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.MemoryGbHourPrice) > 0 {
		i -= len(m.MemoryGbHourPrice)
		copy(dAtA[i:], m.MemoryGbHourPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MemoryGbHourPrice)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GpuHourPrice) > 0 {
		i -= len(m.GpuHourPrice)
		copy(dAtA[i:], m.GpuHourPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuHourPrice)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CpuCoreHourPrice) > 0 {
		i -= len(m.CpuCoreHourPrice)
		copy(dAtA[i:], m.CpuCoreHourPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CpuCoreHourPrice)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BaseNodeHourPrice) > 0 {
		i -= len(m.BaseNodeHourPrice)
		copy(dAtA[i:], m.BaseNodeHourPrice)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.BaseNodeHourPrice)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobResources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobResources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GpuType) > 0 {
		i -= len(m.GpuType)
		copy(dAtA[i:], m.GpuType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuType)))
		i--
		dAtA[i] = 0x32
	}
	if m.StorageGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGb))
		i--
		dAtA[i] = 0x28
	}
	if m.GpusPerNode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpusPerNode))
		i--
		dAtA[i] = 0x20
	}
	if m.MemoryGbPerNode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGbPerNode))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuCoresPerNode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCoresPerNode))
		i--
		dAtA[i] = 0x10
	}
	if m.Nodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Nodes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PreconfiguredWorkload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreconfiguredWorkload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreconfiguredWorkload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Category) > 0 {
		i -= len(m.Category)
		copy(dAtA[i:], m.Category)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Category)))
		i--
		dAtA[i] = 0x3a
	}
	{
		size, err := m.RequiredResources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if len(m.DefaultCommand) > 0 {
		i -= len(m.DefaultCommand)
		copy(dAtA[i:], m.DefaultCommand)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DefaultCommand)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContainerImage) > 0 {
		i -= len(m.ContainerImage)
		copy(dAtA[i:], m.ContainerImage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContainerImage)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WorkloadId) > 0 {
		i -= len(m.WorkloadId)
		copy(dAtA[i:], m.WorkloadId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkloadId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCOffering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCOffering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCOffering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x78
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintTypes(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x72
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintTypes(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x6a
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.SupportsCustomWorkloads {
		i--
		if m.SupportsCustomWorkloads {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.PreconfiguredWorkloads) > 0 {
		for iNdEx := len(m.PreconfiguredWorkloads) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PreconfiguredWorkloads[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if m.MaxRuntimeSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRuntimeSeconds))
		i--
		dAtA[i] = 0x48
	}
	if m.RequiredIdentityThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequiredIdentityThreshold))
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Pricing.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.QueueOptions) > 0 {
		for iNdEx := len(m.QueueOptions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.QueueOptions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobWorkloadSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobWorkloadSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobWorkloadSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsPreconfigured {
		i--
		if m.IsPreconfigured {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.PreconfiguredWorkloadId) > 0 {
		i -= len(m.PreconfiguredWorkloadId)
		copy(dAtA[i:], m.PreconfiguredWorkloadId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PreconfiguredWorkloadId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.WorkingDirectory) > 0 {
		i -= len(m.WorkingDirectory)
		copy(dAtA[i:], m.WorkingDirectory)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.WorkingDirectory)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Environment) > 0 {
		for k := range m.Environment {
			v := m.Environment[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Arguments) > 0 {
		for iNdEx := len(m.Arguments) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Arguments[iNdEx])
			copy(dAtA[i:], m.Arguments[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Arguments[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Command) > 0 {
		i -= len(m.Command)
		copy(dAtA[i:], m.Command)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Command)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContainerImage) > 0 {
		i -= len(m.ContainerImage)
		copy(dAtA[i:], m.ContainerImage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContainerImage)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataReference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataReference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SizeBytes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SizeBytes))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Checksum) > 0 {
		i -= len(m.Checksum)
		copy(dAtA[i:], m.Checksum)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Checksum)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Encrypted {
		i--
		if m.Encrypted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Uri) > 0 {
		i -= len(m.Uri)
		copy(dAtA[i:], m.Uri)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Uri)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCUsageMetrics) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCUsageMetrics) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCUsageMetrics) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodesUsed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NodesUsed))
		i--
		dAtA[i] = 0x48
	}
	if m.NodeHours != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NodeHours))
		i--
		dAtA[i] = 0x40
	}
	if m.NetworkBytesOut != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkBytesOut))
		i--
		dAtA[i] = 0x38
	}
	if m.NetworkBytesIn != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkBytesIn))
		i--
		dAtA[i] = 0x30
	}
	if m.StorageGbHours != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGbHours))
		i--
		dAtA[i] = 0x28
	}
	if m.GpuSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpuSeconds))
		i--
		dAtA[i] = 0x20
	}
	if m.MemoryGbSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGbSeconds))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuCoreSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCoreSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.WallClockSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WallClockSeconds))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HPCJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.CompletedAt != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintTypes(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.StartedAt != nil {
		n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartedAt):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintTypes(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.QueuedAt != nil {
		n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.QueuedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.QueuedAt):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintTypes(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	n11, err11 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err11 != nil {
		return 0, err11
	}
	i -= n11
	i = encodeVarintTypes(dAtA, i, uint64(n11))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	if m.ExitCode != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExitCode))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.StatusMessage) > 0 {
		i -= len(m.StatusMessage)
		copy(dAtA[i:], m.StatusMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StatusMessage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.SchedulingDecisionId) > 0 {
		i -= len(m.SchedulingDecisionId)
		copy(dAtA[i:], m.SchedulingDecisionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SchedulingDecisionId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.AgreedPrice) > 0 {
		for iNdEx := len(m.AgreedPrice) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AgreedPrice[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.MaxRuntimeSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRuntimeSeconds))
		i--
		dAtA[i] = 0x70
	}
	if len(m.EncryptedOutputsPointer) > 0 {
		i -= len(m.EncryptedOutputsPointer)
		copy(dAtA[i:], m.EncryptedOutputsPointer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedOutputsPointer)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.EncryptedInputsPointer) > 0 {
		i -= len(m.EncryptedInputsPointer)
		copy(dAtA[i:], m.EncryptedInputsPointer)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedInputsPointer)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.DataReferences) > 0 {
		for iNdEx := len(m.DataReferences) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DataReferences[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.WorkloadSpec.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if len(m.QueueName) > 0 {
		i -= len(m.QueueName)
		copy(dAtA[i:], m.QueueName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.QueueName)))
		i--
		dAtA[i] = 0x42
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x38
	}
	if len(m.SlurmJobId) > 0 {
		i -= len(m.SlurmJobId)
		copy(dAtA[i:], m.SlurmJobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlurmJobId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsageSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UsageSeconds))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ContributionWeight) > 0 {
		i -= len(m.ContributionWeight)
		copy(dAtA[i:], m.ContributionWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContributionWeight)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JobAccounting) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JobAccounting) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JobAccounting) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.FinalizedAt != nil {
		n14, err14 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.FinalizedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.FinalizedAt):])
		if err14 != nil {
			return 0, err14
		}
		i -= n14
		i = encodeVarintTypes(dAtA, i, uint64(n14))
		i--
		dAtA[i] = 0x7a
	}
	n15, err15 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err15 != nil {
		return 0, err15
	}
	i -= n15
	i = encodeVarintTypes(dAtA, i, uint64(n15))
	i--
	dAtA[i] = 0x72
	if m.JobCompletionStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JobCompletionStatus))
		i--
		dAtA[i] = 0x68
	}
	if len(m.SignedUsageRecordIds) > 0 {
		for iNdEx := len(m.SignedUsageRecordIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SignedUsageRecordIds[iNdEx])
			copy(dAtA[i:], m.SignedUsageRecordIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.SignedUsageRecordIds[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SettlementStatus) > 0 {
		i -= len(m.SettlementStatus)
		copy(dAtA[i:], m.SettlementStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SettlementStatus)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.PlatformFee) > 0 {
		for iNdEx := len(m.PlatformFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlatformFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.NodeRewards) > 0 {
		for iNdEx := len(m.NodeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NodeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.ProviderReward) > 0 {
		for iNdEx := len(m.ProviderReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProviderReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TotalCost) > 0 {
		for iNdEx := len(m.TotalCost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalCost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	{
		size, err := m.UsageMetrics.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LatencyMeasurement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatencyMeasurement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LatencyMeasurement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	n17, err17 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.MeasuredAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.MeasuredAt):])
	if err17 != nil {
		return 0, err17
	}
	i -= n17
	i = encodeVarintTypes(dAtA, i, uint64(n17))
	i--
	dAtA[i] = 0x1a
	if m.LatencyMs != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LatencyMs))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TargetNodeId) > 0 {
		i -= len(m.TargetNodeId)
		copy(dAtA[i:], m.TargetNodeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TargetNodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeResources) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeResources) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeResources) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGb))
		i--
		dAtA[i] = 0x28
	}
	if len(m.GpuType) > 0 {
		i -= len(m.GpuType)
		copy(dAtA[i:], m.GpuType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuType)))
		i--
		dAtA[i] = 0x22
	}
	if m.Gpus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Gpus))
		i--
		dAtA[i] = 0x18
	}
	if m.MemoryGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGb))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuCores != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCores))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeCapacity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeCapacity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeCapacity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.StorageGbAllocated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGbAllocated))
		i--
		dAtA[i] = 0x68
	}
	if m.StorageGbAvailable != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGbAvailable))
		i--
		dAtA[i] = 0x60
	}
	if m.StorageGbTotal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StorageGbTotal))
		i--
		dAtA[i] = 0x58
	}
	if len(m.GpuType) > 0 {
		i -= len(m.GpuType)
		copy(dAtA[i:], m.GpuType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuType)))
		i--
		dAtA[i] = 0x52
	}
	if m.GpusAllocated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpusAllocated))
		i--
		dAtA[i] = 0x48
	}
	if m.GpusAvailable != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpusAvailable))
		i--
		dAtA[i] = 0x40
	}
	if m.GpusTotal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpusTotal))
		i--
		dAtA[i] = 0x38
	}
	if m.MemoryGbAllocated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGbAllocated))
		i--
		dAtA[i] = 0x30
	}
	if m.MemoryGbAvailable != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGbAvailable))
		i--
		dAtA[i] = 0x28
	}
	if m.MemoryGbTotal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryGbTotal))
		i--
		dAtA[i] = 0x20
	}
	if m.CpuCoresAllocated != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCoresAllocated))
		i--
		dAtA[i] = 0x18
	}
	if m.CpuCoresAvailable != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCoresAvailable))
		i--
		dAtA[i] = 0x10
	}
	if m.CpuCoresTotal != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuCoresTotal))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeHealth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHealth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeHealth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SlurmState) > 0 {
		i -= len(m.SlurmState)
		copy(dAtA[i:], m.SlurmState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlurmState)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.LastErrorMessage) > 0 {
		i -= len(m.LastErrorMessage)
		copy(dAtA[i:], m.LastErrorMessage)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LastErrorMessage)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.WarningCount_24H != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.WarningCount_24H))
		i--
		dAtA[i] = 0x78
	}
	if m.ErrorCount_24H != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ErrorCount_24H))
		i--
		dAtA[i] = 0x70
	}
	if m.GpuTemperatureCelsius != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpuTemperatureCelsius))
		i--
		dAtA[i] = 0x68
	}
	if m.TemperatureCelsius != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TemperatureCelsius))
		i--
		dAtA[i] = 0x60
	}
	if m.NetworkUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkUtilizationPercent))
		i--
		dAtA[i] = 0x58
	}
	if m.DiskIoUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DiskIoUtilizationPercent))
		i--
		dAtA[i] = 0x50
	}
	if m.GpuMemoryUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpuMemoryUtilizationPercent))
		i--
		dAtA[i] = 0x48
	}
	if m.GpuUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpuUtilizationPercent))
		i--
		dAtA[i] = 0x40
	}
	if m.MemoryUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemoryUtilizationPercent))
		i--
		dAtA[i] = 0x38
	}
	if m.CpuUtilizationPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CpuUtilizationPercent))
		i--
		dAtA[i] = 0x30
	}
	if len(m.LoadAverage_15M) > 0 {
		i -= len(m.LoadAverage_15M)
		copy(dAtA[i:], m.LoadAverage_15M)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LoadAverage_15M)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LoadAverage_5M) > 0 {
		i -= len(m.LoadAverage_5M)
		copy(dAtA[i:], m.LoadAverage_5M)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LoadAverage_5M)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LoadAverage_1M) > 0 {
		i -= len(m.LoadAverage_1M)
		copy(dAtA[i:], m.LoadAverage_1M)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LoadAverage_1M)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UptimeSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UptimeSeconds))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeHardware) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeHardware) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeHardware) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Features) > 0 {
		for iNdEx := len(m.Features) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Features[iNdEx])
			copy(dAtA[i:], m.Features[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Features[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.StorageType) > 0 {
		i -= len(m.StorageType)
		copy(dAtA[i:], m.StorageType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StorageType)))
		i--
		dAtA[i] = 0x5a
	}
	if m.GpuMemoryGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.GpuMemoryGb))
		i--
		dAtA[i] = 0x50
	}
	if len(m.GpuModel) > 0 {
		i -= len(m.GpuModel)
		copy(dAtA[i:], m.GpuModel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GpuModel)))
		i--
		dAtA[i] = 0x4a
	}
	if m.MemorySpeedMhz != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MemorySpeedMhz))
		i--
		dAtA[i] = 0x40
	}
	if len(m.MemoryType) > 0 {
		i -= len(m.MemoryType)
		copy(dAtA[i:], m.MemoryType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.MemoryType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ThreadsPerCore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ThreadsPerCore))
		i--
		dAtA[i] = 0x30
	}
	if m.CoresPerSocket != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CoresPerSocket))
		i--
		dAtA[i] = 0x28
	}
	if m.Sockets != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Sockets))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CpuArch) > 0 {
		i -= len(m.CpuArch)
		copy(dAtA[i:], m.CpuArch)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CpuArch)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CpuVendor) > 0 {
		i -= len(m.CpuVendor)
		copy(dAtA[i:], m.CpuVendor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CpuVendor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CpuModel) > 0 {
		i -= len(m.CpuModel)
		copy(dAtA[i:], m.CpuModel)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CpuModel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeTopology) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeTopology) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeTopology) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TopologyHint) > 0 {
		i -= len(m.TopologyHint)
		copy(dAtA[i:], m.TopologyHint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TopologyHint)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NetworkFabric) > 0 {
		i -= len(m.NetworkFabric)
		copy(dAtA[i:], m.NetworkFabric)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NetworkFabric)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Interconnect) > 0 {
		i -= len(m.Interconnect)
		copy(dAtA[i:], m.Interconnect)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Interconnect)))
		i--
		dAtA[i] = 0x1a
	}
	if m.NumaMemoryGb != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaMemoryGb))
		i--
		dAtA[i] = 0x10
	}
	if m.NumaNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NumaNodes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NodeLocality) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeLocality) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeLocality) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Position) > 0 {
		i -= len(m.Position)
		copy(dAtA[i:], m.Position)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Position)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Row) > 0 {
		i -= len(m.Row)
		copy(dAtA[i:], m.Row)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Row)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Rack) > 0 {
		i -= len(m.Rack)
		copy(dAtA[i:], m.Rack)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Rack)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Datacenter) > 0 {
		i -= len(m.Datacenter)
		copy(dAtA[i:], m.Datacenter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Datacenter)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NodeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NodeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NodeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Locality != nil {
		{
			size, err := m.Locality.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.Topology != nil {
		{
			size, err := m.Topology.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc2
	}
	if m.Hardware != nil {
		{
			size, err := m.Hardware.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if m.Health != nil {
		{
			size, err := m.Health.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if m.Capacity != nil {
		{
			size, err := m.Capacity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.LastSequenceNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastSequenceNumber))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if len(m.AgentVersion) > 0 {
		i -= len(m.AgentVersion)
		copy(dAtA[i:], m.AgentVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AgentVersion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.HardwareFingerprint) > 0 {
		i -= len(m.HardwareFingerprint)
		copy(dAtA[i:], m.HardwareFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.HardwareFingerprint)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.AgentPubkey) > 0 {
		i -= len(m.AgentPubkey)
		copy(dAtA[i:], m.AgentPubkey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AgentPubkey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.HealthStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.HealthStatus))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x78
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x70
	}
	n23, err23 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err23 != nil {
		return 0, err23
	}
	i -= n23
	i = encodeVarintTypes(dAtA, i, uint64(n23))
	i--
	dAtA[i] = 0x6a
	n24, err24 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.JoinedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.JoinedAt):])
	if err24 != nil {
		return 0, err24
	}
	i -= n24
	i = encodeVarintTypes(dAtA, i, uint64(n24))
	i--
	dAtA[i] = 0x62
	n25, err25 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.LastHeartbeat, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastHeartbeat):])
	if err25 != nil {
		return 0, err25
	}
	i -= n25
	i = encodeVarintTypes(dAtA, i, uint64(n25))
	i--
	dAtA[i] = 0x5a
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	{
		size, err := m.Resources.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	if m.NetworkBandwidthMbps != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NetworkBandwidthMbps))
		i--
		dAtA[i] = 0x40
	}
	if m.AvgLatencyMs != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AvgLatencyMs))
		i--
		dAtA[i] = 0x38
	}
	if len(m.LatencyMeasurements) > 0 {
		for iNdEx := len(m.LatencyMeasurements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LatencyMeasurements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Datacenter) > 0 {
		i -= len(m.Datacenter)
		copy(dAtA[i:], m.Datacenter)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Datacenter)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClusterCandidate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClusterCandidate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClusterCandidate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IneligibilityReason) > 0 {
		i -= len(m.IneligibilityReason)
		copy(dAtA[i:], m.IneligibilityReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IneligibilityReason)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Eligible {
		i--
		if m.Eligible {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if len(m.CombinedScore) > 0 {
		i -= len(m.CombinedScore)
		copy(dAtA[i:], m.CombinedScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CombinedScore)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CapacityScore) > 0 {
		i -= len(m.CapacityScore)
		copy(dAtA[i:], m.CapacityScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CapacityScore)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LatencyScore) > 0 {
		i -= len(m.LatencyScore)
		copy(dAtA[i:], m.LatencyScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LatencyScore)))
		i--
		dAtA[i] = 0x2a
	}
	if m.AvailableNodes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AvailableNodes))
		i--
		dAtA[i] = 0x20
	}
	if m.AvgLatencyMs != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AvgLatencyMs))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Region) > 0 {
		i -= len(m.Region)
		copy(dAtA[i:], m.Region)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Region)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SchedulingDecision) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SchedulingDecision) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SchedulingDecision) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x60
	}
	n27, err27 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err27 != nil {
		return 0, err27
	}
	i -= n27
	i = encodeVarintTypes(dAtA, i, uint64(n27))
	i--
	dAtA[i] = 0x5a
	if len(m.CombinedScore) > 0 {
		i -= len(m.CombinedScore)
		copy(dAtA[i:], m.CombinedScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CombinedScore)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.CapacityScore) > 0 {
		i -= len(m.CapacityScore)
		copy(dAtA[i:], m.CapacityScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CapacityScore)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LatencyScore) > 0 {
		i -= len(m.LatencyScore)
		copy(dAtA[i:], m.LatencyScore)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LatencyScore)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.FallbackReason) > 0 {
		i -= len(m.FallbackReason)
		copy(dAtA[i:], m.FallbackReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FallbackReason)))
		i--
		dAtA[i] = 0x3a
	}
	if m.IsFallback {
		i--
		if m.IsFallback {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if len(m.DecisionReason) > 0 {
		i -= len(m.DecisionReason)
		copy(dAtA[i:], m.DecisionReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DecisionReason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CandidateClusters) > 0 {
		for iNdEx := len(m.CandidateClusters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CandidateClusters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.SelectedClusterId) > 0 {
		i -= len(m.SelectedClusterId)
		copy(dAtA[i:], m.SelectedClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SelectedClusterId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DecisionId) > 0 {
		i -= len(m.DecisionId)
		copy(dAtA[i:], m.DecisionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DecisionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCRewardRecipient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCRewardRecipient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCRewardRecipient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ContributionWeight) > 0 {
		i -= len(m.ContributionWeight)
		copy(dAtA[i:], m.ContributionWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContributionWeight)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RecipientType) > 0 {
		i -= len(m.RecipientType)
		copy(dAtA[i:], m.RecipientType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RecipientType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardCalculationDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardCalculationDetails) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardCalculationDetails) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InputMetrics) > 0 {
		for k := range m.InputMetrics {
			v := m.InputMetrics[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NodeContributionFormula) > 0 {
		i -= len(m.NodeContributionFormula)
		copy(dAtA[i:], m.NodeContributionFormula)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeContributionFormula)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PlatformFeeRate) > 0 {
		i -= len(m.PlatformFeeRate)
		copy(dAtA[i:], m.PlatformFeeRate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlatformFeeRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RewardPoolContribution) > 0 {
		i -= len(m.RewardPoolContribution)
		copy(dAtA[i:], m.RewardPoolContribution)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RewardPoolContribution)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TotalUsageValue) > 0 {
		i -= len(m.TotalUsageValue)
		copy(dAtA[i:], m.TotalUsageValue)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TotalUsageValue)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCRewardRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCRewardRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCRewardRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x70
	}
	n28, err28 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.IssuedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.IssuedAt):])
	if err28 != nil {
		return 0, err28
	}
	i -= n28
	i = encodeVarintTypes(dAtA, i, uint64(n28))
	i--
	dAtA[i] = 0x6a
	if len(m.DisputeId) > 0 {
		i -= len(m.DisputeId)
		copy(dAtA[i:], m.DisputeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisputeId)))
		i--
		dAtA[i] = 0x62
	}
	if m.Disputed {
		i--
		if m.Disputed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	{
		size, err := m.CalculationDetails.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if len(m.FormulaVersion) > 0 {
		i -= len(m.FormulaVersion)
		copy(dAtA[i:], m.FormulaVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FormulaVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if m.JobCompletionStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JobCompletionStatus))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ReferencedUsageRecords) > 0 {
		for iNdEx := len(m.ReferencedUsageRecords) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReferencedUsageRecords[iNdEx])
			copy(dAtA[i:], m.ReferencedUsageRecords[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ReferencedUsageRecords[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Recipients) > 0 {
		for iNdEx := len(m.Recipients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.TotalReward) > 0 {
		for iNdEx := len(m.TotalReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Source != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Source))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ClusterId) > 0 {
		i -= len(m.ClusterId)
		copy(dAtA[i:], m.ClusterId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClusterId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RewardId) > 0 {
		i -= len(m.RewardId)
		copy(dAtA[i:], m.RewardId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RewardId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HPCDispute) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HPCDispute) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HPCDispute) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x68
	}
	if m.ResolvedAt != nil {
		n30, err30 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ResolvedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ResolvedAt):])
		if err30 != nil {
			return 0, err30
		}
		i -= n30
		i = encodeVarintTypes(dAtA, i, uint64(n30))
		i--
		dAtA[i] = 0x62
	}
	n31, err31 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err31 != nil {
		return 0, err31
	}
	i -= n31
	i = encodeVarintTypes(dAtA, i, uint64(n31))
	i--
	dAtA[i] = 0x5a
	if len(m.ResolverAddress) > 0 {
		i -= len(m.ResolverAddress)
		copy(dAtA[i:], m.ResolverAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResolverAddress)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Resolution) > 0 {
		i -= len(m.Resolution)
		copy(dAtA[i:], m.Resolution)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Resolution)))
		i--
		dAtA[i] = 0x4a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Evidence) > 0 {
		i -= len(m.Evidence)
		copy(dAtA[i:], m.Evidence)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Evidence)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DisputeType) > 0 {
		i -= len(m.DisputeType)
		copy(dAtA[i:], m.DisputeType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisputeType)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DisputerAddress) > 0 {
		i -= len(m.DisputerAddress)
		copy(dAtA[i:], m.DisputerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisputerAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RewardId) > 0 {
		i -= len(m.RewardId)
		copy(dAtA[i:], m.RewardId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RewardId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JobId) > 0 {
		i -= len(m.JobId)
		copy(dAtA[i:], m.JobId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.JobId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DisputeId) > 0 {
		i -= len(m.DisputeId)
		copy(dAtA[i:], m.DisputeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DisputeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableProximityClustering {
		i--
		if m.EnableProximityClustering {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if len(m.RewardFormulaVersion) > 0 {
		i -= len(m.RewardFormulaVersion)
		copy(dAtA[i:], m.RewardFormulaVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RewardFormulaVersion)))
		i--
		dAtA[i] = 0x6a
	}
	if m.DisputeResolutionPeriod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DisputeResolutionPeriod))
		i--
		dAtA[i] = 0x60
	}
	if m.MaxLatencyMs != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxLatencyMs))
		i--
		dAtA[i] = 0x58
	}
	if len(m.CapacityWeightFactor) > 0 {
		i -= len(m.CapacityWeightFactor)
		copy(dAtA[i:], m.CapacityWeightFactor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CapacityWeightFactor)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.LatencyWeightFactor) > 0 {
		i -= len(m.LatencyWeightFactor)
		copy(dAtA[i:], m.LatencyWeightFactor)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LatencyWeightFactor)))
		i--
		dAtA[i] = 0x4a
	}
	if m.NodeHeartbeatTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NodeHeartbeatTimeout))
		i--
		dAtA[i] = 0x40
	}
	if m.ClusterHeartbeatTimeout != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ClusterHeartbeatTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.DefaultIdentityThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultIdentityThreshold))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxJobDurationSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxJobDurationSeconds))
		i--
		dAtA[i] = 0x28
	}
	if m.MinJobDurationSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinJobDurationSeconds))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NodeRewardRate) > 0 {
		i -= len(m.NodeRewardRate)
		copy(dAtA[i:], m.NodeRewardRate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NodeRewardRate)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProviderRewardRate) > 0 {
		i -= len(m.ProviderRewardRate)
		copy(dAtA[i:], m.ProviderRewardRate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderRewardRate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlatformFeeRate) > 0 {
		i -= len(m.PlatformFeeRate)
		copy(dAtA[i:], m.PlatformFeeRate)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlatformFeeRate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Partition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Nodes != 0 {
		n += 1 + sovTypes(uint64(m.Nodes))
	}
	if m.MaxRuntime != 0 {
		n += 1 + sovTypes(uint64(m.MaxRuntime))
	}
	if m.DefaultRuntime != 0 {
		n += 1 + sovTypes(uint64(m.DefaultRuntime))
	}
	if m.MaxNodes != 0 {
		n += 1 + sovTypes(uint64(m.MaxNodes))
	}
	if len(m.Features) > 0 {
		for _, s := range m.Features {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Priority != 0 {
		n += 1 + sovTypes(uint64(m.Priority))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ClusterMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalCpuCores != 0 {
		n += 1 + sovTypes(uint64(m.TotalCpuCores))
	}
	if m.TotalMemoryGb != 0 {
		n += 1 + sovTypes(uint64(m.TotalMemoryGb))
	}
	if m.TotalGpus != 0 {
		n += 1 + sovTypes(uint64(m.TotalGpus))
	}
	if len(m.GpuTypes) > 0 {
		for _, s := range m.GpuTypes {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.InterconnectType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StorageType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TotalStorageGb != 0 {
		n += 1 + sovTypes(uint64(m.TotalStorageGb))
	}
	return n
}

func (m *HPCCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if len(m.Partitions) > 0 {
		for _, e := range m.Partitions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TotalNodes != 0 {
		n += 1 + sovTypes(uint64(m.TotalNodes))
	}
	if m.AvailableNodes != 0 {
		n += 1 + sovTypes(uint64(m.AvailableNodes))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.ClusterMetadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.SlurmVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KubernetesClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *QueueOption) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PartitionName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxNodes != 0 {
		n += 1 + sovTypes(uint64(m.MaxNodes))
	}
	if m.MaxRuntime != 0 {
		n += 1 + sovTypes(uint64(m.MaxRuntime))
	}
	if len(m.Features) > 0 {
		for _, s := range m.Features {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.PriceMultiplier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HPCPricing) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseNodeHourPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CpuCoreHourPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.GpuHourPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MemoryGbHourPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.StorageGbPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NetworkGbPrice)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.MinimumCharge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *JobResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nodes != 0 {
		n += 1 + sovTypes(uint64(m.Nodes))
	}
	if m.CpuCoresPerNode != 0 {
		n += 1 + sovTypes(uint64(m.CpuCoresPerNode))
	}
	if m.MemoryGbPerNode != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGbPerNode))
	}
	if m.GpusPerNode != 0 {
		n += 1 + sovTypes(uint64(m.GpusPerNode))
	}
	if m.StorageGb != 0 {
		n += 1 + sovTypes(uint64(m.StorageGb))
	}
	l = len(m.GpuType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PreconfiguredWorkload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WorkloadId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContainerImage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DefaultCommand)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.RequiredResources.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.Category)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HPCOffering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.QueueOptions) > 0 {
		for _, e := range m.QueueOptions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = m.Pricing.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.RequiredIdentityThreshold != 0 {
		n += 1 + sovTypes(uint64(m.RequiredIdentityThreshold))
	}
	if m.MaxRuntimeSeconds != 0 {
		n += 1 + sovTypes(uint64(m.MaxRuntimeSeconds))
	}
	if len(m.PreconfiguredWorkloads) > 0 {
		for _, e := range m.PreconfiguredWorkloads {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SupportsCustomWorkloads {
		n += 2
	}
	if m.Active {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *JobWorkloadSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContainerImage)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Command)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Arguments) > 0 {
		for _, s := range m.Arguments {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Environment) > 0 {
		for k, v := range m.Environment {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	l = len(m.WorkingDirectory)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PreconfiguredWorkloadId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsPreconfigured {
		n += 2
	}
	return n
}

func (m *DataReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Uri)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Encrypted {
		n += 2
	}
	l = len(m.Checksum)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SizeBytes != 0 {
		n += 1 + sovTypes(uint64(m.SizeBytes))
	}
	return n
}

func (m *HPCUsageMetrics) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.WallClockSeconds != 0 {
		n += 1 + sovTypes(uint64(m.WallClockSeconds))
	}
	if m.CpuCoreSeconds != 0 {
		n += 1 + sovTypes(uint64(m.CpuCoreSeconds))
	}
	if m.MemoryGbSeconds != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGbSeconds))
	}
	if m.GpuSeconds != 0 {
		n += 1 + sovTypes(uint64(m.GpuSeconds))
	}
	if m.StorageGbHours != 0 {
		n += 1 + sovTypes(uint64(m.StorageGbHours))
	}
	if m.NetworkBytesIn != 0 {
		n += 1 + sovTypes(uint64(m.NetworkBytesIn))
	}
	if m.NetworkBytesOut != 0 {
		n += 1 + sovTypes(uint64(m.NetworkBytesOut))
	}
	if m.NodeHours != 0 {
		n += 1 + sovTypes(uint64(m.NodeHours))
	}
	if m.NodesUsed != 0 {
		n += 1 + sovTypes(uint64(m.NodesUsed))
	}
	return n
}

func (m *HPCJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SlurmJobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = len(m.QueueName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.WorkloadSpec.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.Resources.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.DataReferences) > 0 {
		for _, e := range m.DataReferences {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.EncryptedInputsPointer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EncryptedOutputsPointer)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxRuntimeSeconds != 0 {
		n += 1 + sovTypes(uint64(m.MaxRuntimeSeconds))
	}
	if len(m.AgreedPrice) > 0 {
		for _, e := range m.AgreedPrice {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SchedulingDecisionId)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.StatusMessage)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.ExitCode != 0 {
		n += 2 + sovTypes(uint64(m.ExitCode))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 2 + l + sovTypes(uint64(l))
	if m.QueuedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.QueuedAt)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.StartedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartedAt)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.CompletedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *NodeReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.ContributionWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.UsageSeconds != 0 {
		n += 1 + sovTypes(uint64(m.UsageSeconds))
	}
	return n
}

func (m *JobAccounting) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.UsageMetrics.Size()
	n += 1 + l + sovTypes(uint64(l))
	if len(m.TotalCost) > 0 {
		for _, e := range m.TotalCost {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ProviderReward) > 0 {
		for _, e := range m.ProviderReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.NodeRewards) > 0 {
		for _, e := range m.NodeRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.PlatformFee) > 0 {
		for _, e := range m.PlatformFee {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.SettlementStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.SignedUsageRecordIds) > 0 {
		for _, s := range m.SignedUsageRecordIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.JobCompletionStatus != 0 {
		n += 1 + sovTypes(uint64(m.JobCompletionStatus))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.FinalizedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.FinalizedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *LatencyMeasurement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TargetNodeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LatencyMs != 0 {
		n += 1 + sovTypes(uint64(m.LatencyMs))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.MeasuredAt)
	n += 1 + l + sovTypes(uint64(l))
	return n
}

func (m *NodeResources) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCores != 0 {
		n += 1 + sovTypes(uint64(m.CpuCores))
	}
	if m.MemoryGb != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGb))
	}
	if m.Gpus != 0 {
		n += 1 + sovTypes(uint64(m.Gpus))
	}
	l = len(m.GpuType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StorageGb != 0 {
		n += 1 + sovTypes(uint64(m.StorageGb))
	}
	return n
}

func (m *NodeCapacity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CpuCoresTotal != 0 {
		n += 1 + sovTypes(uint64(m.CpuCoresTotal))
	}
	if m.CpuCoresAvailable != 0 {
		n += 1 + sovTypes(uint64(m.CpuCoresAvailable))
	}
	if m.CpuCoresAllocated != 0 {
		n += 1 + sovTypes(uint64(m.CpuCoresAllocated))
	}
	if m.MemoryGbTotal != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGbTotal))
	}
	if m.MemoryGbAvailable != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGbAvailable))
	}
	if m.MemoryGbAllocated != 0 {
		n += 1 + sovTypes(uint64(m.MemoryGbAllocated))
	}
	if m.GpusTotal != 0 {
		n += 1 + sovTypes(uint64(m.GpusTotal))
	}
	if m.GpusAvailable != 0 {
		n += 1 + sovTypes(uint64(m.GpusAvailable))
	}
	if m.GpusAllocated != 0 {
		n += 1 + sovTypes(uint64(m.GpusAllocated))
	}
	l = len(m.GpuType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StorageGbTotal != 0 {
		n += 1 + sovTypes(uint64(m.StorageGbTotal))
	}
	if m.StorageGbAvailable != 0 {
		n += 1 + sovTypes(uint64(m.StorageGbAvailable))
	}
	if m.StorageGbAllocated != 0 {
		n += 1 + sovTypes(uint64(m.StorageGbAllocated))
	}
	return n
}

func (m *NodeHealth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.UptimeSeconds != 0 {
		n += 1 + sovTypes(uint64(m.UptimeSeconds))
	}
	l = len(m.LoadAverage_1M)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LoadAverage_5M)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LoadAverage_15M)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CpuUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.CpuUtilizationPercent))
	}
	if m.MemoryUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.MemoryUtilizationPercent))
	}
	if m.GpuUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.GpuUtilizationPercent))
	}
	if m.GpuMemoryUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.GpuMemoryUtilizationPercent))
	}
	if m.DiskIoUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.DiskIoUtilizationPercent))
	}
	if m.NetworkUtilizationPercent != 0 {
		n += 1 + sovTypes(uint64(m.NetworkUtilizationPercent))
	}
	if m.TemperatureCelsius != 0 {
		n += 1 + sovTypes(uint64(m.TemperatureCelsius))
	}
	if m.GpuTemperatureCelsius != 0 {
		n += 1 + sovTypes(uint64(m.GpuTemperatureCelsius))
	}
	if m.ErrorCount_24H != 0 {
		n += 1 + sovTypes(uint64(m.ErrorCount_24H))
	}
	if m.WarningCount_24H != 0 {
		n += 1 + sovTypes(uint64(m.WarningCount_24H))
	}
	l = len(m.LastErrorMessage)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.SlurmState)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NodeHardware) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CpuModel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CpuVendor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CpuArch)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Sockets != 0 {
		n += 1 + sovTypes(uint64(m.Sockets))
	}
	if m.CoresPerSocket != 0 {
		n += 1 + sovTypes(uint64(m.CoresPerSocket))
	}
	if m.ThreadsPerCore != 0 {
		n += 1 + sovTypes(uint64(m.ThreadsPerCore))
	}
	l = len(m.MemoryType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MemorySpeedMhz != 0 {
		n += 1 + sovTypes(uint64(m.MemorySpeedMhz))
	}
	l = len(m.GpuModel)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.GpuMemoryGb != 0 {
		n += 1 + sovTypes(uint64(m.GpuMemoryGb))
	}
	l = len(m.StorageType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Features) > 0 {
		for _, s := range m.Features {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *NodeTopology) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NumaNodes != 0 {
		n += 1 + sovTypes(uint64(m.NumaNodes))
	}
	if m.NumaMemoryGb != 0 {
		n += 1 + sovTypes(uint64(m.NumaMemoryGb))
	}
	l = len(m.Interconnect)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NetworkFabric)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TopologyHint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NodeLocality) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Rack)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Row)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Position)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *NodeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Datacenter)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.LatencyMeasurements) > 0 {
		for _, e := range m.LatencyMeasurements {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.AvgLatencyMs != 0 {
		n += 1 + sovTypes(uint64(m.AvgLatencyMs))
	}
	if m.NetworkBandwidthMbps != 0 {
		n += 1 + sovTypes(uint64(m.NetworkBandwidthMbps))
	}
	l = m.Resources.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Active {
		n += 2
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.LastHeartbeat)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.JoinedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.HealthStatus != 0 {
		n += 2 + sovTypes(uint64(m.HealthStatus))
	}
	l = len(m.AgentPubkey)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.HardwareFingerprint)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	l = len(m.AgentVersion)
	if l > 0 {
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.LastSequenceNumber != 0 {
		n += 2 + sovTypes(uint64(m.LastSequenceNumber))
	}
	if m.Capacity != nil {
		l = m.Capacity.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Health != nil {
		l = m.Health.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Hardware != nil {
		l = m.Hardware.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Topology != nil {
		l = m.Topology.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.Locality != nil {
		l = m.Locality.Size()
		n += 2 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ClusterCandidate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AvgLatencyMs != 0 {
		n += 1 + sovTypes(uint64(m.AvgLatencyMs))
	}
	if m.AvailableNodes != 0 {
		n += 1 + sovTypes(uint64(m.AvailableNodes))
	}
	l = len(m.LatencyScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CapacityScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CombinedScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Eligible {
		n += 2
	}
	l = len(m.IneligibilityReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SchedulingDecision) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DecisionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SelectedClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.CandidateClusters) > 0 {
		for _, e := range m.CandidateClusters {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.DecisionReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IsFallback {
		n += 2
	}
	l = len(m.FallbackReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.LatencyScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CapacityScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CombinedScore)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *HPCRewardRecipient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.RecipientType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContributionWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *RewardCalculationDetails) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TotalUsageValue)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RewardPoolContribution)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PlatformFeeRate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NodeContributionFormula)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.InputMetrics) > 0 {
		for k, v := range m.InputMetrics {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *HPCRewardRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RewardId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClusterId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Source != 0 {
		n += 1 + sovTypes(uint64(m.Source))
	}
	if len(m.TotalReward) > 0 {
		for _, e := range m.TotalReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Recipients) > 0 {
		for _, e := range m.Recipients {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ReferencedUsageRecords) > 0 {
		for _, s := range m.ReferencedUsageRecords {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.JobCompletionStatus != 0 {
		n += 1 + sovTypes(uint64(m.JobCompletionStatus))
	}
	l = len(m.FormulaVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.CalculationDetails.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Disputed {
		n += 2
	}
	l = len(m.DisputeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.IssuedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *HPCDispute) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DisputeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.JobId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RewardId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DisputerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DisputeType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Evidence)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.Resolution)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ResolverAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	if m.ResolvedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ResolvedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlatformFeeRate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ProviderRewardRate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NodeRewardRate)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MinJobDurationSeconds != 0 {
		n += 1 + sovTypes(uint64(m.MinJobDurationSeconds))
	}
	if m.MaxJobDurationSeconds != 0 {
		n += 1 + sovTypes(uint64(m.MaxJobDurationSeconds))
	}
	if m.DefaultIdentityThreshold != 0 {
		n += 1 + sovTypes(uint64(m.DefaultIdentityThreshold))
	}
	if m.ClusterHeartbeatTimeout != 0 {
		n += 1 + sovTypes(uint64(m.ClusterHeartbeatTimeout))
	}
	if m.NodeHeartbeatTimeout != 0 {
		n += 1 + sovTypes(uint64(m.NodeHeartbeatTimeout))
	}
	l = len(m.LatencyWeightFactor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CapacityWeightFactor)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxLatencyMs != 0 {
		n += 1 + sovTypes(uint64(m.MaxLatencyMs))
	}
	if m.DisputeResolutionPeriod != 0 {
		n += 1 + sovTypes(uint64(m.DisputeResolutionPeriod))
	}
	l = len(m.RewardFormulaVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EnableProximityClustering {
		n += 2
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Partition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Partition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Partition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			m.Nodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRuntime", wireType)
			}
			m.MaxRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRuntime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultRuntime", wireType)
			}
			m.DefaultRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultRuntime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNodes", wireType)
			}
			m.MaxNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCpuCores", wireType)
			}
			m.TotalCpuCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCpuCores |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalMemoryGb", wireType)
			}
			m.TotalMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalMemoryGb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalGpus", wireType)
			}
			m.TotalGpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalGpus |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuTypes = append(m.GpuTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InterconnectType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InterconnectType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStorageGb", wireType)
			}
			m.TotalStorageGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalStorageGb |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ClusterState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Partitions = append(m.Partitions, Partition{})
			if err := m.Partitions[len(m.Partitions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalNodes", wireType)
			}
			m.TotalNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableNodes", wireType)
			}
			m.AvailableNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ClusterMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlurmVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlurmVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubernetesClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubernetesClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueueOption) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueueOption: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueueOption: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartitionName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PartitionName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxNodes", wireType)
			}
			m.MaxNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRuntime", wireType)
			}
			m.MaxRuntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRuntime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PriceMultiplier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PriceMultiplier = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCPricing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCPricing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCPricing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseNodeHourPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseNodeHourPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoreHourPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuCoreHourPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuHourPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuHourPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbHourPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemoryGbHourPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGbPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageGbPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkGbPrice", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkGbPrice = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumCharge", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinimumCharge = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			m.Nodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresPerNode", wireType)
			}
			m.CpuCoresPerNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCoresPerNode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbPerNode", wireType)
			}
			m.MemoryGbPerNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGbPerNode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpusPerNode", wireType)
			}
			m.GpusPerNode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpusPerNode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGb", wireType)
			}
			m.StorageGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreconfiguredWorkload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreconfiguredWorkload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreconfiguredWorkload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkloadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultCommand", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DefaultCommand = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RequiredResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Category = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCOffering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCOffering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCOffering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueOptions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueOptions = append(m.QueueOptions, QueueOption{})
			if err := m.QueueOptions[len(m.QueueOptions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pricing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Pricing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredIdentityThreshold", wireType)
			}
			m.RequiredIdentityThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredIdentityThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRuntimeSeconds", wireType)
			}
			m.MaxRuntimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRuntimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreconfiguredWorkloads", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreconfiguredWorkloads = append(m.PreconfiguredWorkloads, PreconfiguredWorkload{})
			if err := m.PreconfiguredWorkloads[len(m.PreconfiguredWorkloads)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportsCustomWorkloads", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SupportsCustomWorkloads = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobWorkloadSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobWorkloadSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobWorkloadSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerImage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContainerImage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Command", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Command = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Arguments", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Arguments = append(m.Arguments, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Environment == nil {
				m.Environment = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Environment[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDirectory = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreconfiguredWorkloadId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreconfiguredWorkloadId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsPreconfigured", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsPreconfigured = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uri", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uri = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encrypted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Encrypted = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeBytes", wireType)
			}
			m.SizeBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SizeBytes |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCUsageMetrics) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCUsageMetrics: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCUsageMetrics: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WallClockSeconds", wireType)
			}
			m.WallClockSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WallClockSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoreSeconds", wireType)
			}
			m.CpuCoreSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCoreSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbSeconds", wireType)
			}
			m.MemoryGbSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGbSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuSeconds", wireType)
			}
			m.GpuSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGbHours", wireType)
			}
			m.StorageGbHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGbHours |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBytesIn", wireType)
			}
			m.NetworkBytesIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBytesIn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBytesOut", wireType)
			}
			m.NetworkBytesOut = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBytesOut |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeHours", wireType)
			}
			m.NodeHours = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeHours |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodesUsed", wireType)
			}
			m.NodesUsed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodesUsed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlurmJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlurmJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueueName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueueName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkloadSpec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.WorkloadSpec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataReferences = append(m.DataReferences, DataReference{})
			if err := m.DataReferences[len(m.DataReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedInputsPointer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedInputsPointer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedOutputsPointer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedOutputsPointer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRuntimeSeconds", wireType)
			}
			m.MaxRuntimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRuntimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgreedPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgreedPrice = append(m.AgreedPrice, types.Coin{})
			if err := m.AgreedPrice[len(m.AgreedPrice)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchedulingDecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchedulingDecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExitCode", wireType)
			}
			m.ExitCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExitCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueuedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QueuedAt == nil {
				m.QueuedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.QueuedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContributionWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContributionWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageSeconds", wireType)
			}
			m.UsageSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JobAccounting) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JobAccounting: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JobAccounting: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UsageMetrics.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalCost = append(m.TotalCost, types.Coin{})
			if err := m.TotalCost[len(m.TotalCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderReward = append(m.ProviderReward, types.Coin{})
			if err := m.ProviderReward[len(m.ProviderReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeRewards = append(m.NodeRewards, NodeReward{})
			if err := m.NodeRewards[len(m.NodeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFee = append(m.PlatformFee, types.Coin{})
			if err := m.PlatformFee[len(m.PlatformFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedUsageRecordIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignedUsageRecordIds = append(m.SignedUsageRecordIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCompletionStatus", wireType)
			}
			m.JobCompletionStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobCompletionStatus |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinalizedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FinalizedAt == nil {
				m.FinalizedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.FinalizedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatencyMeasurement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatencyMeasurement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatencyMeasurement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetNodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetNodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMs", wireType)
			}
			m.LatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatencyMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasuredAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.MeasuredAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeResources) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeResources: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeResources: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCores", wireType)
			}
			m.CpuCores = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCores |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGb", wireType)
			}
			m.MemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gpus", wireType)
			}
			m.Gpus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Gpus |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGb", wireType)
			}
			m.StorageGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeCapacity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeCapacity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeCapacity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresTotal", wireType)
			}
			m.CpuCoresTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCoresTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresAvailable", wireType)
			}
			m.CpuCoresAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCoresAvailable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuCoresAllocated", wireType)
			}
			m.CpuCoresAllocated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuCoresAllocated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbTotal", wireType)
			}
			m.MemoryGbTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGbTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbAvailable", wireType)
			}
			m.MemoryGbAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGbAvailable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryGbAllocated", wireType)
			}
			m.MemoryGbAllocated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryGbAllocated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpusTotal", wireType)
			}
			m.GpusTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpusTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpusAvailable", wireType)
			}
			m.GpusAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpusAvailable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpusAllocated", wireType)
			}
			m.GpusAllocated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpusAllocated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGbTotal", wireType)
			}
			m.StorageGbTotal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGbTotal |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGbAvailable", wireType)
			}
			m.StorageGbAvailable = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGbAvailable |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageGbAllocated", wireType)
			}
			m.StorageGbAllocated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StorageGbAllocated |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHealth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHealth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHealth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= HealthStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptimeSeconds", wireType)
			}
			m.UptimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UptimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAverage_1M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadAverage_1M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAverage_5M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadAverage_5M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoadAverage_15M", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LoadAverage_15M = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUtilizationPercent", wireType)
			}
			m.CpuUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CpuUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryUtilizationPercent", wireType)
			}
			m.MemoryUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemoryUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuUtilizationPercent", wireType)
			}
			m.GpuUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuMemoryUtilizationPercent", wireType)
			}
			m.GpuMemoryUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuMemoryUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DiskIoUtilizationPercent", wireType)
			}
			m.DiskIoUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DiskIoUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkUtilizationPercent", wireType)
			}
			m.NetworkUtilizationPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkUtilizationPercent |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TemperatureCelsius", wireType)
			}
			m.TemperatureCelsius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TemperatureCelsius |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuTemperatureCelsius", wireType)
			}
			m.GpuTemperatureCelsius = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuTemperatureCelsius |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCount_24H", wireType)
			}
			m.ErrorCount_24H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCount_24H |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WarningCount_24H", wireType)
			}
			m.WarningCount_24H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WarningCount_24H |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlurmState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlurmState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeHardware) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeHardware: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeHardware: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuVendor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuVendor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sockets", wireType)
			}
			m.Sockets = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sockets |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoresPerSocket", wireType)
			}
			m.CoresPerSocket = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CoresPerSocket |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ThreadsPerCore", wireType)
			}
			m.ThreadsPerCore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ThreadsPerCore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MemoryType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemorySpeedMhz", wireType)
			}
			m.MemorySpeedMhz = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MemorySpeedMhz |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GpuModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GpuMemoryGb", wireType)
			}
			m.GpuMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GpuMemoryGb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StorageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StorageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Features = append(m.Features, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeTopology) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeTopology: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeTopology: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaNodes", wireType)
			}
			m.NumaNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumaMemoryGb", wireType)
			}
			m.NumaMemoryGb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumaMemoryGb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interconnect", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Interconnect = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkFabric", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkFabric = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopologyHint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TopologyHint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeLocality) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeLocality: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeLocality: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Row", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Row = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Position", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Position = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Datacenter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Datacenter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyMeasurements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyMeasurements = append(m.LatencyMeasurements, LatencyMeasurement{})
			if err := m.LatencyMeasurements[len(m.LatencyMeasurements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgLatencyMs", wireType)
			}
			m.AvgLatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvgLatencyMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkBandwidthMbps", wireType)
			}
			m.NetworkBandwidthMbps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NetworkBandwidthMbps |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Resources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.LastHeartbeat, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JoinedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.JoinedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= NodeState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HealthStatus", wireType)
			}
			m.HealthStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HealthStatus |= HealthStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentPubkey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentPubkey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HardwareFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AgentVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AgentVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSequenceNumber", wireType)
			}
			m.LastSequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSequenceNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Capacity == nil {
				m.Capacity = &NodeCapacity{}
			}
			if err := m.Capacity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Health", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Health == nil {
				m.Health = &NodeHealth{}
			}
			if err := m.Health.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hardware", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hardware == nil {
				m.Hardware = &NodeHardware{}
			}
			if err := m.Hardware.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topology", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Topology == nil {
				m.Topology = &NodeTopology{}
			}
			if err := m.Topology.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locality", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Locality == nil {
				m.Locality = &NodeLocality{}
			}
			if err := m.Locality.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClusterCandidate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClusterCandidate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClusterCandidate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgLatencyMs", wireType)
			}
			m.AvgLatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvgLatencyMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableNodes", wireType)
			}
			m.AvailableNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableNodes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapacityScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombinedScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombinedScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eligible", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Eligible = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IneligibilityReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IneligibilityReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SchedulingDecision) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SchedulingDecision: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SchedulingDecision: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelectedClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelectedClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CandidateClusters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CandidateClusters = append(m.CandidateClusters, ClusterCandidate{})
			if err := m.CandidateClusters[len(m.CandidateClusters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DecisionReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DecisionReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFallback", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFallback = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FallbackReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FallbackReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapacityScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CombinedScore", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CombinedScore = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCRewardRecipient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCRewardRecipient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCRewardRecipient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContributionWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContributionWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardCalculationDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardCalculationDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardCalculationDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsageValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalUsageValue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardPoolContribution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardPoolContribution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeContributionFormula", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeContributionFormula = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InputMetrics", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InputMetrics == nil {
				m.InputMetrics = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InputMetrics[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCRewardRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCRewardRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCRewardRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			m.Source = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Source |= HPCRewardSource(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalReward = append(m.TotalReward, types.Coin{})
			if err := m.TotalReward[len(m.TotalReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipients = append(m.Recipients, HPCRewardRecipient{})
			if err := m.Recipients[len(m.Recipients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferencedUsageRecords", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferencedUsageRecords = append(m.ReferencedUsageRecords, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobCompletionStatus", wireType)
			}
			m.JobCompletionStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JobCompletionStatus |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FormulaVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FormulaVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculationDetails", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CalculationDetails.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Disputed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Disputed = bool(v != 0)
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.IssuedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HPCDispute) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HPCDispute: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HPCDispute: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= DisputeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolution = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolverAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolverAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResolvedAt == nil {
				m.ResolvedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ResolvedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderRewardRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderRewardRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeRewardRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeRewardRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinJobDurationSeconds", wireType)
			}
			m.MinJobDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinJobDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxJobDurationSeconds", wireType)
			}
			m.MaxJobDurationSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxJobDurationSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultIdentityThreshold", wireType)
			}
			m.DefaultIdentityThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultIdentityThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterHeartbeatTimeout", wireType)
			}
			m.ClusterHeartbeatTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterHeartbeatTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeHeartbeatTimeout", wireType)
			}
			m.NodeHeartbeatTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeHeartbeatTimeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatencyWeightFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LatencyWeightFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CapacityWeightFactor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CapacityWeightFactor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxLatencyMs", wireType)
			}
			m.MaxLatencyMs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxLatencyMs |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeResolutionPeriod", wireType)
			}
			m.DisputeResolutionPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputeResolutionPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardFormulaVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardFormulaVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableProximityClustering", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableProximityClustering = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
