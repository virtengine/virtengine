// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/mfa/v1/types.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// FactorType represents the type of authentication factor
type FactorType int32

const (
	// FACTOR_TYPE_UNSPECIFIED represents an unspecified factor type
	FactorTypeUnspecified FactorType = 0
	// FACTOR_TYPE_TOTP represents Time-based One-Time Password
	FactorTypeTOTP FactorType = 1
	// FACTOR_TYPE_FIDO2 represents FIDO2/WebAuthn authentication
	FactorTypeFIDO2 FactorType = 2
	// FACTOR_TYPE_SMS represents SMS OTP authentication
	FactorTypeSMS FactorType = 3
	// FACTOR_TYPE_EMAIL represents Email OTP authentication
	FactorTypeEmail FactorType = 4
	// FACTOR_TYPE_VEID represents VEID identity score threshold
	FactorTypeVEID FactorType = 5
	// FACTOR_TYPE_TRUSTED_DEVICE represents trusted browser/device binding
	FactorTypeTrustedDevice FactorType = 6
	// FACTOR_TYPE_HARDWARE_KEY represents X.509/smart card/PIV hardware key authentication
	FactorTypeHardwareKey FactorType = 7
)

var FactorType_name = map[int32]string{
	0: "FACTOR_TYPE_UNSPECIFIED",
	1: "FACTOR_TYPE_TOTP",
	2: "FACTOR_TYPE_FIDO2",
	3: "FACTOR_TYPE_SMS",
	4: "FACTOR_TYPE_EMAIL",
	5: "FACTOR_TYPE_VEID",
	6: "FACTOR_TYPE_TRUSTED_DEVICE",
	7: "FACTOR_TYPE_HARDWARE_KEY",
}

var FactorType_value = map[string]int32{
	"FACTOR_TYPE_UNSPECIFIED":    0,
	"FACTOR_TYPE_TOTP":           1,
	"FACTOR_TYPE_FIDO2":          2,
	"FACTOR_TYPE_SMS":            3,
	"FACTOR_TYPE_EMAIL":          4,
	"FACTOR_TYPE_VEID":           5,
	"FACTOR_TYPE_TRUSTED_DEVICE": 6,
	"FACTOR_TYPE_HARDWARE_KEY":   7,
}

func (x FactorType) String() string {
	return proto.EnumName(FactorType_name, int32(x))
}

func (FactorType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{0}
}

// FactorSecurityLevel represents the security level of a factor
type FactorSecurityLevel int32

const (
	// FACTOR_SECURITY_LEVEL_UNSPECIFIED represents an unspecified security level
	FactorSecurityLevelUnspecified FactorSecurityLevel = 0
	// FACTOR_SECURITY_LEVEL_LOW represents low security factors (email, SMS)
	FactorSecurityLevelLow FactorSecurityLevel = 1
	// FACTOR_SECURITY_LEVEL_MEDIUM represents medium security factors (TOTP)
	FactorSecurityLevelMedium FactorSecurityLevel = 2
	// FACTOR_SECURITY_LEVEL_HIGH represents high security factors (FIDO2, VEID)
	FactorSecurityLevelHigh FactorSecurityLevel = 3
)

var FactorSecurityLevel_name = map[int32]string{
	0: "FACTOR_SECURITY_LEVEL_UNSPECIFIED",
	1: "FACTOR_SECURITY_LEVEL_LOW",
	2: "FACTOR_SECURITY_LEVEL_MEDIUM",
	3: "FACTOR_SECURITY_LEVEL_HIGH",
}

var FactorSecurityLevel_value = map[string]int32{
	"FACTOR_SECURITY_LEVEL_UNSPECIFIED": 0,
	"FACTOR_SECURITY_LEVEL_LOW":         1,
	"FACTOR_SECURITY_LEVEL_MEDIUM":      2,
	"FACTOR_SECURITY_LEVEL_HIGH":        3,
}

func (x FactorSecurityLevel) String() string {
	return proto.EnumName(FactorSecurityLevel_name, int32(x))
}

func (FactorSecurityLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{1}
}

// FactorEnrollmentStatus represents the status of a factor enrollment
type FactorEnrollmentStatus int32

const (
	// ENROLLMENT_STATUS_UNSPECIFIED represents an unspecified status
	EnrollmentStatusUnspecified FactorEnrollmentStatus = 0
	// ENROLLMENT_STATUS_PENDING represents a pending enrollment awaiting verification
	EnrollmentStatusPending FactorEnrollmentStatus = 1
	// ENROLLMENT_STATUS_ACTIVE represents an active, verified enrollment
	EnrollmentStatusActive FactorEnrollmentStatus = 2
	// ENROLLMENT_STATUS_REVOKED represents a revoked enrollment
	EnrollmentStatusRevoked FactorEnrollmentStatus = 3
	// ENROLLMENT_STATUS_EXPIRED represents an expired enrollment
	EnrollmentStatusExpired FactorEnrollmentStatus = 4
)

var FactorEnrollmentStatus_name = map[int32]string{
	0: "ENROLLMENT_STATUS_UNSPECIFIED",
	1: "ENROLLMENT_STATUS_PENDING",
	2: "ENROLLMENT_STATUS_ACTIVE",
	3: "ENROLLMENT_STATUS_REVOKED",
	4: "ENROLLMENT_STATUS_EXPIRED",
}

var FactorEnrollmentStatus_value = map[string]int32{
	"ENROLLMENT_STATUS_UNSPECIFIED": 0,
	"ENROLLMENT_STATUS_PENDING":     1,
	"ENROLLMENT_STATUS_ACTIVE":      2,
	"ENROLLMENT_STATUS_REVOKED":     3,
	"ENROLLMENT_STATUS_EXPIRED":     4,
}

func (x FactorEnrollmentStatus) String() string {
	return proto.EnumName(FactorEnrollmentStatus_name, int32(x))
}

func (FactorEnrollmentStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{2}
}

// ChallengeStatus represents the status of an MFA challenge
type ChallengeStatus int32

const (
	// CHALLENGE_STATUS_UNSPECIFIED represents an unspecified status
	ChallengeStatusUnspecified ChallengeStatus = 0
	// CHALLENGE_STATUS_PENDING represents a challenge awaiting response
	ChallengeStatusPending ChallengeStatus = 1
	// CHALLENGE_STATUS_VERIFIED represents a successfully verified challenge
	ChallengeStatusVerified ChallengeStatus = 2
	// CHALLENGE_STATUS_FAILED represents a failed challenge
	ChallengeStatusFailed ChallengeStatus = 3
	// CHALLENGE_STATUS_EXPIRED represents an expired challenge
	ChallengeStatusExpired ChallengeStatus = 4
	// CHALLENGE_STATUS_CANCELLED represents a cancelled challenge
	ChallengeStatusCancelled ChallengeStatus = 5
)

var ChallengeStatus_name = map[int32]string{
	0: "CHALLENGE_STATUS_UNSPECIFIED",
	1: "CHALLENGE_STATUS_PENDING",
	2: "CHALLENGE_STATUS_VERIFIED",
	3: "CHALLENGE_STATUS_FAILED",
	4: "CHALLENGE_STATUS_EXPIRED",
	5: "CHALLENGE_STATUS_CANCELLED",
}

var ChallengeStatus_value = map[string]int32{
	"CHALLENGE_STATUS_UNSPECIFIED": 0,
	"CHALLENGE_STATUS_PENDING":     1,
	"CHALLENGE_STATUS_VERIFIED":    2,
	"CHALLENGE_STATUS_FAILED":      3,
	"CHALLENGE_STATUS_EXPIRED":     4,
	"CHALLENGE_STATUS_CANCELLED":   5,
}

func (x ChallengeStatus) String() string {
	return proto.EnumName(ChallengeStatus_name, int32(x))
}

func (ChallengeStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{3}
}

// SensitiveTransactionType represents types of transactions that require MFA
type SensitiveTransactionType int32

const (
	// SENSITIVE_TX_UNSPECIFIED represents an unspecified transaction type
	SensitiveTxUnspecified SensitiveTransactionType = 0
	// SENSITIVE_TX_ACCOUNT_RECOVERY represents account recovery operations
	SensitiveTxAccountRecovery SensitiveTransactionType = 1
	// SENSITIVE_TX_KEY_ROTATION represents key rotation operations
	SensitiveTxKeyRotation SensitiveTransactionType = 2
	// SENSITIVE_TX_LARGE_WITHDRAWAL represents large token withdrawals
	SensitiveTxLargeWithdrawal SensitiveTransactionType = 3
	// SENSITIVE_TX_PROVIDER_REGISTRATION represents provider registration
	SensitiveTxProviderRegistration SensitiveTransactionType = 4
	// SENSITIVE_TX_VALIDATOR_REGISTRATION represents validator registration
	SensitiveTxValidatorRegistration SensitiveTransactionType = 5
	// SENSITIVE_TX_HIGH_VALUE_ORDER represents high-value marketplace orders
	SensitiveTxHighValueOrder SensitiveTransactionType = 6
	// SENSITIVE_TX_ROLE_ASSIGNMENT represents role assignment operations
	SensitiveTxRoleAssignment SensitiveTransactionType = 7
	// SENSITIVE_TX_GOVERNANCE_PROPOSAL represents governance proposal creation
	SensitiveTxGovernanceProposal SensitiveTransactionType = 8
	// SENSITIVE_TX_PRIMARY_EMAIL_CHANGE represents primary email changes
	SensitiveTxPrimaryEmailChange SensitiveTransactionType = 9
	// SENSITIVE_TX_PHONE_NUMBER_CHANGE represents phone number changes
	SensitiveTxPhoneNumberChange SensitiveTransactionType = 10
	// SENSITIVE_TX_TWO_FACTOR_DISABLE represents disabling 2FA
	SensitiveTxTwoFactorDisable SensitiveTransactionType = 11
	// SENSITIVE_TX_ACCOUNT_DELETION represents account deletion
	SensitiveTxAccountDeletion SensitiveTransactionType = 12
	// SENSITIVE_TX_GOVERNANCE_VOTE represents high-stake governance votes
	SensitiveTxGovernanceVote SensitiveTransactionType = 13
	// SENSITIVE_TX_FIRST_OFFERING_CREATE represents first offering creation by provider
	SensitiveTxFirstOfferingCreate SensitiveTransactionType = 14
	// SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS represents transfers to new addresses
	SensitiveTxTransferToNewAddress SensitiveTransactionType = 15
	// SENSITIVE_TX_MEDIUM_WITHDRAWAL represents medium-value withdrawals
	SensitiveTxMediumWithdrawal SensitiveTransactionType = 16
	// SENSITIVE_TX_API_KEY_GENERATION represents API key generation
	SensitiveTxAPIKeyGeneration SensitiveTransactionType = 17
	// SENSITIVE_TX_WEBHOOK_CONFIGURATION represents webhook configuration
	SensitiveTxWebhookConfiguration SensitiveTransactionType = 18
)

var SensitiveTransactionType_name = map[int32]string{
	0:  "SENSITIVE_TX_UNSPECIFIED",
	1:  "SENSITIVE_TX_ACCOUNT_RECOVERY",
	2:  "SENSITIVE_TX_KEY_ROTATION",
	3:  "SENSITIVE_TX_LARGE_WITHDRAWAL",
	4:  "SENSITIVE_TX_PROVIDER_REGISTRATION",
	5:  "SENSITIVE_TX_VALIDATOR_REGISTRATION",
	6:  "SENSITIVE_TX_HIGH_VALUE_ORDER",
	7:  "SENSITIVE_TX_ROLE_ASSIGNMENT",
	8:  "SENSITIVE_TX_GOVERNANCE_PROPOSAL",
	9:  "SENSITIVE_TX_PRIMARY_EMAIL_CHANGE",
	10: "SENSITIVE_TX_PHONE_NUMBER_CHANGE",
	11: "SENSITIVE_TX_TWO_FACTOR_DISABLE",
	12: "SENSITIVE_TX_ACCOUNT_DELETION",
	13: "SENSITIVE_TX_GOVERNANCE_VOTE",
	14: "SENSITIVE_TX_FIRST_OFFERING_CREATE",
	15: "SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS",
	16: "SENSITIVE_TX_MEDIUM_WITHDRAWAL",
	17: "SENSITIVE_TX_API_KEY_GENERATION",
	18: "SENSITIVE_TX_WEBHOOK_CONFIGURATION",
}

var SensitiveTransactionType_value = map[string]int32{
	"SENSITIVE_TX_UNSPECIFIED":             0,
	"SENSITIVE_TX_ACCOUNT_RECOVERY":        1,
	"SENSITIVE_TX_KEY_ROTATION":            2,
	"SENSITIVE_TX_LARGE_WITHDRAWAL":        3,
	"SENSITIVE_TX_PROVIDER_REGISTRATION":   4,
	"SENSITIVE_TX_VALIDATOR_REGISTRATION":  5,
	"SENSITIVE_TX_HIGH_VALUE_ORDER":        6,
	"SENSITIVE_TX_ROLE_ASSIGNMENT":         7,
	"SENSITIVE_TX_GOVERNANCE_PROPOSAL":     8,
	"SENSITIVE_TX_PRIMARY_EMAIL_CHANGE":    9,
	"SENSITIVE_TX_PHONE_NUMBER_CHANGE":     10,
	"SENSITIVE_TX_TWO_FACTOR_DISABLE":      11,
	"SENSITIVE_TX_ACCOUNT_DELETION":        12,
	"SENSITIVE_TX_GOVERNANCE_VOTE":         13,
	"SENSITIVE_TX_FIRST_OFFERING_CREATE":   14,
	"SENSITIVE_TX_TRANSFER_TO_NEW_ADDRESS": 15,
	"SENSITIVE_TX_MEDIUM_WITHDRAWAL":       16,
	"SENSITIVE_TX_API_KEY_GENERATION":      17,
	"SENSITIVE_TX_WEBHOOK_CONFIGURATION":   18,
}

func (x SensitiveTransactionType) String() string {
	return proto.EnumName(SensitiveTransactionType_name, int32(x))
}

func (SensitiveTransactionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{4}
}

// HardwareKeyType represents the type of hardware key
type HardwareKeyType int32

const (
	// HARDWARE_KEY_TYPE_UNSPECIFIED represents an unspecified hardware key type
	HardwareKeyTypeUnspecified HardwareKeyType = 0
	// HARDWARE_KEY_TYPE_X509 represents X.509 certificate-based authentication
	HardwareKeyTypeX509 HardwareKeyType = 1
	// HARDWARE_KEY_TYPE_SMART_CARD represents smart card/PIV authentication
	HardwareKeyTypeSmartCard HardwareKeyType = 2
	// HARDWARE_KEY_TYPE_PIV represents PIV (Personal Identity Verification) card
	HardwareKeyTypePIV HardwareKeyType = 3
)

var HardwareKeyType_name = map[int32]string{
	0: "HARDWARE_KEY_TYPE_UNSPECIFIED",
	1: "HARDWARE_KEY_TYPE_X509",
	2: "HARDWARE_KEY_TYPE_SMART_CARD",
	3: "HARDWARE_KEY_TYPE_PIV",
}

var HardwareKeyType_value = map[string]int32{
	"HARDWARE_KEY_TYPE_UNSPECIFIED": 0,
	"HARDWARE_KEY_TYPE_X509":        1,
	"HARDWARE_KEY_TYPE_SMART_CARD":  2,
	"HARDWARE_KEY_TYPE_PIV":         3,
}

func (x HardwareKeyType) String() string {
	return proto.EnumName(HardwareKeyType_name, int32(x))
}

func (HardwareKeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{5}
}

// RevocationStatus represents the revocation status of a certificate
type RevocationStatus int32

const (
	// REVOCATION_STATUS_UNKNOWN indicates the revocation status is unknown
	RevocationStatusUnknown RevocationStatus = 0
	// REVOCATION_STATUS_GOOD indicates the certificate is not revoked
	RevocationStatusGood RevocationStatus = 1
	// REVOCATION_STATUS_REVOKED indicates the certificate has been revoked
	RevocationStatusRevoked RevocationStatus = 2
	// REVOCATION_STATUS_CHECK_FAILED indicates the revocation check failed
	RevocationStatusCheckFailed RevocationStatus = 3
)

var RevocationStatus_name = map[int32]string{
	0: "REVOCATION_STATUS_UNKNOWN",
	1: "REVOCATION_STATUS_GOOD",
	2: "REVOCATION_STATUS_REVOKED",
	3: "REVOCATION_STATUS_CHECK_FAILED",
}

var RevocationStatus_value = map[string]int32{
	"REVOCATION_STATUS_UNKNOWN":      0,
	"REVOCATION_STATUS_GOOD":         1,
	"REVOCATION_STATUS_REVOKED":      2,
	"REVOCATION_STATUS_CHECK_FAILED": 3,
}

func (x RevocationStatus) String() string {
	return proto.EnumName(RevocationStatus_name, int32(x))
}

func (RevocationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{6}
}

// MFAProof represents proof of MFA verification
type MFAProof struct {
	// SessionID is the authorization session ID
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id" yaml:"session_id"`
	// VerifiedFactors are the factors that were verified
	VerifiedFactors []FactorType `protobuf:"varint,2,rep,packed,name=verified_factors,json=verifiedFactors,proto3,enum=virtengine.mfa.v1.FactorType" json:"verified_factors" yaml:"verified_factors"`
	// Timestamp is when the proof was generated (Unix timestamp)
	Timestamp int64 `protobuf:"varint,3,opt,name=timestamp,proto3" json:"timestamp" yaml:"timestamp"`
	// Signature is the signature over the proof data
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" yaml:"signature"`
}

func (m *MFAProof) Reset()         { *m = MFAProof{} }
func (m *MFAProof) String() string { return proto.CompactTextString(m) }
func (*MFAProof) ProtoMessage()    {}
func (*MFAProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{0}
}
func (m *MFAProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFAProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFAProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFAProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFAProof.Merge(m, src)
}
func (m *MFAProof) XXX_Size() int {
	return m.Size()
}
func (m *MFAProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MFAProof.DiscardUnknown(m)
}

var xxx_messageInfo_MFAProof proto.InternalMessageInfo

func (m *MFAProof) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *MFAProof) GetVerifiedFactors() []FactorType {
	if m != nil {
		return m.VerifiedFactors
	}
	return nil
}

func (m *MFAProof) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *MFAProof) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// FactorCombination represents a set of factors that must ALL be satisfied (AND logic)
type FactorCombination struct {
	// Factors is the list of factor types that must all be verified
	Factors []FactorType `protobuf:"varint,1,rep,packed,name=factors,proto3,enum=virtengine.mfa.v1.FactorType" json:"factors" yaml:"factors"`
	// MinSecurityLevel is the minimum security level required for the combination
	MinSecurityLevel FactorSecurityLevel `protobuf:"varint,2,opt,name=min_security_level,json=minSecurityLevel,proto3,enum=virtengine.mfa.v1.FactorSecurityLevel" json:"min_security_level" yaml:"min_security_level"`
}

func (m *FactorCombination) Reset()         { *m = FactorCombination{} }
func (m *FactorCombination) String() string { return proto.CompactTextString(m) }
func (*FactorCombination) ProtoMessage()    {}
func (*FactorCombination) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{1}
}
func (m *FactorCombination) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FactorCombination) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FactorCombination.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FactorCombination) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FactorCombination.Merge(m, src)
}
func (m *FactorCombination) XXX_Size() int {
	return m.Size()
}
func (m *FactorCombination) XXX_DiscardUnknown() {
	xxx_messageInfo_FactorCombination.DiscardUnknown(m)
}

var xxx_messageInfo_FactorCombination proto.InternalMessageInfo

func (m *FactorCombination) GetFactors() []FactorType {
	if m != nil {
		return m.Factors
	}
	return nil
}

func (m *FactorCombination) GetMinSecurityLevel() FactorSecurityLevel {
	if m != nil {
		return m.MinSecurityLevel
	}
	return FactorSecurityLevelUnspecified
}

// FactorMetadata contains type-specific metadata for enrollments
type FactorMetadata struct {
	// VEIDThreshold is the minimum VEID score required (for VEID factor)
	VeidThreshold uint32 `protobuf:"varint,1,opt,name=veid_threshold,json=veidThreshold,proto3" json:"veid_threshold,omitempty" yaml:"veid_threshold"`
	// DeviceInfo contains device information (for TrustedDevice factor)
	DeviceInfo *DeviceInfo `protobuf:"bytes,2,opt,name=device_info,json=deviceInfo,proto3" json:"device_info,omitempty" yaml:"device_info"`
	// FIDO2Info contains FIDO2-specific metadata
	Fido2Info *FIDO2CredentialInfo `protobuf:"bytes,3,opt,name=fido2_info,json=fido2Info,proto3" json:"fido2_info,omitempty" yaml:"fido2_info"`
	// ContactHash contains a hash of the contact info (for SMS/Email verification tracking)
	ContactHash string `protobuf:"bytes,4,opt,name=contact_hash,json=contactHash,proto3" json:"contact_hash,omitempty" yaml:"contact_hash"`
	// HardwareKeyInfo contains hardware key/X.509/smart card metadata
	HardwareKeyInfo *HardwareKeyEnrollment `protobuf:"bytes,5,opt,name=hardware_key_info,json=hardwareKeyInfo,proto3" json:"hardware_key_info,omitempty" yaml:"hardware_key_info"`
}

func (m *FactorMetadata) Reset()         { *m = FactorMetadata{} }
func (m *FactorMetadata) String() string { return proto.CompactTextString(m) }
func (*FactorMetadata) ProtoMessage()    {}
func (*FactorMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{2}
}
func (m *FactorMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FactorMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FactorMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FactorMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FactorMetadata.Merge(m, src)
}
func (m *FactorMetadata) XXX_Size() int {
	return m.Size()
}
func (m *FactorMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_FactorMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_FactorMetadata proto.InternalMessageInfo

func (m *FactorMetadata) GetVeidThreshold() uint32 {
	if m != nil {
		return m.VeidThreshold
	}
	return 0
}

func (m *FactorMetadata) GetDeviceInfo() *DeviceInfo {
	if m != nil {
		return m.DeviceInfo
	}
	return nil
}

func (m *FactorMetadata) GetFido2Info() *FIDO2CredentialInfo {
	if m != nil {
		return m.Fido2Info
	}
	return nil
}

func (m *FactorMetadata) GetContactHash() string {
	if m != nil {
		return m.ContactHash
	}
	return ""
}

func (m *FactorMetadata) GetHardwareKeyInfo() *HardwareKeyEnrollment {
	if m != nil {
		return m.HardwareKeyInfo
	}
	return nil
}

// DeviceInfo contains information about a trusted device
type DeviceInfo struct {
	// Fingerprint is a unique hash identifying the device
	Fingerprint string `protobuf:"bytes,1,opt,name=fingerprint,proto3" json:"fingerprint" yaml:"fingerprint"`
	// UserAgent is the user agent string (sanitized)
	UserAgent string `protobuf:"bytes,2,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty" yaml:"user_agent"`
	// FirstSeenAt is when this device was first seen
	FirstSeenAt int64 `protobuf:"varint,3,opt,name=first_seen_at,json=firstSeenAt,proto3" json:"first_seen_at" yaml:"first_seen_at"`
	// LastSeenAt is when this device was last seen
	LastSeenAt int64 `protobuf:"varint,4,opt,name=last_seen_at,json=lastSeenAt,proto3" json:"last_seen_at" yaml:"last_seen_at"`
	// IPHash is a hash of the last known IP (for change detection, not tracking)
	IpHash string `protobuf:"bytes,5,opt,name=ip_hash,json=ipHash,proto3" json:"ip_hash,omitempty" yaml:"ip_hash"`
	// TrustExpiresAt is when the device trust expires
	TrustExpiresAt int64 `protobuf:"varint,6,opt,name=trust_expires_at,json=trustExpiresAt,proto3" json:"trust_expires_at" yaml:"trust_expires_at"`
}

func (m *DeviceInfo) Reset()         { *m = DeviceInfo{} }
func (m *DeviceInfo) String() string { return proto.CompactTextString(m) }
func (*DeviceInfo) ProtoMessage()    {}
func (*DeviceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{3}
}
func (m *DeviceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeviceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeviceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeviceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeviceInfo.Merge(m, src)
}
func (m *DeviceInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeviceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeviceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeviceInfo proto.InternalMessageInfo

func (m *DeviceInfo) GetFingerprint() string {
	if m != nil {
		return m.Fingerprint
	}
	return ""
}

func (m *DeviceInfo) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *DeviceInfo) GetFirstSeenAt() int64 {
	if m != nil {
		return m.FirstSeenAt
	}
	return 0
}

func (m *DeviceInfo) GetLastSeenAt() int64 {
	if m != nil {
		return m.LastSeenAt
	}
	return 0
}

func (m *DeviceInfo) GetIpHash() string {
	if m != nil {
		return m.IpHash
	}
	return ""
}

func (m *DeviceInfo) GetTrustExpiresAt() int64 {
	if m != nil {
		return m.TrustExpiresAt
	}
	return 0
}

// FIDO2CredentialInfo contains FIDO2-specific credential information
type FIDO2CredentialInfo struct {
	// CredentialID is the FIDO2 credential identifier
	CredentialId []byte `protobuf:"bytes,1,opt,name=credential_id,json=credentialId,proto3" json:"credential_id" yaml:"credential_id"`
	// PublicKey is the COSE-encoded public key
	PublicKey []byte `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key" yaml:"public_key"`
	// AAGUID is the Authenticator Attestation GUID
	Aaguid []byte `protobuf:"bytes,3,opt,name=aaguid,proto3" json:"aaguid,omitempty" yaml:"aaguid"`
	// SignCount is the signature counter for clone detection
	SignCount uint32 `protobuf:"varint,4,opt,name=sign_count,json=signCount,proto3" json:"sign_count" yaml:"sign_count"`
	// AttestationType indicates the attestation type used
	AttestationType string `protobuf:"bytes,5,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type,omitempty" yaml:"attestation_type"`
}

func (m *FIDO2CredentialInfo) Reset()         { *m = FIDO2CredentialInfo{} }
func (m *FIDO2CredentialInfo) String() string { return proto.CompactTextString(m) }
func (*FIDO2CredentialInfo) ProtoMessage()    {}
func (*FIDO2CredentialInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{4}
}
func (m *FIDO2CredentialInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FIDO2CredentialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FIDO2CredentialInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FIDO2CredentialInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FIDO2CredentialInfo.Merge(m, src)
}
func (m *FIDO2CredentialInfo) XXX_Size() int {
	return m.Size()
}
func (m *FIDO2CredentialInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_FIDO2CredentialInfo.DiscardUnknown(m)
}

var xxx_messageInfo_FIDO2CredentialInfo proto.InternalMessageInfo

func (m *FIDO2CredentialInfo) GetCredentialId() []byte {
	if m != nil {
		return m.CredentialId
	}
	return nil
}

func (m *FIDO2CredentialInfo) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *FIDO2CredentialInfo) GetAaguid() []byte {
	if m != nil {
		return m.Aaguid
	}
	return nil
}

func (m *FIDO2CredentialInfo) GetSignCount() uint32 {
	if m != nil {
		return m.SignCount
	}
	return 0
}

func (m *FIDO2CredentialInfo) GetAttestationType() string {
	if m != nil {
		return m.AttestationType
	}
	return ""
}

// HardwareKeyEnrollment represents a hardware key enrollment for MFA
type HardwareKeyEnrollment struct {
	// KeyType is the type of hardware key
	KeyType HardwareKeyType `protobuf:"varint,1,opt,name=key_type,json=keyType,proto3,enum=virtengine.mfa.v1.HardwareKeyType" json:"key_type" yaml:"key_type"`
	// KeyID is a unique identifier for this key (certificate fingerprint or card serial)
	KeyId string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id" yaml:"key_id"`
	// SubjectDN is the distinguished name from the certificate subject
	SubjectDn string `protobuf:"bytes,3,opt,name=subject_dn,json=subjectDn,proto3" json:"subject_dn,omitempty" yaml:"subject_dn"`
	// IssuerDN is the distinguished name of the certificate issuer
	IssuerDn string `protobuf:"bytes,4,opt,name=issuer_dn,json=issuerDn,proto3" json:"issuer_dn,omitempty" yaml:"issuer_dn"`
	// SerialNumber is the certificate serial number (hex encoded)
	SerialNumber string `protobuf:"bytes,5,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty" yaml:"serial_number"`
	// PublicKeyFingerprint is SHA-256 hash of the public key (hex encoded)
	PublicKeyFingerprint string `protobuf:"bytes,6,opt,name=public_key_fingerprint,json=publicKeyFingerprint,proto3" json:"public_key_fingerprint" yaml:"public_key_fingerprint"`
	// NotBefore is the certificate validity start time
	NotBefore int64 `protobuf:"varint,7,opt,name=not_before,json=notBefore,proto3" json:"not_before" yaml:"not_before"`
	// NotAfter is the certificate validity end time
	NotAfter int64 `protobuf:"varint,8,opt,name=not_after,json=notAfter,proto3" json:"not_after" yaml:"not_after"`
	// KeyUsage indicates the allowed key usage flags
	KeyUsage []string `protobuf:"bytes,9,rep,name=key_usage,json=keyUsage,proto3" json:"key_usage,omitempty" yaml:"key_usage"`
	// ExtendedKeyUsage indicates extended key usage purposes
	ExtendedKeyUsage []string `protobuf:"bytes,10,rep,name=extended_key_usage,json=extendedKeyUsage,proto3" json:"extended_key_usage,omitempty" yaml:"extended_key_usage"`
	// SmartCardInfo contains smart card specific metadata
	SmartCardInfo *SmartCardInfo `protobuf:"bytes,11,opt,name=smart_card_info,json=smartCardInfo,proto3" json:"smart_card_info,omitempty" yaml:"smart_card_info"`
	// RevocationCheckEnabled indicates if revocation checking is enabled
	RevocationCheckEnabled bool `protobuf:"varint,12,opt,name=revocation_check_enabled,json=revocationCheckEnabled,proto3" json:"revocation_check_enabled" yaml:"revocation_check_enabled"`
	// LastRevocationCheck is the timestamp of the last revocation check
	LastRevocationCheck int64 `protobuf:"varint,13,opt,name=last_revocation_check,json=lastRevocationCheck,proto3" json:"last_revocation_check,omitempty" yaml:"last_revocation_check"`
	// RevocationStatus is the current revocation status
	RevocationStatus RevocationStatus `protobuf:"varint,14,opt,name=revocation_status,json=revocationStatus,proto3,enum=virtengine.mfa.v1.RevocationStatus" json:"revocation_status" yaml:"revocation_status"`
	// TrustedCACertFingerprints are the fingerprints of trusted CA certificates
	TrustedCaCertFingerprints []string `protobuf:"bytes,15,rep,name=trusted_ca_cert_fingerprints,json=trustedCaCertFingerprints,proto3" json:"trusted_ca_cert_fingerprints,omitempty" yaml:"trusted_ca_cert_fingerprints"`
}

func (m *HardwareKeyEnrollment) Reset()         { *m = HardwareKeyEnrollment{} }
func (m *HardwareKeyEnrollment) String() string { return proto.CompactTextString(m) }
func (*HardwareKeyEnrollment) ProtoMessage()    {}
func (*HardwareKeyEnrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{5}
}
func (m *HardwareKeyEnrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareKeyEnrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardwareKeyEnrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardwareKeyEnrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareKeyEnrollment.Merge(m, src)
}
func (m *HardwareKeyEnrollment) XXX_Size() int {
	return m.Size()
}
func (m *HardwareKeyEnrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareKeyEnrollment.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareKeyEnrollment proto.InternalMessageInfo

func (m *HardwareKeyEnrollment) GetKeyType() HardwareKeyType {
	if m != nil {
		return m.KeyType
	}
	return HardwareKeyTypeUnspecified
}

func (m *HardwareKeyEnrollment) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *HardwareKeyEnrollment) GetSubjectDn() string {
	if m != nil {
		return m.SubjectDn
	}
	return ""
}

func (m *HardwareKeyEnrollment) GetIssuerDn() string {
	if m != nil {
		return m.IssuerDn
	}
	return ""
}

func (m *HardwareKeyEnrollment) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *HardwareKeyEnrollment) GetPublicKeyFingerprint() string {
	if m != nil {
		return m.PublicKeyFingerprint
	}
	return ""
}

func (m *HardwareKeyEnrollment) GetNotBefore() int64 {
	if m != nil {
		return m.NotBefore
	}
	return 0
}

func (m *HardwareKeyEnrollment) GetNotAfter() int64 {
	if m != nil {
		return m.NotAfter
	}
	return 0
}

func (m *HardwareKeyEnrollment) GetKeyUsage() []string {
	if m != nil {
		return m.KeyUsage
	}
	return nil
}

func (m *HardwareKeyEnrollment) GetExtendedKeyUsage() []string {
	if m != nil {
		return m.ExtendedKeyUsage
	}
	return nil
}

func (m *HardwareKeyEnrollment) GetSmartCardInfo() *SmartCardInfo {
	if m != nil {
		return m.SmartCardInfo
	}
	return nil
}

func (m *HardwareKeyEnrollment) GetRevocationCheckEnabled() bool {
	if m != nil {
		return m.RevocationCheckEnabled
	}
	return false
}

func (m *HardwareKeyEnrollment) GetLastRevocationCheck() int64 {
	if m != nil {
		return m.LastRevocationCheck
	}
	return 0
}

func (m *HardwareKeyEnrollment) GetRevocationStatus() RevocationStatus {
	if m != nil {
		return m.RevocationStatus
	}
	return RevocationStatusUnknown
}

func (m *HardwareKeyEnrollment) GetTrustedCaCertFingerprints() []string {
	if m != nil {
		return m.TrustedCaCertFingerprints
	}
	return nil
}

// SmartCardInfo contains smart card/PIV specific information
type SmartCardInfo struct {
	// CardSerialNumber is the smart card serial number
	CardSerialNumber string `protobuf:"bytes,1,opt,name=card_serial_number,json=cardSerialNumber,proto3" json:"card_serial_number" yaml:"card_serial_number"`
	// CardType indicates the type of smart card (PIV, CAC, etc.)
	CardType string `protobuf:"bytes,2,opt,name=card_type,json=cardType,proto3" json:"card_type" yaml:"card_type"`
	// SlotID indicates which slot the certificate was read from
	SlotId string `protobuf:"bytes,3,opt,name=slot_id,json=slotId,proto3" json:"slot_id,omitempty" yaml:"slot_id"`
	// CHUID is the Card Holder Unique Identifier (for PIV cards)
	Chuid string `protobuf:"bytes,4,opt,name=chuid,proto3" json:"chuid,omitempty" yaml:"chuid"`
	// FASC_N is the Federal Agency Smart Credential Number (if available)
	Fascn string `protobuf:"bytes,5,opt,name=fascn,proto3" json:"fascn,omitempty" yaml:"fascn"`
	// CardHolderName is the name on the card (from CHUID or certificate)
	CardHolderName string `protobuf:"bytes,6,opt,name=card_holder_name,json=cardHolderName,proto3" json:"card_holder_name,omitempty" yaml:"card_holder_name"`
	// ExpirationDate is when the card expires
	ExpirationDate int64 `protobuf:"varint,7,opt,name=expiration_date,json=expirationDate,proto3" json:"expiration_date,omitempty" yaml:"expiration_date"`
	// LastPINVerification is when PIN was last verified
	LastPinVerification int64 `protobuf:"varint,8,opt,name=last_pin_verification,json=lastPinVerification,proto3" json:"last_pin_verification,omitempty" yaml:"last_pin_verification"`
}

func (m *SmartCardInfo) Reset()         { *m = SmartCardInfo{} }
func (m *SmartCardInfo) String() string { return proto.CompactTextString(m) }
func (*SmartCardInfo) ProtoMessage()    {}
func (*SmartCardInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{6}
}
func (m *SmartCardInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SmartCardInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SmartCardInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SmartCardInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmartCardInfo.Merge(m, src)
}
func (m *SmartCardInfo) XXX_Size() int {
	return m.Size()
}
func (m *SmartCardInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SmartCardInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SmartCardInfo proto.InternalMessageInfo

func (m *SmartCardInfo) GetCardSerialNumber() string {
	if m != nil {
		return m.CardSerialNumber
	}
	return ""
}

func (m *SmartCardInfo) GetCardType() string {
	if m != nil {
		return m.CardType
	}
	return ""
}

func (m *SmartCardInfo) GetSlotId() string {
	if m != nil {
		return m.SlotId
	}
	return ""
}

func (m *SmartCardInfo) GetChuid() string {
	if m != nil {
		return m.Chuid
	}
	return ""
}

func (m *SmartCardInfo) GetFascn() string {
	if m != nil {
		return m.Fascn
	}
	return ""
}

func (m *SmartCardInfo) GetCardHolderName() string {
	if m != nil {
		return m.CardHolderName
	}
	return ""
}

func (m *SmartCardInfo) GetExpirationDate() int64 {
	if m != nil {
		return m.ExpirationDate
	}
	return 0
}

func (m *SmartCardInfo) GetLastPinVerification() int64 {
	if m != nil {
		return m.LastPinVerification
	}
	return 0
}

// FactorEnrollment represents a factor enrollment record
type FactorEnrollment struct {
	// AccountAddress is the account that owns this enrollment
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// FactorType is the type of factor
	FactorType FactorType `protobuf:"varint,2,opt,name=factor_type,json=factorType,proto3,enum=virtengine.mfa.v1.FactorType" json:"factor_type" yaml:"factor_type"`
	// FactorID is a unique identifier for this factor enrollment
	FactorId string `protobuf:"bytes,3,opt,name=factor_id,json=factorId,proto3" json:"factor_id" yaml:"factor_id"`
	// PublicIdentifier is the public component of the factor
	PublicIdentifier []byte `protobuf:"bytes,4,opt,name=public_identifier,json=publicIdentifier,proto3" json:"public_identifier,omitempty" yaml:"public_identifier"`
	// Label is a user-friendly label for the factor
	Label string `protobuf:"bytes,5,opt,name=label,proto3" json:"label" yaml:"label"`
	// Status is the current enrollment status
	Status FactorEnrollmentStatus `protobuf:"varint,6,opt,name=status,proto3,enum=virtengine.mfa.v1.FactorEnrollmentStatus" json:"status" yaml:"status"`
	// EnrolledAt is the timestamp when the factor was enrolled
	EnrolledAt int64 `protobuf:"varint,7,opt,name=enrolled_at,json=enrolledAt,proto3" json:"enrolled_at" yaml:"enrolled_at"`
	// VerifiedAt is the timestamp when the enrollment was verified
	VerifiedAt int64 `protobuf:"varint,8,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at,omitempty" yaml:"verified_at"`
	// RevokedAt is the timestamp when the factor was revoked
	RevokedAt int64 `protobuf:"varint,9,opt,name=revoked_at,json=revokedAt,proto3" json:"revoked_at,omitempty" yaml:"revoked_at"`
	// LastUsedAt is the timestamp of the last successful use
	LastUsedAt int64 `protobuf:"varint,10,opt,name=last_used_at,json=lastUsedAt,proto3" json:"last_used_at,omitempty" yaml:"last_used_at"`
	// UseCount tracks how many times this factor has been used
	UseCount uint64 `protobuf:"varint,11,opt,name=use_count,json=useCount,proto3" json:"use_count" yaml:"use_count"`
	// Metadata contains additional factor-specific metadata
	Metadata *FactorMetadata `protobuf:"bytes,12,opt,name=metadata,proto3" json:"metadata,omitempty" yaml:"metadata"`
}

func (m *FactorEnrollment) Reset()         { *m = FactorEnrollment{} }
func (m *FactorEnrollment) String() string { return proto.CompactTextString(m) }
func (*FactorEnrollment) ProtoMessage()    {}
func (*FactorEnrollment) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{7}
}
func (m *FactorEnrollment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FactorEnrollment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FactorEnrollment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FactorEnrollment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FactorEnrollment.Merge(m, src)
}
func (m *FactorEnrollment) XXX_Size() int {
	return m.Size()
}
func (m *FactorEnrollment) XXX_DiscardUnknown() {
	xxx_messageInfo_FactorEnrollment.DiscardUnknown(m)
}

var xxx_messageInfo_FactorEnrollment proto.InternalMessageInfo

func (m *FactorEnrollment) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *FactorEnrollment) GetFactorType() FactorType {
	if m != nil {
		return m.FactorType
	}
	return FactorTypeUnspecified
}

func (m *FactorEnrollment) GetFactorId() string {
	if m != nil {
		return m.FactorId
	}
	return ""
}

func (m *FactorEnrollment) GetPublicIdentifier() []byte {
	if m != nil {
		return m.PublicIdentifier
	}
	return nil
}

func (m *FactorEnrollment) GetLabel() string {
	if m != nil {
		return m.Label
	}
	return ""
}

func (m *FactorEnrollment) GetStatus() FactorEnrollmentStatus {
	if m != nil {
		return m.Status
	}
	return EnrollmentStatusUnspecified
}

func (m *FactorEnrollment) GetEnrolledAt() int64 {
	if m != nil {
		return m.EnrolledAt
	}
	return 0
}

func (m *FactorEnrollment) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *FactorEnrollment) GetRevokedAt() int64 {
	if m != nil {
		return m.RevokedAt
	}
	return 0
}

func (m *FactorEnrollment) GetLastUsedAt() int64 {
	if m != nil {
		return m.LastUsedAt
	}
	return 0
}

func (m *FactorEnrollment) GetUseCount() uint64 {
	if m != nil {
		return m.UseCount
	}
	return 0
}

func (m *FactorEnrollment) GetMetadata() *FactorMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// TrustedDevicePolicy defines how trusted devices can reduce MFA requirements
type TrustedDevicePolicy struct {
	// Enabled indicates if trusted device reduction is enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
	// TrustDuration is how long a device remains trusted (in seconds)
	TrustDuration int64 `protobuf:"varint,2,opt,name=trust_duration,json=trustDuration,proto3" json:"trust_duration" yaml:"trust_duration"`
	// ReducedFactors is the factor combination to use for trusted devices
	ReducedFactors *FactorCombination `protobuf:"bytes,3,opt,name=reduced_factors,json=reducedFactors,proto3" json:"reduced_factors,omitempty" yaml:"reduced_factors"`
	// MaxTrustedDevices is the maximum number of trusted devices per account
	MaxTrustedDevices uint32 `protobuf:"varint,4,opt,name=max_trusted_devices,json=maxTrustedDevices,proto3" json:"max_trusted_devices" yaml:"max_trusted_devices"`
	// RequireReauthForSensitive if true, still requires full MFA for critical actions
	RequireReauthForSensitive bool `protobuf:"varint,5,opt,name=require_reauth_for_sensitive,json=requireReauthForSensitive,proto3" json:"require_reauth_for_sensitive" yaml:"require_reauth_for_sensitive"`
}

func (m *TrustedDevicePolicy) Reset()         { *m = TrustedDevicePolicy{} }
func (m *TrustedDevicePolicy) String() string { return proto.CompactTextString(m) }
func (*TrustedDevicePolicy) ProtoMessage()    {}
func (*TrustedDevicePolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{8}
}
func (m *TrustedDevicePolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedDevicePolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustedDevicePolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustedDevicePolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedDevicePolicy.Merge(m, src)
}
func (m *TrustedDevicePolicy) XXX_Size() int {
	return m.Size()
}
func (m *TrustedDevicePolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedDevicePolicy.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedDevicePolicy proto.InternalMessageInfo

func (m *TrustedDevicePolicy) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *TrustedDevicePolicy) GetTrustDuration() int64 {
	if m != nil {
		return m.TrustDuration
	}
	return 0
}

func (m *TrustedDevicePolicy) GetReducedFactors() *FactorCombination {
	if m != nil {
		return m.ReducedFactors
	}
	return nil
}

func (m *TrustedDevicePolicy) GetMaxTrustedDevices() uint32 {
	if m != nil {
		return m.MaxTrustedDevices
	}
	return 0
}

func (m *TrustedDevicePolicy) GetRequireReauthForSensitive() bool {
	if m != nil {
		return m.RequireReauthForSensitive
	}
	return false
}

// MFAPolicy defines the MFA requirements for an account
type MFAPolicy struct {
	// AccountAddress is the account this policy applies to
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// RequiredFactors is a list of factor combinations (OR logic between combinations)
	RequiredFactors []FactorCombination `protobuf:"bytes,2,rep,name=required_factors,json=requiredFactors,proto3" json:"required_factors" yaml:"required_factors"`
	// TrustedDeviceRule defines how trusted devices affect MFA requirements
	TrustedDeviceRule *TrustedDevicePolicy `protobuf:"bytes,3,opt,name=trusted_device_rule,json=trustedDeviceRule,proto3" json:"trusted_device_rule,omitempty" yaml:"trusted_device_rule"`
	// RecoveryFactors defines factor combinations for account recovery
	RecoveryFactors []FactorCombination `protobuf:"bytes,4,rep,name=recovery_factors,json=recoveryFactors,proto3" json:"recovery_factors" yaml:"recovery_factors"`
	// KeyRotationFactors defines factor combinations for key rotation
	KeyRotationFactors []FactorCombination `protobuf:"bytes,5,rep,name=key_rotation_factors,json=keyRotationFactors,proto3" json:"key_rotation_factors" yaml:"key_rotation_factors"`
	// SessionDuration is how long an MFA session remains valid (in seconds)
	SessionDuration int64 `protobuf:"varint,6,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration" yaml:"session_duration"`
	// VEIDThreshold is the minimum VEID score required for VEID-based factors
	VeidThreshold uint32 `protobuf:"varint,7,opt,name=veid_threshold,json=veidThreshold,proto3" json:"veid_threshold,omitempty" yaml:"veid_threshold"`
	// Enabled indicates if MFA is enabled for this account
	Enabled bool `protobuf:"varint,8,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
	// CreatedAt is when the policy was created
	CreatedAt int64 `protobuf:"varint,9,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// UpdatedAt is when the policy was last updated
	UpdatedAt int64 `protobuf:"varint,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at" yaml:"updated_at"`
}

func (m *MFAPolicy) Reset()         { *m = MFAPolicy{} }
func (m *MFAPolicy) String() string { return proto.CompactTextString(m) }
func (*MFAPolicy) ProtoMessage()    {}
func (*MFAPolicy) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{9}
}
func (m *MFAPolicy) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MFAPolicy) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MFAPolicy.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MFAPolicy) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MFAPolicy.Merge(m, src)
}
func (m *MFAPolicy) XXX_Size() int {
	return m.Size()
}
func (m *MFAPolicy) XXX_DiscardUnknown() {
	xxx_messageInfo_MFAPolicy.DiscardUnknown(m)
}

var xxx_messageInfo_MFAPolicy proto.InternalMessageInfo

func (m *MFAPolicy) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *MFAPolicy) GetRequiredFactors() []FactorCombination {
	if m != nil {
		return m.RequiredFactors
	}
	return nil
}

func (m *MFAPolicy) GetTrustedDeviceRule() *TrustedDevicePolicy {
	if m != nil {
		return m.TrustedDeviceRule
	}
	return nil
}

func (m *MFAPolicy) GetRecoveryFactors() []FactorCombination {
	if m != nil {
		return m.RecoveryFactors
	}
	return nil
}

func (m *MFAPolicy) GetKeyRotationFactors() []FactorCombination {
	if m != nil {
		return m.KeyRotationFactors
	}
	return nil
}

func (m *MFAPolicy) GetSessionDuration() int64 {
	if m != nil {
		return m.SessionDuration
	}
	return 0
}

func (m *MFAPolicy) GetVeidThreshold() uint32 {
	if m != nil {
		return m.VeidThreshold
	}
	return 0
}

func (m *MFAPolicy) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *MFAPolicy) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *MFAPolicy) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

// ClientInfo contains information about the requesting client
type ClientInfo struct {
	// DeviceFingerprint is a hash identifying the device
	DeviceFingerprint string `protobuf:"bytes,1,opt,name=device_fingerprint,json=deviceFingerprint,proto3" json:"device_fingerprint,omitempty" yaml:"device_fingerprint"`
	// IPHash is a hash of the client IP
	IpHash string `protobuf:"bytes,2,opt,name=ip_hash,json=ipHash,proto3" json:"ip_hash,omitempty" yaml:"ip_hash"`
	// UserAgent is the sanitized user agent string
	UserAgent string `protobuf:"bytes,3,opt,name=user_agent,json=userAgent,proto3" json:"user_agent,omitempty" yaml:"user_agent"`
	// RequestedAt is when the request was made
	RequestedAt int64 `protobuf:"varint,4,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at" yaml:"requested_at"`
}

func (m *ClientInfo) Reset()         { *m = ClientInfo{} }
func (m *ClientInfo) String() string { return proto.CompactTextString(m) }
func (*ClientInfo) ProtoMessage()    {}
func (*ClientInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{10}
}
func (m *ClientInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientInfo.Merge(m, src)
}
func (m *ClientInfo) XXX_Size() int {
	return m.Size()
}
func (m *ClientInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ClientInfo proto.InternalMessageInfo

func (m *ClientInfo) GetDeviceFingerprint() string {
	if m != nil {
		return m.DeviceFingerprint
	}
	return ""
}

func (m *ClientInfo) GetIpHash() string {
	if m != nil {
		return m.IpHash
	}
	return ""
}

func (m *ClientInfo) GetUserAgent() string {
	if m != nil {
		return m.UserAgent
	}
	return ""
}

func (m *ClientInfo) GetRequestedAt() int64 {
	if m != nil {
		return m.RequestedAt
	}
	return 0
}

// ChallengeMetadata contains additional challenge information
type ChallengeMetadata struct {
	// FIDO2Challenge contains FIDO2-specific challenge data
	Fido2Challenge *FIDO2ChallengeData `protobuf:"bytes,1,opt,name=fido2_challenge,json=fido2Challenge,proto3" json:"fido2_challenge,omitempty" yaml:"fido2_challenge"`
	// OTPInfo contains OTP-specific tracking data
	OtpInfo *OTPChallengeInfo `protobuf:"bytes,2,opt,name=otp_info,json=otpInfo,proto3" json:"otp_info,omitempty" yaml:"otp_info"`
	// ClientInfo contains information about the requesting client
	ClientInfo *ClientInfo `protobuf:"bytes,3,opt,name=client_info,json=clientInfo,proto3" json:"client_info,omitempty" yaml:"client_info"`
	// HardwareKeyChallenge contains hardware key challenge data
	HardwareKeyChallenge *HardwareKeyChallenge `protobuf:"bytes,4,opt,name=hardware_key_challenge,json=hardwareKeyChallenge,proto3" json:"hardware_key_challenge,omitempty" yaml:"hardware_key_challenge"`
}

func (m *ChallengeMetadata) Reset()         { *m = ChallengeMetadata{} }
func (m *ChallengeMetadata) String() string { return proto.CompactTextString(m) }
func (*ChallengeMetadata) ProtoMessage()    {}
func (*ChallengeMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{11}
}
func (m *ChallengeMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeMetadata.Merge(m, src)
}
func (m *ChallengeMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeMetadata proto.InternalMessageInfo

func (m *ChallengeMetadata) GetFido2Challenge() *FIDO2ChallengeData {
	if m != nil {
		return m.Fido2Challenge
	}
	return nil
}

func (m *ChallengeMetadata) GetOtpInfo() *OTPChallengeInfo {
	if m != nil {
		return m.OtpInfo
	}
	return nil
}

func (m *ChallengeMetadata) GetClientInfo() *ClientInfo {
	if m != nil {
		return m.ClientInfo
	}
	return nil
}

func (m *ChallengeMetadata) GetHardwareKeyChallenge() *HardwareKeyChallenge {
	if m != nil {
		return m.HardwareKeyChallenge
	}
	return nil
}

// FIDO2ChallengeData contains FIDO2-specific challenge information
type FIDO2ChallengeData struct {
	// Challenge is the random challenge bytes
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge" yaml:"challenge"`
	// RelyingPartyID is the relying party identifier
	RelyingPartyId string `protobuf:"bytes,2,opt,name=relying_party_id,json=relyingPartyId,proto3" json:"relying_party_id" yaml:"relying_party_id"`
	// AllowedCredentials is the list of allowed credential IDs
	AllowedCredentials [][]byte `protobuf:"bytes,3,rep,name=allowed_credentials,json=allowedCredentials,proto3" json:"allowed_credentials,omitempty" yaml:"allowed_credentials"`
	// UserVerificationRequirement specifies if user verification is required
	UserVerification string `protobuf:"bytes,4,opt,name=user_verification,json=userVerification,proto3" json:"user_verification" yaml:"user_verification"`
}

func (m *FIDO2ChallengeData) Reset()         { *m = FIDO2ChallengeData{} }
func (m *FIDO2ChallengeData) String() string { return proto.CompactTextString(m) }
func (*FIDO2ChallengeData) ProtoMessage()    {}
func (*FIDO2ChallengeData) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{12}
}
func (m *FIDO2ChallengeData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FIDO2ChallengeData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FIDO2ChallengeData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FIDO2ChallengeData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FIDO2ChallengeData.Merge(m, src)
}
func (m *FIDO2ChallengeData) XXX_Size() int {
	return m.Size()
}
func (m *FIDO2ChallengeData) XXX_DiscardUnknown() {
	xxx_messageInfo_FIDO2ChallengeData.DiscardUnknown(m)
}

var xxx_messageInfo_FIDO2ChallengeData proto.InternalMessageInfo

func (m *FIDO2ChallengeData) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *FIDO2ChallengeData) GetRelyingPartyId() string {
	if m != nil {
		return m.RelyingPartyId
	}
	return ""
}

func (m *FIDO2ChallengeData) GetAllowedCredentials() [][]byte {
	if m != nil {
		return m.AllowedCredentials
	}
	return nil
}

func (m *FIDO2ChallengeData) GetUserVerification() string {
	if m != nil {
		return m.UserVerification
	}
	return ""
}

// OTPChallengeInfo contains OTP tracking information
type OTPChallengeInfo struct {
	// DeliveryMethod indicates how the OTP was delivered
	DeliveryMethod string `protobuf:"bytes,1,opt,name=delivery_method,json=deliveryMethod,proto3" json:"delivery_method" yaml:"delivery_method"`
	// DeliveryDestinationMasked is the masked delivery destination
	DeliveryDestinationMasked string `protobuf:"bytes,2,opt,name=delivery_destination_masked,json=deliveryDestinationMasked,proto3" json:"delivery_destination_masked" yaml:"delivery_destination_masked"`
	// SentAt is when the OTP was sent
	SentAt int64 `protobuf:"varint,3,opt,name=sent_at,json=sentAt,proto3" json:"sent_at" yaml:"sent_at"`
	// ResendCount tracks how many times the OTP was resent
	ResendCount uint32 `protobuf:"varint,4,opt,name=resend_count,json=resendCount,proto3" json:"resend_count" yaml:"resend_count"`
	// LastResendAt is when the OTP was last resent
	LastResendAt int64 `protobuf:"varint,5,opt,name=last_resend_at,json=lastResendAt,proto3" json:"last_resend_at,omitempty" yaml:"last_resend_at"`
}

func (m *OTPChallengeInfo) Reset()         { *m = OTPChallengeInfo{} }
func (m *OTPChallengeInfo) String() string { return proto.CompactTextString(m) }
func (*OTPChallengeInfo) ProtoMessage()    {}
func (*OTPChallengeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{13}
}
func (m *OTPChallengeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OTPChallengeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OTPChallengeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OTPChallengeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OTPChallengeInfo.Merge(m, src)
}
func (m *OTPChallengeInfo) XXX_Size() int {
	return m.Size()
}
func (m *OTPChallengeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_OTPChallengeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_OTPChallengeInfo proto.InternalMessageInfo

func (m *OTPChallengeInfo) GetDeliveryMethod() string {
	if m != nil {
		return m.DeliveryMethod
	}
	return ""
}

func (m *OTPChallengeInfo) GetDeliveryDestinationMasked() string {
	if m != nil {
		return m.DeliveryDestinationMasked
	}
	return ""
}

func (m *OTPChallengeInfo) GetSentAt() int64 {
	if m != nil {
		return m.SentAt
	}
	return 0
}

func (m *OTPChallengeInfo) GetResendCount() uint32 {
	if m != nil {
		return m.ResendCount
	}
	return 0
}

func (m *OTPChallengeInfo) GetLastResendAt() int64 {
	if m != nil {
		return m.LastResendAt
	}
	return 0
}

// HardwareKeyChallenge represents a challenge for hardware key authentication
type HardwareKeyChallenge struct {
	// Challenge is the random challenge bytes to be signed
	Challenge []byte `protobuf:"bytes,1,opt,name=challenge,proto3" json:"challenge" yaml:"challenge"`
	// KeyID is the expected key ID to use for signing
	KeyId string `protobuf:"bytes,2,opt,name=key_id,json=keyId,proto3" json:"key_id" yaml:"key_id"`
	// Nonce is a random nonce for replay protection
	Nonce string `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce" yaml:"nonce"`
	// CreatedAt is when the challenge was created
	CreatedAt int64 `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
}

func (m *HardwareKeyChallenge) Reset()         { *m = HardwareKeyChallenge{} }
func (m *HardwareKeyChallenge) String() string { return proto.CompactTextString(m) }
func (*HardwareKeyChallenge) ProtoMessage()    {}
func (*HardwareKeyChallenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{14}
}
func (m *HardwareKeyChallenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HardwareKeyChallenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HardwareKeyChallenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HardwareKeyChallenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HardwareKeyChallenge.Merge(m, src)
}
func (m *HardwareKeyChallenge) XXX_Size() int {
	return m.Size()
}
func (m *HardwareKeyChallenge) XXX_DiscardUnknown() {
	xxx_messageInfo_HardwareKeyChallenge.DiscardUnknown(m)
}

var xxx_messageInfo_HardwareKeyChallenge proto.InternalMessageInfo

func (m *HardwareKeyChallenge) GetChallenge() []byte {
	if m != nil {
		return m.Challenge
	}
	return nil
}

func (m *HardwareKeyChallenge) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *HardwareKeyChallenge) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *HardwareKeyChallenge) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// Challenge represents an MFA challenge issued to a user
type Challenge struct {
	// ChallengeID is the unique identifier for this challenge
	ChallengeId string `protobuf:"bytes,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id" yaml:"challenge_id"`
	// AccountAddress is the account this challenge is for
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// FactorType is the type of factor this challenge is for
	FactorType FactorType `protobuf:"varint,3,opt,name=factor_type,json=factorType,proto3,enum=virtengine.mfa.v1.FactorType" json:"factor_type" yaml:"factor_type"`
	// FactorID is the specific factor enrollment being challenged
	FactorId string `protobuf:"bytes,4,opt,name=factor_id,json=factorId,proto3" json:"factor_id" yaml:"factor_id"`
	// TransactionType is the sensitive transaction this challenge is for
	TransactionType SensitiveTransactionType `protobuf:"varint,5,opt,name=transaction_type,json=transactionType,proto3,enum=virtengine.mfa.v1.SensitiveTransactionType" json:"transaction_type" yaml:"transaction_type"`
	// Status is the current status of the challenge
	Status ChallengeStatus `protobuf:"varint,6,opt,name=status,proto3,enum=virtengine.mfa.v1.ChallengeStatus" json:"status" yaml:"status"`
	// ChallengeData contains factor-specific challenge data
	ChallengeData []byte `protobuf:"bytes,7,opt,name=challenge_data,json=challengeData,proto3" json:"challenge_data,omitempty" yaml:"challenge_data"`
	// CreatedAt is when the challenge was created
	CreatedAt int64 `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// ExpiresAt is when the challenge expires
	ExpiresAt int64 `protobuf:"varint,9,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// VerifiedAt is when the challenge was verified (if successful)
	VerifiedAt int64 `protobuf:"varint,10,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at,omitempty" yaml:"verified_at"`
	// AttemptCount tracks the number of verification attempts
	AttemptCount uint32 `protobuf:"varint,11,opt,name=attempt_count,json=attemptCount,proto3" json:"attempt_count" yaml:"attempt_count"`
	// MaxAttempts is the maximum number of verification attempts allowed
	MaxAttempts uint32 `protobuf:"varint,12,opt,name=max_attempts,json=maxAttempts,proto3" json:"max_attempts" yaml:"max_attempts"`
	// Nonce is a random value for replay protection
	Nonce string `protobuf:"bytes,13,opt,name=nonce,proto3" json:"nonce" yaml:"nonce"`
	// SessionID links this challenge to an authorization session
	SessionId string `protobuf:"bytes,14,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty" yaml:"session_id"`
	// Metadata contains additional challenge-specific data
	Metadata *ChallengeMetadata `protobuf:"bytes,15,opt,name=metadata,proto3" json:"metadata,omitempty" yaml:"metadata"`
}

func (m *Challenge) Reset()         { *m = Challenge{} }
func (m *Challenge) String() string { return proto.CompactTextString(m) }
func (*Challenge) ProtoMessage()    {}
func (*Challenge) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{15}
}
func (m *Challenge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Challenge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Challenge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Challenge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Challenge.Merge(m, src)
}
func (m *Challenge) XXX_Size() int {
	return m.Size()
}
func (m *Challenge) XXX_DiscardUnknown() {
	xxx_messageInfo_Challenge.DiscardUnknown(m)
}

var xxx_messageInfo_Challenge proto.InternalMessageInfo

func (m *Challenge) GetChallengeId() string {
	if m != nil {
		return m.ChallengeId
	}
	return ""
}

func (m *Challenge) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *Challenge) GetFactorType() FactorType {
	if m != nil {
		return m.FactorType
	}
	return FactorTypeUnspecified
}

func (m *Challenge) GetFactorId() string {
	if m != nil {
		return m.FactorId
	}
	return ""
}

func (m *Challenge) GetTransactionType() SensitiveTransactionType {
	if m != nil {
		return m.TransactionType
	}
	return SensitiveTxUnspecified
}

func (m *Challenge) GetStatus() ChallengeStatus {
	if m != nil {
		return m.Status
	}
	return ChallengeStatusUnspecified
}

func (m *Challenge) GetChallengeData() []byte {
	if m != nil {
		return m.ChallengeData
	}
	return nil
}

func (m *Challenge) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *Challenge) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *Challenge) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *Challenge) GetAttemptCount() uint32 {
	if m != nil {
		return m.AttemptCount
	}
	return 0
}

func (m *Challenge) GetMaxAttempts() uint32 {
	if m != nil {
		return m.MaxAttempts
	}
	return 0
}

func (m *Challenge) GetNonce() string {
	if m != nil {
		return m.Nonce
	}
	return ""
}

func (m *Challenge) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *Challenge) GetMetadata() *ChallengeMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// ChallengeResponse represents a response to an MFA challenge
type ChallengeResponse struct {
	// ChallengeID is the challenge being responded to
	ChallengeId string `protobuf:"bytes,1,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id" yaml:"challenge_id"`
	// FactorType is the type of factor used
	FactorType FactorType `protobuf:"varint,2,opt,name=factor_type,json=factorType,proto3,enum=virtengine.mfa.v1.FactorType" json:"factor_type" yaml:"factor_type"`
	// ResponseData contains the verification data
	ResponseData []byte `protobuf:"bytes,3,opt,name=response_data,json=responseData,proto3" json:"response_data" yaml:"response_data"`
	// ClientInfo contains information about the responding client
	ClientInfo *ClientInfo `protobuf:"bytes,4,opt,name=client_info,json=clientInfo,proto3" json:"client_info,omitempty" yaml:"client_info"`
	// Timestamp is when the response was created
	Timestamp int64 `protobuf:"varint,5,opt,name=timestamp,proto3" json:"timestamp" yaml:"timestamp"`
}

func (m *ChallengeResponse) Reset()         { *m = ChallengeResponse{} }
func (m *ChallengeResponse) String() string { return proto.CompactTextString(m) }
func (*ChallengeResponse) ProtoMessage()    {}
func (*ChallengeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{16}
}
func (m *ChallengeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChallengeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChallengeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChallengeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChallengeResponse.Merge(m, src)
}
func (m *ChallengeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChallengeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChallengeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChallengeResponse proto.InternalMessageInfo

func (m *ChallengeResponse) GetChallengeId() string {
	if m != nil {
		return m.ChallengeId
	}
	return ""
}

func (m *ChallengeResponse) GetFactorType() FactorType {
	if m != nil {
		return m.FactorType
	}
	return FactorTypeUnspecified
}

func (m *ChallengeResponse) GetResponseData() []byte {
	if m != nil {
		return m.ResponseData
	}
	return nil
}

func (m *ChallengeResponse) GetClientInfo() *ClientInfo {
	if m != nil {
		return m.ClientInfo
	}
	return nil
}

func (m *ChallengeResponse) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// AuthorizationSession represents a temporary elevated session after MFA verification
type AuthorizationSession struct {
	// SessionID is the unique identifier for this session
	SessionId string `protobuf:"bytes,1,opt,name=session_id,json=sessionId,proto3" json:"session_id" yaml:"session_id"`
	// AccountAddress is the account this session belongs to
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// TransactionType is the type of transaction authorized
	TransactionType SensitiveTransactionType `protobuf:"varint,3,opt,name=transaction_type,json=transactionType,proto3,enum=virtengine.mfa.v1.SensitiveTransactionType" json:"transaction_type" yaml:"transaction_type"`
	// VerifiedFactors are the factors that were verified for this session
	VerifiedFactors []FactorType `protobuf:"varint,4,rep,packed,name=verified_factors,json=verifiedFactors,proto3,enum=virtengine.mfa.v1.FactorType" json:"verified_factors" yaml:"verified_factors"`
	// CreatedAt is when the session was created
	CreatedAt int64 `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// ExpiresAt is when the session expires
	ExpiresAt int64 `protobuf:"varint,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// UsedAt is when the session was used (if single-use)
	UsedAt int64 `protobuf:"varint,7,opt,name=used_at,json=usedAt,proto3" json:"used_at,omitempty" yaml:"used_at"`
	// IsSingleUse indicates if the session can only be used once
	IsSingleUse bool `protobuf:"varint,8,opt,name=is_single_use,json=isSingleUse,proto3" json:"is_single_use" yaml:"is_single_use"`
	// DeviceFingerprint is the device this session is bound to
	DeviceFingerprint string `protobuf:"bytes,9,opt,name=device_fingerprint,json=deviceFingerprint,proto3" json:"device_fingerprint,omitempty" yaml:"device_fingerprint"`
}

func (m *AuthorizationSession) Reset()         { *m = AuthorizationSession{} }
func (m *AuthorizationSession) String() string { return proto.CompactTextString(m) }
func (*AuthorizationSession) ProtoMessage()    {}
func (*AuthorizationSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{17}
}
func (m *AuthorizationSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthorizationSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthorizationSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthorizationSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizationSession.Merge(m, src)
}
func (m *AuthorizationSession) XXX_Size() int {
	return m.Size()
}
func (m *AuthorizationSession) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizationSession.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizationSession proto.InternalMessageInfo

func (m *AuthorizationSession) GetSessionId() string {
	if m != nil {
		return m.SessionId
	}
	return ""
}

func (m *AuthorizationSession) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *AuthorizationSession) GetTransactionType() SensitiveTransactionType {
	if m != nil {
		return m.TransactionType
	}
	return SensitiveTxUnspecified
}

func (m *AuthorizationSession) GetVerifiedFactors() []FactorType {
	if m != nil {
		return m.VerifiedFactors
	}
	return nil
}

func (m *AuthorizationSession) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *AuthorizationSession) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *AuthorizationSession) GetUsedAt() int64 {
	if m != nil {
		return m.UsedAt
	}
	return 0
}

func (m *AuthorizationSession) GetIsSingleUse() bool {
	if m != nil {
		return m.IsSingleUse
	}
	return false
}

func (m *AuthorizationSession) GetDeviceFingerprint() string {
	if m != nil {
		return m.DeviceFingerprint
	}
	return ""
}

// TrustedDevice represents a stored trusted device record
type TrustedDevice struct {
	// AccountAddress is the account that trusts this device
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// DeviceInfo contains the device information
	DeviceInfo DeviceInfo `protobuf:"bytes,2,opt,name=device_info,json=deviceInfo,proto3" json:"device_info" yaml:"device_info"`
	// AddedAt is when the device was added
	AddedAt int64 `protobuf:"varint,3,opt,name=added_at,json=addedAt,proto3" json:"added_at" yaml:"added_at"`
	// LastUsedAt is when the device was last used
	LastUsedAt int64 `protobuf:"varint,4,opt,name=last_used_at,json=lastUsedAt,proto3" json:"last_used_at" yaml:"last_used_at"`
}

func (m *TrustedDevice) Reset()         { *m = TrustedDevice{} }
func (m *TrustedDevice) String() string { return proto.CompactTextString(m) }
func (*TrustedDevice) ProtoMessage()    {}
func (*TrustedDevice) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{18}
}
func (m *TrustedDevice) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TrustedDevice) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TrustedDevice.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TrustedDevice) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TrustedDevice.Merge(m, src)
}
func (m *TrustedDevice) XXX_Size() int {
	return m.Size()
}
func (m *TrustedDevice) XXX_DiscardUnknown() {
	xxx_messageInfo_TrustedDevice.DiscardUnknown(m)
}

var xxx_messageInfo_TrustedDevice proto.InternalMessageInfo

func (m *TrustedDevice) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *TrustedDevice) GetDeviceInfo() DeviceInfo {
	if m != nil {
		return m.DeviceInfo
	}
	return DeviceInfo{}
}

func (m *TrustedDevice) GetAddedAt() int64 {
	if m != nil {
		return m.AddedAt
	}
	return 0
}

func (m *TrustedDevice) GetLastUsedAt() int64 {
	if m != nil {
		return m.LastUsedAt
	}
	return 0
}

// SensitiveTxConfig represents the configuration for a sensitive transaction type
type SensitiveTxConfig struct {
	// TransactionType is the type of transaction
	TransactionType SensitiveTransactionType `protobuf:"varint,1,opt,name=transaction_type,json=transactionType,proto3,enum=virtengine.mfa.v1.SensitiveTransactionType" json:"transaction_type" yaml:"transaction_type"`
	// Enabled indicates if MFA is required for this transaction type
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
	// MinVEIDScore is the minimum VEID score required
	MinVeidScore uint32 `protobuf:"varint,3,opt,name=min_veid_score,json=minVeidScore,proto3" json:"min_veid_score" yaml:"min_veid_score"`
	// RequiredFactorCombinations are the default factor combinations required
	RequiredFactorCombinations []FactorCombination `protobuf:"bytes,4,rep,name=required_factor_combinations,json=requiredFactorCombinations,proto3" json:"required_factor_combinations" yaml:"required_factor_combinations"`
	// SessionDuration is the authorization session duration in seconds
	SessionDuration int64 `protobuf:"varint,5,opt,name=session_duration,json=sessionDuration,proto3" json:"session_duration" yaml:"session_duration"`
	// IsSingleUse indicates if the authorization is single-use
	IsSingleUse bool `protobuf:"varint,6,opt,name=is_single_use,json=isSingleUse,proto3" json:"is_single_use" yaml:"is_single_use"`
	// AllowTrustedDeviceReduction indicates if trusted devices can reduce MFA
	AllowTrustedDeviceReduction bool `protobuf:"varint,7,opt,name=allow_trusted_device_reduction,json=allowTrustedDeviceReduction,proto3" json:"allow_trusted_device_reduction" yaml:"allow_trusted_device_reduction"`
	// ValueThreshold is the value threshold for amount-based transactions
	ValueThreshold string `protobuf:"bytes,8,opt,name=value_threshold,json=valueThreshold,proto3" json:"value_threshold,omitempty" yaml:"value_threshold"`
	// CooldownPeriod is the cooldown period in seconds for rate-limited operations
	CooldownPeriod int64 `protobuf:"varint,9,opt,name=cooldown_period,json=cooldownPeriod,proto3" json:"cooldown_period,omitempty" yaml:"cooldown_period"`
	// Description provides a human-readable description
	Description string `protobuf:"bytes,10,opt,name=description,proto3" json:"description" yaml:"description"`
}

func (m *SensitiveTxConfig) Reset()         { *m = SensitiveTxConfig{} }
func (m *SensitiveTxConfig) String() string { return proto.CompactTextString(m) }
func (*SensitiveTxConfig) ProtoMessage()    {}
func (*SensitiveTxConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{19}
}
func (m *SensitiveTxConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SensitiveTxConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SensitiveTxConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SensitiveTxConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SensitiveTxConfig.Merge(m, src)
}
func (m *SensitiveTxConfig) XXX_Size() int {
	return m.Size()
}
func (m *SensitiveTxConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SensitiveTxConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SensitiveTxConfig proto.InternalMessageInfo

func (m *SensitiveTxConfig) GetTransactionType() SensitiveTransactionType {
	if m != nil {
		return m.TransactionType
	}
	return SensitiveTxUnspecified
}

func (m *SensitiveTxConfig) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *SensitiveTxConfig) GetMinVeidScore() uint32 {
	if m != nil {
		return m.MinVeidScore
	}
	return 0
}

func (m *SensitiveTxConfig) GetRequiredFactorCombinations() []FactorCombination {
	if m != nil {
		return m.RequiredFactorCombinations
	}
	return nil
}

func (m *SensitiveTxConfig) GetSessionDuration() int64 {
	if m != nil {
		return m.SessionDuration
	}
	return 0
}

func (m *SensitiveTxConfig) GetIsSingleUse() bool {
	if m != nil {
		return m.IsSingleUse
	}
	return false
}

func (m *SensitiveTxConfig) GetAllowTrustedDeviceReduction() bool {
	if m != nil {
		return m.AllowTrustedDeviceReduction
	}
	return false
}

func (m *SensitiveTxConfig) GetValueThreshold() string {
	if m != nil {
		return m.ValueThreshold
	}
	return ""
}

func (m *SensitiveTxConfig) GetCooldownPeriod() int64 {
	if m != nil {
		return m.CooldownPeriod
	}
	return 0
}

func (m *SensitiveTxConfig) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

// Params defines the parameters for the mfa module
type Params struct {
	// DefaultSessionDuration is the default MFA session duration in seconds
	DefaultSessionDuration int64 `protobuf:"varint,1,opt,name=default_session_duration,json=defaultSessionDuration,proto3" json:"default_session_duration" yaml:"default_session_duration"`
	// MaxFactorsPerAccount is the maximum number of factors per account
	MaxFactorsPerAccount uint32 `protobuf:"varint,2,opt,name=max_factors_per_account,json=maxFactorsPerAccount,proto3" json:"max_factors_per_account" yaml:"max_factors_per_account"`
	// MaxChallengeAttempts is the maximum verification attempts per challenge
	MaxChallengeAttempts uint32 `protobuf:"varint,3,opt,name=max_challenge_attempts,json=maxChallengeAttempts,proto3" json:"max_challenge_attempts" yaml:"max_challenge_attempts"`
	// ChallengeTTL is the challenge time-to-live in seconds
	ChallengeTtl int64 `protobuf:"varint,4,opt,name=challenge_ttl,json=challengeTtl,proto3" json:"challenge_ttl" yaml:"challenge_ttl"`
	// MaxTrustedDevices is the maximum trusted devices per account
	MaxTrustedDevices uint32 `protobuf:"varint,5,opt,name=max_trusted_devices,json=maxTrustedDevices,proto3" json:"max_trusted_devices" yaml:"max_trusted_devices"`
	// TrustedDeviceTTL is the trusted device time-to-live in seconds
	TrustedDeviceTtl int64 `protobuf:"varint,6,opt,name=trusted_device_ttl,json=trustedDeviceTtl,proto3" json:"trusted_device_ttl" yaml:"trusted_device_ttl"`
	// MinVEIDScoreForMFA is the minimum VEID score to enable MFA
	MinVeidScoreForMfa uint32 `protobuf:"varint,7,opt,name=min_veid_score_for_mfa,json=minVeidScoreForMfa,proto3" json:"min_veid_score_for_mfa" yaml:"min_veid_score_for_mfa"`
	// RequireAtLeastOneFactor requires at least one factor when MFA is enabled
	RequireAtLeastOneFactor bool `protobuf:"varint,8,opt,name=require_at_least_one_factor,json=requireAtLeastOneFactor,proto3" json:"require_at_least_one_factor" yaml:"require_at_least_one_factor"`
	// AllowedFactorTypes lists the factor types allowed on this chain
	AllowedFactorTypes []FactorType `protobuf:"varint,9,rep,packed,name=allowed_factor_types,json=allowedFactorTypes,proto3,enum=virtengine.mfa.v1.FactorType" json:"allowed_factor_types" yaml:"allowed_factor_types"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{20}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetDefaultSessionDuration() int64 {
	if m != nil {
		return m.DefaultSessionDuration
	}
	return 0
}

func (m *Params) GetMaxFactorsPerAccount() uint32 {
	if m != nil {
		return m.MaxFactorsPerAccount
	}
	return 0
}

func (m *Params) GetMaxChallengeAttempts() uint32 {
	if m != nil {
		return m.MaxChallengeAttempts
	}
	return 0
}

func (m *Params) GetChallengeTtl() int64 {
	if m != nil {
		return m.ChallengeTtl
	}
	return 0
}

func (m *Params) GetMaxTrustedDevices() uint32 {
	if m != nil {
		return m.MaxTrustedDevices
	}
	return 0
}

func (m *Params) GetTrustedDeviceTtl() int64 {
	if m != nil {
		return m.TrustedDeviceTtl
	}
	return 0
}

func (m *Params) GetMinVeidScoreForMfa() uint32 {
	if m != nil {
		return m.MinVeidScoreForMfa
	}
	return 0
}

func (m *Params) GetRequireAtLeastOneFactor() bool {
	if m != nil {
		return m.RequireAtLeastOneFactor
	}
	return false
}

func (m *Params) GetAllowedFactorTypes() []FactorType {
	if m != nil {
		return m.AllowedFactorTypes
	}
	return nil
}

// EventFactorEnrolled is emitted when a factor is enrolled
type EventFactorEnrolled struct {
	// AccountAddress is the account that enrolled the factor
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// FactorType is the type of factor enrolled
	FactorType string `protobuf:"bytes,2,opt,name=factor_type,json=factorType,proto3" json:"factor_type" yaml:"factor_type"`
	// FactorID is the ID of the enrolled factor
	FactorId string `protobuf:"bytes,3,opt,name=factor_id,json=factorId,proto3" json:"factor_id" yaml:"factor_id"`
}

func (m *EventFactorEnrolled) Reset()         { *m = EventFactorEnrolled{} }
func (m *EventFactorEnrolled) String() string { return proto.CompactTextString(m) }
func (*EventFactorEnrolled) ProtoMessage()    {}
func (*EventFactorEnrolled) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{21}
}
func (m *EventFactorEnrolled) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFactorEnrolled) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFactorEnrolled.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFactorEnrolled) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFactorEnrolled.Merge(m, src)
}
func (m *EventFactorEnrolled) XXX_Size() int {
	return m.Size()
}
func (m *EventFactorEnrolled) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFactorEnrolled.DiscardUnknown(m)
}

var xxx_messageInfo_EventFactorEnrolled proto.InternalMessageInfo

func (m *EventFactorEnrolled) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventFactorEnrolled) GetFactorType() string {
	if m != nil {
		return m.FactorType
	}
	return ""
}

func (m *EventFactorEnrolled) GetFactorId() string {
	if m != nil {
		return m.FactorId
	}
	return ""
}

// EventFactorRevoked is emitted when a factor is revoked
type EventFactorRevoked struct {
	// AccountAddress is the account that revoked the factor
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// FactorType is the type of factor revoked
	FactorType string `protobuf:"bytes,2,opt,name=factor_type,json=factorType,proto3" json:"factor_type" yaml:"factor_type"`
	// FactorID is the ID of the revoked factor
	FactorId string `protobuf:"bytes,3,opt,name=factor_id,json=factorId,proto3" json:"factor_id" yaml:"factor_id"`
}

func (m *EventFactorRevoked) Reset()         { *m = EventFactorRevoked{} }
func (m *EventFactorRevoked) String() string { return proto.CompactTextString(m) }
func (*EventFactorRevoked) ProtoMessage()    {}
func (*EventFactorRevoked) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{22}
}
func (m *EventFactorRevoked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventFactorRevoked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventFactorRevoked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventFactorRevoked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventFactorRevoked.Merge(m, src)
}
func (m *EventFactorRevoked) XXX_Size() int {
	return m.Size()
}
func (m *EventFactorRevoked) XXX_DiscardUnknown() {
	xxx_messageInfo_EventFactorRevoked.DiscardUnknown(m)
}

var xxx_messageInfo_EventFactorRevoked proto.InternalMessageInfo

func (m *EventFactorRevoked) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventFactorRevoked) GetFactorType() string {
	if m != nil {
		return m.FactorType
	}
	return ""
}

func (m *EventFactorRevoked) GetFactorId() string {
	if m != nil {
		return m.FactorId
	}
	return ""
}

// EventChallengeVerified is emitted when a challenge is verified
type EventChallengeVerified struct {
	// AccountAddress is the account that verified the challenge
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ChallengeID is the ID of the verified challenge
	ChallengeId string `protobuf:"bytes,2,opt,name=challenge_id,json=challengeId,proto3" json:"challenge_id" yaml:"challenge_id"`
	// FactorType is the type of factor used
	FactorType string `protobuf:"bytes,3,opt,name=factor_type,json=factorType,proto3" json:"factor_type" yaml:"factor_type"`
	// TransactionType is the transaction type that was authorized
	TransactionType string `protobuf:"bytes,4,opt,name=transaction_type,json=transactionType,proto3" json:"transaction_type" yaml:"transaction_type"`
}

func (m *EventChallengeVerified) Reset()         { *m = EventChallengeVerified{} }
func (m *EventChallengeVerified) String() string { return proto.CompactTextString(m) }
func (*EventChallengeVerified) ProtoMessage()    {}
func (*EventChallengeVerified) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{23}
}
func (m *EventChallengeVerified) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventChallengeVerified) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventChallengeVerified.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventChallengeVerified) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventChallengeVerified.Merge(m, src)
}
func (m *EventChallengeVerified) XXX_Size() int {
	return m.Size()
}
func (m *EventChallengeVerified) XXX_DiscardUnknown() {
	xxx_messageInfo_EventChallengeVerified.DiscardUnknown(m)
}

var xxx_messageInfo_EventChallengeVerified proto.InternalMessageInfo

func (m *EventChallengeVerified) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventChallengeVerified) GetChallengeId() string {
	if m != nil {
		return m.ChallengeId
	}
	return ""
}

func (m *EventChallengeVerified) GetFactorType() string {
	if m != nil {
		return m.FactorType
	}
	return ""
}

func (m *EventChallengeVerified) GetTransactionType() string {
	if m != nil {
		return m.TransactionType
	}
	return ""
}

// EventMFAPolicyUpdated is emitted when an MFA policy is updated
type EventMFAPolicyUpdated struct {
	// AccountAddress is the account whose policy was updated
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Enabled indicates if MFA is now enabled
	Enabled bool `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
}

func (m *EventMFAPolicyUpdated) Reset()         { *m = EventMFAPolicyUpdated{} }
func (m *EventMFAPolicyUpdated) String() string { return proto.CompactTextString(m) }
func (*EventMFAPolicyUpdated) ProtoMessage()    {}
func (*EventMFAPolicyUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_a11bdbeae5e11e4c, []int{24}
}
func (m *EventMFAPolicyUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMFAPolicyUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMFAPolicyUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMFAPolicyUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMFAPolicyUpdated.Merge(m, src)
}
func (m *EventMFAPolicyUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventMFAPolicyUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMFAPolicyUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventMFAPolicyUpdated proto.InternalMessageInfo

func (m *EventMFAPolicyUpdated) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventMFAPolicyUpdated) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func init() {
	proto.RegisterEnum("virtengine.mfa.v1.FactorType", FactorType_name, FactorType_value)
	proto.RegisterEnum("virtengine.mfa.v1.FactorSecurityLevel", FactorSecurityLevel_name, FactorSecurityLevel_value)
	proto.RegisterEnum("virtengine.mfa.v1.FactorEnrollmentStatus", FactorEnrollmentStatus_name, FactorEnrollmentStatus_value)
	proto.RegisterEnum("virtengine.mfa.v1.ChallengeStatus", ChallengeStatus_name, ChallengeStatus_value)
	proto.RegisterEnum("virtengine.mfa.v1.SensitiveTransactionType", SensitiveTransactionType_name, SensitiveTransactionType_value)
	proto.RegisterEnum("virtengine.mfa.v1.HardwareKeyType", HardwareKeyType_name, HardwareKeyType_value)
	proto.RegisterEnum("virtengine.mfa.v1.RevocationStatus", RevocationStatus_name, RevocationStatus_value)
	proto.RegisterType((*MFAProof)(nil), "virtengine.mfa.v1.MFAProof")
	proto.RegisterType((*FactorCombination)(nil), "virtengine.mfa.v1.FactorCombination")
	proto.RegisterType((*FactorMetadata)(nil), "virtengine.mfa.v1.FactorMetadata")
	proto.RegisterType((*DeviceInfo)(nil), "virtengine.mfa.v1.DeviceInfo")
	proto.RegisterType((*FIDO2CredentialInfo)(nil), "virtengine.mfa.v1.FIDO2CredentialInfo")
	proto.RegisterType((*HardwareKeyEnrollment)(nil), "virtengine.mfa.v1.HardwareKeyEnrollment")
	proto.RegisterType((*SmartCardInfo)(nil), "virtengine.mfa.v1.SmartCardInfo")
	proto.RegisterType((*FactorEnrollment)(nil), "virtengine.mfa.v1.FactorEnrollment")
	proto.RegisterType((*TrustedDevicePolicy)(nil), "virtengine.mfa.v1.TrustedDevicePolicy")
	proto.RegisterType((*MFAPolicy)(nil), "virtengine.mfa.v1.MFAPolicy")
	proto.RegisterType((*ClientInfo)(nil), "virtengine.mfa.v1.ClientInfo")
	proto.RegisterType((*ChallengeMetadata)(nil), "virtengine.mfa.v1.ChallengeMetadata")
	proto.RegisterType((*FIDO2ChallengeData)(nil), "virtengine.mfa.v1.FIDO2ChallengeData")
	proto.RegisterType((*OTPChallengeInfo)(nil), "virtengine.mfa.v1.OTPChallengeInfo")
	proto.RegisterType((*HardwareKeyChallenge)(nil), "virtengine.mfa.v1.HardwareKeyChallenge")
	proto.RegisterType((*Challenge)(nil), "virtengine.mfa.v1.Challenge")
	proto.RegisterType((*ChallengeResponse)(nil), "virtengine.mfa.v1.ChallengeResponse")
	proto.RegisterType((*AuthorizationSession)(nil), "virtengine.mfa.v1.AuthorizationSession")
	proto.RegisterType((*TrustedDevice)(nil), "virtengine.mfa.v1.TrustedDevice")
	proto.RegisterType((*SensitiveTxConfig)(nil), "virtengine.mfa.v1.SensitiveTxConfig")
	proto.RegisterType((*Params)(nil), "virtengine.mfa.v1.Params")
	proto.RegisterType((*EventFactorEnrolled)(nil), "virtengine.mfa.v1.EventFactorEnrolled")
	proto.RegisterType((*EventFactorRevoked)(nil), "virtengine.mfa.v1.EventFactorRevoked")
	proto.RegisterType((*EventChallengeVerified)(nil), "virtengine.mfa.v1.EventChallengeVerified")
	proto.RegisterType((*EventMFAPolicyUpdated)(nil), "virtengine.mfa.v1.EventMFAPolicyUpdated")
}

func init() { proto.RegisterFile("virtengine/mfa/v1/types.proto", fileDescriptor_a11bdbeae5e11e4c) }

var fileDescriptor_a11bdbeae5e11e4c = []byte{
	// 5453 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe4, 0x7c, 0x4d, 0x6c, 0x24, 0xc7,
	0x75, 0xff, 0x0e, 0xbf, 0xa7, 0x48, 0x0e, 0x9b, 0x4d, 0x2e, 0x97, 0x9c, 0xdd, 0xe5, 0x8c, 0x4a,
	0xfe, 0x58, 0xcb, 0x7f, 0x2f, 0xff, 0x5a, 0xc5, 0x1f, 0x5a, 0xc7, 0x92, 0x9a, 0x33, 0x4d, 0x72,
	0x44, 0x72, 0x66, 0x5c, 0x33, 0xe4, 0x6a, 0x15, 0x43, 0xad, 0xde, 0xe9, 0x22, 0xd9, 0xe1, 0x4c,
	0x37, 0xd5, 0xdd, 0xc3, 0x5d, 0xe6, 0x96, 0x38, 0xb1, 0x15, 0xe6, 0xe2, 0x8f, 0x00, 0xce, 0x85,
	0x48, 0x00, 0x07, 0x41, 0x8e, 0x06, 0x92, 0x53, 0xee, 0x09, 0x7c, 0x0a, 0x04, 0x9f, 0x12, 0x24,
	0x18, 0x18, 0x52, 0x80, 0x04, 0x3c, 0xf2, 0x92, 0x53, 0x3e, 0x50, 0x1f, 0xdd, 0x55, 0xfd, 0xc1,
	0x95, 0xf6, 0xc3, 0xab, 0x43, 0x2e, 0x8b, 0xa9, 0xdf, 0x7b, 0xf5, 0xaa, 0xfa, 0xd5, 0xab, 0xf7,
	0x5e, 0xbd, 0x2a, 0x2e, 0xb8, 0x79, 0x6c, 0x7b, 0x01, 0x76, 0xf6, 0x6d, 0x07, 0xaf, 0xf4, 0xf6,
	0xcc, 0x95, 0xe3, 0x57, 0x57, 0x82, 0x93, 0x23, 0xec, 0xdf, 0x3e, 0xf2, 0xdc, 0xc0, 0x55, 0x67,
	0x05, 0xf9, 0x76, 0x6f, 0xcf, 0xbc, 0x7d, 0xfc, 0x6a, 0x71, 0x7e, 0xdf, 0xdd, 0x77, 0x29, 0x75,
	0x85, 0xfc, 0x62, 0x8c, 0xc5, 0xa5, 0x8e, 0xeb, 0xf7, 0x5c, 0xdf, 0x60, 0x04, 0xd6, 0xe0, 0xa4,
	0x59, 0xb3, 0x67, 0x3b, 0xee, 0x0a, 0xfd, 0x97, 0x41, 0xf0, 0x5f, 0x86, 0xc0, 0xc4, 0xf6, 0x9a,
	0xd6, 0xf4, 0x5c, 0x77, 0x4f, 0x5d, 0x05, 0xc0, 0xc7, 0xbe, 0x6f, 0xbb, 0x8e, 0x61, 0x5b, 0x8b,
	0xb9, 0x72, 0xee, 0x56, 0x7e, 0xf5, 0xe5, 0xf3, 0x41, 0x49, 0x42, 0x2f, 0x06, 0xa5, 0xd9, 0x13,
	0xb3, 0xd7, 0xbd, 0x0b, 0x05, 0x06, 0x51, 0x9e, 0x37, 0x6a, 0x96, 0x7a, 0x02, 0x94, 0x63, 0xec,
	0xd9, 0x7b, 0x36, 0xb6, 0x8c, 0x3d, 0xb3, 0x13, 0xb8, 0x9e, 0xbf, 0x38, 0x54, 0x1e, 0xbe, 0x55,
	0xb8, 0x73, 0xf3, 0x76, 0xea, 0x13, 0x6e, 0xaf, 0x51, 0x8e, 0xf6, 0xc9, 0x11, 0x5e, 0x5d, 0x39,
	0x1f, 0x94, 0x52, 0x5d, 0x2f, 0x06, 0xa5, 0x6b, 0x6c, 0xb8, 0x24, 0x05, 0xa2, 0x99, 0x10, 0x62,
	0x42, 0x7c, 0xf5, 0x4d, 0x90, 0x0f, 0xec, 0x1e, 0xf6, 0x03, 0xb3, 0x77, 0xb4, 0x38, 0x5c, 0xce,
	0xdd, 0x1a, 0x5e, 0x7d, 0xe9, 0x7c, 0x50, 0x12, 0xe0, 0xc5, 0xa0, 0xa4, 0x30, 0x69, 0x11, 0x04,
	0x91, 0x20, 0xab, 0x35, 0x90, 0xf7, 0xed, 0x7d, 0xc7, 0x0c, 0xfa, 0x1e, 0x5e, 0x1c, 0x29, 0xe7,
	0x6e, 0x4d, 0xad, 0x7e, 0xf5, 0x7c, 0x50, 0x9a, 0x8b, 0xc0, 0xff, 0xe7, 0xf6, 0xec, 0x00, 0xf7,
	0x8e, 0x82, 0x13, 0x21, 0x2a, 0x22, 0x12, 0x35, 0x84, 0xbf, 0xef, 0x8e, 0xfc, 0xc7, 0x5f, 0x94,
	0x72, 0xf0, 0xbf, 0x72, 0x60, 0x96, 0xcd, 0xae, 0xe2, 0xf6, 0x1e, 0xd8, 0x8e, 0x19, 0xd8, 0xae,
	0xa3, 0xee, 0x82, 0xf1, 0x50, 0x33, 0xb9, 0xcf, 0xa2, 0x99, 0x9b, 0xe7, 0x83, 0xd2, 0xb8, 0x50,
	0x48, 0x81, 0x8d, 0x1b, 0xe9, 0x21, 0x24, 0xa9, 0x7f, 0x9c, 0x03, 0x6a, 0xcf, 0x76, 0x0c, 0x1f,
	0x77, 0xfa, 0x9e, 0x1d, 0x9c, 0x18, 0x5d, 0x7c, 0x8c, 0xbb, 0x8b, 0x43, 0xe5, 0xdc, 0xad, 0xc2,
	0x9d, 0x2f, 0x5d, 0x3a, 0x46, 0x8b, 0xb3, 0x6f, 0x11, 0xee, 0xd5, 0xd7, 0xce, 0x07, 0xa5, 0x0c,
	0x29, 0x17, 0x83, 0xd2, 0x12, 0x1b, 0x37, 0x4d, 0x83, 0x48, 0xe9, 0xd9, 0x4e, 0x4c, 0x0c, 0xff,
	0xfe, 0xbf, 0x1f, 0x01, 0x05, 0x36, 0xc8, 0x36, 0x0e, 0x4c, 0xcb, 0x0c, 0x4c, 0xf5, 0x7b, 0xa0,
	0x70, 0x8c, 0x6d, 0xcb, 0x08, 0x0e, 0x3c, 0xec, 0x1f, 0xb8, 0x5d, 0x66, 0x67, 0xd3, 0xab, 0x5f,
	0x3f, 0x1f, 0x94, 0x16, 0xe3, 0x94, 0x98, 0xb6, 0xaf, 0x86, 0x66, 0x20, 0x73, 0x40, 0x34, 0x4d,
	0x80, 0x76, 0xd8, 0x56, 0x5d, 0x30, 0x69, 0xe1, 0x63, 0xbb, 0x83, 0x0d, 0xdb, 0xd9, 0x73, 0xe9,
	0xa7, 0x4f, 0x66, 0xaa, 0xb7, 0x4a, 0xb9, 0x6a, 0xce, 0x9e, 0x4b, 0x0d, 0xef, 0xaa, 0xd4, 0x2b,
	0x36, 0xac, 0xca, 0x86, 0x95, 0xc8, 0x10, 0x01, 0x2b, 0xea, 0xac, 0x06, 0x00, 0xec, 0xd9, 0x96,
	0x7b, 0x87, 0x8d, 0x37, 0x4c, 0xc7, 0xcb, 0x54, 0x75, 0xad, 0xda, 0xb8, 0x53, 0xf1, 0xb0, 0x85,
	0x9d, 0xc0, 0x36, 0xbb, 0x74, 0xe0, 0xaf, 0x9d, 0x0f, 0x4a, 0xf3, 0xa2, 0x77, 0x6c, 0x5c, 0xbe,
	0xc9, 0x04, 0x15, 0xa2, 0x3c, 0x6d, 0xd0, 0x51, 0xdb, 0x60, 0xaa, 0xe3, 0x3a, 0x81, 0xd9, 0x09,
	0x8c, 0x03, 0xd3, 0x3f, 0xa0, 0xb6, 0x9a, 0x5f, 0x7d, 0xf5, 0x7c, 0x50, 0x5a, 0x90, 0xf1, 0x98,
	0xc4, 0x39, 0x26, 0x51, 0xa6, 0x43, 0x34, 0xc9, 0x9b, 0x1b, 0xa6, 0x7f, 0xa0, 0xfe, 0x38, 0x07,
	0x66, 0x0f, 0x4c, 0xcf, 0x7a, 0x68, 0x7a, 0xd8, 0x38, 0xc4, 0x27, 0xec, 0x9b, 0x46, 0xe9, 0x37,
	0xdd, 0xca, 0xf8, 0xa6, 0x0d, 0xce, 0xbb, 0x89, 0x4f, 0x74, 0xc7, 0x73, 0xbb, 0xdd, 0x1e, 0x76,
	0x82, 0xd5, 0x6f, 0x9f, 0x0f, 0x4a, 0xd7, 0x53, 0x62, 0x62, 0x53, 0x59, 0x64, 0x53, 0x49, 0x31,
	0x41, 0x34, 0x73, 0x20, 0x64, 0x92, 0x2f, 0xe5, 0x76, 0xf4, 0xeb, 0x61, 0x00, 0xc4, 0x8a, 0xa9,
	0xeb, 0x60, 0x72, 0xcf, 0x76, 0xf6, 0xb1, 0x77, 0xe4, 0xd9, 0x4e, 0xc0, 0x1d, 0xd5, 0x17, 0xcf,
	0x07, 0x25, 0x19, 0x16, 0x8b, 0x27, 0x81, 0x10, 0xc9, 0x2c, 0xea, 0x16, 0x00, 0x7d, 0x1f, 0x7b,
	0x86, 0xb9, 0x8f, 0x9d, 0x80, 0x5a, 0x4b, 0x9e, 0xad, 0x8a, 0x40, 0xb3, 0x56, 0x45, 0x50, 0x21,
	0xca, 0x93, 0x86, 0x46, 0x7e, 0xab, 0xdb, 0x60, 0x7a, 0xcf, 0xf6, 0xfc, 0xc0, 0xf0, 0x31, 0x76,
	0x0c, 0x33, 0xe0, 0x3e, 0xe8, 0x2b, 0xe7, 0x83, 0x52, 0x9c, 0x70, 0x31, 0x28, 0xcd, 0x87, 0x53,
	0x93, 0x60, 0x3a, 0x39, 0xcf, 0x0f, 0x5a, 0x18, 0x3b, 0x5a, 0xa0, 0xd6, 0xc0, 0x54, 0xd7, 0x94,
	0xa4, 0x8d, 0x50, 0x69, 0x5f, 0x3e, 0x1f, 0x94, 0x62, 0xb8, 0x58, 0x5a, 0x19, 0x85, 0x08, 0x90,
	0x26, 0x17, 0xf5, 0x16, 0x18, 0xb7, 0x8f, 0x98, 0xa9, 0x8c, 0xd2, 0x8f, 0x24, 0x52, 0x66, 0x39,
	0x14, 0xfb, 0x42, 0xee, 0x5c, 0x38, 0x09, 0xa2, 0x31, 0xfb, 0x88, 0xda, 0xc6, 0x7d, 0xa0, 0x04,
	0x5e, 0xdf, 0x0f, 0x0c, 0xfc, 0xe8, 0xc8, 0xf6, 0xb0, 0x4f, 0x26, 0x34, 0x46, 0x27, 0x44, 0xfd,
	0x76, 0x92, 0x26, 0xfc, 0x76, 0x92, 0x02, 0x51, 0x81, 0x42, 0x3a, 0x43, 0xb4, 0x80, 0x2f, 0xf1,
	0x9f, 0x0d, 0x83, 0xb9, 0x8c, 0x4d, 0xa2, 0xd6, 0xc1, 0x74, 0x27, 0x42, 0xc2, 0xb0, 0x34, 0xc5,
	0x94, 0x1a, 0x23, 0x08, 0xa5, 0xc6, 0x60, 0x88, 0xa6, 0x44, 0xbb, 0x66, 0x91, 0x18, 0x77, 0xd4,
	0x7f, 0xd0, 0xb5, 0x3b, 0xc4, 0xea, 0xe8, 0x92, 0x4f, 0xb1, 0x18, 0x27, 0x50, 0xb1, 0xd0, 0x02,
	0x83, 0x28, 0xcf, 0x1a, 0x9b, 0xf8, 0x44, 0xfd, 0x0e, 0x18, 0x33, 0xcd, 0xfd, 0xbe, 0x6d, 0xd1,
	0x15, 0x9e, 0xa2, 0xa6, 0xa7, 0x30, 0x24, 0xa6, 0xcc, 0x69, 0x26, 0x85, 0x51, 0x20, 0xe2, 0x9d,
	0x68, 0x98, 0xb5, 0xf7, 0x1d, 0xa3, 0xe3, 0xf6, 0x1d, 0xb6, 0xac, 0xd3, 0x3c, 0xcc, 0x46, 0xa8,
	0x14, 0x66, 0x23, 0x8c, 0xc7, 0x97, 0x0a, 0xf9, 0xad, 0x5a, 0x40, 0x31, 0x83, 0x80, 0xc4, 0x2d,
	0x12, 0x52, 0x0c, 0x92, 0x29, 0xf0, 0xa5, 0x7d, 0xfd, 0x7c, 0x50, 0x2a, 0x26, 0x69, 0xb1, 0x69,
	0xf1, 0x95, 0x49, 0xf2, 0x40, 0x34, 0x23, 0x41, 0x24, 0xf2, 0xf0, 0xa5, 0xf9, 0xb7, 0x49, 0x70,
	0x35, 0x73, 0xaf, 0xab, 0xef, 0x81, 0x09, 0xb2, 0x77, 0xe9, 0xe8, 0x39, 0x1a, 0x66, 0xe0, 0xe3,
	0xfd, 0x04, 0x8d, 0x67, 0xa5, 0xf3, 0x41, 0x29, 0xea, 0x77, 0x31, 0x28, 0xcd, 0xb0, 0xf9, 0x84,
	0x08, 0x44, 0xe3, 0x87, 0x8c, 0x53, 0xbd, 0x03, 0xc6, 0xa8, 0x6f, 0xb0, 0xf8, 0xde, 0xbc, 0x7e,
	0x3e, 0x28, 0x71, 0x44, 0xa8, 0x97, 0xb5, 0x21, 0x1a, 0x3d, 0xc4, 0x27, 0x35, 0x8b, 0xec, 0x69,
	0xbf, 0xff, 0xe0, 0x77, 0x71, 0x27, 0x30, 0x2c, 0x87, 0x2e, 0x10, 0xdf, 0xd3, 0x02, 0xcd, 0xda,
	0xd3, 0x82, 0x4a, 0xf4, 0xcc, 0x1a, 0x55, 0x47, 0xdd, 0x00, 0x79, 0xdb, 0xf7, 0xfb, 0xd8, 0x23,
	0xc2, 0x98, 0x9b, 0xa5, 0x29, 0x41, 0x04, 0x66, 0xa5, 0x04, 0x11, 0x11, 0xa2, 0x09, 0xf6, 0xbb,
	0xea, 0xa8, 0xef, 0x80, 0x69, 0x1f, 0x7b, 0xc4, 0x28, 0x9d, 0x7e, 0xef, 0x01, 0xf6, 0xf8, 0x72,
	0x91, 0x78, 0x7b, 0x2d, 0x46, 0x88, 0x49, 0x9c, 0x0f, 0x93, 0x2d, 0x89, 0x01, 0xa2, 0x29, 0xd6,
	0xae, 0xd3, 0xa6, 0xfa, 0x01, 0x58, 0x10, 0x86, 0x6a, 0xc8, 0x9e, 0x71, 0x8c, 0x0e, 0x41, 0x3c,
	0xf2, 0x25, 0x1c, 0x17, 0x83, 0xd2, 0xcd, 0xa4, 0xa9, 0x1b, 0x31, 0x7f, 0x39, 0x1f, 0x99, 0xfd,
	0x9a, 0xe4, 0x38, 0x57, 0x01, 0x70, 0xdc, 0xc0, 0x78, 0x80, 0xf7, 0x5c, 0x0f, 0x2f, 0x8e, 0x53,
	0x47, 0x40, 0x4d, 0x58, 0xa0, 0x42, 0xb5, 0x02, 0x83, 0x28, 0xef, 0xb8, 0xc1, 0x2a, 0xfd, 0xad,
	0xbe, 0x01, 0x48, 0xc3, 0x30, 0xf7, 0x02, 0xec, 0x2d, 0x4e, 0x88, 0x74, 0x2d, 0x02, 0x85, 0x42,
	0x23, 0x08, 0xa2, 0x09, 0xc7, 0x0d, 0x34, 0xf2, 0x93, 0x2c, 0x0d, 0x99, 0x6d, 0xdf, 0x37, 0xf7,
	0xf1, 0x62, 0xbe, 0x3c, 0x1c, 0x2e, 0x4d, 0x04, 0x66, 0x2d, 0x4d, 0x44, 0x84, 0x88, 0x98, 0xe0,
	0x0e, 0xf9, 0xa9, 0x1e, 0x02, 0x15, 0x3f, 0x0a, 0xb0, 0x63, 0x61, 0xcb, 0x10, 0x22, 0x01, 0x15,
	0xf9, 0x9d, 0xf3, 0x41, 0xe9, 0x46, 0x9a, 0x1a, 0x93, 0xcd, 0x33, 0xa3, 0x34, 0x17, 0x44, 0x4a,
	0x08, 0x6e, 0x86, 0x83, 0xfd, 0x7e, 0x0e, 0xcc, 0xf8, 0x3d, 0xd3, 0x0b, 0x8c, 0x8e, 0xe9, 0x59,
	0x2c, 0xc6, 0x4e, 0xd2, 0x18, 0x5b, 0xce, 0xd8, 0x3b, 0x2d, 0xc2, 0x59, 0x31, 0x3d, 0x8b, 0x66,
	0x0c, 0xdf, 0x3c, 0x1f, 0x94, 0x96, 0x12, 0x9d, 0x63, 0x33, 0x59, 0xe0, 0xe6, 0x12, 0x67, 0x81,
	0x68, 0xda, 0x97, 0xe5, 0xa8, 0x27, 0x60, 0xd1, 0xc3, 0xc7, 0x6e, 0x87, 0x6d, 0xfe, 0xce, 0x01,
	0xee, 0x1c, 0x1a, 0xd8, 0x31, 0x1f, 0x74, 0xb1, 0xb5, 0x38, 0x55, 0xce, 0xdd, 0x9a, 0x58, 0x7d,
	0x93, 0xa4, 0x63, 0x97, 0xf1, 0x5c, 0x0c, 0x4a, 0x25, 0x36, 0xd0, 0x65, 0x1c, 0x10, 0x2d, 0x08,
	0x52, 0x85, 0x50, 0x74, 0x46, 0x50, 0x1f, 0x82, 0xab, 0x34, 0x4e, 0x25, 0x7b, 0x2e, 0x4e, 0x53,
	0x0b, 0xa8, 0x9c, 0x0f, 0x4a, 0xa5, 0x4c, 0x86, 0xd8, 0x77, 0xde, 0x90, 0x22, 0x5e, 0x92, 0x11,
	0xa2, 0x39, 0x82, 0xa3, 0xf8, 0xf8, 0xea, 0xf7, 0x73, 0x60, 0x56, 0x62, 0x25, 0x6e, 0xae, 0xef,
	0x2f, 0x16, 0xa8, 0xd7, 0x7a, 0x39, 0x43, 0xf3, 0xa2, 0x7f, 0x8b, 0xb2, 0xd2, 0xf4, 0x2a, 0x2d,
	0x41, 0xa4, 0x33, 0x29, 0x12, 0x44, 0x8a, 0x97, 0x10, 0xa2, 0xfe, 0x24, 0x07, 0x6e, 0xd0, 0xf8,
	0x87, 0x2d, 0xa3, 0x63, 0x1a, 0x1d, 0xec, 0x05, 0xf2, 0x7e, 0xf3, 0x17, 0x67, 0xa8, 0xd5, 0x7d,
	0xf7, 0x7c, 0x50, 0xfa, 0xd2, 0xe3, 0xf8, 0x62, 0xda, 0x78, 0x59, 0x0a, 0xb5, 0x97, 0xf0, 0x43,
	0xb4, 0xc4, 0xc9, 0x15, 0xb3, 0x82, 0xbd, 0x40, 0xda, 0xcc, 0x3e, 0x77, 0xf3, 0xbf, 0x18, 0x05,
	0xd3, 0x31, 0x73, 0x53, 0x4d, 0xa0, 0x52, 0x1b, 0x8a, 0xfb, 0xad, 0x5c, 0xe4, 0xb7, 0x32, 0xa8,
	0x62, 0x37, 0xa4, 0x69, 0x10, 0x29, 0x04, 0x6c, 0xc9, 0xbe, 0xeb, 0x0d, 0x90, 0xa7, 0x8c, 0x34,
	0x84, 0x30, 0x27, 0x4f, 0x9d, 0x40, 0x04, 0x8a, 0xad, 0x1b, 0x41, 0x10, 0x4d, 0x90, 0xdf, 0x34,
	0x42, 0xbc, 0x05, 0xc6, 0xfd, 0xae, 0x1b, 0x18, 0x3c, 0x16, 0xf3, 0xcc, 0x86, 0x43, 0x59, 0x99,
	0x0d, 0x27, 0x41, 0x34, 0x46, 0x7e, 0xd5, 0x2c, 0xf5, 0x75, 0x30, 0xda, 0x39, 0x20, 0xb1, 0x7c,
	0x24, 0x3a, 0xef, 0xce, 0x50, 0x20, 0xd6, 0x7b, 0x8a, 0xcf, 0xe1, 0x80, 0x46, 0x72, 0xd6, 0x83,
	0x74, 0xdd, 0x33, 0xfd, 0x8e, 0xc3, 0x5d, 0x39, 0xed, 0x4a, 0x81, 0xac, 0xae, 0x94, 0x00, 0x11,
	0xeb, 0xa1, 0x76, 0x00, 0xd5, 0x85, 0x41, 0x4e, 0x2d, 0xd8, 0x33, 0x1c, 0xb3, 0x87, 0xb9, 0xb7,
	0xa6, 0xf1, 0x3b, 0x49, 0xcb, 0x8a, 0xdf, 0x49, 0x1e, 0x88, 0x0a, 0x04, 0xda, 0xa0, 0x48, 0xdd,
	0xec, 0x61, 0xf5, 0x7d, 0x30, 0x43, 0x13, 0x2f, 0x66, 0x94, 0x96, 0x19, 0x84, 0xae, 0x9a, 0xfa,
	0x91, 0x04, 0x29, 0xcb, 0x8f, 0x24, 0x58, 0x20, 0x2a, 0x08, 0xa4, 0x6a, 0x06, 0x38, 0xda, 0xcd,
	0x47, 0xb6, 0x63, 0xb0, 0xe3, 0x38, 0xb3, 0x76, 0xee, 0xcf, 0xc5, 0x6e, 0x4e, 0x32, 0x5c, 0xba,
	0x9b, 0x93, 0x8c, 0x7c, 0x37, 0x37, 0x6d, 0x67, 0x57, 0x42, 0xb9, 0xc9, 0xfe, 0x78, 0x02, 0x28,
	0xec, 0x7c, 0x29, 0x25, 0x25, 0x0e, 0x98, 0x31, 0x3b, 0x34, 0x63, 0x32, 0x4c, 0xcb, 0xf2, 0xb0,
	0xef, 0x73, 0x93, 0xd5, 0xc9, 0xfa, 0x24, 0x48, 0xe2, 0x5b, 0x13, 0x04, 0xf8, 0xab, 0xbf, 0xfd,
	0xda, 0x3c, 0xaf, 0x9e, 0x68, 0x0c, 0x6a, 0x05, 0x9e, 0xed, 0xec, 0xa3, 0x02, 0xe7, 0xe4, 0xa8,
	0x8a, 0xc1, 0x24, 0x3b, 0x81, 0x0b, 0x23, 0xfe, 0xd4, 0x23, 0x3d, 0x3b, 0xac, 0x88, 0x5e, 0xd2,
	0x61, 0x45, 0x80, 0x10, 0x81, 0xbd, 0xa8, 0x0b, 0xd9, 0x29, 0x9c, 0x16, 0xd9, 0x3a, 0xdd, 0x29,
	0x11, 0x28, 0x76, 0x4a, 0x04, 0x41, 0x34, 0xc1, 0x7e, 0xd7, 0x2c, 0xf5, 0x00, 0xcc, 0xf2, 0x18,
	0x6f, 0xd3, 0x6c, 0x78, 0xcf, 0xc6, 0x1e, 0x2f, 0x72, 0xd0, 0x23, 0x5b, 0x8a, 0x98, 0x75, 0x64,
	0x4b, 0x31, 0x41, 0xa4, 0x30, 0xac, 0x16, 0x41, 0xea, 0x0a, 0x18, 0xed, 0x9a, 0x0f, 0x70, 0x97,
	0x6f, 0x8b, 0xa5, 0xf3, 0x41, 0x89, 0x01, 0x62, 0x33, 0xd0, 0x26, 0x44, 0x0c, 0x56, 0xdf, 0x03,
	0x63, 0xdc, 0x1d, 0x8f, 0x51, 0xe5, 0x7d, 0xe5, 0x52, 0xe5, 0x89, 0x65, 0xe6, 0x4e, 0x99, 0x66,
	0x84, 0x91, 0x27, 0xe6, 0x19, 0x61, 0xe8, 0x7e, 0x39, 0x41, 0x5d, 0x03, 0x93, 0x98, 0x76, 0xc4,
	0x16, 0x39, 0xb7, 0xb0, 0x3d, 0x40, 0x97, 0x40, 0x82, 0xc5, 0x12, 0x48, 0x20, 0x44, 0x20, 0x6c,
	0x69, 0x81, 0xda, 0x04, 0x93, 0x51, 0x19, 0xca, 0x0c, 0xb8, 0x8d, 0xd3, 0xf2, 0x81, 0x04, 0x67,
	0x95, 0x0f, 0x24, 0x32, 0x44, 0x20, 0x6c, 0x69, 0xf4, 0x00, 0x4a, 0x42, 0xc4, 0x21, 0x13, 0x98,
	0xa7, 0x02, 0x69, 0xb2, 0x2a, 0xd0, 0xac, 0x64, 0x55, 0x50, 0x21, 0xca, 0xf3, 0x86, 0x16, 0xa8,
	0x2d, 0x7e, 0x62, 0xec, 0xfb, 0x4c, 0x1e, 0xa0, 0xf2, 0x68, 0x59, 0x40, 0xc6, 0xb3, 0xca, 0x02,
	0x32, 0x9d, 0x9f, 0x1d, 0x77, 0x7c, 0x2a, 0xf4, 0x0d, 0x40, 0x8e, 0xb8, 0xfc, 0xb0, 0x42, 0x12,
	0x95, 0x11, 0x66, 0x77, 0x11, 0x28, 0xec, 0x2e, 0x82, 0x20, 0x9a, 0xe8, 0xfb, 0x98, 0x9d, 0x54,
	0x0e, 0xc0, 0x44, 0x8f, 0x17, 0x7f, 0x68, 0x6e, 0x31, 0x79, 0xe7, 0xa5, 0x4b, 0x97, 0x37, 0xac,
	0x12, 0xd1, 0xe3, 0x9d, 0x1a, 0x76, 0x8b, 0xcd, 0x97, 0x1f, 0x16, 0x42, 0x1a, 0x44, 0x91, 0x74,
	0xee, 0x13, 0x7e, 0x3e, 0x02, 0xe6, 0xda, 0x2c, 0xd4, 0xb1, 0x92, 0x41, 0xd3, 0xed, 0xda, 0x9d,
	0x13, 0xf5, 0x9b, 0x60, 0x3c, 0x4c, 0x71, 0x72, 0x34, 0xc5, 0xa1, 0x65, 0x35, 0x91, 0xd1, 0x14,
	0xc2, 0xc5, 0xe7, 0x09, 0x4c, 0x48, 0x52, 0x11, 0x60, 0x27, 0x56, 0xc3, 0xea, 0x33, 0xcf, 0x47,
	0xb7, 0xf8, 0x30, 0x4d, 0x36, 0x13, 0x14, 0x51, 0xa7, 0x8a, 0xe3, 0x10, 0x4d, 0x53, 0xa0, 0xca,
	0xdb, 0xea, 0x0f, 0x72, 0x60, 0xc6, 0xc3, 0x56, 0xbf, 0x23, 0x55, 0x49, 0x59, 0xf1, 0xe8, 0x0b,
	0x97, 0x2a, 0x47, 0x2a, 0x21, 0x32, 0x07, 0x9e, 0x10, 0x90, 0xe5, 0xc0, 0x13, 0x2c, 0x10, 0x15,
	0x38, 0x12, 0xd6, 0x4c, 0x31, 0x98, 0xeb, 0x99, 0x8f, 0x8c, 0x30, 0x75, 0x60, 0x95, 0x2d, 0x9f,
	0x1f, 0x4a, 0xbf, 0x4e, 0xd2, 0xe9, 0x0c, 0xf2, 0xc5, 0xa0, 0x54, 0xe4, 0xcb, 0x90, 0x26, 0x42,
	0x34, 0xdb, 0x33, 0x1f, 0xc5, 0x56, 0xc0, 0x57, 0x3f, 0xcc, 0x81, 0x1b, 0x1e, 0xfe, 0xa0, 0x6f,
	0x7b, 0xd8, 0xf0, 0xb0, 0xd9, 0x0f, 0x0e, 0x8c, 0x3d, 0xd7, 0x33, 0x7c, 0xec, 0xf8, 0x76, 0x60,
	0x1f, 0xb3, 0xb3, 0xeb, 0xc4, 0xea, 0x3a, 0x49, 0xb6, 0x1f, 0xc7, 0x27, 0x92, 0x9d, 0xc7, 0x71,
	0x41, 0xb4, 0xc4, 0xc9, 0x88, 0x52, 0xd7, 0x5c, 0xaf, 0x15, 0xd2, 0xb8, 0x95, 0xfc, 0xdd, 0x04,
	0xc8, 0x6f, 0xaf, 0x69, 0xdc, 0x36, 0x5e, 0x74, 0xc8, 0xf8, 0xc3, 0x1c, 0x50, 0xf8, 0x0c, 0xe3,
	0x55, 0xf2, 0xcf, 0xba, 0xfe, 0xaf, 0xfd, 0x72, 0x50, 0xba, 0x72, 0x3e, 0x28, 0xa5, 0xa4, 0x88,
	0xf4, 0x20, 0x49, 0x81, 0x68, 0x26, 0x84, 0xc2, 0xc5, 0xff, 0x59, 0x0e, 0xcc, 0xc5, 0x57, 0xcf,
	0xf0, 0xfa, 0x5d, 0xfc, 0x98, 0x32, 0x66, 0xc6, 0xc6, 0xa2, 0x47, 0x85, 0x9b, 0x19, 0x62, 0x62,
	0xf6, 0x58, 0x8c, 0xa7, 0xa8, 0x12, 0x1b, 0x44, 0xb3, 0x81, 0x2c, 0x15, 0xf5, 0xbb, 0x98, 0x2b,
	0xa8, 0xe3, 0x1e, 0x63, 0xef, 0x24, 0x52, 0xd0, 0xc8, 0xd3, 0x29, 0x28, 0x2e, 0x45, 0x56, 0x50,
	0x9c, 0x42, 0x15, 0xc4, 0xa0, 0x50, 0x41, 0x3f, 0xcd, 0x81, 0x79, 0x72, 0x98, 0xf3, 0x5c, 0x5e,
	0x27, 0x09, 0xa7, 0x32, 0xfa, 0x04, 0x53, 0xf9, 0x36, 0x9f, 0x4a, 0xa6, 0xa4, 0x8b, 0x41, 0xe9,
	0xba, 0x38, 0x99, 0x26, 0xa9, 0x10, 0xa9, 0x87, 0xf8, 0x04, 0x71, 0x34, 0x9c, 0xd5, 0xbb, 0x40,
	0x09, 0x2f, 0x5f, 0x22, 0x97, 0x24, 0xd5, 0xe2, 0x92, 0x34, 0xf1, 0xc5, 0x49, 0x0a, 0x44, 0x33,
	0x1c, 0x8a, 0x1c, 0x53, 0xba, 0x3c, 0x3f, 0xfe, 0x1c, 0xcb, 0xf3, 0x92, 0x0f, 0x9e, 0x78, 0x22,
	0x1f, 0xbc, 0x0a, 0x40, 0xc7, 0xc3, 0x66, 0x20, 0xc7, 0x49, 0x5a, 0x6f, 0x10, 0xa8, 0x88, 0x8e,
	0x02, 0x83, 0x28, 0xcf, 0x1b, 0x1a, 0xad, 0x59, 0xf4, 0x8f, 0xac, 0x50, 0x06, 0x10, 0x32, 0x04,
	0x2a, 0x95, 0x78, 0x23, 0x0c, 0xa2, 0x3c, 0x6f, 0x44, 0xb5, 0xca, 0x7f, 0x1d, 0x02, 0xa0, 0xd2,
	0xb5, 0xb1, 0x13, 0xd0, 0x63, 0x52, 0x17, 0xa8, 0xdc, 0x9e, 0xd3, 0x55, 0x69, 0x5a, 0x3e, 0x48,
	0x53, 0xb3, 0xca, 0x07, 0x69, 0x2e, 0x88, 0x66, 0x19, 0x28, 0x97, 0x5e, 0xa4, 0x5a, 0xee, 0xd0,
	0xd3, 0xd5, 0x72, 0xe3, 0x55, 0xef, 0xe1, 0x67, 0xac, 0x7a, 0xbf, 0x0d, 0xa6, 0x88, 0x5f, 0xc1,
	0x3e, 0x57, 0xac, 0x54, 0xa6, 0x96, 0x71, 0x91, 0x6a, 0xc8, 0x28, 0x44, 0x93, 0x51, 0x33, 0x52,
	0xef, 0x5f, 0x8d, 0x80, 0xd9, 0xca, 0x81, 0xd9, 0xed, 0x62, 0x67, 0x1f, 0x47, 0x17, 0x47, 0x3f,
	0xcc, 0x81, 0x19, 0x76, 0x1d, 0xd2, 0x09, 0x69, 0x54, 0xc7, 0x93, 0x77, 0xbe, 0x78, 0xe9, 0x7d,
	0x4b, 0xc8, 0x58, 0x25, 0x39, 0x05, 0x8d, 0x99, 0x09, 0x09, 0x59, 0x31, 0x33, 0xc1, 0x02, 0x51,
	0x81, 0x22, 0x91, 0x30, 0xd5, 0x06, 0x13, 0x6e, 0x70, 0x24, 0xdf, 0x30, 0x65, 0xd5, 0x0f, 0x1a,
	0xed, 0x66, 0xd4, 0x85, 0x16, 0x6f, 0x68, 0x4e, 0x13, 0x76, 0xcc, 0xca, 0x69, 0x42, 0x1a, 0x44,
	0xe3, 0x6e, 0x70, 0x44, 0x4d, 0xcb, 0x05, 0x93, 0x1d, 0x6a, 0x68, 0xf2, 0xfd, 0x52, 0xd6, 0xd9,
	0x42, 0x98, 0x23, 0x4b, 0x48, 0xa5, 0x5e, 0x59, 0x09, 0xa9, 0x44, 0x86, 0x08, 0x74, 0x84, 0x2d,
	0xff, 0x65, 0x0e, 0x2c, 0xc4, 0xee, 0x65, 0x84, 0xb2, 0x47, 0xe8, 0xe0, 0x5f, 0x7e, 0x7c, 0x81,
	0x37, 0xfa, 0x64, 0x1a, 0x3a, 0xcb, 0xd9, 0xa2, 0x62, 0x33, 0xba, 0x99, 0x71, 0x19, 0x24, 0x29,
	0x7f, 0xfe, 0x20, 0x43, 0x38, 0x37, 0x94, 0x0f, 0x87, 0x81, 0x9a, 0x5e, 0x68, 0xf5, 0x4d, 0x90,
	0x8f, 0x9b, 0xc8, 0x14, 0xaf, 0x29, 0x84, 0xa0, 0x54, 0x53, 0x10, 0x03, 0x09, 0xb2, 0x7a, 0x9f,
	0x04, 0x9f, 0xee, 0x89, 0xed, 0xec, 0x1b, 0x47, 0xa6, 0x17, 0x48, 0x05, 0xe8, 0x15, 0x16, 0x52,
	0xe2, 0x34, 0x39, 0xa4, 0xc4, 0x29, 0x34, 0xdf, 0xa2, 0x50, 0x93, 0x20, 0x35, 0x4b, 0x3d, 0x02,
	0x73, 0x66, 0xb7, 0xeb, 0x3e, 0xc4, 0x96, 0x21, 0xae, 0x25, 0x48, 0xee, 0x37, 0x7c, 0x6b, 0x8a,
	0x45, 0xd2, 0x0c, 0x72, 0x56, 0x24, 0xcd, 0x60, 0x83, 0x48, 0xe5, 0xa8, 0xb8, 0x43, 0xf1, 0xd5,
	0xf7, 0xc0, 0x2c, 0xdd, 0xb9, 0xb1, 0xe3, 0xb9, 0xb8, 0x30, 0x4c, 0x13, 0xc5, 0x69, 0x2f, 0x45,
	0x82, 0x48, 0x21, 0x58, 0xc6, 0x49, 0xfc, 0x9f, 0x87, 0x81, 0x92, 0xb4, 0x78, 0x75, 0x17, 0xcc,
	0x58, 0xb8, 0x6b, 0xd3, 0x20, 0xdb, 0xc3, 0xc1, 0x81, 0x1b, 0x3e, 0x2a, 0x20, 0xde, 0x26, 0x49,
	0x12, 0x1b, 0x30, 0x41, 0x80, 0xa8, 0x10, 0x22, 0xdb, 0x14, 0x50, 0xff, 0x28, 0x07, 0xae, 0x47,
	0x4c, 0x16, 0xf6, 0x03, 0x1e, 0x6a, 0x8d, 0x9e, 0xe9, 0x1f, 0xe2, 0x70, 0xad, 0x88, 0x01, 0x3e,
	0x8e, 0xed, 0x62, 0x50, 0x82, 0x89, 0x01, 0xd3, 0x4c, 0x10, 0x2d, 0x85, 0xd4, 0xaa, 0x20, 0x6e,
	0x53, 0x9a, 0xfa, 0x0d, 0x30, 0xee, 0x93, 0x6d, 0x14, 0x5d, 0xf5, 0xd1, 0x70, 0xc6, 0x21, 0xa9,
	0xe4, 0xc4, 0x00, 0x72, 0x1e, 0xc5, 0x4e, 0xa0, 0x71, 0x97, 0xe9, 0x63, 0xc7, 0x8a, 0x5d, 0x01,
	0x71, 0x97, 0x29, 0x70, 0xd9, 0x65, 0x0a, 0x94, 0xba, 0x4c, 0xd2, 0x64, 0xc7, 0xab, 0xdf, 0x01,
	0x05, 0x5e, 0x05, 0xa5, 0x2c, 0x66, 0x40, 0x53, 0xe9, 0x61, 0x16, 0xb0, 0xe3, 0x94, 0xac, 0x80,
	0x1d, 0xe7, 0x80, 0x68, 0x8a, 0x95, 0x4e, 0x49, 0x3b, 0xf2, 0xc7, 0x3f, 0x18, 0x02, 0xf3, 0x59,
	0x5b, 0xfc, 0xd9, 0x37, 0xda, 0xd3, 0xdc, 0xef, 0xac, 0x80, 0x51, 0xc7, 0x75, 0x3a, 0x98, 0x07,
	0x2e, 0x5a, 0x5d, 0xa0, 0x80, 0xa8, 0x2e, 0xd0, 0x26, 0x44, 0x0c, 0x4e, 0xe4, 0x0e, 0x23, 0x4f,
	0x93, 0x3b, 0x70, 0x45, 0xfc, 0x0c, 0x80, 0xbc, 0xf8, 0xfa, 0xb7, 0xc1, 0x54, 0xf4, 0x25, 0xe2,
	0xbd, 0x0c, 0x5d, 0x45, 0x19, 0x97, 0xae, 0xde, 0x25, 0x14, 0xa2, 0xc9, 0xa8, 0x59, 0xb3, 0xb2,
	0x0e, 0x20, 0x43, 0x2f, 0xb0, 0x66, 0x35, 0xfc, 0x22, 0x6a, 0x56, 0x23, 0x4f, 0x5e, 0xb3, 0xfa,
	0x61, 0x0e, 0x28, 0x81, 0x67, 0x3a, 0xbe, 0xd9, 0x89, 0x5f, 0x73, 0x16, 0xee, 0x7c, 0x35, 0xeb,
	0xb2, 0x24, 0x3c, 0xe4, 0xb5, 0x45, 0x1f, 0xf1, 0xb6, 0x28, 0x29, 0x48, 0xbe, 0xa3, 0x8e, 0x53,
	0x20, 0x9a, 0x09, 0xe2, 0x12, 0xd4, 0x7b, 0x89, 0x12, 0x55, 0xd6, 0x3d, 0x67, 0x64, 0x1a, 0x4f,
	0x52, 0x9b, 0xfa, 0x1e, 0x28, 0x08, 0xbb, 0xa0, 0x45, 0x92, 0x71, 0xba, 0x91, 0xe8, 0xfe, 0x8d,
	0x53, 0xb2, 0xf6, 0x6f, 0x9c, 0x03, 0xa2, 0xe9, 0x4e, 0x2c, 0x14, 0xc6, 0x6d, 0x7f, 0xe2, 0x69,
	0xf3, 0x66, 0xe9, 0xd2, 0x5f, 0xca, 0xbd, 0x63, 0xd7, 0xfd, 0xb3, 0x52, 0xc5, 0x98, 0x5f, 0xf4,
	0xe7, 0x71, 0x78, 0xc7, 0x9f, 0xac, 0x9c, 0x81, 0x67, 0xaf, 0x9c, 0xd5, 0xc1, 0xb4, 0x19, 0x50,
	0x6e, 0xa9, 0x34, 0x35, 0xcd, 0xde, 0x05, 0xc4, 0x08, 0xe2, 0x12, 0x35, 0x06, 0x43, 0x34, 0xc5,
	0xdb, 0xcc, 0x8f, 0xbe, 0x0d, 0xa6, 0x7a, 0xe6, 0x23, 0x83, 0x63, 0x3e, 0x2d, 0x55, 0x71, 0x9f,
	0x2c, 0xe3, 0x62, 0x37, 0xcb, 0x28, 0x44, 0x93, 0x3d, 0xf3, 0x91, 0xc6, 0x5b, 0xc2, 0x45, 0x4d,
	0x7f, 0x46, 0x17, 0xb5, 0x15, 0x7b, 0x78, 0x57, 0x90, 0xee, 0xac, 0x23, 0x34, 0xf3, 0xce, 0x3a,
	0xfb, 0x09, 0xde, 0xa1, 0x54, 0x71, 0x9b, 0xb9, 0xb4, 0xa8, 0x94, 0xca, 0xb0, 0x9f, 0xa5, 0xe8,
	0xf6, 0x8f, 0xc3, 0x52, 0xca, 0x8e, 0xb0, 0x7f, 0xe4, 0x3a, 0xfe, 0xf3, 0xf5, 0x90, 0x2f, 0xa8,
	0xca, 0x5e, 0x07, 0xd3, 0x1e, 0x9f, 0x3e, 0xdb, 0x8d, 0xc3, 0xe2, 0xb9, 0x49, 0x8c, 0x20, 0xcc,
	0x2a, 0x06, 0x43, 0x34, 0x15, 0xb6, 0xe9, 0x06, 0x4c, 0x24, 0xf0, 0x23, 0xbf, 0xf1, 0x04, 0x3e,
	0xf6, 0x08, 0x72, 0xf4, 0xc9, 0x1f, 0x41, 0x86, 0x47, 0xdc, 0x31, 0x30, 0xaf, 0xf5, 0x83, 0x03,
	0xd7, 0xb3, 0x7f, 0x8f, 0xdd, 0x5f, 0x32, 0xf3, 0x7a, 0x2e, 0x6f, 0x44, 0x5f, 0x74, 0xb4, 0xcb,
	0x0c, 0x23, 0xc3, 0x9f, 0x47, 0x18, 0xc9, 0x7a, 0x1d, 0x3b, 0xf2, 0x62, 0x5e, 0xc7, 0xc6, 0x43,
	0xc1, 0xe8, 0x73, 0x08, 0x05, 0x63, 0x4f, 0x15, 0x0a, 0xde, 0x02, 0xe3, 0xe1, 0xfd, 0xc4, 0x78,
	0x54, 0x2a, 0x98, 0xcd, 0xba, 0x9a, 0x28, 0x44, 0xa7, 0x10, 0x36, 0x91, 0xb1, 0x3e, 0xbb, 0x91,
	0xd8, 0x06, 0xd3, 0xb6, 0x6f, 0xf8, 0xb6, 0xb3, 0xdf, 0xc5, 0x46, 0xdf, 0xc7, 0xbc, 0x96, 0x44,
	0xf7, 0x68, 0x8c, 0x20, 0xf6, 0x68, 0x0c, 0x86, 0x68, 0xd2, 0xf6, 0x5b, 0xb4, 0xb9, 0xe3, 0xe3,
	0x4b, 0xca, 0x37, 0xf9, 0xdf, 0x4c, 0xf9, 0x86, 0x6f, 0xaf, 0xff, 0x1c, 0x02, 0xd3, 0xb1, 0x5a,
	0xea, 0x0b, 0x2f, 0x41, 0xdb, 0x4f, 0xf1, 0x52, 0xf6, 0x2b, 0xbc, 0x92, 0x29, 0xf7, 0xfc, 0x0c,
	0x6f, 0x64, 0xef, 0x82, 0x09, 0xd3, 0xb2, 0xd8, 0x92, 0xb3, 0x73, 0x12, 0x7d, 0x01, 0x16, 0x62,
	0x22, 0xbe, 0x84, 0x08, 0x44, 0xe3, 0xf4, 0xa7, 0xf4, 0x08, 0x32, 0x34, 0x99, 0xe4, 0x23, 0x48,
	0x8e, 0x7f, 0x86, 0x8b, 0xac, 0xf0, 0x95, 0xc3, 0x04, 0x98, 0x15, 0x1b, 0xfc, 0x51, 0xc5, 0x75,
	0xf6, 0xec, 0xfd, 0x6c, 0x0f, 0x91, 0xfb, 0x3c, 0x3c, 0x84, 0x54, 0x22, 0x1d, 0x7a, 0xa2, 0x12,
	0xe9, 0x77, 0x41, 0xa1, 0x47, 0xef, 0xce, 0x6d, 0xcb, 0xf0, 0x3b, 0xae, 0xc7, 0x3c, 0xdc, 0x34,
	0xbb, 0xa6, 0x8a, 0x53, 0x44, 0xfa, 0x18, 0xc7, 0x21, 0x9a, 0xea, 0xd9, 0xce, 0x2e, 0xb6, 0xad,
	0x16, 0x69, 0xaa, 0x7f, 0x23, 0x6e, 0x6d, 0x42, 0xcf, 0x62, 0x74, 0x44, 0x65, 0xfb, 0xc9, 0x2a,
	0xf2, 0x9b, 0xdc, 0x78, 0x1e, 0x2b, 0x31, 0x75, 0xbf, 0x93, 0xc9, 0x05, 0x51, 0x31, 0x7e, 0x95,
	0x21, 0x8d, 0x93, 0x5d, 0x1e, 0x1f, 0x7d, 0x4e, 0xe5, 0xf1, 0x94, 0xeb, 0x19, 0x7b, 0x26, 0xd7,
	0xf3, 0xa3, 0x1c, 0x58, 0xa6, 0x25, 0x1b, 0x23, 0x79, 0x31, 0x82, 0xad, 0x3e, 0xb5, 0x09, 0xea,
	0x23, 0x27, 0x56, 0x37, 0xcf, 0x07, 0xa5, 0x4f, 0xe1, 0xbc, 0x18, 0x94, 0xbe, 0x28, 0x95, 0x86,
	0x2e, 0xe5, 0x83, 0xe8, 0x3a, 0x65, 0x88, 0xb9, 0x1f, 0x14, 0x52, 0xd5, 0xf7, 0xc1, 0xcc, 0xb1,
	0xd9, 0xed, 0x63, 0xe9, 0x06, 0x60, 0x82, 0xfa, 0x21, 0x5a, 0x3e, 0x4d, 0x90, 0xb2, 0xca, 0xa7,
	0x09, 0x16, 0x88, 0x0a, 0x14, 0x11, 0x97, 0x00, 0xef, 0x83, 0x99, 0x8e, 0xeb, 0x76, 0x2d, 0xf7,
	0xa1, 0x63, 0x1c, 0x61, 0xcf, 0x76, 0x2d, 0x7e, 0xa8, 0xa0, 0x23, 0x24, 0x48, 0x59, 0x23, 0x24,
	0x58, 0x20, 0x2a, 0x84, 0x48, 0x93, 0x02, 0xea, 0x3a, 0xf1, 0x6d, 0x7e, 0xc7, 0xb3, 0x8f, 0xa8,
	0x0a, 0x81, 0x78, 0x1f, 0x2e, 0xc1, 0xb2, 0xe3, 0x8a, 0x40, 0x88, 0x64, 0x16, 0xee, 0x32, 0xfe,
	0x7a, 0x02, 0x8c, 0x35, 0x4d, 0xcf, 0xec, 0xf9, 0xea, 0x09, 0x58, 0xb4, 0xf0, 0x9e, 0xd9, 0xef,
	0x06, 0x46, 0xca, 0xc6, 0x72, 0xf4, 0x23, 0xe8, 0xc3, 0xb9, 0xcb, 0x78, 0xc4, 0xc3, 0xb9, 0xcb,
	0x38, 0x20, 0x5a, 0xe0, 0xa4, 0x56, 0xc2, 0xf4, 0x02, 0x70, 0x8d, 0x1c, 0x39, 0x78, 0x80, 0x27,
	0xdf, 0x6e, 0x70, 0x97, 0x4e, 0x1d, 0xc5, 0x34, 0x8d, 0x55, 0x97, 0xb1, 0x5c, 0x0c, 0x4a, 0xcb,
	0xe2, 0xd8, 0x92, 0xc1, 0x00, 0xd1, 0x7c, 0xcf, 0x7c, 0xc4, 0x73, 0x85, 0x26, 0xf6, 0x34, 0x06,
	0xab, 0x1f, 0x80, 0x05, 0xd2, 0x43, 0x24, 0xe6, 0xd1, 0x01, 0x89, 0x79, 0x17, 0xfa, 0xb6, 0x34,
	0x9b, 0x43, 0xd4, 0x76, 0xb3, 0xe9, 0x6c, 0xc8, 0xe8, 0xd4, 0x10, 0x9d, 0x9e, 0xea, 0x40, 0x1c,
	0x62, 0x8d, 0x20, 0xe8, 0x72, 0x9f, 0xcf, 0x5e, 0x7c, 0xcb, 0x04, 0xe9, 0xc5, 0xb7, 0x0c, 0x43,
	0x24, 0x4e, 0x17, 0xed, 0xa0, 0x7b, 0xd9, 0x15, 0xf7, 0xe8, 0x73, 0xbe, 0xe2, 0x36, 0x81, 0x9a,
	0xd8, 0x72, 0x64, 0xee, 0x2c, 0x47, 0xa2, 0x8f, 0xe5, 0xd2, 0x54, 0x91, 0x3c, 0xa4, 0x69, 0x10,
	0x29, 0xb1, 0x6b, 0x51, 0xf2, 0x25, 0x2e, 0x58, 0x88, 0x3b, 0x6c, 0x7a, 0xed, 0xdd, 0xdb, 0x33,
	0xf9, 0x25, 0x1d, 0x5b, 0x8c, 0x4c, 0x0e, 0x69, 0x31, 0x32, 0xe9, 0x10, 0xa9, 0xb2, 0xeb, 0x5f,
	0x73, 0xbd, 0xed, 0x3d, 0x53, 0xfd, 0x7e, 0x0e, 0x5c, 0x0f, 0x2f, 0xda, 0xcd, 0xc0, 0xe8, 0x62,
	0x12, 0x5c, 0x5d, 0x07, 0x73, 0x0b, 0xe2, 0x89, 0x17, 0x2d, 0xb4, 0x3e, 0x86, 0x4d, 0x14, 0x5a,
	0x1f, 0xc3, 0x04, 0xd1, 0x35, 0x4e, 0xd5, 0x82, 0x2d, 0x42, 0x6b, 0x38, 0x98, 0x99, 0xa3, 0xfa,
	0x61, 0x0e, 0xcc, 0x87, 0xe5, 0x6e, 0xe9, 0xe0, 0xe6, 0xd3, 0x47, 0xbf, 0x9f, 0x9a, 0x39, 0x13,
	0xaf, 0x92, 0xd9, 0x5d, 0x5c, 0xbd, 0x66, 0x51, 0x45, 0x31, 0x5d, 0xc8, 0xf2, 0xef, 0x2e, 0x13,
	0x87, 0x70, 0xfa, 0xef, 0xbf, 0x78, 0xe5, 0x6a, 0xe2, 0xaf, 0xf5, 0x98, 0x7f, 0x80, 0x3f, 0x1d,
	0x02, 0x73, 0xfa, 0x31, 0x76, 0x02, 0xf9, 0xb9, 0x12, 0xb6, 0x5e, 0x78, 0x76, 0xb7, 0x96, 0x3e,
	0x2d, 0xe7, 0x3f, 0x87, 0x47, 0x67, 0xdc, 0x81, 0xfe, 0x64, 0x08, 0xa8, 0x92, 0x56, 0x10, 0x7b,
	0xb0, 0xf4, 0x7f, 0x5c, 0x29, 0xff, 0x3d, 0x04, 0x16, 0xa8, 0x52, 0x22, 0x0f, 0xb8, 0xcb, 0x4f,
	0x6c, 0x2f, 0x5c, 0x31, 0xc9, 0x3a, 0xcd, 0xd0, 0x33, 0xd4, 0x69, 0xd6, 0xd2, 0x95, 0xe5, 0xa7,
	0x52, 0xf2, 0xbb, 0x19, 0x09, 0xf9, 0x88, 0xb8, 0x83, 0x7b, 0x96, 0x1c, 0x9b, 0x2f, 0xc0, 0x3f,
	0xe4, 0xc0, 0x55, 0xba, 0x00, 0xd1, 0x3b, 0xa0, 0x1d, 0x76, 0xcf, 0xff, 0xc2, 0xf5, 0xff, 0xb4,
	0x39, 0x3f, 0xfb, 0x90, 0x57, 0xfe, 0x74, 0x18, 0x00, 0xe1, 0xa4, 0xd4, 0x6f, 0x80, 0x6b, 0x6b,
	0x5a, 0xa5, 0xdd, 0x40, 0x46, 0xfb, 0x7e, 0x53, 0x37, 0x76, 0xea, 0xad, 0xa6, 0x5e, 0xa9, 0xad,
	0xd5, 0xf4, 0xaa, 0x72, 0xa5, 0xb8, 0x74, 0x7a, 0x56, 0xbe, 0x2a, 0x98, 0x77, 0x1c, 0xff, 0x08,
	0x77, 0x98, 0xd5, 0xdd, 0x02, 0x8a, 0xdc, 0xaf, 0xdd, 0x68, 0x37, 0x95, 0x5c, 0x51, 0x3d, 0x3d,
	0x2b, 0x17, 0x44, 0x07, 0x82, 0xaa, 0xaf, 0x80, 0x59, 0x99, 0x93, 0x5e, 0xc1, 0x2a, 0x43, 0xc5,
	0xb9, 0xd3, 0xb3, 0xf2, 0x8c, 0x60, 0xa5, 0xb0, 0xfa, 0x25, 0x30, 0x23, 0xf3, 0xb6, 0xb6, 0x5b,
	0xca, 0x70, 0x71, 0xf6, 0xf4, 0xac, 0x3c, 0x2d, 0x38, 0x5b, 0xdb, 0xad, 0xa4, 0x4c, 0x7d, 0x5b,
	0xab, 0x6d, 0x29, 0x23, 0x49, 0x99, 0x7a, 0xcf, 0xb4, 0xbb, 0xc9, 0x99, 0xee, 0xea, 0xb5, 0xaa,
	0x32, 0x9a, 0x9c, 0x29, 0x41, 0xd5, 0x6f, 0x83, 0x62, 0xec, 0x9b, 0xd0, 0x4e, 0xab, 0xad, 0x57,
	0x8d, 0xaa, 0xbe, 0x5b, 0xab, 0xe8, 0xca, 0x58, 0xf1, 0xfa, 0xe9, 0x59, 0xf9, 0x9a, 0xf4, 0x75,
	0xb1, 0x23, 0xf9, 0x37, 0xc1, 0xa2, 0xdc, 0x79, 0x43, 0x43, 0xd5, 0x7b, 0x1a, 0xd2, 0x8d, 0x4d,
	0xfd, 0xbe, 0x32, 0x9e, 0xd4, 0xa4, 0x74, 0x41, 0x56, 0x1c, 0xf9, 0xf0, 0xe7, 0xcb, 0x57, 0x5e,
	0xf9, 0xf3, 0x21, 0x30, 0x97, 0xf1, 0x17, 0xb6, 0x6a, 0x0d, 0xbc, 0xc4, 0xc5, 0xb6, 0xf4, 0xca,
	0x0e, 0xaa, 0xb5, 0xef, 0x1b, 0x5b, 0xfa, 0xae, 0xbe, 0x95, 0x58, 0x29, 0x78, 0x7a, 0x56, 0x5e,
	0xce, 0xe8, 0x2f, 0x2f, 0xd9, 0xeb, 0x60, 0x29, 0x5b, 0xd4, 0x56, 0xe3, 0x9e, 0x92, 0x2b, 0x16,
	0x4f, 0xcf, 0xca, 0x0b, 0x19, 0x22, 0xb6, 0xdc, 0x87, 0xea, 0x9b, 0xe0, 0x46, 0x76, 0xd7, 0x6d,
	0xbd, 0x5a, 0xdb, 0xd9, 0x56, 0x86, 0x8a, 0x37, 0x4f, 0xcf, 0xca, 0x4b, 0x19, 0xbd, 0xb7, 0xb1,
	0x65, 0xf7, 0x7b, 0x92, 0x6a, 0x13, 0x02, 0x36, 0x6a, 0xeb, 0x1b, 0xca, 0xb0, 0xac, 0xda, 0x58,
	0xf7, 0x0d, 0x7b, 0xff, 0x80, 0x6b, 0xe8, 0xa3, 0x21, 0xb0, 0x90, 0xfd, 0xae, 0x57, 0x5d, 0x05,
	0x37, 0xf5, 0x3a, 0x6a, 0x6c, 0x6d, 0x6d, 0xeb, 0xf5, 0xb6, 0xd1, 0x6a, 0x6b, 0xed, 0x9d, 0x56,
	0x42, 0x41, 0xa5, 0xd3, 0xb3, 0xf2, 0xf5, 0x64, 0x47, 0x59, 0x3b, 0x77, 0xc1, 0x52, 0x5a, 0x46,
	0x53, 0xaf, 0x57, 0x6b, 0xf5, 0x75, 0x25, 0xc7, 0x26, 0x98, 0xec, 0xdf, 0xc4, 0x8e, 0x65, 0x3b,
	0xfb, 0xea, 0xb7, 0xc0, 0x62, 0xba, 0xaf, 0x56, 0x69, 0xd7, 0x76, 0x75, 0x65, 0x88, 0x29, 0x36,
	0xd9, 0x55, 0xeb, 0x04, 0xf6, 0x31, 0xce, 0x1e, 0x15, 0xe9, 0xbb, 0x8d, 0x4d, 0xbd, 0x1a, 0xaa,
	0x25, 0xd9, 0x35, 0x8c, 0x88, 0x99, 0x7d, 0xf5, 0x77, 0x9a, 0x35, 0xa4, 0x57, 0x95, 0x91, 0xec,
	0xbe, 0xec, 0x0f, 0x29, 0x2d, 0xae, 0xd2, 0xff, 0x19, 0x02, 0x33, 0x89, 0x7b, 0x28, 0xf5, 0x2d,
	0x70, 0xa3, 0xb2, 0xa1, 0x6d, 0x6d, 0xe9, 0xf5, 0x75, 0x3d, 0x5b, 0x95, 0xcb, 0xa7, 0x67, 0xe5,
	0x62, 0xa2, 0x9b, 0xac, 0xc9, 0x6f, 0x81, 0xc5, 0x94, 0x04, 0xa1, 0x48, 0xaa, 0x8d, 0x44, 0xef,
	0x50, 0x8f, 0x77, 0xc1, 0x52, 0xaa, 0xe7, 0xae, 0x8e, 0xd8, 0xc0, 0x43, 0xec, 0x8b, 0x12, 0x5d,
	0xa3, 0x30, 0xf8, 0x0d, 0x70, 0x2d, 0xd5, 0x77, 0x4d, 0xab, 0x6d, 0x51, 0x3d, 0xd2, 0xed, 0x97,
	0xe8, 0xb9, 0x66, 0xda, 0xdd, 0x4b, 0x66, 0x2b, 0x94, 0x98, 0x35, 0x5b, 0xae, 0x43, 0xf5, 0xb7,
	0x41, 0x31, 0xd5, 0xb3, 0xa2, 0xd5, 0x2b, 0xfa, 0x16, 0x19, 0x74, 0xb4, 0x78, 0xe3, 0xf4, 0xac,
	0xbc, 0x98, 0xe8, 0x5b, 0x31, 0x9d, 0x0e, 0x26, 0x49, 0x1e, 0x5f, 0x81, 0x5f, 0x01, 0xb0, 0x78,
	0x59, 0x7d, 0x88, 0x4c, 0xad, 0xa5, 0xd7, 0x5b, 0x35, 0x62, 0x47, 0x46, 0xfb, 0x9d, 0xc4, 0x32,
	0xd0, 0xa9, 0x49, 0xc5, 0x29, 0x79, 0x09, 0x34, 0x70, 0x33, 0xd6, 0x53, 0xab, 0x54, 0x1a, 0x3b,
	0xf5, 0xb6, 0x81, 0xf4, 0x4a, 0x63, 0x57, 0x47, 0xf7, 0x95, 0x1c, 0x5b, 0x45, 0xa9, 0x3b, 0x3f,
	0xc3, 0x21, 0xfe, 0xa8, 0x91, 0x78, 0x8b, 0x98, 0x88, 0x4d, 0xfd, 0xbe, 0x81, 0x1a, 0x6d, 0xad,
	0x5d, 0x6b, 0xd4, 0x43, 0xa3, 0x96, 0xba, 0x6f, 0x8a, 0x97, 0x87, 0xa9, 0xd1, 0xb7, 0x34, 0xb4,
	0xae, 0x1b, 0xf7, 0x6a, 0xed, 0x8d, 0x2a, 0xd2, 0xee, 0x69, 0x5b, 0xca, 0x70, 0x6a, 0xf4, 0x2d,
	0xd3, 0xdb, 0xc7, 0xf7, 0xec, 0xe0, 0xc0, 0xf2, 0xcc, 0x87, 0x66, 0x57, 0xdd, 0x04, 0x30, 0x26,
	0xa2, 0x89, 0x1a, 0xbb, 0xb5, 0xaa, 0x8e, 0x0c, 0xa4, 0xaf, 0xd7, 0x5a, 0x6d, 0xc4, 0xa6, 0x31,
	0x52, 0x7c, 0xf9, 0xf4, 0xac, 0x5c, 0x92, 0xe4, 0x34, 0x3d, 0xf7, 0xd8, 0xb6, 0xb0, 0x87, 0xf0,
	0xbe, 0xed, 0x07, 0x51, 0x1d, 0xe6, 0xe5, 0x98, 0xb0, 0x5d, 0x6d, 0xab, 0x56, 0xd5, 0x88, 0x33,
	0x8a, 0x49, 0x1b, 0x2d, 0x7e, 0xe1, 0xf4, 0xac, 0x5c, 0x96, 0xa4, 0xed, 0x9a, 0x5d, 0xdb, 0x32,
	0x69, 0x12, 0x2a, 0x89, 0x7b, 0x2b, 0xf1, 0x79, 0xc4, 0x85, 0x11, 0x99, 0x3b, 0xba, 0xd1, 0x40,
	0x55, 0x1d, 0x29, 0x63, 0xcc, 0x1b, 0x4a, 0x82, 0x88, 0x1b, 0xdb, 0x35, 0xbb, 0x7d, 0xdc, 0xf0,
	0x2c, 0xec, 0x11, 0x77, 0x1a, 0x93, 0x80, 0x1a, 0x5b, 0xba, 0xa1, 0xb5, 0x5a, 0xb5, 0xf5, 0x3a,
	0xd9, 0xcb, 0xca, 0x78, 0x4a, 0x00, 0x72, 0xbb, 0x58, 0xf3, 0x7d, 0x7b, 0xdf, 0xa1, 0x7f, 0xb5,
	0xb2, 0x0e, 0xca, 0x31, 0x01, 0xeb, 0x64, 0x55, 0xeb, 0xc4, 0xf6, 0x88, 0xa6, 0x9a, 0x8d, 0x96,
	0xb6, 0xa5, 0x4c, 0x14, 0x5f, 0x3a, 0x3d, 0x2b, 0xdf, 0x94, 0x84, 0xac, 0x93, 0x95, 0x75, 0x88,
	0x05, 0x36, 0x3d, 0xf7, 0xc8, 0xf5, 0xcd, 0xae, 0xba, 0x01, 0x5e, 0x4a, 0xe8, 0xb9, 0xb6, 0xad,
	0xa1, 0xfb, 0x2c, 0xa2, 0x1a, 0x95, 0x0d, 0xad, 0xbe, 0xae, 0x2b, 0xf9, 0x94, 0xa4, 0xa6, 0x67,
	0xf7, 0x4c, 0xef, 0x84, 0x06, 0xd8, 0xca, 0x81, 0xe9, 0xec, 0x63, 0x75, 0x2d, 0x31, 0xa5, 0xe6,
	0x46, 0xa3, 0xae, 0x1b, 0xf5, 0x9d, 0xed, 0x55, 0x1d, 0x85, 0x82, 0x40, 0xb1, 0x7c, 0x7a, 0x56,
	0xbe, 0x21, 0x0b, 0x3a, 0x70, 0x1d, 0xcc, 0xfe, 0xba, 0x8b, 0xcb, 0xa9, 0x82, 0x52, 0x4c, 0x4e,
	0xfb, 0x5e, 0xc3, 0xe0, 0xa1, 0xa3, 0x5a, 0x6b, 0x69, 0xab, 0x5b, 0xba, 0x32, 0xc9, 0xbc, 0xb9,
	0x24, 0xa6, 0xfd, 0xd0, 0x65, 0xa1, 0xa1, 0x6a, 0xfb, 0x24, 0xd9, 0xb9, 0x74, 0x03, 0x54, 0xf5,
	0x2d, 0x9d, 0x2e, 0xf6, 0xd4, 0x65, 0x1b, 0xa0, 0x8a, 0xbb, 0x98, 0x2e, 0x73, 0x72, 0x91, 0x24,
	0x1d, 0xef, 0x36, 0xda, 0xba, 0x32, 0x9d, 0x5a, 0x24, 0xa1, 0xdf, 0x5d, 0x37, 0xc0, 0xea, 0xdb,
	0x09, 0x1b, 0x5e, 0xab, 0xa1, 0x56, 0xdb, 0x68, 0xac, 0xad, 0xe9, 0xa8, 0x56, 0x5f, 0x37, 0x2a,
	0x48, 0xd7, 0xda, 0xba, 0x52, 0x60, 0xb1, 0x5b, 0x12, 0xb3, 0x66, 0x7b, 0x7e, 0xd0, 0xd8, 0xdb,
	0xc3, 0x24, 0xfd, 0xab, 0xd0, 0xeb, 0x14, 0x75, 0x1b, 0x7c, 0x21, 0xae, 0x15, 0xa4, 0xd5, 0x5b,
	0x6b, 0x3a, 0x32, 0xda, 0x0d, 0xa3, 0xae, 0xdf, 0x33, 0xb4, 0x6a, 0x15, 0xe9, 0xad, 0x96, 0x32,
	0x93, 0xda, 0x11, 0xd4, 0xa9, 0xec, 0x61, 0xaf, 0xed, 0xd6, 0xf1, 0xc3, 0x30, 0x87, 0xac, 0x80,
	0xe5, 0x98, 0x38, 0x16, 0xc6, 0xe5, 0x2d, 0xaa, 0xa4, 0x74, 0xcc, 0x22, 0xb9, 0xb4, 0x47, 0x93,
	0x2b, 0xa5, 0x35, 0x6b, 0xd4, 0x4b, 0xac, 0xeb, 0x75, 0x9d, 0x6f, 0xa9, 0xd9, 0x94, 0x14, 0xad,
	0x59, 0xdb, 0xc4, 0x27, 0xeb, 0xd8, 0xc1, 0x7c, 0x37, 0x25, 0x77, 0xfa, 0x3d, 0x7d, 0x75, 0xa3,
	0xd1, 0xd8, 0x34, 0x2a, 0x8d, 0xfa, 0x5a, 0x6d, 0x7d, 0x87, 0x0b, 0x52, 0x53, 0xdf, 0x75, 0x0f,
	0x3f, 0x38, 0x70, 0xdd, 0x43, 0x56, 0x92, 0xe7, 0x65, 0x2f, 0xee, 0x54, 0xff, 0x60, 0x08, 0xcc,
	0x24, 0xfe, 0x8c, 0x9c, 0x18, 0x84, 0x9c, 0x92, 0x65, 0x65, 0xbb, 0xd4, 0x20, 0x12, 0xfd, 0x64,
	0xa7, 0xfa, 0x1a, 0x58, 0x48, 0x8b, 0x78, 0xe7, 0xeb, 0xff, 0xff, 0x75, 0x25, 0x57, 0xbc, 0x76,
	0x7a, 0x56, 0x9e, 0x4b, 0xf4, 0x25, 0x24, 0xf5, 0x0d, 0x70, 0x23, 0xdd, 0xa9, 0xb5, 0xad, 0xa1,
	0xb6, 0x51, 0xd1, 0x10, 0x89, 0x6a, 0x34, 0x4c, 0x24, 0xba, 0x46, 0x7f, 0x59, 0xa9, 0xbe, 0x0a,
	0xae, 0xa6, 0xfb, 0x37, 0x6b, 0xbb, 0xca, 0x70, 0x71, 0xe1, 0xf4, 0xac, 0xac, 0x26, 0x3a, 0x36,
	0x6b, 0xbb, 0x5c, 0x09, 0x7f, 0x32, 0x04, 0x94, 0xe4, 0x5f, 0xa5, 0x92, 0x00, 0x4b, 0x92, 0x8b,
	0x0a, 0x55, 0xaa, 0x88, 0xee, 0x9b, 0xf5, 0xc6, 0xbd, 0xba, 0x72, 0x85, 0x05, 0xd8, 0x64, 0xa7,
	0x1d, 0xe7, 0xd0, 0x71, 0x1f, 0x3a, 0xea, 0x6f, 0x81, 0x85, 0x74, 0xdf, 0xf5, 0x46, 0xa3, 0xaa,
	0xe4, 0x8a, 0x8b, 0xa7, 0x67, 0xe5, 0xf9, 0x64, 0xc7, 0x75, 0xd7, 0xb5, 0xb2, 0x47, 0x0c, 0x13,
	0x9c, 0xa1, 0xec, 0x11, 0xc3, 0x04, 0xa7, 0x02, 0x96, 0xd3, 0x7d, 0x2b, 0x1b, 0x7a, 0x65, 0x53,
	0x44, 0x76, 0x6a, 0x5f, 0x49, 0x01, 0xf4, 0x6f, 0x78, 0x59, 0x7c, 0x67, 0xda, 0x58, 0xdd, 0xfe,
	0xe5, 0xc7, 0xcb, 0xb9, 0x8f, 0x3e, 0x5e, 0xce, 0xfd, 0xfa, 0xe3, 0xe5, 0xdc, 0x8f, 0x3e, 0x59,
	0xbe, 0xf2, 0xd1, 0x27, 0xcb, 0x57, 0xfe, 0xe9, 0x93, 0xe5, 0x2b, 0xef, 0xbe, 0xb6, 0x6f, 0x07,
	0x07, 0xfd, 0x07, 0xb7, 0x3b, 0x6e, 0x6f, 0x45, 0x2a, 0xd3, 0x48, 0x3f, 0x7d, 0xeb, 0x70, 0x65,
	0xdf, 0x5d, 0x71, 0x5c, 0x2b, 0xfc, 0xbf, 0x96, 0x1e, 0x8c, 0xd1, 0xff, 0x0f, 0xe9, 0xb5, 0xff,
	0x0d, 0x00, 0x00, 0xff, 0xff, 0x2a, 0x46, 0x6f, 0x89, 0x87, 0x49, 0x00, 0x00,
}

func (this *MFAProof) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MFAProof)
	if !ok {
		that2, ok := that.(MFAProof)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	if len(this.VerifiedFactors) != len(that1.VerifiedFactors) {
		return false
	}
	for i := range this.VerifiedFactors {
		if this.VerifiedFactors[i] != that1.VerifiedFactors[i] {
			return false
		}
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	return true
}
func (this *FactorCombination) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FactorCombination)
	if !ok {
		that2, ok := that.(FactorCombination)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Factors) != len(that1.Factors) {
		return false
	}
	for i := range this.Factors {
		if this.Factors[i] != that1.Factors[i] {
			return false
		}
	}
	if this.MinSecurityLevel != that1.MinSecurityLevel {
		return false
	}
	return true
}
func (this *FactorMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FactorMetadata)
	if !ok {
		that2, ok := that.(FactorMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.VeidThreshold != that1.VeidThreshold {
		return false
	}
	if !this.DeviceInfo.Equal(that1.DeviceInfo) {
		return false
	}
	if !this.Fido2Info.Equal(that1.Fido2Info) {
		return false
	}
	if this.ContactHash != that1.ContactHash {
		return false
	}
	if !this.HardwareKeyInfo.Equal(that1.HardwareKeyInfo) {
		return false
	}
	return true
}
func (this *DeviceInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DeviceInfo)
	if !ok {
		that2, ok := that.(DeviceInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Fingerprint != that1.Fingerprint {
		return false
	}
	if this.UserAgent != that1.UserAgent {
		return false
	}
	if this.FirstSeenAt != that1.FirstSeenAt {
		return false
	}
	if this.LastSeenAt != that1.LastSeenAt {
		return false
	}
	if this.IpHash != that1.IpHash {
		return false
	}
	if this.TrustExpiresAt != that1.TrustExpiresAt {
		return false
	}
	return true
}
func (this *FIDO2CredentialInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FIDO2CredentialInfo)
	if !ok {
		that2, ok := that.(FIDO2CredentialInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.CredentialId, that1.CredentialId) {
		return false
	}
	if !bytes.Equal(this.PublicKey, that1.PublicKey) {
		return false
	}
	if !bytes.Equal(this.Aaguid, that1.Aaguid) {
		return false
	}
	if this.SignCount != that1.SignCount {
		return false
	}
	if this.AttestationType != that1.AttestationType {
		return false
	}
	return true
}
func (this *HardwareKeyEnrollment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HardwareKeyEnrollment)
	if !ok {
		that2, ok := that.(HardwareKeyEnrollment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.KeyType != that1.KeyType {
		return false
	}
	if this.KeyId != that1.KeyId {
		return false
	}
	if this.SubjectDn != that1.SubjectDn {
		return false
	}
	if this.IssuerDn != that1.IssuerDn {
		return false
	}
	if this.SerialNumber != that1.SerialNumber {
		return false
	}
	if this.PublicKeyFingerprint != that1.PublicKeyFingerprint {
		return false
	}
	if this.NotBefore != that1.NotBefore {
		return false
	}
	if this.NotAfter != that1.NotAfter {
		return false
	}
	if len(this.KeyUsage) != len(that1.KeyUsage) {
		return false
	}
	for i := range this.KeyUsage {
		if this.KeyUsage[i] != that1.KeyUsage[i] {
			return false
		}
	}
	if len(this.ExtendedKeyUsage) != len(that1.ExtendedKeyUsage) {
		return false
	}
	for i := range this.ExtendedKeyUsage {
		if this.ExtendedKeyUsage[i] != that1.ExtendedKeyUsage[i] {
			return false
		}
	}
	if !this.SmartCardInfo.Equal(that1.SmartCardInfo) {
		return false
	}
	if this.RevocationCheckEnabled != that1.RevocationCheckEnabled {
		return false
	}
	if this.LastRevocationCheck != that1.LastRevocationCheck {
		return false
	}
	if this.RevocationStatus != that1.RevocationStatus {
		return false
	}
	if len(this.TrustedCaCertFingerprints) != len(that1.TrustedCaCertFingerprints) {
		return false
	}
	for i := range this.TrustedCaCertFingerprints {
		if this.TrustedCaCertFingerprints[i] != that1.TrustedCaCertFingerprints[i] {
			return false
		}
	}
	return true
}
func (this *SmartCardInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SmartCardInfo)
	if !ok {
		that2, ok := that.(SmartCardInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CardSerialNumber != that1.CardSerialNumber {
		return false
	}
	if this.CardType != that1.CardType {
		return false
	}
	if this.SlotId != that1.SlotId {
		return false
	}
	if this.Chuid != that1.Chuid {
		return false
	}
	if this.Fascn != that1.Fascn {
		return false
	}
	if this.CardHolderName != that1.CardHolderName {
		return false
	}
	if this.ExpirationDate != that1.ExpirationDate {
		return false
	}
	if this.LastPinVerification != that1.LastPinVerification {
		return false
	}
	return true
}
func (this *FactorEnrollment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FactorEnrollment)
	if !ok {
		that2, ok := that.(FactorEnrollment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if this.FactorId != that1.FactorId {
		return false
	}
	if !bytes.Equal(this.PublicIdentifier, that1.PublicIdentifier) {
		return false
	}
	if this.Label != that1.Label {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.EnrolledAt != that1.EnrolledAt {
		return false
	}
	if this.VerifiedAt != that1.VerifiedAt {
		return false
	}
	if this.RevokedAt != that1.RevokedAt {
		return false
	}
	if this.LastUsedAt != that1.LastUsedAt {
		return false
	}
	if this.UseCount != that1.UseCount {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *TrustedDevicePolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrustedDevicePolicy)
	if !ok {
		that2, ok := that.(TrustedDevicePolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.TrustDuration != that1.TrustDuration {
		return false
	}
	if !this.ReducedFactors.Equal(that1.ReducedFactors) {
		return false
	}
	if this.MaxTrustedDevices != that1.MaxTrustedDevices {
		return false
	}
	if this.RequireReauthForSensitive != that1.RequireReauthForSensitive {
		return false
	}
	return true
}
func (this *MFAPolicy) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MFAPolicy)
	if !ok {
		that2, ok := that.(MFAPolicy)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if len(this.RequiredFactors) != len(that1.RequiredFactors) {
		return false
	}
	for i := range this.RequiredFactors {
		if !this.RequiredFactors[i].Equal(&that1.RequiredFactors[i]) {
			return false
		}
	}
	if !this.TrustedDeviceRule.Equal(that1.TrustedDeviceRule) {
		return false
	}
	if len(this.RecoveryFactors) != len(that1.RecoveryFactors) {
		return false
	}
	for i := range this.RecoveryFactors {
		if !this.RecoveryFactors[i].Equal(&that1.RecoveryFactors[i]) {
			return false
		}
	}
	if len(this.KeyRotationFactors) != len(that1.KeyRotationFactors) {
		return false
	}
	for i := range this.KeyRotationFactors {
		if !this.KeyRotationFactors[i].Equal(&that1.KeyRotationFactors[i]) {
			return false
		}
	}
	if this.SessionDuration != that1.SessionDuration {
		return false
	}
	if this.VeidThreshold != that1.VeidThreshold {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.UpdatedAt != that1.UpdatedAt {
		return false
	}
	return true
}
func (this *ClientInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ClientInfo)
	if !ok {
		that2, ok := that.(ClientInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeviceFingerprint != that1.DeviceFingerprint {
		return false
	}
	if this.IpHash != that1.IpHash {
		return false
	}
	if this.UserAgent != that1.UserAgent {
		return false
	}
	if this.RequestedAt != that1.RequestedAt {
		return false
	}
	return true
}
func (this *ChallengeMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeMetadata)
	if !ok {
		that2, ok := that.(ChallengeMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Fido2Challenge.Equal(that1.Fido2Challenge) {
		return false
	}
	if !this.OtpInfo.Equal(that1.OtpInfo) {
		return false
	}
	if !this.ClientInfo.Equal(that1.ClientInfo) {
		return false
	}
	if !this.HardwareKeyChallenge.Equal(that1.HardwareKeyChallenge) {
		return false
	}
	return true
}
func (this *FIDO2ChallengeData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FIDO2ChallengeData)
	if !ok {
		that2, ok := that.(FIDO2ChallengeData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Challenge, that1.Challenge) {
		return false
	}
	if this.RelyingPartyId != that1.RelyingPartyId {
		return false
	}
	if len(this.AllowedCredentials) != len(that1.AllowedCredentials) {
		return false
	}
	for i := range this.AllowedCredentials {
		if !bytes.Equal(this.AllowedCredentials[i], that1.AllowedCredentials[i]) {
			return false
		}
	}
	if this.UserVerification != that1.UserVerification {
		return false
	}
	return true
}
func (this *OTPChallengeInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OTPChallengeInfo)
	if !ok {
		that2, ok := that.(OTPChallengeInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DeliveryMethod != that1.DeliveryMethod {
		return false
	}
	if this.DeliveryDestinationMasked != that1.DeliveryDestinationMasked {
		return false
	}
	if this.SentAt != that1.SentAt {
		return false
	}
	if this.ResendCount != that1.ResendCount {
		return false
	}
	if this.LastResendAt != that1.LastResendAt {
		return false
	}
	return true
}
func (this *HardwareKeyChallenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HardwareKeyChallenge)
	if !ok {
		that2, ok := that.(HardwareKeyChallenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Challenge, that1.Challenge) {
		return false
	}
	if this.KeyId != that1.KeyId {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	return true
}
func (this *Challenge) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Challenge)
	if !ok {
		that2, ok := that.(Challenge)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChallengeId != that1.ChallengeId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if this.FactorId != that1.FactorId {
		return false
	}
	if this.TransactionType != that1.TransactionType {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !bytes.Equal(this.ChallengeData, that1.ChallengeData) {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	if this.VerifiedAt != that1.VerifiedAt {
		return false
	}
	if this.AttemptCount != that1.AttemptCount {
		return false
	}
	if this.MaxAttempts != that1.MaxAttempts {
		return false
	}
	if this.Nonce != that1.Nonce {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	if !this.Metadata.Equal(that1.Metadata) {
		return false
	}
	return true
}
func (this *ChallengeResponse) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChallengeResponse)
	if !ok {
		that2, ok := that.(ChallengeResponse)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ChallengeId != that1.ChallengeId {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if !bytes.Equal(this.ResponseData, that1.ResponseData) {
		return false
	}
	if !this.ClientInfo.Equal(that1.ClientInfo) {
		return false
	}
	if this.Timestamp != that1.Timestamp {
		return false
	}
	return true
}
func (this *AuthorizationSession) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuthorizationSession)
	if !ok {
		that2, ok := that.(AuthorizationSession)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SessionId != that1.SessionId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.TransactionType != that1.TransactionType {
		return false
	}
	if len(this.VerifiedFactors) != len(that1.VerifiedFactors) {
		return false
	}
	for i := range this.VerifiedFactors {
		if this.VerifiedFactors[i] != that1.VerifiedFactors[i] {
			return false
		}
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	if this.UsedAt != that1.UsedAt {
		return false
	}
	if this.IsSingleUse != that1.IsSingleUse {
		return false
	}
	if this.DeviceFingerprint != that1.DeviceFingerprint {
		return false
	}
	return true
}
func (this *TrustedDevice) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TrustedDevice)
	if !ok {
		that2, ok := that.(TrustedDevice)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if !this.DeviceInfo.Equal(&that1.DeviceInfo) {
		return false
	}
	if this.AddedAt != that1.AddedAt {
		return false
	}
	if this.LastUsedAt != that1.LastUsedAt {
		return false
	}
	return true
}
func (this *SensitiveTxConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SensitiveTxConfig)
	if !ok {
		that2, ok := that.(SensitiveTxConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TransactionType != that1.TransactionType {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.MinVeidScore != that1.MinVeidScore {
		return false
	}
	if len(this.RequiredFactorCombinations) != len(that1.RequiredFactorCombinations) {
		return false
	}
	for i := range this.RequiredFactorCombinations {
		if !this.RequiredFactorCombinations[i].Equal(&that1.RequiredFactorCombinations[i]) {
			return false
		}
	}
	if this.SessionDuration != that1.SessionDuration {
		return false
	}
	if this.IsSingleUse != that1.IsSingleUse {
		return false
	}
	if this.AllowTrustedDeviceReduction != that1.AllowTrustedDeviceReduction {
		return false
	}
	if this.ValueThreshold != that1.ValueThreshold {
		return false
	}
	if this.CooldownPeriod != that1.CooldownPeriod {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.DefaultSessionDuration != that1.DefaultSessionDuration {
		return false
	}
	if this.MaxFactorsPerAccount != that1.MaxFactorsPerAccount {
		return false
	}
	if this.MaxChallengeAttempts != that1.MaxChallengeAttempts {
		return false
	}
	if this.ChallengeTtl != that1.ChallengeTtl {
		return false
	}
	if this.MaxTrustedDevices != that1.MaxTrustedDevices {
		return false
	}
	if this.TrustedDeviceTtl != that1.TrustedDeviceTtl {
		return false
	}
	if this.MinVeidScoreForMfa != that1.MinVeidScoreForMfa {
		return false
	}
	if this.RequireAtLeastOneFactor != that1.RequireAtLeastOneFactor {
		return false
	}
	if len(this.AllowedFactorTypes) != len(that1.AllowedFactorTypes) {
		return false
	}
	for i := range this.AllowedFactorTypes {
		if this.AllowedFactorTypes[i] != that1.AllowedFactorTypes[i] {
			return false
		}
	}
	return true
}
func (this *EventFactorEnrolled) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventFactorEnrolled)
	if !ok {
		that2, ok := that.(EventFactorEnrolled)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if this.FactorId != that1.FactorId {
		return false
	}
	return true
}
func (this *EventFactorRevoked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventFactorRevoked)
	if !ok {
		that2, ok := that.(EventFactorRevoked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if this.FactorId != that1.FactorId {
		return false
	}
	return true
}
func (this *EventChallengeVerified) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventChallengeVerified)
	if !ok {
		that2, ok := that.(EventChallengeVerified)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.ChallengeId != that1.ChallengeId {
		return false
	}
	if this.FactorType != that1.FactorType {
		return false
	}
	if this.TransactionType != that1.TransactionType {
		return false
	}
	return true
}
func (this *EventMFAPolicyUpdated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventMFAPolicyUpdated)
	if !ok {
		that2, ok := that.(EventMFAPolicyUpdated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	return true
}
func (m *MFAProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x22
	}
	if m.Timestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x18
	}
	if len(m.VerifiedFactors) > 0 {
		dAtA2 := make([]byte, len(m.VerifiedFactors)*10)
		var j1 int
		for _, num := range m.VerifiedFactors {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintTypes(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FactorCombination) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FactorCombination) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FactorCombination) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinSecurityLevel != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinSecurityLevel))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Factors) > 0 {
		dAtA4 := make([]byte, len(m.Factors)*10)
		var j3 int
		for _, num := range m.Factors {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		i -= j3
		copy(dAtA[i:], dAtA4[:j3])
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FactorMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FactorMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FactorMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HardwareKeyInfo != nil {
		{
			size, err := m.HardwareKeyInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ContactHash) > 0 {
		i -= len(m.ContactHash)
		copy(dAtA[i:], m.ContactHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ContactHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.Fido2Info != nil {
		{
			size, err := m.Fido2Info.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.DeviceInfo != nil {
		{
			size, err := m.DeviceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VeidThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VeidThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DeviceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeviceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeviceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TrustExpiresAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrustExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.IpHash) > 0 {
		i -= len(m.IpHash)
		copy(dAtA[i:], m.IpHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpHash)))
		i--
		dAtA[i] = 0x2a
	}
	if m.LastSeenAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastSeenAt))
		i--
		dAtA[i] = 0x20
	}
	if m.FirstSeenAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FirstSeenAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Fingerprint) > 0 {
		i -= len(m.Fingerprint)
		copy(dAtA[i:], m.Fingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Fingerprint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FIDO2CredentialInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FIDO2CredentialInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FIDO2CredentialInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.SignCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SignCount))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Aaguid) > 0 {
		i -= len(m.Aaguid)
		copy(dAtA[i:], m.Aaguid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Aaguid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CredentialId) > 0 {
		i -= len(m.CredentialId)
		copy(dAtA[i:], m.CredentialId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CredentialId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HardwareKeyEnrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareKeyEnrollment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareKeyEnrollment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TrustedCaCertFingerprints) > 0 {
		for iNdEx := len(m.TrustedCaCertFingerprints) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TrustedCaCertFingerprints[iNdEx])
			copy(dAtA[i:], m.TrustedCaCertFingerprints[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.TrustedCaCertFingerprints[iNdEx])))
			i--
			dAtA[i] = 0x7a
		}
	}
	if m.RevocationStatus != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RevocationStatus))
		i--
		dAtA[i] = 0x70
	}
	if m.LastRevocationCheck != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastRevocationCheck))
		i--
		dAtA[i] = 0x68
	}
	if m.RevocationCheckEnabled {
		i--
		if m.RevocationCheckEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.SmartCardInfo != nil {
		{
			size, err := m.SmartCardInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ExtendedKeyUsage) > 0 {
		for iNdEx := len(m.ExtendedKeyUsage) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ExtendedKeyUsage[iNdEx])
			copy(dAtA[i:], m.ExtendedKeyUsage[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.ExtendedKeyUsage[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.KeyUsage) > 0 {
		for iNdEx := len(m.KeyUsage) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.KeyUsage[iNdEx])
			copy(dAtA[i:], m.KeyUsage[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyUsage[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.NotAfter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NotAfter))
		i--
		dAtA[i] = 0x40
	}
	if m.NotBefore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.NotBefore))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PublicKeyFingerprint) > 0 {
		i -= len(m.PublicKeyFingerprint)
		copy(dAtA[i:], m.PublicKeyFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKeyFingerprint)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SerialNumber) > 0 {
		i -= len(m.SerialNumber)
		copy(dAtA[i:], m.SerialNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SerialNumber)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.IssuerDn) > 0 {
		i -= len(m.IssuerDn)
		copy(dAtA[i:], m.IssuerDn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IssuerDn)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SubjectDn) > 0 {
		i -= len(m.SubjectDn)
		copy(dAtA[i:], m.SubjectDn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SubjectDn)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0x12
	}
	if m.KeyType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SmartCardInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmartCardInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SmartCardInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastPinVerification != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastPinVerification))
		i--
		dAtA[i] = 0x40
	}
	if m.ExpirationDate != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpirationDate))
		i--
		dAtA[i] = 0x38
	}
	if len(m.CardHolderName) > 0 {
		i -= len(m.CardHolderName)
		copy(dAtA[i:], m.CardHolderName)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CardHolderName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Fascn) > 0 {
		i -= len(m.Fascn)
		copy(dAtA[i:], m.Fascn)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Fascn)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Chuid) > 0 {
		i -= len(m.Chuid)
		copy(dAtA[i:], m.Chuid)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Chuid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SlotId) > 0 {
		i -= len(m.SlotId)
		copy(dAtA[i:], m.SlotId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlotId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.CardType) > 0 {
		i -= len(m.CardType)
		copy(dAtA[i:], m.CardType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CardType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CardSerialNumber) > 0 {
		i -= len(m.CardSerialNumber)
		copy(dAtA[i:], m.CardSerialNumber)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.CardSerialNumber)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FactorEnrollment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FactorEnrollment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FactorEnrollment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.UseCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UseCount))
		i--
		dAtA[i] = 0x58
	}
	if m.LastUsedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUsedAt))
		i--
		dAtA[i] = 0x50
	}
	if m.RevokedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RevokedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.EnrolledAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EnrolledAt))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Label) > 0 {
		i -= len(m.Label)
		copy(dAtA[i:], m.Label)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Label)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PublicIdentifier) > 0 {
		i -= len(m.PublicIdentifier)
		copy(dAtA[i:], m.PublicIdentifier)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicIdentifier)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FactorId) > 0 {
		i -= len(m.FactorId)
		copy(dAtA[i:], m.FactorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FactorType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FactorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustedDevicePolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedDevicePolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedDevicePolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireReauthForSensitive {
		i--
		if m.RequireReauthForSensitive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MaxTrustedDevices != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxTrustedDevices))
		i--
		dAtA[i] = 0x20
	}
	if m.ReducedFactors != nil {
		{
			size, err := m.ReducedFactors.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TrustDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrustDuration))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MFAPolicy) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MFAPolicy) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MFAPolicy) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x50
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.VeidThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VeidThreshold))
		i--
		dAtA[i] = 0x38
	}
	if m.SessionDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x30
	}
	if len(m.KeyRotationFactors) > 0 {
		for iNdEx := len(m.KeyRotationFactors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KeyRotationFactors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RecoveryFactors) > 0 {
		for iNdEx := len(m.RecoveryFactors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RecoveryFactors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.TrustedDeviceRule != nil {
		{
			size, err := m.TrustedDeviceRule.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RequiredFactors) > 0 {
		for iNdEx := len(m.RequiredFactors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequiredFactors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClientInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequestedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequestedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserAgent) > 0 {
		i -= len(m.UserAgent)
		copy(dAtA[i:], m.UserAgent)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserAgent)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IpHash) > 0 {
		i -= len(m.IpHash)
		copy(dAtA[i:], m.IpHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.IpHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeviceFingerprint) > 0 {
		i -= len(m.DeviceFingerprint)
		copy(dAtA[i:], m.DeviceFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceFingerprint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HardwareKeyChallenge != nil {
		{
			size, err := m.HardwareKeyChallenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ClientInfo != nil {
		{
			size, err := m.ClientInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.OtpInfo != nil {
		{
			size, err := m.OtpInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Fido2Challenge != nil {
		{
			size, err := m.Fido2Challenge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FIDO2ChallengeData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FIDO2ChallengeData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FIDO2ChallengeData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserVerification) > 0 {
		i -= len(m.UserVerification)
		copy(dAtA[i:], m.UserVerification)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserVerification)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AllowedCredentials) > 0 {
		for iNdEx := len(m.AllowedCredentials) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedCredentials[iNdEx])
			copy(dAtA[i:], m.AllowedCredentials[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.AllowedCredentials[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RelyingPartyId) > 0 {
		i -= len(m.RelyingPartyId)
		copy(dAtA[i:], m.RelyingPartyId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RelyingPartyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OTPChallengeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OTPChallengeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OTPChallengeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastResendAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastResendAt))
		i--
		dAtA[i] = 0x28
	}
	if m.ResendCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ResendCount))
		i--
		dAtA[i] = 0x20
	}
	if m.SentAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SentAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.DeliveryDestinationMasked) > 0 {
		i -= len(m.DeliveryDestinationMasked)
		copy(dAtA[i:], m.DeliveryDestinationMasked)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeliveryDestinationMasked)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DeliveryMethod) > 0 {
		i -= len(m.DeliveryMethod)
		copy(dAtA[i:], m.DeliveryMethod)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeliveryMethod)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HardwareKeyChallenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HardwareKeyChallenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HardwareKeyChallenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.KeyId) > 0 {
		i -= len(m.KeyId)
		copy(dAtA[i:], m.KeyId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.KeyId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Challenge) > 0 {
		i -= len(m.Challenge)
		copy(dAtA[i:], m.Challenge)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Challenge)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Challenge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Challenge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Challenge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x6a
	}
	if m.MaxAttempts != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxAttempts))
		i--
		dAtA[i] = 0x60
	}
	if m.AttemptCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AttemptCount))
		i--
		dAtA[i] = 0x58
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x50
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ChallengeData) > 0 {
		i -= len(m.ChallengeData)
		copy(dAtA[i:], m.ChallengeData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChallengeData)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	if m.TransactionType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TransactionType))
		i--
		dAtA[i] = 0x28
	}
	if len(m.FactorId) > 0 {
		i -= len(m.FactorId)
		copy(dAtA[i:], m.FactorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorId)))
		i--
		dAtA[i] = 0x22
	}
	if m.FactorType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FactorType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChallengeId) > 0 {
		i -= len(m.ChallengeId)
		copy(dAtA[i:], m.ChallengeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChallengeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChallengeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChallengeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChallengeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x28
	}
	if m.ClientInfo != nil {
		{
			size, err := m.ClientInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.ResponseData) > 0 {
		i -= len(m.ResponseData)
		copy(dAtA[i:], m.ResponseData)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResponseData)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FactorType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.FactorType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChallengeId) > 0 {
		i -= len(m.ChallengeId)
		copy(dAtA[i:], m.ChallengeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChallengeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthorizationSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthorizationSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthorizationSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DeviceFingerprint) > 0 {
		i -= len(m.DeviceFingerprint)
		copy(dAtA[i:], m.DeviceFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceFingerprint)))
		i--
		dAtA[i] = 0x4a
	}
	if m.IsSingleUse {
		i--
		if m.IsSingleUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UsedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UsedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.VerifiedFactors) > 0 {
		dAtA19 := make([]byte, len(m.VerifiedFactors)*10)
		var j18 int
		for _, num := range m.VerifiedFactors {
			for num >= 1<<7 {
				dAtA19[j18] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j18++
			}
			dAtA19[j18] = uint8(num)
			j18++
		}
		i -= j18
		copy(dAtA[i:], dAtA19[:j18])
		i = encodeVarintTypes(dAtA, i, uint64(j18))
		i--
		dAtA[i] = 0x22
	}
	if m.TransactionType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TransactionType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessionId) > 0 {
		i -= len(m.SessionId)
		copy(dAtA[i:], m.SessionId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SessionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TrustedDevice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TrustedDevice) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TrustedDevice) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUsedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUsedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.AddedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AddedAt))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.DeviceInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SensitiveTxConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SensitiveTxConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SensitiveTxConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x52
	}
	if m.CooldownPeriod != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CooldownPeriod))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ValueThreshold) > 0 {
		i -= len(m.ValueThreshold)
		copy(dAtA[i:], m.ValueThreshold)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValueThreshold)))
		i--
		dAtA[i] = 0x42
	}
	if m.AllowTrustedDeviceReduction {
		i--
		if m.AllowTrustedDeviceReduction {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IsSingleUse {
		i--
		if m.IsSingleUse {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.SessionDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SessionDuration))
		i--
		dAtA[i] = 0x28
	}
	if len(m.RequiredFactorCombinations) > 0 {
		for iNdEx := len(m.RequiredFactorCombinations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RequiredFactorCombinations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MinVeidScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinVeidScore))
		i--
		dAtA[i] = 0x18
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.TransactionType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TransactionType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AllowedFactorTypes) > 0 {
		dAtA22 := make([]byte, len(m.AllowedFactorTypes)*10)
		var j21 int
		for _, num := range m.AllowedFactorTypes {
			for num >= 1<<7 {
				dAtA22[j21] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j21++
			}
			dAtA22[j21] = uint8(num)
			j21++
		}
		i -= j21
		copy(dAtA[i:], dAtA22[:j21])
		i = encodeVarintTypes(dAtA, i, uint64(j21))
		i--
		dAtA[i] = 0x4a
	}
	if m.RequireAtLeastOneFactor {
		i--
		if m.RequireAtLeastOneFactor {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.MinVeidScoreForMfa != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinVeidScoreForMfa))
		i--
		dAtA[i] = 0x38
	}
	if m.TrustedDeviceTtl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TrustedDeviceTtl))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxTrustedDevices != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxTrustedDevices))
		i--
		dAtA[i] = 0x28
	}
	if m.ChallengeTtl != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ChallengeTtl))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxChallengeAttempts != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxChallengeAttempts))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxFactorsPerAccount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxFactorsPerAccount))
		i--
		dAtA[i] = 0x10
	}
	if m.DefaultSessionDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DefaultSessionDuration))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventFactorEnrolled) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFactorEnrolled) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFactorEnrolled) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FactorId) > 0 {
		i -= len(m.FactorId)
		copy(dAtA[i:], m.FactorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FactorType) > 0 {
		i -= len(m.FactorType)
		copy(dAtA[i:], m.FactorType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventFactorRevoked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventFactorRevoked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventFactorRevoked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FactorId) > 0 {
		i -= len(m.FactorId)
		copy(dAtA[i:], m.FactorId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FactorType) > 0 {
		i -= len(m.FactorType)
		copy(dAtA[i:], m.FactorType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventChallengeVerified) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventChallengeVerified) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventChallengeVerified) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TransactionType) > 0 {
		i -= len(m.TransactionType)
		copy(dAtA[i:], m.TransactionType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TransactionType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FactorType) > 0 {
		i -= len(m.FactorType)
		copy(dAtA[i:], m.FactorType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.FactorType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChallengeId) > 0 {
		i -= len(m.ChallengeId)
		copy(dAtA[i:], m.ChallengeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ChallengeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMFAPolicyUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMFAPolicyUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMFAPolicyUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MFAProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.VerifiedFactors) > 0 {
		l = 0
		for _, e := range m.VerifiedFactors {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.Timestamp != 0 {
		n += 1 + sovTypes(uint64(m.Timestamp))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FactorCombination) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Factors) > 0 {
		l = 0
		for _, e := range m.Factors {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.MinSecurityLevel != 0 {
		n += 1 + sovTypes(uint64(m.MinSecurityLevel))
	}
	return n
}

func (m *FactorMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VeidThreshold != 0 {
		n += 1 + sovTypes(uint64(m.VeidThreshold))
	}
	if m.DeviceInfo != nil {
		l = m.DeviceInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Fido2Info != nil {
		l = m.Fido2Info.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ContactHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HardwareKeyInfo != nil {
		l = m.HardwareKeyInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DeviceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Fingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FirstSeenAt != 0 {
		n += 1 + sovTypes(uint64(m.FirstSeenAt))
	}
	if m.LastSeenAt != 0 {
		n += 1 + sovTypes(uint64(m.LastSeenAt))
	}
	l = len(m.IpHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TrustExpiresAt != 0 {
		n += 1 + sovTypes(uint64(m.TrustExpiresAt))
	}
	return n
}

func (m *FIDO2CredentialInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CredentialId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Aaguid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SignCount != 0 {
		n += 1 + sovTypes(uint64(m.SignCount))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *HardwareKeyEnrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.KeyType != 0 {
		n += 1 + sovTypes(uint64(m.KeyType))
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SubjectDn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IssuerDn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SerialNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.NotBefore != 0 {
		n += 1 + sovTypes(uint64(m.NotBefore))
	}
	if m.NotAfter != 0 {
		n += 1 + sovTypes(uint64(m.NotAfter))
	}
	if len(m.KeyUsage) > 0 {
		for _, s := range m.KeyUsage {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ExtendedKeyUsage) > 0 {
		for _, s := range m.ExtendedKeyUsage {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SmartCardInfo != nil {
		l = m.SmartCardInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RevocationCheckEnabled {
		n += 2
	}
	if m.LastRevocationCheck != 0 {
		n += 1 + sovTypes(uint64(m.LastRevocationCheck))
	}
	if m.RevocationStatus != 0 {
		n += 1 + sovTypes(uint64(m.RevocationStatus))
	}
	if len(m.TrustedCaCertFingerprints) > 0 {
		for _, s := range m.TrustedCaCertFingerprints {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *SmartCardInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CardSerialNumber)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CardType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SlotId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Chuid)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Fascn)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.CardHolderName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpirationDate != 0 {
		n += 1 + sovTypes(uint64(m.ExpirationDate))
	}
	if m.LastPinVerification != 0 {
		n += 1 + sovTypes(uint64(m.LastPinVerification))
	}
	return n
}

func (m *FactorEnrollment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FactorType != 0 {
		n += 1 + sovTypes(uint64(m.FactorType))
	}
	l = len(m.FactorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicIdentifier)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.EnrolledAt != 0 {
		n += 1 + sovTypes(uint64(m.EnrolledAt))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.VerifiedAt))
	}
	if m.RevokedAt != 0 {
		n += 1 + sovTypes(uint64(m.RevokedAt))
	}
	if m.LastUsedAt != 0 {
		n += 1 + sovTypes(uint64(m.LastUsedAt))
	}
	if m.UseCount != 0 {
		n += 1 + sovTypes(uint64(m.UseCount))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TrustedDevicePolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.TrustDuration != 0 {
		n += 1 + sovTypes(uint64(m.TrustDuration))
	}
	if m.ReducedFactors != nil {
		l = m.ReducedFactors.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MaxTrustedDevices != 0 {
		n += 1 + sovTypes(uint64(m.MaxTrustedDevices))
	}
	if m.RequireReauthForSensitive {
		n += 2
	}
	return n
}

func (m *MFAPolicy) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RequiredFactors) > 0 {
		for _, e := range m.RequiredFactors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.TrustedDeviceRule != nil {
		l = m.TrustedDeviceRule.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RecoveryFactors) > 0 {
		for _, e := range m.RecoveryFactors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.KeyRotationFactors) > 0 {
		for _, e := range m.KeyRotationFactors {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SessionDuration != 0 {
		n += 1 + sovTypes(uint64(m.SessionDuration))
	}
	if m.VeidThreshold != 0 {
		n += 1 + sovTypes(uint64(m.VeidThreshold))
	}
	if m.Enabled {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.UpdatedAt))
	}
	return n
}

func (m *ClientInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeviceFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.IpHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserAgent)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequestedAt != 0 {
		n += 1 + sovTypes(uint64(m.RequestedAt))
	}
	return n
}

func (m *ChallengeMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Fido2Challenge != nil {
		l = m.Fido2Challenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OtpInfo != nil {
		l = m.OtpInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientInfo != nil {
		l = m.ClientInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.HardwareKeyChallenge != nil {
		l = m.HardwareKeyChallenge.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *FIDO2ChallengeData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RelyingPartyId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.AllowedCredentials) > 0 {
		for _, b := range m.AllowedCredentials {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.UserVerification)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OTPChallengeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DeliveryMethod)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeliveryDestinationMasked)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.SentAt != 0 {
		n += 1 + sovTypes(uint64(m.SentAt))
	}
	if m.ResendCount != 0 {
		n += 1 + sovTypes(uint64(m.ResendCount))
	}
	if m.LastResendAt != 0 {
		n += 1 + sovTypes(uint64(m.LastResendAt))
	}
	return n
}

func (m *HardwareKeyChallenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Challenge)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.KeyId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	return n
}

func (m *Challenge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChallengeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FactorType != 0 {
		n += 1 + sovTypes(uint64(m.FactorType))
	}
	l = len(m.FactorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TransactionType != 0 {
		n += 1 + sovTypes(uint64(m.TransactionType))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	l = len(m.ChallengeData)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovTypes(uint64(m.ExpiresAt))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.VerifiedAt))
	}
	if m.AttemptCount != 0 {
		n += 1 + sovTypes(uint64(m.AttemptCount))
	}
	if m.MaxAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxAttempts))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ChallengeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChallengeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.FactorType != 0 {
		n += 1 + sovTypes(uint64(m.FactorType))
	}
	l = len(m.ResponseData)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ClientInfo != nil {
		l = m.ClientInfo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTypes(uint64(m.Timestamp))
	}
	return n
}

func (m *AuthorizationSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessionId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.TransactionType != 0 {
		n += 1 + sovTypes(uint64(m.TransactionType))
	}
	if len(m.VerifiedFactors) > 0 {
		l = 0
		for _, e := range m.VerifiedFactors {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovTypes(uint64(m.ExpiresAt))
	}
	if m.UsedAt != 0 {
		n += 1 + sovTypes(uint64(m.UsedAt))
	}
	if m.IsSingleUse {
		n += 2
	}
	l = len(m.DeviceFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *TrustedDevice) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.DeviceInfo.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.AddedAt != 0 {
		n += 1 + sovTypes(uint64(m.AddedAt))
	}
	if m.LastUsedAt != 0 {
		n += 1 + sovTypes(uint64(m.LastUsedAt))
	}
	return n
}

func (m *SensitiveTxConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TransactionType != 0 {
		n += 1 + sovTypes(uint64(m.TransactionType))
	}
	if m.Enabled {
		n += 2
	}
	if m.MinVeidScore != 0 {
		n += 1 + sovTypes(uint64(m.MinVeidScore))
	}
	if len(m.RequiredFactorCombinations) > 0 {
		for _, e := range m.RequiredFactorCombinations {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SessionDuration != 0 {
		n += 1 + sovTypes(uint64(m.SessionDuration))
	}
	if m.IsSingleUse {
		n += 2
	}
	if m.AllowTrustedDeviceReduction {
		n += 2
	}
	l = len(m.ValueThreshold)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CooldownPeriod != 0 {
		n += 1 + sovTypes(uint64(m.CooldownPeriod))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DefaultSessionDuration != 0 {
		n += 1 + sovTypes(uint64(m.DefaultSessionDuration))
	}
	if m.MaxFactorsPerAccount != 0 {
		n += 1 + sovTypes(uint64(m.MaxFactorsPerAccount))
	}
	if m.MaxChallengeAttempts != 0 {
		n += 1 + sovTypes(uint64(m.MaxChallengeAttempts))
	}
	if m.ChallengeTtl != 0 {
		n += 1 + sovTypes(uint64(m.ChallengeTtl))
	}
	if m.MaxTrustedDevices != 0 {
		n += 1 + sovTypes(uint64(m.MaxTrustedDevices))
	}
	if m.TrustedDeviceTtl != 0 {
		n += 1 + sovTypes(uint64(m.TrustedDeviceTtl))
	}
	if m.MinVeidScoreForMfa != 0 {
		n += 1 + sovTypes(uint64(m.MinVeidScoreForMfa))
	}
	if m.RequireAtLeastOneFactor {
		n += 2
	}
	if len(m.AllowedFactorTypes) > 0 {
		l = 0
		for _, e := range m.AllowedFactorTypes {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *EventFactorEnrolled) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FactorType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FactorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventFactorRevoked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FactorType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FactorId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventChallengeVerified) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ChallengeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.FactorType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.TransactionType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventMFAPolicyUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MFAProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v FactorType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FactorType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VerifiedFactors = append(m.VerifiedFactors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.VerifiedFactors) == 0 {
					m.VerifiedFactors = make([]FactorType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FactorType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FactorType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VerifiedFactors = append(m.VerifiedFactors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedFactors", wireType)
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FactorCombination) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FactorCombination: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FactorCombination: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v FactorType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FactorType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Factors = append(m.Factors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Factors) == 0 {
					m.Factors = make([]FactorType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FactorType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FactorType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Factors = append(m.Factors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Factors", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSecurityLevel", wireType)
			}
			m.MinSecurityLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSecurityLevel |= FactorSecurityLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FactorMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FactorMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FactorMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeidThreshold", wireType)
			}
			m.VeidThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VeidThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeviceInfo == nil {
				m.DeviceInfo = &DeviceInfo{}
			}
			if err := m.DeviceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fido2Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fido2Info == nil {
				m.Fido2Info = &FIDO2CredentialInfo{}
			}
			if err := m.Fido2Info.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContactHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContactHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareKeyInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HardwareKeyInfo == nil {
				m.HardwareKeyInfo = &HardwareKeyEnrollment{}
			}
			if err := m.HardwareKeyInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeviceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeviceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeviceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstSeenAt", wireType)
			}
			m.FirstSeenAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstSeenAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeenAt", wireType)
			}
			m.LastSeenAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSeenAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustExpiresAt", wireType)
			}
			m.TrustExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FIDO2CredentialInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FIDO2CredentialInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FIDO2CredentialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CredentialId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CredentialId = append(m.CredentialId[:0], dAtA[iNdEx:postIndex]...)
			if m.CredentialId == nil {
				m.CredentialId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Aaguid", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Aaguid = append(m.Aaguid[:0], dAtA[iNdEx:postIndex]...)
			if m.Aaguid == nil {
				m.Aaguid = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignCount", wireType)
			}
			m.SignCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareKeyEnrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareKeyEnrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareKeyEnrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= HardwareKeyType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubjectDn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubjectDn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IssuerDn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IssuerDn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotBefore", wireType)
			}
			m.NotBefore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotBefore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NotAfter", wireType)
			}
			m.NotAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NotAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyUsage = append(m.KeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtendedKeyUsage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExtendedKeyUsage = append(m.ExtendedKeyUsage, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmartCardInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmartCardInfo == nil {
				m.SmartCardInfo = &SmartCardInfo{}
			}
			if err := m.SmartCardInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevocationCheckEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RevocationCheckEnabled = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastRevocationCheck", wireType)
			}
			m.LastRevocationCheck = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastRevocationCheck |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevocationStatus", wireType)
			}
			m.RevocationStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevocationStatus |= RevocationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedCaCertFingerprints", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustedCaCertFingerprints = append(m.TrustedCaCertFingerprints, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmartCardInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmartCardInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmartCardInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardSerialNumber", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardSerialNumber = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlotId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlotId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fascn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fascn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CardHolderName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CardHolderName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpirationDate", wireType)
			}
			m.ExpirationDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpirationDate |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastPinVerification", wireType)
			}
			m.LastPinVerification = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastPinVerification |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FactorEnrollment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FactorEnrollment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FactorEnrollment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			m.FactorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FactorType |= FactorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicIdentifier", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicIdentifier = append(m.PublicIdentifier[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicIdentifier == nil {
				m.PublicIdentifier = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= FactorEnrollmentStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnrolledAt", wireType)
			}
			m.EnrolledAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EnrolledAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedAt", wireType)
			}
			m.RevokedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RevokedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUsedAt", wireType)
			}
			m.LastUsedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUsedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UseCount", wireType)
			}
			m.UseCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UseCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &FactorMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedDevicePolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedDevicePolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedDevicePolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustDuration", wireType)
			}
			m.TrustDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReducedFactors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReducedFactors == nil {
				m.ReducedFactors = &FactorCombination{}
			}
			if err := m.ReducedFactors.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrustedDevices", wireType)
			}
			m.MaxTrustedDevices = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrustedDevices |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireReauthForSensitive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireReauthForSensitive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MFAPolicy) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MFAPolicy: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MFAPolicy: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredFactors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredFactors = append(m.RequiredFactors, FactorCombination{})
			if err := m.RequiredFactors[len(m.RequiredFactors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedDeviceRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TrustedDeviceRule == nil {
				m.TrustedDeviceRule = &TrustedDevicePolicy{}
			}
			if err := m.TrustedDeviceRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecoveryFactors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecoveryFactors = append(m.RecoveryFactors, FactorCombination{})
			if err := m.RecoveryFactors[len(m.RecoveryFactors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyRotationFactors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyRotationFactors = append(m.KeyRotationFactors, FactorCombination{})
			if err := m.KeyRotationFactors[len(m.KeyRotationFactors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeidThreshold", wireType)
			}
			m.VeidThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VeidThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserAgent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserAgent = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAt", wireType)
			}
			m.RequestedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fido2Challenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fido2Challenge == nil {
				m.Fido2Challenge = &FIDO2ChallengeData{}
			}
			if err := m.Fido2Challenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OtpInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OtpInfo == nil {
				m.OtpInfo = &OTPChallengeInfo{}
			}
			if err := m.OtpInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientInfo == nil {
				m.ClientInfo = &ClientInfo{}
			}
			if err := m.ClientInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardwareKeyChallenge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HardwareKeyChallenge == nil {
				m.HardwareKeyChallenge = &HardwareKeyChallenge{}
			}
			if err := m.HardwareKeyChallenge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FIDO2ChallengeData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FIDO2ChallengeData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FIDO2ChallengeData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelyingPartyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelyingPartyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedCredentials", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedCredentials = append(m.AllowedCredentials, make([]byte, postIndex-iNdEx))
			copy(m.AllowedCredentials[len(m.AllowedCredentials)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserVerification", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserVerification = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OTPChallengeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OTPChallengeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OTPChallengeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliveryMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeliveryDestinationMasked", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeliveryDestinationMasked = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SentAt", wireType)
			}
			m.SentAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SentAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResendCount", wireType)
			}
			m.ResendCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResendCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResendAt", wireType)
			}
			m.LastResendAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastResendAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HardwareKeyChallenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HardwareKeyChallenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HardwareKeyChallenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Challenge", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Challenge = append(m.Challenge[:0], dAtA[iNdEx:postIndex]...)
			if m.Challenge == nil {
				m.Challenge = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Challenge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Challenge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Challenge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			m.FactorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FactorType |= FactorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionType", wireType)
			}
			m.TransactionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionType |= SensitiveTransactionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ChallengeStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeData = append(m.ChallengeData[:0], dAtA[iNdEx:postIndex]...)
			if m.ChallengeData == nil {
				m.ChallengeData = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttemptCount", wireType)
			}
			m.AttemptCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttemptCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAttempts", wireType)
			}
			m.MaxAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &ChallengeMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChallengeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChallengeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChallengeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			m.FactorType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FactorType |= FactorType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseData", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResponseData = append(m.ResponseData[:0], dAtA[iNdEx:postIndex]...)
			if m.ResponseData == nil {
				m.ResponseData = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClientInfo == nil {
				m.ClientInfo = &ClientInfo{}
			}
			if err := m.ClientInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthorizationSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthorizationSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthorizationSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionType", wireType)
			}
			m.TransactionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionType |= SensitiveTransactionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType == 0 {
				var v FactorType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FactorType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.VerifiedFactors = append(m.VerifiedFactors, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.VerifiedFactors) == 0 {
					m.VerifiedFactors = make([]FactorType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FactorType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FactorType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.VerifiedFactors = append(m.VerifiedFactors, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedFactors", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedAt", wireType)
			}
			m.UsedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSingleUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSingleUse = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TrustedDevice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TrustedDevice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TrustedDevice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeviceInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			m.AddedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUsedAt", wireType)
			}
			m.LastUsedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUsedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SensitiveTxConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SensitiveTxConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SensitiveTxConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionType", wireType)
			}
			m.TransactionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TransactionType |= SensitiveTransactionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVeidScore", wireType)
			}
			m.MinVeidScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVeidScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredFactorCombinations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredFactorCombinations = append(m.RequiredFactorCombinations, FactorCombination{})
			if err := m.RequiredFactorCombinations[len(m.RequiredFactorCombinations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionDuration", wireType)
			}
			m.SessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSingleUse", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSingleUse = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowTrustedDeviceReduction", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowTrustedDeviceReduction = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValueThreshold", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValueThreshold = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CooldownPeriod", wireType)
			}
			m.CooldownPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CooldownPeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefaultSessionDuration", wireType)
			}
			m.DefaultSessionDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DefaultSessionDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFactorsPerAccount", wireType)
			}
			m.MaxFactorsPerAccount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFactorsPerAccount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxChallengeAttempts", wireType)
			}
			m.MaxChallengeAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxChallengeAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeTtl", wireType)
			}
			m.ChallengeTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChallengeTtl |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTrustedDevices", wireType)
			}
			m.MaxTrustedDevices = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTrustedDevices |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustedDeviceTtl", wireType)
			}
			m.TrustedDeviceTtl = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrustedDeviceTtl |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinVeidScoreForMfa", wireType)
			}
			m.MinVeidScoreForMfa = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinVeidScoreForMfa |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireAtLeastOneFactor", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireAtLeastOneFactor = bool(v != 0)
		case 9:
			if wireType == 0 {
				var v FactorType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= FactorType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AllowedFactorTypes = append(m.AllowedFactorTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthTypes
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.AllowedFactorTypes) == 0 {
					m.AllowedFactorTypes = make([]FactorType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v FactorType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= FactorType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AllowedFactorTypes = append(m.AllowedFactorTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedFactorTypes", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFactorEnrolled) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFactorEnrolled: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFactorEnrolled: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventFactorRevoked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventFactorRevoked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventFactorRevoked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventChallengeVerified) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventChallengeVerified: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventChallengeVerified: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChallengeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChallengeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactorType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactorType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransactionType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TransactionType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMFAPolicyUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMFAPolicyUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMFAPolicyUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)

