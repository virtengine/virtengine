// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/staking/v1/params.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Params defines the parameters for the staking module
type Params struct {
	// EpochLength is the number of blocks per reward epoch
	EpochLength uint64 `protobuf:"varint,1,opt,name=epoch_length,json=epochLength,proto3" json:"epoch_length"`
	// BaseRewardPerBlock is the base reward per block in smallest unit
	BaseRewardPerBlock int64 `protobuf:"varint,2,opt,name=base_reward_per_block,json=baseRewardPerBlock,proto3" json:"base_reward_per_block"`
	// VEIDRewardPool is the VEID verification reward pool per epoch
	VeidRewardPool int64 `protobuf:"varint,3,opt,name=veid_reward_pool,json=veidRewardPool,proto3" json:"veid_reward_pool"`
	// IdentityNetworkRewardPool is the identity network reward pool per epoch
	IdentityNetworkRewardPool int64 `protobuf:"varint,4,opt,name=identity_network_reward_pool,json=identityNetworkRewardPool,proto3" json:"identity_network_reward_pool"`
	// DowntimeThreshold is the consecutive missed blocks before slashing
	DowntimeThreshold int64 `protobuf:"varint,5,opt,name=downtime_threshold,json=downtimeThreshold,proto3" json:"downtime_threshold"`
	// SignedBlocksWindow is the window size for tracking missed blocks
	SignedBlocksWindow int64 `protobuf:"varint,6,opt,name=signed_blocks_window,json=signedBlocksWindow,proto3" json:"signed_blocks_window"`
	// MinSignedPerWindow is the minimum percentage that must be signed (fixed-point)
	MinSignedPerWindow int64 `protobuf:"varint,7,opt,name=min_signed_per_window,json=minSignedPerWindow,proto3" json:"min_signed_per_window"`
	// SlashFractionDoubleSign is the slash fraction for double signing (fixed-point)
	SlashFractionDoubleSign int64 `protobuf:"varint,8,opt,name=slash_fraction_double_sign,json=slashFractionDoubleSign,proto3" json:"slash_fraction_double_sign"`
	// SlashFractionDowntime is the slash fraction for downtime (fixed-point)
	SlashFractionDowntime int64 `protobuf:"varint,9,opt,name=slash_fraction_downtime,json=slashFractionDowntime,proto3" json:"slash_fraction_downtime"`
	// SlashFractionInvalidAttestation is the slash fraction for invalid VEID attestation (fixed-point)
	SlashFractionInvalidAttestation int64 `protobuf:"varint,10,opt,name=slash_fraction_invalid_attestation,json=slashFractionInvalidAttestation,proto3" json:"slash_fraction_invalid_attestation"`
	// JailDurationDowntime is the jail duration for downtime (seconds)
	JailDurationDowntime int64 `protobuf:"varint,11,opt,name=jail_duration_downtime,json=jailDurationDowntime,proto3" json:"jail_duration_downtime"`
	// JailDurationDoubleSign is the jail duration for double signing (seconds)
	JailDurationDoubleSign int64 `protobuf:"varint,12,opt,name=jail_duration_double_sign,json=jailDurationDoubleSign,proto3" json:"jail_duration_double_sign"`
	// JailDurationInvalidAttestation is the jail duration for invalid attestation (seconds)
	JailDurationInvalidAttestation int64 `protobuf:"varint,13,opt,name=jail_duration_invalid_attestation,json=jailDurationInvalidAttestation,proto3" json:"jail_duration_invalid_attestation"`
	// ScoreTolerance is the allowed score difference from consensus (fixed-point)
	ScoreTolerance int64 `protobuf:"varint,14,opt,name=score_tolerance,json=scoreTolerance,proto3" json:"score_tolerance"`
	// MaxMissedVEIDRecomputations is max missed recomputations before slash
	MaxMissedVeidRecomputations int64 `protobuf:"varint,15,opt,name=max_missed_veid_recomputations,json=maxMissedVeidRecomputations,proto3" json:"max_missed_veid_recomputations"`
	// RewardDenom is the denomination for rewards
	RewardDenom string `protobuf:"bytes,16,opt,name=reward_denom,json=rewardDenom,proto3" json:"reward_denom"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_cebae7e0cc1e2edc, []int{0}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetEpochLength() uint64 {
	if m != nil {
		return m.EpochLength
	}
	return 0
}

func (m *Params) GetBaseRewardPerBlock() int64 {
	if m != nil {
		return m.BaseRewardPerBlock
	}
	return 0
}

func (m *Params) GetVeidRewardPool() int64 {
	if m != nil {
		return m.VeidRewardPool
	}
	return 0
}

func (m *Params) GetIdentityNetworkRewardPool() int64 {
	if m != nil {
		return m.IdentityNetworkRewardPool
	}
	return 0
}

func (m *Params) GetDowntimeThreshold() int64 {
	if m != nil {
		return m.DowntimeThreshold
	}
	return 0
}

func (m *Params) GetSignedBlocksWindow() int64 {
	if m != nil {
		return m.SignedBlocksWindow
	}
	return 0
}

func (m *Params) GetMinSignedPerWindow() int64 {
	if m != nil {
		return m.MinSignedPerWindow
	}
	return 0
}

func (m *Params) GetSlashFractionDoubleSign() int64 {
	if m != nil {
		return m.SlashFractionDoubleSign
	}
	return 0
}

func (m *Params) GetSlashFractionDowntime() int64 {
	if m != nil {
		return m.SlashFractionDowntime
	}
	return 0
}

func (m *Params) GetSlashFractionInvalidAttestation() int64 {
	if m != nil {
		return m.SlashFractionInvalidAttestation
	}
	return 0
}

func (m *Params) GetJailDurationDowntime() int64 {
	if m != nil {
		return m.JailDurationDowntime
	}
	return 0
}

func (m *Params) GetJailDurationDoubleSign() int64 {
	if m != nil {
		return m.JailDurationDoubleSign
	}
	return 0
}

func (m *Params) GetJailDurationInvalidAttestation() int64 {
	if m != nil {
		return m.JailDurationInvalidAttestation
	}
	return 0
}

func (m *Params) GetScoreTolerance() int64 {
	if m != nil {
		return m.ScoreTolerance
	}
	return 0
}

func (m *Params) GetMaxMissedVeidRecomputations() int64 {
	if m != nil {
		return m.MaxMissedVeidRecomputations
	}
	return 0
}

func (m *Params) GetRewardDenom() string {
	if m != nil {
		return m.RewardDenom
	}
	return ""
}

func init() {
	proto.RegisterType((*Params)(nil), "virtengine.staking.v1.Params")
}

func init() {
	proto.RegisterFile("virtengine/staking/v1/params.proto", fileDescriptor_cebae7e0cc1e2edc)
}

var fileDescriptor_cebae7e0cc1e2edc = []byte{
	// 687 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x94, 0xdf, 0x6e, 0xd3, 0x30,
	0x14, 0xc6, 0x17, 0x36, 0x06, 0xf3, 0xc6, 0xfe, 0x84, 0x6e, 0xcb, 0x3a, 0x88, 0x4b, 0x25, 0xd0,
	0xae, 0x1a, 0x4d, 0xbb, 0x40, 0x42, 0x08, 0x89, 0x6a, 0x20, 0x81, 0x06, 0x2a, 0xde, 0x04, 0x08,
	0x2e, 0x2c, 0xb7, 0x31, 0xa9, 0x69, 0x62, 0x57, 0xb1, 0xdb, 0x8e, 0xb7, 0xe0, 0x11, 0x78, 0x0a,
	0x9e, 0x81, 0xcb, 0x5d, 0x72, 0x15, 0xa1, 0xed, 0x06, 0xf9, 0x29, 0x50, 0x9c, 0x74, 0x4d, 0xbb,
	0x6e, 0xe3, 0xa6, 0xea, 0xf9, 0xbe, 0xdf, 0xf9, 0x8e, 0x72, 0xa2, 0x1c, 0x50, 0xed, 0xb3, 0x58,
	0x51, 0x1e, 0x30, 0x4e, 0x3d, 0xa9, 0x48, 0x87, 0xf1, 0xc0, 0xeb, 0xef, 0x7a, 0x5d, 0x12, 0x93,
	0x48, 0xd6, 0xba, 0xb1, 0x50, 0xc2, 0x5e, 0x1f, 0x31, 0xb5, 0x9c, 0xa9, 0xf5, 0x77, 0xcb, 0xa5,
	0x40, 0x04, 0xc2, 0x10, 0x5e, 0xfa, 0x2f, 0x83, 0xcb, 0x6b, 0x24, 0x62, 0x5c, 0x78, 0xe6, 0x37,
	0x93, 0xaa, 0x3f, 0x01, 0x98, 0x6f, 0x98, 0x40, 0x7b, 0x0f, 0x2c, 0xd1, 0xae, 0x68, 0xb5, 0x71,
	0x48, 0x79, 0xa0, 0xda, 0x8e, 0x55, 0xb1, 0x76, 0xe6, 0xea, 0xab, 0x3a, 0x81, 0x63, 0x3a, 0x5a,
	0x34, 0xd5, 0x81, 0x29, 0xec, 0x03, 0xb0, 0xde, 0x24, 0x92, 0xe2, 0x98, 0x0e, 0x48, 0xec, 0xe3,
	0x2e, 0x8d, 0x71, 0x33, 0x14, 0xad, 0x8e, 0x73, 0xa3, 0x62, 0xed, 0xcc, 0xd6, 0xb7, 0x74, 0x02,
	0xa7, 0x03, 0xc8, 0x4e, 0x65, 0x64, 0xd4, 0x06, 0x8d, 0xeb, 0xa9, 0x66, 0x3f, 0x03, 0xab, 0x7d,
	0xca, 0xfc, 0x73, 0x58, 0x88, 0xd0, 0x99, 0x35, 0x41, 0x25, 0x9d, 0xc0, 0x0b, 0x1e, 0x5a, 0x4e,
	0x95, 0x3c, 0x43, 0x88, 0xd0, 0x26, 0xe0, 0x1e, 0xf3, 0x29, 0x57, 0x4c, 0x7d, 0xc3, 0x9c, 0xaa,
	0x81, 0x88, 0x3b, 0x63, 0x59, 0x73, 0x26, 0xab, 0xa2, 0x13, 0x78, 0x25, 0x87, 0xb6, 0x86, 0xee,
	0xdb, 0xcc, 0x2c, 0x8c, 0x78, 0x01, 0x6c, 0x5f, 0x0c, 0xb8, 0x62, 0x11, 0xc5, 0xaa, 0x1d, 0x53,
	0xd9, 0x16, 0xa1, 0xef, 0xdc, 0x34, 0xc1, 0x1b, 0x3a, 0x81, 0x53, 0x5c, 0xb4, 0x36, 0xd4, 0x8e,
	0x86, 0x92, 0xfd, 0x1a, 0x94, 0x24, 0x0b, 0x38, 0xf5, 0xb3, 0x6d, 0x48, 0x3c, 0x60, 0xdc, 0x17,
	0x03, 0x67, 0xde, 0x04, 0x39, 0x3a, 0x81, 0x53, 0x7d, 0x64, 0x67, 0xaa, 0x59, 0x97, 0xfc, 0x60,
	0xb4, 0xf4, 0x1d, 0x44, 0x8c, 0xe3, 0x9c, 0x4f, 0x37, 0x9c, 0x87, 0xdd, 0x1a, 0xbd, 0x83, 0xa9,
	0x00, 0xb2, 0x23, 0xc6, 0x0f, 0x8d, 0xda, 0xa0, 0x71, 0x9e, 0xf6, 0x19, 0x94, 0x65, 0x48, 0x64,
	0x1b, 0x7f, 0x89, 0x49, 0x4b, 0x31, 0xc1, 0xb1, 0x2f, 0x7a, 0xcd, 0x90, 0x9a, 0x76, 0xe7, 0xb6,
	0x89, 0x74, 0x75, 0x02, 0xaf, 0xa0, 0xd0, 0xa6, 0xf1, 0x5e, 0xe6, 0xd6, 0xbe, 0x71, 0xd2, 0x39,
	0xf6, 0x21, 0xd8, 0xbc, 0xd0, 0x96, 0xad, 0xc6, 0x59, 0x30, 0xc9, 0xdb, 0x3a, 0x81, 0x97, 0x21,
	0x68, 0x7d, 0x22, 0x36, 0x93, 0x6d, 0x09, 0xaa, 0x13, 0x1d, 0x8c, 0xf7, 0x49, 0xc8, 0x7c, 0x4c,
	0x94, 0xa2, 0x52, 0x91, 0x54, 0x73, 0x80, 0xc9, 0x7f, 0xa4, 0x13, 0xf8, 0x1f, 0x34, 0x82, 0x63,
	0xa3, 0x5e, 0x65, 0xc4, 0xf3, 0x11, 0x60, 0x37, 0xc0, 0xc6, 0x57, 0xc2, 0x42, 0xec, 0xf7, 0x62,
	0x32, 0xfe, 0x20, 0x8b, 0x66, 0x50, 0x59, 0x27, 0xf0, 0x12, 0x02, 0x95, 0x52, 0x7d, 0x3f, 0x97,
	0xcf, 0x1f, 0xe3, 0x23, 0xd8, 0x9a, 0xe4, 0x47, 0x7b, 0x5f, 0x32, 0xa1, 0xf7, 0x75, 0x02, 0x2f,
	0x87, 0xd0, 0xc6, 0x78, 0xee, 0xf9, 0xd6, 0xbb, 0xe0, 0xc1, 0x78, 0xd3, 0xb4, 0xfd, 0xdc, 0x31,
	0x13, 0x1e, 0xea, 0x04, 0x5e, 0x0f, 0x23, 0xb7, 0x38, 0x69, 0xca, 0x76, 0x9e, 0x82, 0x15, 0xd9,
	0x12, 0x31, 0xc5, 0x4a, 0x84, 0x34, 0x26, 0xbc, 0x45, 0x9d, 0x65, 0x93, 0x7f, 0x57, 0x27, 0x70,
	0xd2, 0x42, 0xcb, 0x46, 0x38, 0x1a, 0xd6, 0x76, 0x00, 0xdc, 0x88, 0x1c, 0xe3, 0x88, 0x49, 0x49,
	0x7d, 0x9c, 0x7f, 0xf5, 0x2d, 0x11, 0x75, 0x7b, 0x59, 0xbc, 0x74, 0x56, 0x4c, 0x58, 0x55, 0x27,
	0xf0, 0x1a, 0x12, 0x6d, 0x47, 0xe4, 0xf8, 0x8d, 0xb1, 0xdf, 0x9b, 0x5b, 0x51, 0x34, 0xd3, 0x93,
	0x97, 0x7f, 0xf6, 0x3e, 0xe5, 0x22, 0x72, 0x56, 0x2b, 0xd6, 0xce, 0x42, 0x76, 0xf2, 0x8a, 0x3a,
	0x5a, 0xcc, 0xaa, 0xfd, 0xb4, 0x78, 0x32, 0xf7, 0xf7, 0x07, 0xb4, 0xea, 0xef, 0x7e, 0x9d, 0xba,
	0xd6, 0xc9, 0xa9, 0x6b, 0xfd, 0x39, 0x75, 0xad, 0xef, 0x67, 0xee, 0xcc, 0xc9, 0x99, 0x3b, 0xf3,
	0xfb, 0xcc, 0x9d, 0xf9, 0xf4, 0x38, 0x60, 0xaa, 0xdd, 0x6b, 0xd6, 0x5a, 0x22, 0xf2, 0x0a, 0x17,
	0xbc, 0x78, 0xcc, 0xfd, 0x8e, 0x17, 0x08, 0x8f, 0x0b, 0xbf, 0x78, 0xd8, 0x9b, 0xf3, 0xe6, 0x24,
	0xef, 0xfd, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x62, 0xb9, 0x83, 0xa1, 0xf8, 0x05, 0x00, 0x00,
}

func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EpochLength != that1.EpochLength {
		return false
	}
	if this.BaseRewardPerBlock != that1.BaseRewardPerBlock {
		return false
	}
	if this.VeidRewardPool != that1.VeidRewardPool {
		return false
	}
	if this.IdentityNetworkRewardPool != that1.IdentityNetworkRewardPool {
		return false
	}
	if this.DowntimeThreshold != that1.DowntimeThreshold {
		return false
	}
	if this.SignedBlocksWindow != that1.SignedBlocksWindow {
		return false
	}
	if this.MinSignedPerWindow != that1.MinSignedPerWindow {
		return false
	}
	if this.SlashFractionDoubleSign != that1.SlashFractionDoubleSign {
		return false
	}
	if this.SlashFractionDowntime != that1.SlashFractionDowntime {
		return false
	}
	if this.SlashFractionInvalidAttestation != that1.SlashFractionInvalidAttestation {
		return false
	}
	if this.JailDurationDowntime != that1.JailDurationDowntime {
		return false
	}
	if this.JailDurationDoubleSign != that1.JailDurationDoubleSign {
		return false
	}
	if this.JailDurationInvalidAttestation != that1.JailDurationInvalidAttestation {
		return false
	}
	if this.ScoreTolerance != that1.ScoreTolerance {
		return false
	}
	if this.MaxMissedVeidRecomputations != that1.MaxMissedVeidRecomputations {
		return false
	}
	if this.RewardDenom != that1.RewardDenom {
		return false
	}
	return true
}
func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RewardDenom) > 0 {
		i -= len(m.RewardDenom)
		copy(dAtA[i:], m.RewardDenom)
		i = encodeVarintParams(dAtA, i, uint64(len(m.RewardDenom)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.MaxMissedVeidRecomputations != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MaxMissedVeidRecomputations))
		i--
		dAtA[i] = 0x78
	}
	if m.ScoreTolerance != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.ScoreTolerance))
		i--
		dAtA[i] = 0x70
	}
	if m.JailDurationInvalidAttestation != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.JailDurationInvalidAttestation))
		i--
		dAtA[i] = 0x68
	}
	if m.JailDurationDoubleSign != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.JailDurationDoubleSign))
		i--
		dAtA[i] = 0x60
	}
	if m.JailDurationDowntime != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.JailDurationDowntime))
		i--
		dAtA[i] = 0x58
	}
	if m.SlashFractionInvalidAttestation != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SlashFractionInvalidAttestation))
		i--
		dAtA[i] = 0x50
	}
	if m.SlashFractionDowntime != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SlashFractionDowntime))
		i--
		dAtA[i] = 0x48
	}
	if m.SlashFractionDoubleSign != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SlashFractionDoubleSign))
		i--
		dAtA[i] = 0x40
	}
	if m.MinSignedPerWindow != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.MinSignedPerWindow))
		i--
		dAtA[i] = 0x38
	}
	if m.SignedBlocksWindow != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.SignedBlocksWindow))
		i--
		dAtA[i] = 0x30
	}
	if m.DowntimeThreshold != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.DowntimeThreshold))
		i--
		dAtA[i] = 0x28
	}
	if m.IdentityNetworkRewardPool != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.IdentityNetworkRewardPool))
		i--
		dAtA[i] = 0x20
	}
	if m.VeidRewardPool != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.VeidRewardPool))
		i--
		dAtA[i] = 0x18
	}
	if m.BaseRewardPerBlock != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.BaseRewardPerBlock))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochLength != 0 {
		i = encodeVarintParams(dAtA, i, uint64(m.EpochLength))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintParams(dAtA []byte, offset int, v uint64) int {
	offset -= sovParams(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochLength != 0 {
		n += 1 + sovParams(uint64(m.EpochLength))
	}
	if m.BaseRewardPerBlock != 0 {
		n += 1 + sovParams(uint64(m.BaseRewardPerBlock))
	}
	if m.VeidRewardPool != 0 {
		n += 1 + sovParams(uint64(m.VeidRewardPool))
	}
	if m.IdentityNetworkRewardPool != 0 {
		n += 1 + sovParams(uint64(m.IdentityNetworkRewardPool))
	}
	if m.DowntimeThreshold != 0 {
		n += 1 + sovParams(uint64(m.DowntimeThreshold))
	}
	if m.SignedBlocksWindow != 0 {
		n += 1 + sovParams(uint64(m.SignedBlocksWindow))
	}
	if m.MinSignedPerWindow != 0 {
		n += 1 + sovParams(uint64(m.MinSignedPerWindow))
	}
	if m.SlashFractionDoubleSign != 0 {
		n += 1 + sovParams(uint64(m.SlashFractionDoubleSign))
	}
	if m.SlashFractionDowntime != 0 {
		n += 1 + sovParams(uint64(m.SlashFractionDowntime))
	}
	if m.SlashFractionInvalidAttestation != 0 {
		n += 1 + sovParams(uint64(m.SlashFractionInvalidAttestation))
	}
	if m.JailDurationDowntime != 0 {
		n += 1 + sovParams(uint64(m.JailDurationDowntime))
	}
	if m.JailDurationDoubleSign != 0 {
		n += 1 + sovParams(uint64(m.JailDurationDoubleSign))
	}
	if m.JailDurationInvalidAttestation != 0 {
		n += 1 + sovParams(uint64(m.JailDurationInvalidAttestation))
	}
	if m.ScoreTolerance != 0 {
		n += 1 + sovParams(uint64(m.ScoreTolerance))
	}
	if m.MaxMissedVeidRecomputations != 0 {
		n += 1 + sovParams(uint64(m.MaxMissedVeidRecomputations))
	}
	l = len(m.RewardDenom)
	if l > 0 {
		n += 2 + l + sovParams(uint64(l))
	}
	return n
}

func sovParams(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozParams(x uint64) (n int) {
	return sovParams(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowParams
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochLength", wireType)
			}
			m.EpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseRewardPerBlock", wireType)
			}
			m.BaseRewardPerBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BaseRewardPerBlock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VeidRewardPool", wireType)
			}
			m.VeidRewardPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VeidRewardPool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityNetworkRewardPool", wireType)
			}
			m.IdentityNetworkRewardPool = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IdentityNetworkRewardPool |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeThreshold", wireType)
			}
			m.DowntimeThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DowntimeThreshold |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignedBlocksWindow", wireType)
			}
			m.SignedBlocksWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignedBlocksWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSignedPerWindow", wireType)
			}
			m.MinSignedPerWindow = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinSignedPerWindow |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFractionDoubleSign", wireType)
			}
			m.SlashFractionDoubleSign = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashFractionDoubleSign |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFractionDowntime", wireType)
			}
			m.SlashFractionDowntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashFractionDowntime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashFractionInvalidAttestation", wireType)
			}
			m.SlashFractionInvalidAttestation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashFractionInvalidAttestation |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDurationDowntime", wireType)
			}
			m.JailDurationDowntime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JailDurationDowntime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDurationDoubleSign", wireType)
			}
			m.JailDurationDoubleSign = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JailDurationDoubleSign |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDurationInvalidAttestation", wireType)
			}
			m.JailDurationInvalidAttestation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JailDurationInvalidAttestation |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreTolerance", wireType)
			}
			m.ScoreTolerance = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreTolerance |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxMissedVeidRecomputations", wireType)
			}
			m.MaxMissedVeidRecomputations = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxMissedVeidRecomputations |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowParams
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthParams
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthParams
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipParams(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthParams
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipParams(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowParams
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowParams
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthParams
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupParams
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthParams
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthParams        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowParams          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupParams = fmt.Errorf("proto: unexpected end of group")
)
