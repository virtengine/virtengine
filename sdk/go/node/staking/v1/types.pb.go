// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/staking/v1/types.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// SlashReason indicates the reason for slashing
type SlashReason int32

const (
	// SLASH_REASON_UNSPECIFIED is the default/invalid reason
	SlashReasonUnspecified SlashReason = 0
	// SLASH_REASON_DOUBLE_SIGNING is for double signing infractions
	SlashReasonDoubleSigning SlashReason = 1
	// SLASH_REASON_DOWNTIME is for excessive downtime
	SlashReasonDowntime SlashReason = 2
	// SLASH_REASON_INVALID_VEID_ATTESTATION is for invalid VEID attestations
	SlashReasonInvalidVEIDAttestation SlashReason = 3
	// SLASH_REASON_MISSED_RECOMPUTATION is for missing VEID recomputation
	SlashReasonMissedRecomputation SlashReason = 4
	// SLASH_REASON_INCONSISTENT_SCORE is for scores differing from consensus
	SlashReasonInconsistentScore SlashReason = 5
	// SLASH_REASON_EXPIRED_ATTESTATION is for expired attestation
	SlashReasonExpiredAttestation SlashReason = 6
	// SLASH_REASON_DEBUG_MODE_ENABLED is for enclave debug mode
	SlashReasonDebugModeEnabled SlashReason = 7
	// SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT is for non-allowlisted enclave measurement
	SlashReasonNonAllowlistedMeasurement SlashReason = 8
)

var SlashReason_name = map[int32]string{
	0: "SLASH_REASON_UNSPECIFIED",
	1: "SLASH_REASON_DOUBLE_SIGNING",
	2: "SLASH_REASON_DOWNTIME",
	3: "SLASH_REASON_INVALID_VEID_ATTESTATION",
	4: "SLASH_REASON_MISSED_RECOMPUTATION",
	5: "SLASH_REASON_INCONSISTENT_SCORE",
	6: "SLASH_REASON_EXPIRED_ATTESTATION",
	7: "SLASH_REASON_DEBUG_MODE_ENABLED",
	8: "SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT",
}

var SlashReason_value = map[string]int32{
	"SLASH_REASON_UNSPECIFIED":                 0,
	"SLASH_REASON_DOUBLE_SIGNING":              1,
	"SLASH_REASON_DOWNTIME":                    2,
	"SLASH_REASON_INVALID_VEID_ATTESTATION":    3,
	"SLASH_REASON_MISSED_RECOMPUTATION":        4,
	"SLASH_REASON_INCONSISTENT_SCORE":          5,
	"SLASH_REASON_EXPIRED_ATTESTATION":         6,
	"SLASH_REASON_DEBUG_MODE_ENABLED":          7,
	"SLASH_REASON_NON_ALLOWLISTED_MEASUREMENT": 8,
}

func (x SlashReason) String() string {
	return proto.EnumName(SlashReason_name, int32(x))
}

func (SlashReason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{0}
}

// RewardType indicates the type of reward
type RewardType int32

const (
	// REWARD_TYPE_UNSPECIFIED is the default/invalid reward type
	RewardTypeUnspecified RewardType = 0
	// REWARD_TYPE_BLOCK_PROPOSAL is for block proposal rewards
	RewardTypeBlockProposal RewardType = 1
	// REWARD_TYPE_VEID_VERIFICATION is for VEID verification rewards
	RewardTypeVEIDVerification RewardType = 2
	// REWARD_TYPE_UPTIME is for uptime-based rewards
	RewardTypeUptime RewardType = 3
	// REWARD_TYPE_IDENTITY_NETWORK is for identity network participation rewards
	RewardTypeIdentityNetwork RewardType = 4
	// REWARD_TYPE_STAKING is for base staking rewards
	RewardTypeStaking RewardType = 5
)

var RewardType_name = map[int32]string{
	0: "REWARD_TYPE_UNSPECIFIED",
	1: "REWARD_TYPE_BLOCK_PROPOSAL",
	2: "REWARD_TYPE_VEID_VERIFICATION",
	3: "REWARD_TYPE_UPTIME",
	4: "REWARD_TYPE_IDENTITY_NETWORK",
	5: "REWARD_TYPE_STAKING",
}

var RewardType_value = map[string]int32{
	"REWARD_TYPE_UNSPECIFIED":       0,
	"REWARD_TYPE_BLOCK_PROPOSAL":    1,
	"REWARD_TYPE_VEID_VERIFICATION": 2,
	"REWARD_TYPE_UPTIME":            3,
	"REWARD_TYPE_IDENTITY_NETWORK":  4,
	"REWARD_TYPE_STAKING":           5,
}

func (x RewardType) String() string {
	return proto.EnumName(RewardType_name, int32(x))
}

func (RewardType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{1}
}

// ValidatorPerformance represents a validator's performance metrics
type ValidatorPerformance struct {
	// ValidatorAddress is the validator's blockchain address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// BlocksProposed is the number of blocks proposed in the current epoch
	BlocksProposed int64 `protobuf:"varint,2,opt,name=blocks_proposed,json=blocksProposed,proto3" json:"blocks_proposed"`
	// BlocksExpected is the expected number of blocks based on stake weight
	BlocksExpected int64 `protobuf:"varint,3,opt,name=blocks_expected,json=blocksExpected,proto3" json:"blocks_expected"`
	// BlocksMissed is the number of missed blocks (when expected to sign)
	BlocksMissed int64 `protobuf:"varint,4,opt,name=blocks_missed,json=blocksMissed,proto3" json:"blocks_missed"`
	// TotalSignatures is the total number of blocks signed
	TotalSignatures int64 `protobuf:"varint,5,opt,name=total_signatures,json=totalSignatures,proto3" json:"total_signatures"`
	// VEIDVerificationsCompleted is the number of VEID verifications completed
	VEIDVerificationsCompleted int64 `protobuf:"varint,6,opt,name=veid_verifications_completed,json=veidVerificationsCompleted,proto3" json:"veid_verifications_completed"`
	// VEIDVerificationsExpected is the expected VEID verifications based on committee selection
	VEIDVerificationsExpected int64 `protobuf:"varint,7,opt,name=veid_verifications_expected,json=veidVerificationsExpected,proto3" json:"veid_verifications_expected"`
	// VEIDVerificationScore is the quality score for VEID verifications (0-10000)
	VEIDVerificationScore int64 `protobuf:"varint,8,opt,name=veid_verification_score,json=veidVerificationScore,proto3" json:"veid_verification_score"`
	// UptimeSeconds is the total uptime in seconds
	UptimeSeconds int64 `protobuf:"varint,9,opt,name=uptime_seconds,json=uptimeSeconds,proto3" json:"uptime_seconds"`
	// DowntimeSeconds is the total downtime in seconds
	DowntimeSeconds int64 `protobuf:"varint,10,opt,name=downtime_seconds,json=downtimeSeconds,proto3" json:"downtime_seconds"`
	// ConsecutiveMissedBlocks is the current streak of missed blocks
	ConsecutiveMissedBlocks int64 `protobuf:"varint,11,opt,name=consecutive_missed_blocks,json=consecutiveMissedBlocks,proto3" json:"consecutive_missed_blocks"`
	// LastProposedHeight is the last height where this validator proposed a block
	LastProposedHeight int64 `protobuf:"varint,12,opt,name=last_proposed_height,json=lastProposedHeight,proto3" json:"last_proposed_height"`
	// LastSignedHeight is the last height where this validator signed
	LastSignedHeight int64 `protobuf:"varint,13,opt,name=last_signed_height,json=lastSignedHeight,proto3" json:"last_signed_height"`
	// EpochNumber is the epoch this performance record belongs to
	EpochNumber uint64 `protobuf:"varint,14,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number"`
	// UpdatedAt is when this record was last updated
	UpdatedAt *time.Time `protobuf:"bytes,15,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	// OverallScore is the computed overall performance score (0-10000)
	OverallScore int64 `protobuf:"varint,16,opt,name=overall_score,json=overallScore,proto3" json:"overall_score"`
}

func (m *ValidatorPerformance) Reset()         { *m = ValidatorPerformance{} }
func (m *ValidatorPerformance) String() string { return proto.CompactTextString(m) }
func (*ValidatorPerformance) ProtoMessage()    {}
func (*ValidatorPerformance) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{0}
}
func (m *ValidatorPerformance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorPerformance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorPerformance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorPerformance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorPerformance.Merge(m, src)
}
func (m *ValidatorPerformance) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorPerformance) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorPerformance.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorPerformance proto.InternalMessageInfo

func (m *ValidatorPerformance) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorPerformance) GetBlocksProposed() int64 {
	if m != nil {
		return m.BlocksProposed
	}
	return 0
}

func (m *ValidatorPerformance) GetBlocksExpected() int64 {
	if m != nil {
		return m.BlocksExpected
	}
	return 0
}

func (m *ValidatorPerformance) GetBlocksMissed() int64 {
	if m != nil {
		return m.BlocksMissed
	}
	return 0
}

func (m *ValidatorPerformance) GetTotalSignatures() int64 {
	if m != nil {
		return m.TotalSignatures
	}
	return 0
}

func (m *ValidatorPerformance) GetVEIDVerificationsCompleted() int64 {
	if m != nil {
		return m.VEIDVerificationsCompleted
	}
	return 0
}

func (m *ValidatorPerformance) GetVEIDVerificationsExpected() int64 {
	if m != nil {
		return m.VEIDVerificationsExpected
	}
	return 0
}

func (m *ValidatorPerformance) GetVEIDVerificationScore() int64 {
	if m != nil {
		return m.VEIDVerificationScore
	}
	return 0
}

func (m *ValidatorPerformance) GetUptimeSeconds() int64 {
	if m != nil {
		return m.UptimeSeconds
	}
	return 0
}

func (m *ValidatorPerformance) GetDowntimeSeconds() int64 {
	if m != nil {
		return m.DowntimeSeconds
	}
	return 0
}

func (m *ValidatorPerformance) GetConsecutiveMissedBlocks() int64 {
	if m != nil {
		return m.ConsecutiveMissedBlocks
	}
	return 0
}

func (m *ValidatorPerformance) GetLastProposedHeight() int64 {
	if m != nil {
		return m.LastProposedHeight
	}
	return 0
}

func (m *ValidatorPerformance) GetLastSignedHeight() int64 {
	if m != nil {
		return m.LastSignedHeight
	}
	return 0
}

func (m *ValidatorPerformance) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *ValidatorPerformance) GetUpdatedAt() *time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return nil
}

func (m *ValidatorPerformance) GetOverallScore() int64 {
	if m != nil {
		return m.OverallScore
	}
	return 0
}

// ValidatorSigningInfo contains validator signing information for slashing
type ValidatorSigningInfo struct {
	// ValidatorAddress is the validator's blockchain address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// StartHeight is the height at which validator started signing
	StartHeight int64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height"`
	// IndexOffset is the current index offset into the signed blocks window
	IndexOffset int64 `protobuf:"varint,3,opt,name=index_offset,json=indexOffset,proto3" json:"index_offset"`
	// JailedUntil is the time until which the validator is jailed
	JailedUntil *time.Time `protobuf:"bytes,4,opt,name=jailed_until,json=jailedUntil,proto3,stdtime" json:"jailed_until" yaml:"jailed_until"`
	// Tombstoned indicates if the validator has been tombstoned (permanently banned)
	Tombstoned bool `protobuf:"varint,5,opt,name=tombstoned,proto3" json:"tombstoned"`
	// MissedBlocksCounter is the counter for missed blocks in the current window
	MissedBlocksCounter int64 `protobuf:"varint,6,opt,name=missed_blocks_counter,json=missedBlocksCounter,proto3" json:"missed_blocks_counter"`
	// InfractionCount is the total number of infractions
	InfractionCount int64 `protobuf:"varint,7,opt,name=infraction_count,json=infractionCount,proto3" json:"infraction_count"`
}

func (m *ValidatorSigningInfo) Reset()         { *m = ValidatorSigningInfo{} }
func (m *ValidatorSigningInfo) String() string { return proto.CompactTextString(m) }
func (*ValidatorSigningInfo) ProtoMessage()    {}
func (*ValidatorSigningInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{1}
}
func (m *ValidatorSigningInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorSigningInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorSigningInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorSigningInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorSigningInfo.Merge(m, src)
}
func (m *ValidatorSigningInfo) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorSigningInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorSigningInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorSigningInfo proto.InternalMessageInfo

func (m *ValidatorSigningInfo) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorSigningInfo) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *ValidatorSigningInfo) GetIndexOffset() int64 {
	if m != nil {
		return m.IndexOffset
	}
	return 0
}

func (m *ValidatorSigningInfo) GetJailedUntil() *time.Time {
	if m != nil {
		return m.JailedUntil
	}
	return nil
}

func (m *ValidatorSigningInfo) GetTombstoned() bool {
	if m != nil {
		return m.Tombstoned
	}
	return false
}

func (m *ValidatorSigningInfo) GetMissedBlocksCounter() int64 {
	if m != nil {
		return m.MissedBlocksCounter
	}
	return 0
}

func (m *ValidatorSigningInfo) GetInfractionCount() int64 {
	if m != nil {
		return m.InfractionCount
	}
	return 0
}

// RewardEpoch represents a reward epoch
type RewardEpoch struct {
	// EpochNumber is the epoch identifier
	EpochNumber uint64 `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number"`
	// StartHeight is the starting block height
	StartHeight int64 `protobuf:"varint,2,opt,name=start_height,json=startHeight,proto3" json:"start_height"`
	// EndHeight is the ending block height
	EndHeight int64 `protobuf:"varint,3,opt,name=end_height,json=endHeight,proto3" json:"end_height"`
	// StartTime is when the epoch started
	StartTime *time.Time `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time" yaml:"start_time"`
	// EndTime is when the epoch ended (zero if current)
	EndTime *time.Time `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty" yaml:"end_time"`
	// TotalRewardsDistributed is the total rewards distributed
	TotalRewardsDistributed github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=total_rewards_distributed,json=totalRewardsDistributed,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_rewards_distributed" yaml:"total_rewards_distributed"`
	// BlockProposalRewards is rewards from block proposals
	BlockProposalRewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=block_proposal_rewards,json=blockProposalRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"block_proposal_rewards" yaml:"block_proposal_rewards"`
	// VEIDRewards is rewards from VEID verification work
	VEIDRewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,8,rep,name=veid_rewards,json=veidRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"veid_rewards" yaml:"veid_rewards"`
	// UptimeRewards is rewards from uptime
	UptimeRewards github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=uptime_rewards,json=uptimeRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"uptime_rewards" yaml:"uptime_rewards"`
	// ValidatorCount is the number of validators in this epoch
	ValidatorCount int64 `protobuf:"varint,10,opt,name=validator_count,json=validatorCount,proto3" json:"validator_count"`
	// TotalStake is the total stake in this epoch
	TotalStake string `protobuf:"bytes,11,opt,name=total_stake,json=totalStake,proto3" json:"total_stake"`
	// Finalized indicates if this epoch is finalized
	Finalized bool `protobuf:"varint,12,opt,name=finalized,proto3" json:"finalized"`
}

func (m *RewardEpoch) Reset()         { *m = RewardEpoch{} }
func (m *RewardEpoch) String() string { return proto.CompactTextString(m) }
func (*RewardEpoch) ProtoMessage()    {}
func (*RewardEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{2}
}
func (m *RewardEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardEpoch.Merge(m, src)
}
func (m *RewardEpoch) XXX_Size() int {
	return m.Size()
}
func (m *RewardEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_RewardEpoch proto.InternalMessageInfo

func (m *RewardEpoch) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *RewardEpoch) GetStartHeight() int64 {
	if m != nil {
		return m.StartHeight
	}
	return 0
}

func (m *RewardEpoch) GetEndHeight() int64 {
	if m != nil {
		return m.EndHeight
	}
	return 0
}

func (m *RewardEpoch) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *RewardEpoch) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *RewardEpoch) GetTotalRewardsDistributed() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalRewardsDistributed
	}
	return nil
}

func (m *RewardEpoch) GetBlockProposalRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.BlockProposalRewards
	}
	return nil
}

func (m *RewardEpoch) GetVEIDRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.VEIDRewards
	}
	return nil
}

func (m *RewardEpoch) GetUptimeRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.UptimeRewards
	}
	return nil
}

func (m *RewardEpoch) GetValidatorCount() int64 {
	if m != nil {
		return m.ValidatorCount
	}
	return 0
}

func (m *RewardEpoch) GetTotalStake() string {
	if m != nil {
		return m.TotalStake
	}
	return ""
}

func (m *RewardEpoch) GetFinalized() bool {
	if m != nil {
		return m.Finalized
	}
	return false
}

// ValidatorReward represents a validator's rewards for an epoch
type ValidatorReward struct {
	// ValidatorAddress is the validator's address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// EpochNumber is the epoch this reward belongs to
	EpochNumber uint64 `protobuf:"varint,2,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number"`
	// TotalReward is the total reward amount
	TotalReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=total_reward,json=totalReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_reward" yaml:"total_reward"`
	// BlockProposalReward is reward from block proposals
	BlockProposalReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=block_proposal_reward,json=blockProposalReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"block_proposal_reward" yaml:"block_proposal_reward"`
	// VEIDReward is reward from VEID verification
	VEIDReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=veid_reward,json=veidReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"veid_reward" yaml:"veid_reward"`
	// UptimeReward is reward from uptime
	UptimeReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=uptime_reward,json=uptimeReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"uptime_reward" yaml:"uptime_reward"`
	// IdentityNetworkReward is reward from identity network participation
	IdentityNetworkReward github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=identity_network_reward,json=identityNetworkReward,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"identity_network_reward" yaml:"identity_network_reward"`
	// PerformanceScore is the performance score used for calculation
	PerformanceScore int64 `protobuf:"varint,8,opt,name=performance_score,json=performanceScore,proto3" json:"performance_score"`
	// StakeWeight is the stake weight used for calculation
	StakeWeight string `protobuf:"bytes,9,opt,name=stake_weight,json=stakeWeight,proto3" json:"stake_weight"`
	// CalculatedAt is when the reward was calculated
	CalculatedAt *time.Time `protobuf:"bytes,10,opt,name=calculated_at,json=calculatedAt,proto3,stdtime" json:"calculated_at" yaml:"calculated_at"`
	// BlockHeight is when the reward was recorded
	BlockHeight int64 `protobuf:"varint,11,opt,name=block_height,json=blockHeight,proto3" json:"block_height"`
	// Claimed indicates if the reward has been claimed
	Claimed bool `protobuf:"varint,12,opt,name=claimed,proto3" json:"claimed"`
	// ClaimedAt is when the reward was claimed
	ClaimedAt *time.Time `protobuf:"bytes,13,opt,name=claimed_at,json=claimedAt,proto3,stdtime" json:"claimed_at,omitempty" yaml:"claimed_at"`
}

func (m *ValidatorReward) Reset()         { *m = ValidatorReward{} }
func (m *ValidatorReward) String() string { return proto.CompactTextString(m) }
func (*ValidatorReward) ProtoMessage()    {}
func (*ValidatorReward) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{3}
}
func (m *ValidatorReward) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorReward) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorReward.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorReward) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorReward.Merge(m, src)
}
func (m *ValidatorReward) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorReward) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorReward.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorReward proto.InternalMessageInfo

func (m *ValidatorReward) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorReward) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *ValidatorReward) GetTotalReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalReward
	}
	return nil
}

func (m *ValidatorReward) GetBlockProposalReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.BlockProposalReward
	}
	return nil
}

func (m *ValidatorReward) GetVEIDReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.VEIDReward
	}
	return nil
}

func (m *ValidatorReward) GetUptimeReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.UptimeReward
	}
	return nil
}

func (m *ValidatorReward) GetIdentityNetworkReward() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.IdentityNetworkReward
	}
	return nil
}

func (m *ValidatorReward) GetPerformanceScore() int64 {
	if m != nil {
		return m.PerformanceScore
	}
	return 0
}

func (m *ValidatorReward) GetStakeWeight() string {
	if m != nil {
		return m.StakeWeight
	}
	return ""
}

func (m *ValidatorReward) GetCalculatedAt() *time.Time {
	if m != nil {
		return m.CalculatedAt
	}
	return nil
}

func (m *ValidatorReward) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *ValidatorReward) GetClaimed() bool {
	if m != nil {
		return m.Claimed
	}
	return false
}

func (m *ValidatorReward) GetClaimedAt() *time.Time {
	if m != nil {
		return m.ClaimedAt
	}
	return nil
}

// SlashRecord represents a slashing record
type SlashRecord struct {
	// SlashID is the unique identifier for this slashing event
	SlashId string `protobuf:"bytes,1,opt,name=slash_id,json=slashId,proto3" json:"slash_id" yaml:"slash_id"`
	// ValidatorAddress is the validator being slashed
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// Reason is the reason for slashing
	Reason SlashReason `protobuf:"varint,3,opt,name=reason,proto3,enum=virtengine.staking.v1.SlashReason" json:"reason" yaml:"reason"`
	// Amount is the amount slashed
	Amount github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount" yaml:"amount"`
	// SlashPercent is the percentage slashed (fixed-point, 1e6 scale)
	SlashPercent int64 `protobuf:"varint,5,opt,name=slash_percent,json=slashPercent,proto3" json:"slash_percent"`
	// InfractionHeight is the block height of the infraction
	InfractionHeight int64 `protobuf:"varint,6,opt,name=infraction_height,json=infractionHeight,proto3" json:"infraction_height"`
	// SlashHeight is the block height when slash was executed
	SlashHeight int64 `protobuf:"varint,7,opt,name=slash_height,json=slashHeight,proto3" json:"slash_height"`
	// SlashTime is when the slash was executed
	SlashTime *time.Time `protobuf:"bytes,8,opt,name=slash_time,json=slashTime,proto3,stdtime" json:"slash_time" yaml:"slash_time"`
	// Jailed indicates if the validator was jailed
	Jailed bool `protobuf:"varint,9,opt,name=jailed,proto3" json:"jailed"`
	// JailDuration is how long the validator is jailed
	JailDuration int64 `protobuf:"varint,10,opt,name=jail_duration,json=jailDuration,proto3" json:"jail_duration"`
	// JailedUntil is when the jail period ends
	JailedUntil *time.Time `protobuf:"bytes,11,opt,name=jailed_until,json=jailedUntil,proto3,stdtime" json:"jailed_until,omitempty" yaml:"jailed_until"`
	// Tombstoned indicates if validator is permanently banned
	Tombstoned bool `protobuf:"varint,12,opt,name=tombstoned,proto3" json:"tombstoned"`
	// Evidence contains the infraction evidence
	Evidence string `protobuf:"bytes,13,opt,name=evidence,proto3" json:"evidence,omitempty"`
	// EvidenceHash is the hash of the evidence
	EvidenceHash string `protobuf:"bytes,14,opt,name=evidence_hash,json=evidenceHash,proto3" json:"evidence_hash,omitempty"`
	// ReporterAddress is who reported the infraction (if any)
	ReporterAddress string `protobuf:"bytes,15,opt,name=reporter_address,json=reporterAddress,proto3" json:"reporter_address,omitempty" yaml:"reporter_address"`
}

func (m *SlashRecord) Reset()         { *m = SlashRecord{} }
func (m *SlashRecord) String() string { return proto.CompactTextString(m) }
func (*SlashRecord) ProtoMessage()    {}
func (*SlashRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{4}
}
func (m *SlashRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashRecord.Merge(m, src)
}
func (m *SlashRecord) XXX_Size() int {
	return m.Size()
}
func (m *SlashRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SlashRecord proto.InternalMessageInfo

func (m *SlashRecord) GetSlashId() string {
	if m != nil {
		return m.SlashId
	}
	return ""
}

func (m *SlashRecord) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *SlashRecord) GetReason() SlashReason {
	if m != nil {
		return m.Reason
	}
	return SlashReasonUnspecified
}

func (m *SlashRecord) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *SlashRecord) GetSlashPercent() int64 {
	if m != nil {
		return m.SlashPercent
	}
	return 0
}

func (m *SlashRecord) GetInfractionHeight() int64 {
	if m != nil {
		return m.InfractionHeight
	}
	return 0
}

func (m *SlashRecord) GetSlashHeight() int64 {
	if m != nil {
		return m.SlashHeight
	}
	return 0
}

func (m *SlashRecord) GetSlashTime() *time.Time {
	if m != nil {
		return m.SlashTime
	}
	return nil
}

func (m *SlashRecord) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *SlashRecord) GetJailDuration() int64 {
	if m != nil {
		return m.JailDuration
	}
	return 0
}

func (m *SlashRecord) GetJailedUntil() *time.Time {
	if m != nil {
		return m.JailedUntil
	}
	return nil
}

func (m *SlashRecord) GetTombstoned() bool {
	if m != nil {
		return m.Tombstoned
	}
	return false
}

func (m *SlashRecord) GetEvidence() string {
	if m != nil {
		return m.Evidence
	}
	return ""
}

func (m *SlashRecord) GetEvidenceHash() string {
	if m != nil {
		return m.EvidenceHash
	}
	return ""
}

func (m *SlashRecord) GetReporterAddress() string {
	if m != nil {
		return m.ReporterAddress
	}
	return ""
}

// DoubleSignEvidence represents evidence of double signing
type DoubleSignEvidence struct {
	// EvidenceID is the unique identifier
	EvidenceId string `protobuf:"bytes,1,opt,name=evidence_id,json=evidenceId,proto3" json:"evidence_id"`
	// ValidatorAddress is the validator who double signed
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// Height1 is the first height of the double sign
	Height_1 int64 `protobuf:"varint,3,opt,name=height_1,json=height1,proto3" json:"height_1"`
	// Height2 is the second height of the double sign
	Height_2 int64 `protobuf:"varint,4,opt,name=height_2,json=height2,proto3" json:"height_2"`
	// VoteHash1 is the hash of the first vote
	VoteHash_1 string `protobuf:"bytes,5,opt,name=vote_hash_1,json=voteHash1,proto3" json:"vote_hash_1"`
	// VoteHash2 is the hash of the second vote
	VoteHash_2 string `protobuf:"bytes,6,opt,name=vote_hash_2,json=voteHash2,proto3" json:"vote_hash_2"`
	// DetectedAt is when the double sign was detected
	DetectedAt *time.Time `protobuf:"bytes,7,opt,name=detected_at,json=detectedAt,proto3,stdtime" json:"detected_at" yaml:"detected_at"`
	// DetectedHeight is the block height when detected
	DetectedHeight int64 `protobuf:"varint,8,opt,name=detected_height,json=detectedHeight,proto3" json:"detected_height"`
	// Processed indicates if this evidence has been processed
	Processed bool `protobuf:"varint,9,opt,name=processed,proto3" json:"processed"`
}

func (m *DoubleSignEvidence) Reset()         { *m = DoubleSignEvidence{} }
func (m *DoubleSignEvidence) String() string { return proto.CompactTextString(m) }
func (*DoubleSignEvidence) ProtoMessage()    {}
func (*DoubleSignEvidence) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{5}
}
func (m *DoubleSignEvidence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DoubleSignEvidence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DoubleSignEvidence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DoubleSignEvidence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DoubleSignEvidence.Merge(m, src)
}
func (m *DoubleSignEvidence) XXX_Size() int {
	return m.Size()
}
func (m *DoubleSignEvidence) XXX_DiscardUnknown() {
	xxx_messageInfo_DoubleSignEvidence.DiscardUnknown(m)
}

var xxx_messageInfo_DoubleSignEvidence proto.InternalMessageInfo

func (m *DoubleSignEvidence) GetEvidenceId() string {
	if m != nil {
		return m.EvidenceId
	}
	return ""
}

func (m *DoubleSignEvidence) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *DoubleSignEvidence) GetHeight_1() int64 {
	if m != nil {
		return m.Height_1
	}
	return 0
}

func (m *DoubleSignEvidence) GetHeight_2() int64 {
	if m != nil {
		return m.Height_2
	}
	return 0
}

func (m *DoubleSignEvidence) GetVoteHash_1() string {
	if m != nil {
		return m.VoteHash_1
	}
	return ""
}

func (m *DoubleSignEvidence) GetVoteHash_2() string {
	if m != nil {
		return m.VoteHash_2
	}
	return ""
}

func (m *DoubleSignEvidence) GetDetectedAt() *time.Time {
	if m != nil {
		return m.DetectedAt
	}
	return nil
}

func (m *DoubleSignEvidence) GetDetectedHeight() int64 {
	if m != nil {
		return m.DetectedHeight
	}
	return 0
}

func (m *DoubleSignEvidence) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

// InvalidVEIDAttestation represents evidence of invalid VEID attestation
type InvalidVEIDAttestation struct {
	// RecordID is the unique identifier
	RecordId string `protobuf:"bytes,1,opt,name=record_id,json=recordId,proto3" json:"record_id"`
	// ValidatorAddress is the validator with invalid attestation
	ValidatorAddress string `protobuf:"bytes,2,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// AttestationID is the ID of the invalid attestation
	AttestationId string `protobuf:"bytes,3,opt,name=attestation_id,json=attestationId,proto3" json:"attestation_id"`
	// Reason is why the attestation is invalid
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason"`
	// ExpectedScore is the expected score from consensus
	ExpectedScore int64 `protobuf:"varint,5,opt,name=expected_score,json=expectedScore,proto3" json:"expected_score"`
	// ActualScore is the score the validator reported
	ActualScore int64 `protobuf:"varint,6,opt,name=actual_score,json=actualScore,proto3" json:"actual_score"`
	// ScoreDifference is the difference between expected and actual
	ScoreDifference int64 `protobuf:"varint,7,opt,name=score_difference,json=scoreDifference,proto3" json:"score_difference"`
	// DetectedAt is when the issue was detected
	DetectedAt *time.Time `protobuf:"bytes,8,opt,name=detected_at,json=detectedAt,proto3,stdtime" json:"detected_at" yaml:"detected_at"`
	// DetectedHeight is the block height when detected
	DetectedHeight int64 `protobuf:"varint,9,opt,name=detected_height,json=detectedHeight,proto3" json:"detected_height"`
	// Processed indicates if this evidence has been processed
	Processed bool `protobuf:"varint,10,opt,name=processed,proto3" json:"processed"`
}

func (m *InvalidVEIDAttestation) Reset()         { *m = InvalidVEIDAttestation{} }
func (m *InvalidVEIDAttestation) String() string { return proto.CompactTextString(m) }
func (*InvalidVEIDAttestation) ProtoMessage()    {}
func (*InvalidVEIDAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{6}
}
func (m *InvalidVEIDAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvalidVEIDAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvalidVEIDAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvalidVEIDAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvalidVEIDAttestation.Merge(m, src)
}
func (m *InvalidVEIDAttestation) XXX_Size() int {
	return m.Size()
}
func (m *InvalidVEIDAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_InvalidVEIDAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_InvalidVEIDAttestation proto.InternalMessageInfo

func (m *InvalidVEIDAttestation) GetRecordId() string {
	if m != nil {
		return m.RecordId
	}
	return ""
}

func (m *InvalidVEIDAttestation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *InvalidVEIDAttestation) GetAttestationId() string {
	if m != nil {
		return m.AttestationId
	}
	return ""
}

func (m *InvalidVEIDAttestation) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *InvalidVEIDAttestation) GetExpectedScore() int64 {
	if m != nil {
		return m.ExpectedScore
	}
	return 0
}

func (m *InvalidVEIDAttestation) GetActualScore() int64 {
	if m != nil {
		return m.ActualScore
	}
	return 0
}

func (m *InvalidVEIDAttestation) GetScoreDifference() int64 {
	if m != nil {
		return m.ScoreDifference
	}
	return 0
}

func (m *InvalidVEIDAttestation) GetDetectedAt() *time.Time {
	if m != nil {
		return m.DetectedAt
	}
	return nil
}

func (m *InvalidVEIDAttestation) GetDetectedHeight() int64 {
	if m != nil {
		return m.DetectedHeight
	}
	return 0
}

func (m *InvalidVEIDAttestation) GetProcessed() bool {
	if m != nil {
		return m.Processed
	}
	return false
}

// SlashConfig defines the slashing configuration for a reason
type SlashConfig struct {
	// Reason is the slash reason
	Reason SlashReason `protobuf:"varint,1,opt,name=reason,proto3,enum=virtengine.staking.v1.SlashReason" json:"reason"`
	// SlashPercent is the base slash percentage (fixed-point, 1e6 scale)
	SlashPercent int64 `protobuf:"varint,2,opt,name=slash_percent,json=slashPercent,proto3" json:"slash_percent"`
	// JailDuration is the jail duration in seconds
	JailDuration int64 `protobuf:"varint,3,opt,name=jail_duration,json=jailDuration,proto3" json:"jail_duration"`
	// IsTombstone indicates if this should tombstone the validator
	IsTombstone bool `protobuf:"varint,4,opt,name=is_tombstone,json=isTombstone,proto3" json:"is_tombstone"`
	// EscalationMultiplier is the multiplier for repeat offenses
	EscalationMultiplier int64 `protobuf:"varint,5,opt,name=escalation_multiplier,json=escalationMultiplier,proto3" json:"escalation_multiplier"`
}

func (m *SlashConfig) Reset()         { *m = SlashConfig{} }
func (m *SlashConfig) String() string { return proto.CompactTextString(m) }
func (*SlashConfig) ProtoMessage()    {}
func (*SlashConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_4dea8fe2866e6012, []int{7}
}
func (m *SlashConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SlashConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SlashConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SlashConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SlashConfig.Merge(m, src)
}
func (m *SlashConfig) XXX_Size() int {
	return m.Size()
}
func (m *SlashConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SlashConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SlashConfig proto.InternalMessageInfo

func (m *SlashConfig) GetReason() SlashReason {
	if m != nil {
		return m.Reason
	}
	return SlashReasonUnspecified
}

func (m *SlashConfig) GetSlashPercent() int64 {
	if m != nil {
		return m.SlashPercent
	}
	return 0
}

func (m *SlashConfig) GetJailDuration() int64 {
	if m != nil {
		return m.JailDuration
	}
	return 0
}

func (m *SlashConfig) GetIsTombstone() bool {
	if m != nil {
		return m.IsTombstone
	}
	return false
}

func (m *SlashConfig) GetEscalationMultiplier() int64 {
	if m != nil {
		return m.EscalationMultiplier
	}
	return 0
}

func init() {
	proto.RegisterEnum("virtengine.staking.v1.SlashReason", SlashReason_name, SlashReason_value)
	proto.RegisterEnum("virtengine.staking.v1.RewardType", RewardType_name, RewardType_value)
	proto.RegisterType((*ValidatorPerformance)(nil), "virtengine.staking.v1.ValidatorPerformance")
	proto.RegisterType((*ValidatorSigningInfo)(nil), "virtengine.staking.v1.ValidatorSigningInfo")
	proto.RegisterType((*RewardEpoch)(nil), "virtengine.staking.v1.RewardEpoch")
	proto.RegisterType((*ValidatorReward)(nil), "virtengine.staking.v1.ValidatorReward")
	proto.RegisterType((*SlashRecord)(nil), "virtengine.staking.v1.SlashRecord")
	proto.RegisterType((*DoubleSignEvidence)(nil), "virtengine.staking.v1.DoubleSignEvidence")
	proto.RegisterType((*InvalidVEIDAttestation)(nil), "virtengine.staking.v1.InvalidVEIDAttestation")
	proto.RegisterType((*SlashConfig)(nil), "virtengine.staking.v1.SlashConfig")
}

func init() { proto.RegisterFile("virtengine/staking/v1/types.proto", fileDescriptor_4dea8fe2866e6012) }

var fileDescriptor_4dea8fe2866e6012 = []byte{
	// 2878 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x5a, 0xcd, 0x73, 0x1b, 0xc7,
	0xb1, 0x17, 0xf8, 0x09, 0x0c, 0x40, 0x12, 0x5a, 0x91, 0x22, 0x08, 0x49, 0x5c, 0x88, 0xf5, 0x5c,
	0xe6, 0xb3, 0x2d, 0xd0, 0xa4, 0xde, 0xf3, 0x7b, 0x76, 0x9c, 0x38, 0x00, 0xb1, 0x96, 0x11, 0x91,
	0x00, 0x3d, 0x00, 0xc5, 0x28, 0x39, 0x6c, 0x2d, 0x76, 0x07, 0xe0, 0x9a, 0xc0, 0x2e, 0xb2, 0xbb,
	0xa0, 0xac, 0x94, 0x2b, 0x95, 0x63, 0x0a, 0xb9, 0xf8, 0x92, 0x43, 0x0e, 0xa8, 0xa4, 0x2a, 0xc9,
	0xc5, 0xb9, 0xa5, 0x72, 0xc8, 0x21, 0x87, 0x1c, 0x5d, 0x95, 0x8b, 0x2b, 0xa7, 0x9c, 0xd6, 0x29,
	0x3a, 0x87, 0x04, 0x47, 0xfe, 0x05, 0xa9, 0xf9, 0xd8, 0x9d, 0x59, 0x80, 0x14, 0x48, 0x57, 0x25,
	0xba, 0x48, 0xdb, 0xbf, 0xfe, 0x98, 0x9e, 0x99, 0xee, 0x9e, 0x9e, 0x21, 0xc0, 0xfd, 0x53, 0xd3,
	0xf1, 0x90, 0xd5, 0x32, 0x2d, 0xb4, 0xe5, 0x7a, 0xda, 0x89, 0x69, 0xb5, 0xb6, 0x4e, 0xb7, 0xb7,
	0xbc, 0xe7, 0x5d, 0xe4, 0xe6, 0xbb, 0x8e, 0xed, 0xd9, 0xd2, 0x0a, 0x17, 0xc9, 0x33, 0x91, 0xfc,
	0xe9, 0x76, 0x76, 0xb9, 0x65, 0xb7, 0x6c, 0x22, 0xb1, 0x85, 0xbf, 0xa8, 0x70, 0x76, 0x4d, 0xb7,
	0xdd, 0x8e, 0xed, 0xaa, 0x94, 0x41, 0x09, 0xc6, 0xba, 0xa9, 0x75, 0x4c, 0xcb, 0xde, 0x22, 0xff,
	0x32, 0x68, 0x9d, 0x0a, 0x6c, 0x35, 0x34, 0x17, 0x6d, 0x9d, 0x6e, 0x37, 0x90, 0xa7, 0x6d, 0x6f,
	0xe9, 0xb6, 0x69, 0x31, 0xbe, 0xdc, 0xb2, 0xed, 0x56, 0x1b, 0x6d, 0x11, 0xaa, 0xd1, 0x6b, 0x6e,
	0x79, 0x66, 0x07, 0xb9, 0x9e, 0xd6, 0xe9, 0x52, 0x81, 0x8d, 0xdf, 0x01, 0xb0, 0xfc, 0x44, 0x6b,
	0x9b, 0x86, 0xe6, 0xd9, 0xce, 0x01, 0x72, 0x9a, 0xb6, 0xd3, 0xd1, 0x2c, 0x1d, 0x49, 0xa7, 0xe0,
	0xe6, 0x69, 0x80, 0xab, 0x9a, 0x61, 0x38, 0xc8, 0x75, 0x33, 0xb1, 0x5c, 0x6c, 0x33, 0x51, 0x2c,
	0x0f, 0x7d, 0x79, 0x9c, 0x79, 0xee, 0xcb, 0x99, 0xe7, 0x5a, 0xa7, 0xfd, 0xce, 0xc6, 0x18, 0x6b,
	0xe3, 0x2f, 0xbf, 0x7f, 0xb0, 0xcc, 0xa6, 0x52, 0xa0, 0x50, 0xcd, 0x73, 0x4c, 0xab, 0x05, 0xd3,
	0xa1, 0x2c, 0xc3, 0xa5, 0x77, 0xc1, 0x52, 0xa3, 0x6d, 0xeb, 0x27, 0x64, 0x05, 0xba, 0xb6, 0x8b,
	0x8c, 0xcc, 0x54, 0x2e, 0xb6, 0x39, 0x5d, 0xbc, 0x35, 0xf4, 0xe5, 0x51, 0x16, 0x5c, 0xa4, 0xc0,
	0x01, 0xa3, 0x05, 0x6d, 0xf4, 0x71, 0x17, 0xe9, 0x1e, 0x32, 0x32, 0xd3, 0x63, 0xda, 0x01, 0x2b,
	0xd0, 0x56, 0x18, 0x2d, 0xbd, 0x05, 0x16, 0x98, 0x48, 0xc7, 0x74, 0xf1, 0xc8, 0x33, 0x44, 0xf7,
	0xe6, 0xd0, 0x97, 0xa3, 0x0c, 0x98, 0xa2, 0xe4, 0x3e, 0xa1, 0xa4, 0xf7, 0x40, 0xda, 0xb3, 0x3d,
	0xad, 0xad, 0xba, 0x66, 0xcb, 0xd2, 0xbc, 0x9e, 0x83, 0xdc, 0xcc, 0x2c, 0x51, 0x5d, 0x1e, 0xfa,
	0xf2, 0x18, 0x0f, 0x2e, 0x11, 0xa4, 0x16, 0x02, 0xd2, 0x8f, 0x63, 0xe0, 0xee, 0x29, 0x32, 0x0d,
	0xf5, 0x14, 0x39, 0x66, 0xd3, 0xd4, 0x35, 0xcf, 0xb4, 0x2d, 0x57, 0xd5, 0xed, 0x4e, 0xb7, 0x8d,
	0xf0, 0x24, 0xe6, 0x88, 0xb5, 0x6f, 0x9d, 0xf9, 0x72, 0xf6, 0x89, 0x52, 0x2e, 0x3d, 0x11, 0xc5,
	0x76, 0x03, 0xa9, 0xa1, 0x2f, 0xbf, 0xd0, 0x0a, 0xcc, 0x62, 0xee, 0xc5, 0xba, 0xd2, 0x27, 0xe0,
	0xce, 0x05, 0xba, 0xe1, 0x2a, 0xce, 0x13, 0x07, 0xde, 0x3d, 0xf3, 0xe5, 0xb5, 0x31, 0x07, 0x82,
	0xf5, 0x1b, 0xfa, 0xf2, 0x8b, 0x6c, 0xc0, 0xb5, 0xb1, 0xe1, 0xc3, 0x95, 0x6f, 0x83, 0xd5, 0x31,
	0x4d, 0xd5, 0xd5, 0x6d, 0x07, 0x65, 0xe2, 0x64, 0xe4, 0xff, 0x39, 0xf3, 0xe5, 0x95, 0xd1, 0x91,
	0x6b, 0x58, 0x60, 0xe8, 0xcb, 0x97, 0xe9, 0xc2, 0x95, 0xd1, 0x11, 0x89, 0x86, 0xf4, 0x36, 0x58,
	0xec, 0x75, 0x71, 0x26, 0xa8, 0x2e, 0xd2, 0x6d, 0xcb, 0x70, 0x33, 0x09, 0x32, 0x88, 0x34, 0xf4,
	0xe5, 0x11, 0x0e, 0x5c, 0xa0, 0x74, 0x8d, 0x92, 0x78, 0xab, 0x0d, 0xfb, 0x99, 0x15, 0x51, 0x06,
	0x7c, 0xab, 0x47, 0x79, 0x70, 0x29, 0x40, 0x02, 0x03, 0x4f, 0xc1, 0x9a, 0x6e, 0x5b, 0x2e, 0xd2,
	0x7b, 0x9e, 0x79, 0x8a, 0x58, 0x3c, 0xa9, 0x34, 0x9c, 0x32, 0x49, 0x62, 0xe9, 0xde, 0xd0, 0x97,
	0x2f, 0x17, 0x82, 0xab, 0x02, 0x8b, 0x06, 0x60, 0x91, 0x30, 0xa4, 0xef, 0x80, 0xe5, 0xb6, 0xe6,
	0x7a, 0x61, 0x76, 0xa8, 0xc7, 0xc8, 0x6c, 0x1d, 0x7b, 0x99, 0x14, 0xb1, 0x9a, 0x19, 0xfa, 0xf2,
	0x85, 0x7c, 0x28, 0x61, 0x34, 0x48, 0xa1, 0x0f, 0x08, 0x26, 0x95, 0x00, 0x41, 0x49, 0xd4, 0x72,
	0x4b, 0x0b, 0xc4, 0xd2, 0xed, 0xa1, 0x2f, 0x5f, 0xc0, 0x85, 0x69, 0x8c, 0xd5, 0x08, 0xc4, 0xac,
	0x3c, 0x04, 0x29, 0xd4, 0xb5, 0xf5, 0x63, 0xd5, 0xea, 0x75, 0x1a, 0xc8, 0xc9, 0x2c, 0xe6, 0x62,
	0x9b, 0x33, 0xc5, 0xf4, 0xd0, 0x97, 0x23, 0x38, 0x4c, 0x12, 0xaa, 0x42, 0x08, 0xa9, 0x01, 0x40,
	0xaf, 0x6b, 0x68, 0x1e, 0x32, 0x54, 0xcd, 0xcb, 0x2c, 0xe5, 0x62, 0x9b, 0xc9, 0x9d, 0x6c, 0x9e,
	0x16, 0xb2, 0x7c, 0x50, 0xc8, 0xf2, 0xf5, 0xa0, 0x90, 0x15, 0x5f, 0x1d, 0xfa, 0xb2, 0xa0, 0x71,
	0xee, 0xcb, 0x37, 0x69, 0x1d, 0xe2, 0xd8, 0xc6, 0xa7, 0x5f, 0xca, 0x31, 0x98, 0x60, 0x40, 0xc1,
	0xc3, 0x99, 0x6e, 0x9f, 0x22, 0x47, 0x6b, 0xb7, 0x59, 0x94, 0xa5, 0x79, 0xa6, 0x47, 0x18, 0x30,
	0xc5, 0x48, 0x12, 0x39, 0xef, 0xcc, 0xfc, 0xe3, 0x97, 0x72, 0x6c, 0xe3, 0xb3, 0x19, 0xa1, 0x68,
	0xe2, 0x09, 0x9b, 0x56, 0xab, 0x6c, 0x35, 0xed, 0x97, 0x56, 0x34, 0x1f, 0x82, 0x94, 0xeb, 0x69,
	0x8e, 0x17, 0xec, 0x13, 0xad, 0x98, 0x64, 0x9d, 0x45, 0x1c, 0x26, 0x09, 0xc5, 0x37, 0xc7, 0xb4,
	0x0c, 0xf4, 0xb1, 0x6a, 0x37, 0x9b, 0x2e, 0xf2, 0x58, 0xa1, 0x24, 0x4a, 0x22, 0x0e, 0x93, 0x84,
	0xaa, 0x12, 0x42, 0xfa, 0x08, 0xa4, 0x3e, 0xd2, 0xcc, 0x36, 0x32, 0xd4, 0x9e, 0xe5, 0x99, 0x6d,
	0x52, 0x21, 0x5f, 0xbc, 0x3d, 0xaf, 0x63, 0x83, 0xa2, 0xce, 0xb9, 0x2f, 0xdf, 0xa2, 0x73, 0x16,
	0x51, 0xba, 0x45, 0x49, 0x0a, 0x1d, 0x62, 0x44, 0xca, 0x03, 0xe0, 0xd9, 0x9d, 0x86, 0xeb, 0xd9,
	0x16, 0x32, 0x48, 0x41, 0x8d, 0x17, 0x17, 0xf1, 0x66, 0x73, 0x14, 0x0a, 0xdf, 0xd2, 0x3e, 0x58,
	0x89, 0x64, 0x8a, 0xaa, 0xdb, 0x3d, 0xcb, 0x43, 0x0e, 0xab, 0x9e, 0x6b, 0x43, 0x5f, 0xbe, 0x58,
	0x00, 0xde, 0xea, 0x08, 0x79, 0xb4, 0x4b, 0x41, 0x9c, 0xea, 0xa6, 0xd5, 0x74, 0x34, 0x9d, 0x14,
	0x14, 0x22, 0xca, 0xca, 0x20, 0x49, 0xf5, 0x51, 0x1e, 0x5c, 0xe2, 0x08, 0x31, 0xc1, 0x82, 0xe5,
	0xef, 0x09, 0x90, 0x84, 0xe8, 0x99, 0xe6, 0x18, 0x0a, 0x0e, 0xf2, 0xb1, 0x9c, 0x88, 0x5d, 0x25,
	0x27, 0xbe, 0xd6, 0x06, 0x3f, 0x00, 0x00, 0x59, 0x61, 0xee, 0xd2, 0xed, 0x25, 0xeb, 0xc7, 0x51,
	0x98, 0x40, 0x56, 0x90, 0xac, 0x0d, 0x00, 0xa8, 0x2d, 0x5c, 0xae, 0xae, 0xb0, 0xb1, 0x24, 0xef,
	0xb8, 0x06, 0xcf, 0x3b, 0x8e, 0xb1, 0xbc, 0x23, 0x00, 0x56, 0x94, 0x0c, 0x10, 0xc7, 0x83, 0x93,
	0x11, 0x66, 0x27, 0x8e, 0xf0, 0x00, 0x17, 0x9a, 0x40, 0xfe, 0x0d, 0xbb, 0x63, 0x7a, 0xa8, 0xd3,
	0xf5, 0x9e, 0x9f, 0xfb, 0xf2, 0x12, 0x1d, 0x29, 0xe0, 0xd1, 0x71, 0xe6, 0x91, 0x65, 0x90, 0x51,
	0x3e, 0x8f, 0x81, 0x35, 0x7a, 0xe8, 0x3a, 0x64, 0xe1, 0x5d, 0xd5, 0x30, 0x5d, 0xcf, 0x31, 0x1b,
	0x3d, 0x7a, 0x96, 0x4e, 0x6f, 0x26, 0x77, 0xd6, 0xf2, 0x2c, 0xb7, 0x70, 0xeb, 0x94, 0x67, 0xad,
	0x53, 0x7e, 0xd7, 0x36, 0xad, 0xe2, 0x0f, 0x3e, 0xf7, 0xe5, 0x1b, 0xb8, 0x06, 0x5f, 0x6a, 0xe3,
	0xdc, 0x97, 0x73, 0xd4, 0x83, 0x4b, 0x45, 0x36, 0x3e, 0xfb, 0x52, 0xde, 0x6c, 0x99, 0xde, 0x71,
	0xaf, 0x91, 0xd7, 0xed, 0x0e, 0xeb, 0xe4, 0xd8, 0x7f, 0x0f, 0x5c, 0xe3, 0x84, 0xb5, 0x88, 0x78,
	0x44, 0x17, 0xae, 0x12, 0x3b, 0x34, 0x4c, 0xdc, 0x12, 0xb7, 0x22, 0xfd, 0x31, 0x06, 0x6e, 0x93,
	0x60, 0x65, 0x55, 0x9b, 0x0f, 0x96, 0x99, 0x9f, 0x34, 0x8f, 0x13, 0x36, 0x8f, 0x4b, 0x0c, 0x9c,
	0xfb, 0xf2, 0x3d, 0x3a, 0x89, 0x8b, 0xf9, 0xd7, 0x9b, 0xc1, 0x32, 0x31, 0x72, 0xc0, 0x6c, 0xb0,
	0x99, 0x48, 0xbf, 0x8e, 0x81, 0x14, 0x39, 0x9c, 0x03, 0xa7, 0xe3, 0x93, 0x9c, 0x6e, 0x62, 0xa7,
	0xcf, 0x7c, 0x39, 0x89, 0x0f, 0x7b, 0x66, 0x06, 0x87, 0xb9, 0x68, 0x85, 0x57, 0x10, 0x11, 0xbd,
	0x9e, 0xbf, 0x49, 0xac, 0x1a, 0xb8, 0x39, 0x88, 0x85, 0x1d, 0x41, 0xe0, 0x68, 0x62, 0x92, 0xa3,
	0xdf, 0x67, 0xab, 0x3b, 0xa2, 0x78, 0xee, 0xcb, 0x2b, 0xc1, 0xf1, 0x23, 0xe2, 0xd7, 0xf3, 0x8e,
	0x75, 0x1d, 0x81, 0x7f, 0xef, 0x82, 0x25, 0x7e, 0x3e, 0xd0, 0x4a, 0x04, 0x78, 0x5b, 0x3b, 0xc2,
	0x82, 0x8b, 0x21, 0x40, 0xea, 0x90, 0xf4, 0x26, 0x48, 0xb2, 0x16, 0xd4, 0xd3, 0x4e, 0x10, 0x69,
	0x32, 0x12, 0xc5, 0xa5, 0xa1, 0x2f, 0x8b, 0x30, 0xae, 0xa4, 0xb8, 0x29, 0xc5, 0xdf, 0xd2, 0xeb,
	0x20, 0xd1, 0x34, 0x2d, 0xad, 0x6d, 0xfe, 0x10, 0x19, 0xa4, 0x7d, 0x88, 0x17, 0x17, 0x86, 0xbe,
	0xcc, 0x41, 0xc8, 0x3f, 0x59, 0x99, 0xfb, 0x73, 0x12, 0x2c, 0x85, 0x67, 0x22, 0xf5, 0xfb, 0x65,
	0x1e, 0x87, 0x91, 0x12, 0x3b, 0x75, 0x95, 0x12, 0xfb, 0xb3, 0x18, 0x48, 0x89, 0xd9, 0x9c, 0x99,
	0x9e, 0x14, 0x01, 0x47, 0x2c, 0x02, 0x22, 0x6a, 0x3c, 0x36, 0x45, 0xf4, 0x9a, 0xb1, 0x29, 0x54,
	0x03, 0xe9, 0x0f, 0x31, 0xb0, 0x72, 0x61, 0x82, 0x66, 0x66, 0x26, 0x39, 0x68, 0x32, 0x07, 0x2f,
	0xd6, 0x3f, 0xf7, 0xe5, 0xbb, 0x2f, 0xc8, 0xff, 0xeb, 0xb9, 0x7c, 0xeb, 0x82, 0xf4, 0x97, 0x7e,
	0x11, 0x03, 0x49, 0x21, 0x43, 0x33, 0xb3, 0x93, 0x1c, 0xd6, 0x59, 0xf2, 0x03, 0x9e, 0xfc, 0x38,
	0x4c, 0x05, 0x1b, 0xe7, 0xbe, 0x2c, 0x8d, 0xa5, 0xfe, 0xf5, 0x5c, 0x05, 0x3c, 0xf3, 0xa5, 0x9f,
	0xc7, 0xc0, 0x42, 0x24, 0x4f, 0x27, 0x9f, 0x0e, 0x4f, 0xd9, 0xa2, 0x46, 0xf5, 0xce, 0x7d, 0x79,
	0xf9, 0x82, 0xb4, 0xbf, 0x9e, 0x67, 0x29, 0x31, 0xeb, 0xa5, 0x3f, 0xc5, 0xc0, 0xaa, 0x69, 0x20,
	0xcb, 0x33, 0xbd, 0xe7, 0xaa, 0x85, 0xbc, 0x67, 0xb6, 0x73, 0x12, 0x78, 0x39, 0xb1, 0xf6, 0x77,
	0x98, 0x97, 0x97, 0x59, 0x38, 0xf7, 0xe5, 0x75, 0xea, 0xef, 0x25, 0x02, 0xd7, 0xf3, 0x7c, 0x25,
	0xb0, 0x52, 0xa1, 0x46, 0xd8, 0x14, 0x8a, 0xe0, 0x66, 0x97, 0xbf, 0x29, 0x44, 0x2e, 0x74, 0x2b,
	0xb8, 0x00, 0x8c, 0x31, 0x61, 0x5a, 0x80, 0xe8, 0x65, 0x8d, 0xb6, 0x3e, 0x27, 0x48, 0x7d, 0x46,
	0xfb, 0x98, 0x04, 0xa9, 0x1f, 0x41, 0xeb, 0x13, 0xe2, 0xa4, 0xf5, 0x39, 0x41, 0x47, 0xb4, 0x97,
	0xb1, 0xc0, 0x82, 0xae, 0xb5, 0xf5, 0x5e, 0x3b, 0xb8, 0x46, 0x80, 0x2b, 0x35, 0x1b, 0x51, 0x25,
	0xbe, 0xa7, 0x11, 0x98, 0x36, 0x1b, 0x29, 0x8e, 0x15, 0x48, 0x2f, 0x4d, 0x93, 0x88, 0x35, 0x5b,
	0x49, 0xde, 0x9f, 0x89, 0x38, 0x4c, 0x12, 0x8a, 0x35, 0x5c, 0xaf, 0x80, 0x79, 0xbd, 0xad, 0x99,
	0x9d, 0xb0, 0xc6, 0x26, 0x87, 0xbe, 0x1c, 0x40, 0x30, 0xf8, 0x90, 0xda, 0x00, 0xb0, 0x4f, 0x3c,
	0x91, 0x85, 0x89, 0x13, 0xd9, 0xc6, 0x17, 0x3d, 0xae, 0x11, 0xe9, 0x9b, 0x58, 0x87, 0xc6, 0xb9,
	0xac, 0x43, 0x63, 0x40, 0x21, 0x68, 0x5a, 0x7f, 0x9b, 0x00, 0xc9, 0x5a, 0x5b, 0x73, 0x8f, 0x21,
	0xd2, 0x6d, 0xc7, 0x90, 0xde, 0x01, 0x71, 0x17, 0x93, 0xaa, 0x69, 0xb0, 0x02, 0x2e, 0x0f, 0x7d,
	0x39, 0xc4, 0x78, 0x47, 0x16, 0x20, 0x1b, 0x70, 0x9e, 0x7c, 0x96, 0x2f, 0x39, 0x05, 0xa6, 0xfe,
	0xfd, 0xa7, 0xc0, 0x11, 0x98, 0x73, 0x90, 0xe6, 0xda, 0x16, 0x69, 0x7d, 0x17, 0x77, 0x36, 0xf2,
	0x17, 0xbe, 0xc3, 0xe5, 0xd9, 0x3c, 0xb1, 0x64, 0xf1, 0xce, 0xd0, 0x97, 0x99, 0xd6, 0xb9, 0x2f,
	0x2f, 0x50, 0x2f, 0x28, 0xbd, 0x01, 0x19, 0x43, 0xfa, 0x11, 0x98, 0xd3, 0x3a, 0xe4, 0x10, 0x9e,
	0x58, 0x81, 0x1f, 0xb3, 0x34, 0x64, 0x0a, 0xdc, 0x26, 0xa5, 0xaf, 0x97, 0x64, 0xcc, 0x08, 0xbe,
	0xbc, 0xd2, 0x65, 0xee, 0x22, 0x47, 0x47, 0x96, 0xc7, 0xde, 0x9a, 0xc8, 0xe5, 0x35, 0xc2, 0x80,
	0x29, 0x42, 0x1e, 0x50, 0x0a, 0x67, 0xa3, 0x70, 0x69, 0x61, 0x91, 0x3a, 0xc7, 0xb3, 0x71, 0x8c,
	0x09, 0x85, 0x4b, 0x0e, 0xbf, 0x34, 0xd2, 0x21, 0x98, 0xfa, 0xbc, 0x70, 0x11, 0x11, 0x70, 0x98,
	0x24, 0x94, 0x70, 0xb3, 0x20, 0x4c, 0xd2, 0xf7, 0xc7, 0xaf, 0x78, 0xb3, 0x08, 0x35, 0x84, 0x9b,
	0x45, 0x88, 0x05, 0x37, 0x0b, 0x0c, 0x90, 0x9e, 0x7f, 0x03, 0xcc, 0xd1, 0xbb, 0x23, 0x29, 0x10,
	0xf1, 0x22, 0xc0, 0xab, 0x4e, 0x11, 0xc8, 0xfe, 0xc7, 0x0b, 0x87, 0xbf, 0x54, 0xa3, 0xe7, 0x90,
	0xd7, 0x20, 0xd6, 0x44, 0x91, 0x85, 0x8b, 0x30, 0x20, 0xb9, 0xb0, 0x96, 0x18, 0x25, 0x79, 0x23,
	0x97, 0xde, 0xe4, 0xc4, 0x19, 0xfc, 0x2f, 0x6e, 0xbb, 0x45, 0x9d, 0x48, 0x16, 0x7e, 0x9d, 0xeb,
	0x6f, 0x6a, 0xe2, 0xf5, 0x77, 0x07, 0xc4, 0xd1, 0x29, 0xae, 0xc3, 0x3a, 0x22, 0x55, 0x22, 0x41,
	0x1f, 0x6a, 0x02, 0x8c, 0x7b, 0x00, 0x43, 0x39, 0xe9, 0xdb, 0x60, 0x21, 0xf8, 0x56, 0x8f, 0x35,
	0xf7, 0x98, 0xbc, 0xd0, 0x24, 0x48, 0x1a, 0xac, 0x46, 0x18, 0x82, 0x76, 0x2a, 0x60, 0x7c, 0xa0,
	0xb9, 0xc7, 0xd2, 0x27, 0x20, 0xed, 0xa0, 0xae, 0xed, 0x78, 0x88, 0x27, 0xf7, 0x12, 0x31, 0xf2,
	0xe1, 0xd0, 0x97, 0xb3, 0xa3, 0xbc, 0xc8, 0x3a, 0xac, 0x06, 0xf9, 0x15, 0x95, 0xb9, 0x3c, 0xc9,
	0x97, 0x02, 0x51, 0x06, 0x07, 0xbd, 0xe7, 0x0c, 0x90, 0x4a, 0x76, 0xaf, 0xd1, 0x46, 0x35, 0xb3,
	0x65, 0x29, 0xc1, 0xe4, 0xde, 0x04, 0xc9, 0x70, 0x0e, 0x61, 0xdd, 0x22, 0x7d, 0xaf, 0x00, 0x43,
	0x10, 0x10, 0x2f, 0xb1, 0x54, 0xbd, 0x0a, 0xe2, 0x34, 0x6f, 0xd4, 0x6d, 0x76, 0x4f, 0x4f, 0xe1,
	0xf2, 0x1a, 0x60, 0x70, 0x9e, 0x7e, 0x6d, 0x0b, 0x82, 0x3b, 0xec, 0x71, 0x5a, 0x14, 0xdc, 0x09,
	0x04, 0x77, 0xa4, 0x2d, 0x90, 0x3c, 0xb5, 0x3d, 0xba, 0x77, 0xea, 0x36, 0xa9, 0x10, 0x6c, 0xee,
	0x02, 0x0c, 0x13, 0x98, 0xc0, 0xdb, 0xb8, 0x1d, 0x55, 0xd8, 0x21, 0x65, 0x61, 0x4c, 0x61, 0x87,
	0x2b, 0xec, 0x48, 0x4d, 0x90, 0x34, 0x90, 0x47, 0x9e, 0x6f, 0xf1, 0xb9, 0x34, 0x3f, 0x31, 0x27,
	0xfe, 0x1b, 0x1b, 0x13, 0x54, 0x78, 0x2b, 0x27, 0x80, 0x34, 0x0f, 0x40, 0x80, 0x14, 0x3c, 0x7c,
	0xf7, 0x09, 0xf9, 0xac, 0xe8, 0xc4, 0xf9, 0xdd, 0x67, 0x84, 0x05, 0x17, 0x03, 0x80, 0x95, 0x9e,
	0xd7, 0x41, 0xa2, 0xeb, 0xd8, 0x3a, 0x22, 0xcf, 0xf9, 0x09, 0x7e, 0x93, 0x09, 0x41, 0xc8, 0x3f,
	0x59, 0x34, 0xfd, 0x66, 0x16, 0xdc, 0x2e, 0x5b, 0x64, 0x8f, 0x70, 0x1b, 0x5a, 0xf0, 0x3c, 0x3c,
	0x01, 0x52, 0x08, 0x5e, 0x03, 0x09, 0x87, 0x1c, 0x88, 0x3c, 0x9e, 0x88, 0xb5, 0x10, 0x84, 0x71,
	0xfa, 0xf9, 0x12, 0x63, 0xe9, 0x6d, 0xb0, 0xa8, 0x71, 0x97, 0xb1, 0xa3, 0xd3, 0x64, 0x50, 0xf2,
	0xb8, 0x1d, 0xe5, 0xc0, 0x05, 0x81, 0x2e, 0x1b, 0xb8, 0x86, 0xb2, 0x13, 0x73, 0x86, 0xa8, 0x00,
	0x7e, 0x1a, 0x86, 0x87, 0xdf, 0xdb, 0x60, 0x31, 0x78, 0xd0, 0x67, 0xfd, 0xdc, 0x2c, 0x7f, 0x3b,
	0x8f, 0x72, 0xe0, 0x42, 0x40, 0x87, 0x9d, 0x9c, 0xa6, 0x7b, 0x3d, 0x2d, 0x78, 0x73, 0x9d, 0xe3,
	0x67, 0x87, 0x88, 0xc3, 0x24, 0xa5, 0xa8, 0xd2, 0x7b, 0x20, 0x4d, 0x50, 0xd5, 0x30, 0x9b, 0x4d,
	0xe4, 0x90, 0xea, 0x26, 0xbc, 0xc2, 0x8d, 0xf2, 0xe0, 0x12, 0x41, 0x4a, 0x21, 0x30, 0x1a, 0xa7,
	0xf1, 0xff, 0x60, 0x9c, 0x26, 0xbe, 0x66, 0x9c, 0x82, 0x2b, 0xc5, 0xe9, 0x17, 0x53, 0xac, 0x47,
	0xdb, 0xb5, 0xad, 0xa6, 0xd9, 0x92, 0xde, 0x0f, 0x77, 0x2f, 0x76, 0xe5, 0x7e, 0xe7, 0xa2, 0x1d,
	0x1e, 0x6b, 0x2f, 0xa6, 0xae, 0xd6, 0x5e, 0x8c, 0x9d, 0xae, 0xd3, 0x57, 0x3b, 0x5d, 0x1f, 0x82,
	0x94, 0xe9, 0xaa, 0xe1, 0x41, 0x46, 0x62, 0x2f, 0xce, 0xde, 0xa1, 0x05, 0x1c, 0x26, 0x4d, 0xb7,
	0x1e, 0x10, 0x52, 0x05, 0xac, 0x20, 0x57, 0xd7, 0xda, 0x34, 0x94, 0x3b, 0xbd, 0xb6, 0x67, 0x76,
	0xdb, 0x26, 0x72, 0x58, 0x34, 0x92, 0xb7, 0xde, 0x0b, 0x05, 0xe0, 0x32, 0x87, 0xf7, 0x43, 0x94,
	0x2e, 0xe9, 0x6b, 0x3f, 0x9d, 0x0d, 0xdb, 0x5e, 0xb2, 0x14, 0xff, 0x0f, 0x32, 0xb5, 0xbd, 0x42,
	0xed, 0x03, 0x15, 0x2a, 0x85, 0x5a, 0xb5, 0xa2, 0x1e, 0x56, 0x6a, 0x07, 0xca, 0x6e, 0xf9, 0xfd,
	0xb2, 0x52, 0x4a, 0xdf, 0xc8, 0x66, 0xfb, 0x83, 0xdc, 0x6d, 0x41, 0xfc, 0xd0, 0x72, 0xbb, 0x48,
	0x37, 0x9b, 0x26, 0x32, 0xa4, 0x6f, 0x82, 0x3b, 0x11, 0xcd, 0x52, 0xf5, 0xb0, 0xb8, 0xa7, 0xa8,
	0xb5, 0xf2, 0xa3, 0x4a, 0xb9, 0xf2, 0x28, 0x1d, 0xcb, 0xde, 0xed, 0x0f, 0x72, 0x19, 0x41, 0x99,
	0x9f, 0x5f, 0xa6, 0xd5, 0x92, 0x76, 0xc0, 0xca, 0x88, 0xfa, 0x51, 0xa5, 0x5e, 0xde, 0x57, 0xd2,
	0x53, 0xd9, 0xd5, 0xfe, 0x20, 0x77, 0x2b, 0xa2, 0x48, 0xff, 0xc0, 0x24, 0x1d, 0x80, 0x57, 0x22,
	0x3a, 0xe5, 0xca, 0x93, 0xc2, 0x5e, 0xb9, 0xa4, 0xe2, 0x22, 0xa6, 0x16, 0xea, 0x75, 0xa5, 0x56,
	0x2f, 0xd4, 0xcb, 0xd5, 0x4a, 0x7a, 0x3a, 0xfb, 0x4a, 0x7f, 0x90, 0xbb, 0x2f, 0xd8, 0xb8, 0xa4,
	0xdc, 0x95, 0xc1, 0xfd, 0x88, 0xc5, 0xfd, 0x72, 0xad, 0xa6, 0x94, 0x54, 0xa8, 0xec, 0x56, 0xf7,
	0x0f, 0x0e, 0x99, 0xb5, 0x99, 0xec, 0x46, 0x7f, 0x90, 0x5b, 0x17, 0xac, 0xd1, 0x3f, 0x4a, 0xe1,
	0x9b, 0x43, 0xa7, 0xdb, 0x63, 0xa6, 0x14, 0x20, 0x8f, 0x38, 0xb7, 0x5b, 0xad, 0xd4, 0xca, 0xb5,
	0xba, 0x52, 0xa9, 0xab, 0xb5, 0xdd, 0x2a, 0x54, 0xd2, 0xb3, 0xd9, 0x5c, 0x7f, 0x90, 0xbb, 0x1b,
	0x71, 0x4b, 0xb7, 0x2d, 0xd7, 0x74, 0x3d, 0x64, 0x79, 0xb4, 0x1a, 0x3c, 0x02, 0xb9, 0x88, 0x19,
	0xe5, 0xbb, 0x07, 0x65, 0xa8, 0x44, 0xa7, 0x37, 0x97, 0xbd, 0xdf, 0x1f, 0xe4, 0xee, 0x09, 0x76,
	0x94, 0x8f, 0xbb, 0xa6, 0x83, 0x93, 0x94, 0x4f, 0xad, 0x34, 0xe2, 0x4f, 0x49, 0x29, 0x1e, 0x3e,
	0x52, 0xf7, 0xab, 0x25, 0x45, 0x55, 0x2a, 0x85, 0xe2, 0x9e, 0x52, 0x4a, 0xcf, 0x67, 0xe5, 0xfe,
	0x20, 0x77, 0x47, 0x5c, 0x6a, 0xd4, 0xe8, 0xb5, 0xf6, 0x6d, 0x03, 0x29, 0x96, 0xd6, 0xc0, 0x0d,
	0xe5, 0x13, 0xb0, 0x19, 0xb1, 0x52, 0xa9, 0x56, 0xd4, 0xc2, 0xde, 0x5e, 0xf5, 0x68, 0x0f, 0xcf,
	0xac, 0xa4, 0xee, 0x2b, 0x85, 0xda, 0x21, 0x54, 0xf6, 0x95, 0x4a, 0x3d, 0x1d, 0xcf, 0x6e, 0xf6,
	0x07, 0xb9, 0xff, 0x12, 0xcc, 0x55, 0x6c, 0xab, 0xd0, 0x6e, 0xdb, 0xcf, 0xda, 0x78, 0x86, 0xc6,
	0x3e, 0xd2, 0xdc, 0x9e, 0x83, 0x3a, 0xc8, 0xf2, 0xb2, 0x33, 0x3f, 0xf9, 0xd5, 0xfa, 0x8d, 0xd7,
	0xfe, 0x39, 0x05, 0x00, 0xbd, 0x48, 0xd7, 0x9f, 0x77, 0x91, 0xf4, 0x16, 0x58, 0x85, 0xca, 0x51,
	0x01, 0x96, 0xd4, 0xfa, 0xd3, 0x03, 0x65, 0x24, 0x16, 0xd7, 0xfa, 0x83, 0xdc, 0x0a, 0x17, 0x16,
	0x43, 0xf1, 0x1b, 0x20, 0x2b, 0xea, 0x15, 0xf7, 0xaa, 0xbb, 0x8f, 0xd5, 0x03, 0x58, 0x3d, 0xa8,
	0xd6, 0x0a, 0x7b, 0xe9, 0x58, 0xf6, 0x4e, 0x7f, 0x90, 0x5b, 0xe5, 0xaa, 0x45, 0xf1, 0x21, 0x47,
	0x2a, 0x80, 0x7b, 0xa2, 0x32, 0x89, 0xa5, 0x27, 0x0a, 0x2c, 0xbf, 0x5f, 0xde, 0xa5, 0xab, 0x3d,
	0x95, 0x5d, 0xef, 0x0f, 0x72, 0x59, 0xae, 0x3f, 0xfa, 0x47, 0x5a, 0xe9, 0x0d, 0x20, 0x45, 0xfc,
	0x3e, 0x20, 0x81, 0x3c, 0x9d, 0x5d, 0xee, 0x0f, 0x72, 0x69, 0xc1, 0x65, 0xf2, 0xf6, 0x21, 0xbd,
	0x07, 0xee, 0x8a, 0xd2, 0xe5, 0x92, 0x52, 0xa9, 0x97, 0xeb, 0x4f, 0xd5, 0x8a, 0x52, 0x3f, 0xaa,
	0xc2, 0xc7, 0xe9, 0x99, 0xec, 0xbd, 0xfe, 0x20, 0xb7, 0xc6, 0xf5, 0xca, 0xd1, 0x97, 0x07, 0x29,
	0x0f, 0x6e, 0x89, 0x06, 0x6a, 0xf5, 0xc2, 0x63, 0x9c, 0x71, 0xb3, 0xd9, 0x95, 0xfe, 0x20, 0x77,
	0x93, 0xeb, 0xd5, 0x68, 0x45, 0xa4, 0x6b, 0x5d, 0xfc, 0xf0, 0xf3, 0xb3, 0xf5, 0xd8, 0x17, 0x67,
	0xeb, 0xb1, 0xbf, 0x9d, 0xad, 0xc7, 0x3e, 0xfd, 0x6a, 0xfd, 0xc6, 0x17, 0x5f, 0xad, 0xdf, 0xf8,
	0xeb, 0x57, 0xeb, 0x37, 0xbe, 0xf7, 0x7f, 0xc2, 0xfd, 0x4c, 0xf8, 0xad, 0x87, 0xf8, 0xb3, 0x0f,
	0xe3, 0x64, 0xab, 0x65, 0x6f, 0x59, 0xb6, 0x21, 0xfe, 0x04, 0xa4, 0x31, 0x47, 0xce, 0x96, 0x87,
	0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0xa9, 0x3d, 0xfa, 0xa2, 0x22, 0x22, 0x00, 0x00,
}

func (this *ValidatorPerformance) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorPerformance)
	if !ok {
		that2, ok := that.(ValidatorPerformance)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.BlocksProposed != that1.BlocksProposed {
		return false
	}
	if this.BlocksExpected != that1.BlocksExpected {
		return false
	}
	if this.BlocksMissed != that1.BlocksMissed {
		return false
	}
	if this.TotalSignatures != that1.TotalSignatures {
		return false
	}
	if this.VEIDVerificationsCompleted != that1.VEIDVerificationsCompleted {
		return false
	}
	if this.VEIDVerificationsExpected != that1.VEIDVerificationsExpected {
		return false
	}
	if this.VEIDVerificationScore != that1.VEIDVerificationScore {
		return false
	}
	if this.UptimeSeconds != that1.UptimeSeconds {
		return false
	}
	if this.DowntimeSeconds != that1.DowntimeSeconds {
		return false
	}
	if this.ConsecutiveMissedBlocks != that1.ConsecutiveMissedBlocks {
		return false
	}
	if this.LastProposedHeight != that1.LastProposedHeight {
		return false
	}
	if this.LastSignedHeight != that1.LastSignedHeight {
		return false
	}
	if this.EpochNumber != that1.EpochNumber {
		return false
	}
	if that1.UpdatedAt == nil {
		if this.UpdatedAt != nil {
			return false
		}
	} else if !this.UpdatedAt.Equal(*that1.UpdatedAt) {
		return false
	}
	if this.OverallScore != that1.OverallScore {
		return false
	}
	return true
}
func (this *ValidatorSigningInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorSigningInfo)
	if !ok {
		that2, ok := that.(ValidatorSigningInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.StartHeight != that1.StartHeight {
		return false
	}
	if this.IndexOffset != that1.IndexOffset {
		return false
	}
	if that1.JailedUntil == nil {
		if this.JailedUntil != nil {
			return false
		}
	} else if !this.JailedUntil.Equal(*that1.JailedUntil) {
		return false
	}
	if this.Tombstoned != that1.Tombstoned {
		return false
	}
	if this.MissedBlocksCounter != that1.MissedBlocksCounter {
		return false
	}
	if this.InfractionCount != that1.InfractionCount {
		return false
	}
	return true
}
func (this *RewardEpoch) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RewardEpoch)
	if !ok {
		that2, ok := that.(RewardEpoch)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EpochNumber != that1.EpochNumber {
		return false
	}
	if this.StartHeight != that1.StartHeight {
		return false
	}
	if this.EndHeight != that1.EndHeight {
		return false
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if len(this.TotalRewardsDistributed) != len(that1.TotalRewardsDistributed) {
		return false
	}
	for i := range this.TotalRewardsDistributed {
		if !this.TotalRewardsDistributed[i].Equal(&that1.TotalRewardsDistributed[i]) {
			return false
		}
	}
	if len(this.BlockProposalRewards) != len(that1.BlockProposalRewards) {
		return false
	}
	for i := range this.BlockProposalRewards {
		if !this.BlockProposalRewards[i].Equal(&that1.BlockProposalRewards[i]) {
			return false
		}
	}
	if len(this.VEIDRewards) != len(that1.VEIDRewards) {
		return false
	}
	for i := range this.VEIDRewards {
		if !this.VEIDRewards[i].Equal(&that1.VEIDRewards[i]) {
			return false
		}
	}
	if len(this.UptimeRewards) != len(that1.UptimeRewards) {
		return false
	}
	for i := range this.UptimeRewards {
		if !this.UptimeRewards[i].Equal(&that1.UptimeRewards[i]) {
			return false
		}
	}
	if this.ValidatorCount != that1.ValidatorCount {
		return false
	}
	if this.TotalStake != that1.TotalStake {
		return false
	}
	if this.Finalized != that1.Finalized {
		return false
	}
	return true
}
func (this *ValidatorReward) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorReward)
	if !ok {
		that2, ok := that.(ValidatorReward)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.EpochNumber != that1.EpochNumber {
		return false
	}
	if len(this.TotalReward) != len(that1.TotalReward) {
		return false
	}
	for i := range this.TotalReward {
		if !this.TotalReward[i].Equal(&that1.TotalReward[i]) {
			return false
		}
	}
	if len(this.BlockProposalReward) != len(that1.BlockProposalReward) {
		return false
	}
	for i := range this.BlockProposalReward {
		if !this.BlockProposalReward[i].Equal(&that1.BlockProposalReward[i]) {
			return false
		}
	}
	if len(this.VEIDReward) != len(that1.VEIDReward) {
		return false
	}
	for i := range this.VEIDReward {
		if !this.VEIDReward[i].Equal(&that1.VEIDReward[i]) {
			return false
		}
	}
	if len(this.UptimeReward) != len(that1.UptimeReward) {
		return false
	}
	for i := range this.UptimeReward {
		if !this.UptimeReward[i].Equal(&that1.UptimeReward[i]) {
			return false
		}
	}
	if len(this.IdentityNetworkReward) != len(that1.IdentityNetworkReward) {
		return false
	}
	for i := range this.IdentityNetworkReward {
		if !this.IdentityNetworkReward[i].Equal(&that1.IdentityNetworkReward[i]) {
			return false
		}
	}
	if this.PerformanceScore != that1.PerformanceScore {
		return false
	}
	if this.StakeWeight != that1.StakeWeight {
		return false
	}
	if that1.CalculatedAt == nil {
		if this.CalculatedAt != nil {
			return false
		}
	} else if !this.CalculatedAt.Equal(*that1.CalculatedAt) {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	if this.Claimed != that1.Claimed {
		return false
	}
	if that1.ClaimedAt == nil {
		if this.ClaimedAt != nil {
			return false
		}
	} else if !this.ClaimedAt.Equal(*that1.ClaimedAt) {
		return false
	}
	return true
}
func (this *SlashRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlashRecord)
	if !ok {
		that2, ok := that.(SlashRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.SlashId != that1.SlashId {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if len(this.Amount) != len(that1.Amount) {
		return false
	}
	for i := range this.Amount {
		if !this.Amount[i].Equal(&that1.Amount[i]) {
			return false
		}
	}
	if this.SlashPercent != that1.SlashPercent {
		return false
	}
	if this.InfractionHeight != that1.InfractionHeight {
		return false
	}
	if this.SlashHeight != that1.SlashHeight {
		return false
	}
	if that1.SlashTime == nil {
		if this.SlashTime != nil {
			return false
		}
	} else if !this.SlashTime.Equal(*that1.SlashTime) {
		return false
	}
	if this.Jailed != that1.Jailed {
		return false
	}
	if this.JailDuration != that1.JailDuration {
		return false
	}
	if that1.JailedUntil == nil {
		if this.JailedUntil != nil {
			return false
		}
	} else if !this.JailedUntil.Equal(*that1.JailedUntil) {
		return false
	}
	if this.Tombstoned != that1.Tombstoned {
		return false
	}
	if this.Evidence != that1.Evidence {
		return false
	}
	if this.EvidenceHash != that1.EvidenceHash {
		return false
	}
	if this.ReporterAddress != that1.ReporterAddress {
		return false
	}
	return true
}
func (this *DoubleSignEvidence) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*DoubleSignEvidence)
	if !ok {
		that2, ok := that.(DoubleSignEvidence)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.EvidenceId != that1.EvidenceId {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.Height_1 != that1.Height_1 {
		return false
	}
	if this.Height_2 != that1.Height_2 {
		return false
	}
	if this.VoteHash_1 != that1.VoteHash_1 {
		return false
	}
	if this.VoteHash_2 != that1.VoteHash_2 {
		return false
	}
	if that1.DetectedAt == nil {
		if this.DetectedAt != nil {
			return false
		}
	} else if !this.DetectedAt.Equal(*that1.DetectedAt) {
		return false
	}
	if this.DetectedHeight != that1.DetectedHeight {
		return false
	}
	if this.Processed != that1.Processed {
		return false
	}
	return true
}
func (this *InvalidVEIDAttestation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*InvalidVEIDAttestation)
	if !ok {
		that2, ok := that.(InvalidVEIDAttestation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RecordId != that1.RecordId {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.AttestationId != that1.AttestationId {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.ExpectedScore != that1.ExpectedScore {
		return false
	}
	if this.ActualScore != that1.ActualScore {
		return false
	}
	if this.ScoreDifference != that1.ScoreDifference {
		return false
	}
	if that1.DetectedAt == nil {
		if this.DetectedAt != nil {
			return false
		}
	} else if !this.DetectedAt.Equal(*that1.DetectedAt) {
		return false
	}
	if this.DetectedHeight != that1.DetectedHeight {
		return false
	}
	if this.Processed != that1.Processed {
		return false
	}
	return true
}
func (this *SlashConfig) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SlashConfig)
	if !ok {
		that2, ok := that.(SlashConfig)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.SlashPercent != that1.SlashPercent {
		return false
	}
	if this.JailDuration != that1.JailDuration {
		return false
	}
	if this.IsTombstone != that1.IsTombstone {
		return false
	}
	if this.EscalationMultiplier != that1.EscalationMultiplier {
		return false
	}
	return true
}
func (m *ValidatorPerformance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorPerformance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorPerformance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverallScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.OverallScore))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UpdatedAt != nil {
		n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.UpdatedAt):])
		if err1 != nil {
			return 0, err1
		}
		i -= n1
		i = encodeVarintTypes(dAtA, i, uint64(n1))
		i--
		dAtA[i] = 0x7a
	}
	if m.EpochNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x70
	}
	if m.LastSignedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastSignedHeight))
		i--
		dAtA[i] = 0x68
	}
	if m.LastProposedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastProposedHeight))
		i--
		dAtA[i] = 0x60
	}
	if m.ConsecutiveMissedBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConsecutiveMissedBlocks))
		i--
		dAtA[i] = 0x58
	}
	if m.DowntimeSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DowntimeSeconds))
		i--
		dAtA[i] = 0x50
	}
	if m.UptimeSeconds != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UptimeSeconds))
		i--
		dAtA[i] = 0x48
	}
	if m.VEIDVerificationScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VEIDVerificationScore))
		i--
		dAtA[i] = 0x40
	}
	if m.VEIDVerificationsExpected != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VEIDVerificationsExpected))
		i--
		dAtA[i] = 0x38
	}
	if m.VEIDVerificationsCompleted != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VEIDVerificationsCompleted))
		i--
		dAtA[i] = 0x30
	}
	if m.TotalSignatures != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalSignatures))
		i--
		dAtA[i] = 0x28
	}
	if m.BlocksMissed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlocksMissed))
		i--
		dAtA[i] = 0x20
	}
	if m.BlocksExpected != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlocksExpected))
		i--
		dAtA[i] = 0x18
	}
	if m.BlocksProposed != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlocksProposed))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorSigningInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorSigningInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorSigningInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.InfractionCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InfractionCount))
		i--
		dAtA[i] = 0x38
	}
	if m.MissedBlocksCounter != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MissedBlocksCounter))
		i--
		dAtA[i] = 0x30
	}
	if m.Tombstoned {
		i--
		if m.Tombstoned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.JailedUntil != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.JailedUntil, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.JailedUntil):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintTypes(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x22
	}
	if m.IndexOffset != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.IndexOffset))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Finalized {
		i--
		if m.Finalized {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if len(m.TotalStake) > 0 {
		i -= len(m.TotalStake)
		copy(dAtA[i:], m.TotalStake)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.TotalStake)))
		i--
		dAtA[i] = 0x5a
	}
	if m.ValidatorCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ValidatorCount))
		i--
		dAtA[i] = 0x50
	}
	if len(m.UptimeRewards) > 0 {
		for iNdEx := len(m.UptimeRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UptimeRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.VEIDRewards) > 0 {
		for iNdEx := len(m.VEIDRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VEIDRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.BlockProposalRewards) > 0 {
		for iNdEx := len(m.BlockProposalRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockProposalRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TotalRewardsDistributed) > 0 {
		for iNdEx := len(m.TotalRewardsDistributed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalRewardsDistributed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.EndTime != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintTypes(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartTime != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartTime):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintTypes(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x22
	}
	if m.EndHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.StartHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.StartHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.EpochNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorReward) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorReward) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorReward) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimedAt != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ClaimedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ClaimedAt):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTypes(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x6a
	}
	if m.Claimed {
		i--
		if m.Claimed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.CalculatedAt != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CalculatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CalculatedAt):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintTypes(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x52
	}
	if len(m.StakeWeight) > 0 {
		i -= len(m.StakeWeight)
		copy(dAtA[i:], m.StakeWeight)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.StakeWeight)))
		i--
		dAtA[i] = 0x4a
	}
	if m.PerformanceScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PerformanceScore))
		i--
		dAtA[i] = 0x40
	}
	if len(m.IdentityNetworkReward) > 0 {
		for iNdEx := len(m.IdentityNetworkReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IdentityNetworkReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.UptimeReward) > 0 {
		for iNdEx := len(m.UptimeReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UptimeReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.VEIDReward) > 0 {
		for iNdEx := len(m.VEIDReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.VEIDReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.BlockProposalReward) > 0 {
		for iNdEx := len(m.BlockProposalReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.BlockProposalReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TotalReward) > 0 {
		for iNdEx := len(m.TotalReward) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalReward[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.EpochNumber != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReporterAddress) > 0 {
		i -= len(m.ReporterAddress)
		copy(dAtA[i:], m.ReporterAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ReporterAddress)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.EvidenceHash) > 0 {
		i -= len(m.EvidenceHash)
		copy(dAtA[i:], m.EvidenceHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EvidenceHash)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Evidence) > 0 {
		i -= len(m.Evidence)
		copy(dAtA[i:], m.Evidence)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Evidence)))
		i--
		dAtA[i] = 0x6a
	}
	if m.Tombstoned {
		i--
		if m.Tombstoned {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.JailedUntil != nil {
		n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.JailedUntil, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.JailedUntil):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintTypes(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x5a
	}
	if m.JailDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JailDuration))
		i--
		dAtA[i] = 0x50
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.SlashTime != nil {
		n8, err8 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.SlashTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SlashTime):])
		if err8 != nil {
			return 0, err8
		}
		i -= n8
		i = encodeVarintTypes(dAtA, i, uint64(n8))
		i--
		dAtA[i] = 0x42
	}
	if m.SlashHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlashHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.InfractionHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.InfractionHeight))
		i--
		dAtA[i] = 0x30
	}
	if m.SlashPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlashPercent))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Reason != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SlashId) > 0 {
		i -= len(m.SlashId)
		copy(dAtA[i:], m.SlashId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SlashId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DoubleSignEvidence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DoubleSignEvidence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DoubleSignEvidence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.DetectedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DetectedHeight))
		i--
		dAtA[i] = 0x40
	}
	if m.DetectedAt != nil {
		n9, err9 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.DetectedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DetectedAt):])
		if err9 != nil {
			return 0, err9
		}
		i -= n9
		i = encodeVarintTypes(dAtA, i, uint64(n9))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.VoteHash_2) > 0 {
		i -= len(m.VoteHash_2)
		copy(dAtA[i:], m.VoteHash_2)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VoteHash_2)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.VoteHash_1) > 0 {
		i -= len(m.VoteHash_1)
		copy(dAtA[i:], m.VoteHash_1)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.VoteHash_1)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Height_2 != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height_2))
		i--
		dAtA[i] = 0x20
	}
	if m.Height_1 != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Height_1))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EvidenceId) > 0 {
		i -= len(m.EvidenceId)
		copy(dAtA[i:], m.EvidenceId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EvidenceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvalidVEIDAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvalidVEIDAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvalidVEIDAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Processed {
		i--
		if m.Processed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.DetectedHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DetectedHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.DetectedAt != nil {
		n10, err10 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.DetectedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DetectedAt):])
		if err10 != nil {
			return 0, err10
		}
		i -= n10
		i = encodeVarintTypes(dAtA, i, uint64(n10))
		i--
		dAtA[i] = 0x42
	}
	if m.ScoreDifference != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ScoreDifference))
		i--
		dAtA[i] = 0x38
	}
	if m.ActualScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ActualScore))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpectedScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpectedScore))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AttestationId) > 0 {
		i -= len(m.AttestationId)
		copy(dAtA[i:], m.AttestationId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AttestationId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RecordId) > 0 {
		i -= len(m.RecordId)
		copy(dAtA[i:], m.RecordId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RecordId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SlashConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SlashConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SlashConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EscalationMultiplier != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.EscalationMultiplier))
		i--
		dAtA[i] = 0x28
	}
	if m.IsTombstone {
		i--
		if m.IsTombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.JailDuration != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.JailDuration))
		i--
		dAtA[i] = 0x18
	}
	if m.SlashPercent != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SlashPercent))
		i--
		dAtA[i] = 0x10
	}
	if m.Reason != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Reason))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ValidatorPerformance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlocksProposed != 0 {
		n += 1 + sovTypes(uint64(m.BlocksProposed))
	}
	if m.BlocksExpected != 0 {
		n += 1 + sovTypes(uint64(m.BlocksExpected))
	}
	if m.BlocksMissed != 0 {
		n += 1 + sovTypes(uint64(m.BlocksMissed))
	}
	if m.TotalSignatures != 0 {
		n += 1 + sovTypes(uint64(m.TotalSignatures))
	}
	if m.VEIDVerificationsCompleted != 0 {
		n += 1 + sovTypes(uint64(m.VEIDVerificationsCompleted))
	}
	if m.VEIDVerificationsExpected != 0 {
		n += 1 + sovTypes(uint64(m.VEIDVerificationsExpected))
	}
	if m.VEIDVerificationScore != 0 {
		n += 1 + sovTypes(uint64(m.VEIDVerificationScore))
	}
	if m.UptimeSeconds != 0 {
		n += 1 + sovTypes(uint64(m.UptimeSeconds))
	}
	if m.DowntimeSeconds != 0 {
		n += 1 + sovTypes(uint64(m.DowntimeSeconds))
	}
	if m.ConsecutiveMissedBlocks != 0 {
		n += 1 + sovTypes(uint64(m.ConsecutiveMissedBlocks))
	}
	if m.LastProposedHeight != 0 {
		n += 1 + sovTypes(uint64(m.LastProposedHeight))
	}
	if m.LastSignedHeight != 0 {
		n += 1 + sovTypes(uint64(m.LastSignedHeight))
	}
	if m.EpochNumber != 0 {
		n += 1 + sovTypes(uint64(m.EpochNumber))
	}
	if m.UpdatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.UpdatedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.OverallScore != 0 {
		n += 2 + sovTypes(uint64(m.OverallScore))
	}
	return n
}

func (m *ValidatorSigningInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.StartHeight != 0 {
		n += 1 + sovTypes(uint64(m.StartHeight))
	}
	if m.IndexOffset != 0 {
		n += 1 + sovTypes(uint64(m.IndexOffset))
	}
	if m.JailedUntil != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.JailedUntil)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Tombstoned {
		n += 2
	}
	if m.MissedBlocksCounter != 0 {
		n += 1 + sovTypes(uint64(m.MissedBlocksCounter))
	}
	if m.InfractionCount != 0 {
		n += 1 + sovTypes(uint64(m.InfractionCount))
	}
	return n
}

func (m *RewardEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovTypes(uint64(m.EpochNumber))
	}
	if m.StartHeight != 0 {
		n += 1 + sovTypes(uint64(m.StartHeight))
	}
	if m.EndHeight != 0 {
		n += 1 + sovTypes(uint64(m.EndHeight))
	}
	if m.StartTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.TotalRewardsDistributed) > 0 {
		for _, e := range m.TotalRewardsDistributed {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.BlockProposalRewards) > 0 {
		for _, e := range m.BlockProposalRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.VEIDRewards) > 0 {
		for _, e := range m.VEIDRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.UptimeRewards) > 0 {
		for _, e := range m.UptimeRewards {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.ValidatorCount != 0 {
		n += 1 + sovTypes(uint64(m.ValidatorCount))
	}
	l = len(m.TotalStake)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Finalized {
		n += 2
	}
	return n
}

func (m *ValidatorReward) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.EpochNumber != 0 {
		n += 1 + sovTypes(uint64(m.EpochNumber))
	}
	if len(m.TotalReward) > 0 {
		for _, e := range m.TotalReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.BlockProposalReward) > 0 {
		for _, e := range m.BlockProposalReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.VEIDReward) > 0 {
		for _, e := range m.VEIDReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.UptimeReward) > 0 {
		for _, e := range m.UptimeReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.IdentityNetworkReward) > 0 {
		for _, e := range m.IdentityNetworkReward {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.PerformanceScore != 0 {
		n += 1 + sovTypes(uint64(m.PerformanceScore))
	}
	l = len(m.StakeWeight)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CalculatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CalculatedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	if m.Claimed {
		n += 2
	}
	if m.ClaimedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ClaimedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *SlashRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SlashId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Reason != 0 {
		n += 1 + sovTypes(uint64(m.Reason))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.SlashPercent != 0 {
		n += 1 + sovTypes(uint64(m.SlashPercent))
	}
	if m.InfractionHeight != 0 {
		n += 1 + sovTypes(uint64(m.InfractionHeight))
	}
	if m.SlashHeight != 0 {
		n += 1 + sovTypes(uint64(m.SlashHeight))
	}
	if m.SlashTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.SlashTime)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.JailDuration != 0 {
		n += 1 + sovTypes(uint64(m.JailDuration))
	}
	if m.JailedUntil != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.JailedUntil)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Tombstoned {
		n += 2
	}
	l = len(m.Evidence)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EvidenceHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ReporterAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *DoubleSignEvidence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EvidenceId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Height_1 != 0 {
		n += 1 + sovTypes(uint64(m.Height_1))
	}
	if m.Height_2 != 0 {
		n += 1 + sovTypes(uint64(m.Height_2))
	}
	l = len(m.VoteHash_1)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.VoteHash_2)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DetectedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DetectedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DetectedHeight != 0 {
		n += 1 + sovTypes(uint64(m.DetectedHeight))
	}
	if m.Processed {
		n += 2
	}
	return n
}

func (m *InvalidVEIDAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RecordId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AttestationId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ExpectedScore != 0 {
		n += 1 + sovTypes(uint64(m.ExpectedScore))
	}
	if m.ActualScore != 0 {
		n += 1 + sovTypes(uint64(m.ActualScore))
	}
	if m.ScoreDifference != 0 {
		n += 1 + sovTypes(uint64(m.ScoreDifference))
	}
	if m.DetectedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.DetectedAt)
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.DetectedHeight != 0 {
		n += 1 + sovTypes(uint64(m.DetectedHeight))
	}
	if m.Processed {
		n += 2
	}
	return n
}

func (m *SlashConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reason != 0 {
		n += 1 + sovTypes(uint64(m.Reason))
	}
	if m.SlashPercent != 0 {
		n += 1 + sovTypes(uint64(m.SlashPercent))
	}
	if m.JailDuration != 0 {
		n += 1 + sovTypes(uint64(m.JailDuration))
	}
	if m.IsTombstone {
		n += 2
	}
	if m.EscalationMultiplier != 0 {
		n += 1 + sovTypes(uint64(m.EscalationMultiplier))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ValidatorPerformance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorPerformance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorPerformance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksProposed", wireType)
			}
			m.BlocksProposed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksProposed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksExpected", wireType)
			}
			m.BlocksExpected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksExpected |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlocksMissed", wireType)
			}
			m.BlocksMissed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlocksMissed |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSignatures", wireType)
			}
			m.TotalSignatures = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalSignatures |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VEIDVerificationsCompleted", wireType)
			}
			m.VEIDVerificationsCompleted = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VEIDVerificationsCompleted |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VEIDVerificationsExpected", wireType)
			}
			m.VEIDVerificationsExpected = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VEIDVerificationsExpected |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VEIDVerificationScore", wireType)
			}
			m.VEIDVerificationScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VEIDVerificationScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptimeSeconds", wireType)
			}
			m.UptimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UptimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DowntimeSeconds", wireType)
			}
			m.DowntimeSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DowntimeSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsecutiveMissedBlocks", wireType)
			}
			m.ConsecutiveMissedBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsecutiveMissedBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastProposedHeight", wireType)
			}
			m.LastProposedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastProposedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSignedHeight", wireType)
			}
			m.LastSignedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSignedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatedAt == nil {
				m.UpdatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverallScore", wireType)
			}
			m.OverallScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverallScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorSigningInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorSigningInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorSigningInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexOffset", wireType)
			}
			m.IndexOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IndexOffset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailedUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JailedUntil == nil {
				m.JailedUntil = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.JailedUntil, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstoned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tombstoned = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MissedBlocksCounter", wireType)
			}
			m.MissedBlocksCounter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MissedBlocksCounter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfractionCount", wireType)
			}
			m.InfractionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfractionCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartHeight", wireType)
			}
			m.StartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndHeight", wireType)
			}
			m.EndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewardsDistributed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalRewardsDistributed = append(m.TotalRewardsDistributed, types.Coin{})
			if err := m.TotalRewardsDistributed[len(m.TotalRewardsDistributed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockProposalRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockProposalRewards = append(m.BlockProposalRewards, types.Coin{})
			if err := m.BlockProposalRewards[len(m.BlockProposalRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VEIDRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VEIDRewards = append(m.VEIDRewards, types.Coin{})
			if err := m.VEIDRewards[len(m.VEIDRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptimeRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UptimeRewards = append(m.UptimeRewards, types.Coin{})
			if err := m.UptimeRewards[len(m.UptimeRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorCount", wireType)
			}
			m.ValidatorCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalStake", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalStake = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalized", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Finalized = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorReward) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorReward: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorReward: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalReward = append(m.TotalReward, types.Coin{})
			if err := m.TotalReward[len(m.TotalReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockProposalReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockProposalReward = append(m.BlockProposalReward, types.Coin{})
			if err := m.BlockProposalReward[len(m.BlockProposalReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VEIDReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VEIDReward = append(m.VEIDReward, types.Coin{})
			if err := m.VEIDReward[len(m.VEIDReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UptimeReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UptimeReward = append(m.UptimeReward, types.Coin{})
			if err := m.UptimeReward[len(m.UptimeReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityNetworkReward", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdentityNetworkReward = append(m.IdentityNetworkReward, types.Coin{})
			if err := m.IdentityNetworkReward[len(m.IdentityNetworkReward)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PerformanceScore", wireType)
			}
			m.PerformanceScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PerformanceScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakeWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakeWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalculatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CalculatedAt == nil {
				m.CalculatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CalculatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Claimed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Claimed = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ClaimedAt == nil {
				m.ClaimedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ClaimedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SlashId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= SlashReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPercent", wireType)
			}
			m.SlashPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPercent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfractionHeight", wireType)
			}
			m.InfractionHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InfractionHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashHeight", wireType)
			}
			m.SlashHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SlashTime == nil {
				m.SlashTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.SlashTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDuration", wireType)
			}
			m.JailDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JailDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailedUntil", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JailedUntil == nil {
				m.JailedUntil = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.JailedUntil, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tombstoned", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Tombstoned = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReporterAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReporterAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DoubleSignEvidence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DoubleSignEvidence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DoubleSignEvidence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height_1", wireType)
			}
			m.Height_1 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height_1 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height_2", wireType)
			}
			m.Height_2 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height_2 |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteHash_1", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoteHash_1 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteHash_2", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VoteHash_2 = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectedAt == nil {
				m.DetectedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.DetectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedHeight", wireType)
			}
			m.DetectedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvalidVEIDAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvalidVEIDAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvalidVEIDAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecordId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedScore", wireType)
			}
			m.ExpectedScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActualScore", wireType)
			}
			m.ActualScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActualScore |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreDifference", wireType)
			}
			m.ScoreDifference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreDifference |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DetectedAt == nil {
				m.DetectedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.DetectedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DetectedHeight", wireType)
			}
			m.DetectedHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DetectedHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Processed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Processed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SlashConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SlashConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SlashConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			m.Reason = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Reason |= SlashReason(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlashPercent", wireType)
			}
			m.SlashPercent = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SlashPercent |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field JailDuration", wireType)
			}
			m.JailDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.JailDuration |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTombstone = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscalationMultiplier", wireType)
			}
			m.EscalationMultiplier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscalationMultiplier |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)

