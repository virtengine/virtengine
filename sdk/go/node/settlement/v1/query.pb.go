// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/settlement/v1/query.proto

package v1

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	github_com_cosmos_cosmos_sdk_types "github.com/cosmos/cosmos-sdk/types"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ReleaseCondition defines a condition that must be met for escrow release.
type ReleaseCondition struct {
	Type                      string   `protobuf:"bytes,1,opt,name=type,proto3" json:"type,omitempty"`
	UnlockAfter               int64    `protobuf:"varint,2,opt,name=unlock_after,json=unlockAfter,proto3" json:"unlock_after,omitempty"`
	RequiredSigners           []string `protobuf:"bytes,3,rep,name=required_signers,json=requiredSigners,proto3" json:"required_signers,omitempty"`
	SignatureThreshold        uint32   `protobuf:"varint,4,opt,name=signature_threshold,json=signatureThreshold,proto3" json:"signature_threshold,omitempty"`
	MinUsageUnits             uint64   `protobuf:"varint,5,opt,name=min_usage_units,json=minUsageUnits,proto3" json:"min_usage_units,omitempty"`
	RequiredVerificationScore uint32   `protobuf:"varint,6,opt,name=required_verification_score,json=requiredVerificationScore,proto3" json:"required_verification_score,omitempty"`
	Satisfied                 bool     `protobuf:"varint,7,opt,name=satisfied,proto3" json:"satisfied,omitempty"`
	SatisfiedAt               int64    `protobuf:"varint,8,opt,name=satisfied_at,json=satisfiedAt,proto3" json:"satisfied_at,omitempty"`
}

func (m *ReleaseCondition) Reset()         { *m = ReleaseCondition{} }
func (m *ReleaseCondition) String() string { return proto.CompactTextString(m) }
func (*ReleaseCondition) ProtoMessage()    {}
func (*ReleaseCondition) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{0}
}
func (m *ReleaseCondition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReleaseCondition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReleaseCondition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReleaseCondition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReleaseCondition.Merge(m, src)
}
func (m *ReleaseCondition) XXX_Size() int {
	return m.Size()
}
func (m *ReleaseCondition) XXX_DiscardUnknown() {
	xxx_messageInfo_ReleaseCondition.DiscardUnknown(m)
}

var xxx_messageInfo_ReleaseCondition proto.InternalMessageInfo

func (m *ReleaseCondition) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ReleaseCondition) GetUnlockAfter() int64 {
	if m != nil {
		return m.UnlockAfter
	}
	return 0
}

func (m *ReleaseCondition) GetRequiredSigners() []string {
	if m != nil {
		return m.RequiredSigners
	}
	return nil
}

func (m *ReleaseCondition) GetSignatureThreshold() uint32 {
	if m != nil {
		return m.SignatureThreshold
	}
	return 0
}

func (m *ReleaseCondition) GetMinUsageUnits() uint64 {
	if m != nil {
		return m.MinUsageUnits
	}
	return 0
}

func (m *ReleaseCondition) GetRequiredVerificationScore() uint32 {
	if m != nil {
		return m.RequiredVerificationScore
	}
	return 0
}

func (m *ReleaseCondition) GetSatisfied() bool {
	if m != nil {
		return m.Satisfied
	}
	return false
}

func (m *ReleaseCondition) GetSatisfiedAt() int64 {
	if m != nil {
		return m.SatisfiedAt
	}
	return 0
}

// EscrowAccount represents funds held in escrow for a marketplace order.
type EscrowAccount struct {
	EscrowId        string                                   `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	OrderId         string                                   `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId         string                                   `protobuf:"bytes,3,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Depositor       string                                   `protobuf:"bytes,4,opt,name=depositor,proto3" json:"depositor,omitempty"`
	Recipient       string                                   `protobuf:"bytes,5,opt,name=recipient,proto3" json:"recipient,omitempty"`
	Amount          github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	Balance         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=balance,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"balance"`
	State           string                                   `protobuf:"bytes,8,opt,name=state,proto3" json:"state,omitempty"`
	Conditions      []ReleaseCondition                       `protobuf:"bytes,9,rep,name=conditions,proto3" json:"conditions"`
	CreatedAt       int64                                    `protobuf:"varint,10,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ExpiresAt       int64                                    `protobuf:"varint,11,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	ActivatedAt     int64                                    `protobuf:"varint,12,opt,name=activated_at,json=activatedAt,proto3" json:"activated_at,omitempty"`
	ClosedAt        int64                                    `protobuf:"varint,13,opt,name=closed_at,json=closedAt,proto3" json:"closed_at,omitempty"`
	ClosureReason   string                                   `protobuf:"bytes,14,opt,name=closure_reason,json=closureReason,proto3" json:"closure_reason,omitempty"`
	TotalSettled    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,15,rep,name=total_settled,json=totalSettled,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_settled"`
	SettlementCount uint32                                   `protobuf:"varint,16,opt,name=settlement_count,json=settlementCount,proto3" json:"settlement_count,omitempty"`
	BlockHeight     int64                                    `protobuf:"varint,17,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *EscrowAccount) Reset()         { *m = EscrowAccount{} }
func (m *EscrowAccount) String() string { return proto.CompactTextString(m) }
func (*EscrowAccount) ProtoMessage()    {}
func (*EscrowAccount) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{1}
}
func (m *EscrowAccount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EscrowAccount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EscrowAccount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EscrowAccount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EscrowAccount.Merge(m, src)
}
func (m *EscrowAccount) XXX_Size() int {
	return m.Size()
}
func (m *EscrowAccount) XXX_DiscardUnknown() {
	xxx_messageInfo_EscrowAccount.DiscardUnknown(m)
}

var xxx_messageInfo_EscrowAccount proto.InternalMessageInfo

func (m *EscrowAccount) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *EscrowAccount) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *EscrowAccount) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *EscrowAccount) GetDepositor() string {
	if m != nil {
		return m.Depositor
	}
	return ""
}

func (m *EscrowAccount) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

func (m *EscrowAccount) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *EscrowAccount) GetBalance() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Balance
	}
	return nil
}

func (m *EscrowAccount) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *EscrowAccount) GetConditions() []ReleaseCondition {
	if m != nil {
		return m.Conditions
	}
	return nil
}

func (m *EscrowAccount) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *EscrowAccount) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *EscrowAccount) GetActivatedAt() int64 {
	if m != nil {
		return m.ActivatedAt
	}
	return 0
}

func (m *EscrowAccount) GetClosedAt() int64 {
	if m != nil {
		return m.ClosedAt
	}
	return 0
}

func (m *EscrowAccount) GetClosureReason() string {
	if m != nil {
		return m.ClosureReason
	}
	return ""
}

func (m *EscrowAccount) GetTotalSettled() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalSettled
	}
	return nil
}

func (m *EscrowAccount) GetSettlementCount() uint32 {
	if m != nil {
		return m.SettlementCount
	}
	return 0
}

func (m *EscrowAccount) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// SettlementRecord represents a completed settlement for an order.
type SettlementRecord struct {
	SettlementId    string                                   `protobuf:"bytes,1,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	EscrowId        string                                   `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	OrderId         string                                   `protobuf:"bytes,3,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId         string                                   `protobuf:"bytes,4,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Provider        string                                   `protobuf:"bytes,5,opt,name=provider,proto3" json:"provider,omitempty"`
	Customer        string                                   `protobuf:"bytes,6,opt,name=customer,proto3" json:"customer,omitempty"`
	TotalAmount     github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,7,rep,name=total_amount,json=totalAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_amount"`
	ProviderShare   github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,8,rep,name=provider_share,json=providerShare,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"provider_share"`
	PlatformFee     github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,9,rep,name=platform_fee,json=platformFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"platform_fee"`
	ValidatorFee    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,10,rep,name=validator_fee,json=validatorFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"validator_fee"`
	SettledAt       int64                                    `protobuf:"varint,11,opt,name=settled_at,json=settledAt,proto3" json:"settled_at,omitempty"`
	UsageRecordIds  []string                                 `protobuf:"bytes,12,rep,name=usage_record_ids,json=usageRecordIds,proto3" json:"usage_record_ids,omitempty"`
	TotalUsageUnits uint64                                   `protobuf:"varint,13,opt,name=total_usage_units,json=totalUsageUnits,proto3" json:"total_usage_units,omitempty"`
	PeriodStart     int64                                    `protobuf:"varint,14,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	PeriodEnd       int64                                    `protobuf:"varint,15,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
	BlockHeight     int64                                    `protobuf:"varint,16,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	SettlementType  string                                   `protobuf:"bytes,17,opt,name=settlement_type,json=settlementType,proto3" json:"settlement_type,omitempty"`
	IsFinal         bool                                     `protobuf:"varint,18,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
}

func (m *SettlementRecord) Reset()         { *m = SettlementRecord{} }
func (m *SettlementRecord) String() string { return proto.CompactTextString(m) }
func (*SettlementRecord) ProtoMessage()    {}
func (*SettlementRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{2}
}
func (m *SettlementRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SettlementRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SettlementRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SettlementRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SettlementRecord.Merge(m, src)
}
func (m *SettlementRecord) XXX_Size() int {
	return m.Size()
}
func (m *SettlementRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_SettlementRecord.DiscardUnknown(m)
}

var xxx_messageInfo_SettlementRecord proto.InternalMessageInfo

func (m *SettlementRecord) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *SettlementRecord) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *SettlementRecord) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *SettlementRecord) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *SettlementRecord) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *SettlementRecord) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *SettlementRecord) GetTotalAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalAmount
	}
	return nil
}

func (m *SettlementRecord) GetProviderShare() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ProviderShare
	}
	return nil
}

func (m *SettlementRecord) GetPlatformFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.PlatformFee
	}
	return nil
}

func (m *SettlementRecord) GetValidatorFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ValidatorFee
	}
	return nil
}

func (m *SettlementRecord) GetSettledAt() int64 {
	if m != nil {
		return m.SettledAt
	}
	return 0
}

func (m *SettlementRecord) GetUsageRecordIds() []string {
	if m != nil {
		return m.UsageRecordIds
	}
	return nil
}

func (m *SettlementRecord) GetTotalUsageUnits() uint64 {
	if m != nil {
		return m.TotalUsageUnits
	}
	return 0
}

func (m *SettlementRecord) GetPeriodStart() int64 {
	if m != nil {
		return m.PeriodStart
	}
	return 0
}

func (m *SettlementRecord) GetPeriodEnd() int64 {
	if m != nil {
		return m.PeriodEnd
	}
	return 0
}

func (m *SettlementRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *SettlementRecord) GetSettlementType() string {
	if m != nil {
		return m.SettlementType
	}
	return ""
}

func (m *SettlementRecord) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

// UsageRecord represents a signed usage record from a provider.
type UsageRecord struct {
	UsageId              string                                   `protobuf:"bytes,1,opt,name=usage_id,json=usageId,proto3" json:"usage_id,omitempty"`
	OrderId              string                                   `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId              string                                   `protobuf:"bytes,3,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Provider             string                                   `protobuf:"bytes,4,opt,name=provider,proto3" json:"provider,omitempty"`
	Customer             string                                   `protobuf:"bytes,5,opt,name=customer,proto3" json:"customer,omitempty"`
	UsageUnits           uint64                                   `protobuf:"varint,6,opt,name=usage_units,json=usageUnits,proto3" json:"usage_units,omitempty"`
	UsageType            string                                   `protobuf:"bytes,7,opt,name=usage_type,json=usageType,proto3" json:"usage_type,omitempty"`
	PeriodStart          int64                                    `protobuf:"varint,8,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	PeriodEnd            int64                                    `protobuf:"varint,9,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
	UnitPrice            types.DecCoin                            `protobuf:"bytes,10,opt,name=unit_price,json=unitPrice,proto3" json:"unit_price"`
	TotalCost            github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,11,rep,name=total_cost,json=totalCost,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_cost"`
	ProviderSignature    []byte                                   `protobuf:"bytes,12,opt,name=provider_signature,json=providerSignature,proto3" json:"provider_signature,omitempty"`
	CustomerAcknowledged bool                                     `protobuf:"varint,13,opt,name=customer_acknowledged,json=customerAcknowledged,proto3" json:"customer_acknowledged,omitempty"`
	CustomerSignature    []byte                                   `protobuf:"bytes,14,opt,name=customer_signature,json=customerSignature,proto3" json:"customer_signature,omitempty"`
	Settled              bool                                     `protobuf:"varint,15,opt,name=settled,proto3" json:"settled,omitempty"`
	SettlementId         string                                   `protobuf:"bytes,16,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	SubmittedAt          int64                                    `protobuf:"varint,17,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at,omitempty"`
	BlockHeight          int64                                    `protobuf:"varint,18,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	Metadata             map[string]string                        `protobuf:"bytes,19,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *UsageRecord) Reset()         { *m = UsageRecord{} }
func (m *UsageRecord) String() string { return proto.CompactTextString(m) }
func (*UsageRecord) ProtoMessage()    {}
func (*UsageRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{3}
}
func (m *UsageRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageRecord.Merge(m, src)
}
func (m *UsageRecord) XXX_Size() int {
	return m.Size()
}
func (m *UsageRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageRecord.DiscardUnknown(m)
}

var xxx_messageInfo_UsageRecord proto.InternalMessageInfo

func (m *UsageRecord) GetUsageId() string {
	if m != nil {
		return m.UsageId
	}
	return ""
}

func (m *UsageRecord) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *UsageRecord) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *UsageRecord) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *UsageRecord) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *UsageRecord) GetUsageUnits() uint64 {
	if m != nil {
		return m.UsageUnits
	}
	return 0
}

func (m *UsageRecord) GetUsageType() string {
	if m != nil {
		return m.UsageType
	}
	return ""
}

func (m *UsageRecord) GetPeriodStart() int64 {
	if m != nil {
		return m.PeriodStart
	}
	return 0
}

func (m *UsageRecord) GetPeriodEnd() int64 {
	if m != nil {
		return m.PeriodEnd
	}
	return 0
}

func (m *UsageRecord) GetUnitPrice() types.DecCoin {
	if m != nil {
		return m.UnitPrice
	}
	return types.DecCoin{}
}

func (m *UsageRecord) GetTotalCost() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalCost
	}
	return nil
}

func (m *UsageRecord) GetProviderSignature() []byte {
	if m != nil {
		return m.ProviderSignature
	}
	return nil
}

func (m *UsageRecord) GetCustomerAcknowledged() bool {
	if m != nil {
		return m.CustomerAcknowledged
	}
	return false
}

func (m *UsageRecord) GetCustomerSignature() []byte {
	if m != nil {
		return m.CustomerSignature
	}
	return nil
}

func (m *UsageRecord) GetSettled() bool {
	if m != nil {
		return m.Settled
	}
	return false
}

func (m *UsageRecord) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *UsageRecord) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

func (m *UsageRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *UsageRecord) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// UsageTypeSummary aggregates usage by type.
type UsageTypeSummary struct {
	UsageType  string                                   `protobuf:"bytes,1,opt,name=usage_type,json=usageType,proto3" json:"usage_type,omitempty"`
	UsageUnits uint64                                   `protobuf:"varint,2,opt,name=usage_units,json=usageUnits,proto3" json:"usage_units,omitempty"`
	TotalCost  github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=total_cost,json=totalCost,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_cost"`
}

func (m *UsageTypeSummary) Reset()         { *m = UsageTypeSummary{} }
func (m *UsageTypeSummary) String() string { return proto.CompactTextString(m) }
func (*UsageTypeSummary) ProtoMessage()    {}
func (*UsageTypeSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{4}
}
func (m *UsageTypeSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageTypeSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageTypeSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageTypeSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageTypeSummary.Merge(m, src)
}
func (m *UsageTypeSummary) XXX_Size() int {
	return m.Size()
}
func (m *UsageTypeSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageTypeSummary.DiscardUnknown(m)
}

var xxx_messageInfo_UsageTypeSummary proto.InternalMessageInfo

func (m *UsageTypeSummary) GetUsageType() string {
	if m != nil {
		return m.UsageType
	}
	return ""
}

func (m *UsageTypeSummary) GetUsageUnits() uint64 {
	if m != nil {
		return m.UsageUnits
	}
	return 0
}

func (m *UsageTypeSummary) GetTotalCost() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalCost
	}
	return nil
}

// UsageSummary provides aggregated usage information.
type UsageSummary struct {
	Provider        string                                   `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	OrderId         string                                   `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	PeriodStart     int64                                    `protobuf:"varint,3,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	PeriodEnd       int64                                    `protobuf:"varint,4,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
	TotalUsageUnits uint64                                   `protobuf:"varint,5,opt,name=total_usage_units,json=totalUsageUnits,proto3" json:"total_usage_units,omitempty"`
	TotalCost       github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,6,rep,name=total_cost,json=totalCost,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_cost"`
	ByUsageType     []UsageTypeSummary                       `protobuf:"bytes,7,rep,name=by_usage_type,json=byUsageType,proto3" json:"by_usage_type"`
	GeneratedAt     int64                                    `protobuf:"varint,8,opt,name=generated_at,json=generatedAt,proto3" json:"generated_at,omitempty"`
	BlockHeight     int64                                    `protobuf:"varint,9,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	UsageRecordIds  []string                                 `protobuf:"bytes,10,rep,name=usage_record_ids,json=usageRecordIds,proto3" json:"usage_record_ids,omitempty"`
}

func (m *UsageSummary) Reset()         { *m = UsageSummary{} }
func (m *UsageSummary) String() string { return proto.CompactTextString(m) }
func (*UsageSummary) ProtoMessage()    {}
func (*UsageSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{5}
}
func (m *UsageSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsageSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsageSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsageSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsageSummary.Merge(m, src)
}
func (m *UsageSummary) XXX_Size() int {
	return m.Size()
}
func (m *UsageSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_UsageSummary.DiscardUnknown(m)
}

var xxx_messageInfo_UsageSummary proto.InternalMessageInfo

func (m *UsageSummary) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *UsageSummary) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *UsageSummary) GetPeriodStart() int64 {
	if m != nil {
		return m.PeriodStart
	}
	return 0
}

func (m *UsageSummary) GetPeriodEnd() int64 {
	if m != nil {
		return m.PeriodEnd
	}
	return 0
}

func (m *UsageSummary) GetTotalUsageUnits() uint64 {
	if m != nil {
		return m.TotalUsageUnits
	}
	return 0
}

func (m *UsageSummary) GetTotalCost() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalCost
	}
	return nil
}

func (m *UsageSummary) GetByUsageType() []UsageTypeSummary {
	if m != nil {
		return m.ByUsageType
	}
	return nil
}

func (m *UsageSummary) GetGeneratedAt() int64 {
	if m != nil {
		return m.GeneratedAt
	}
	return 0
}

func (m *UsageSummary) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *UsageSummary) GetUsageRecordIds() []string {
	if m != nil {
		return m.UsageRecordIds
	}
	return nil
}

// RewardRecipient represents a single reward recipient.
type RewardRecipient struct {
	Address           string                                   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Amount            github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	Reason            string                                   `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	UsageUnits        uint64                                   `protobuf:"varint,4,opt,name=usage_units,json=usageUnits,proto3" json:"usage_units,omitempty"`
	VerificationScore uint32                                   `protobuf:"varint,5,opt,name=verification_score,json=verificationScore,proto3" json:"verification_score,omitempty"`
	StakingWeight     string                                   `protobuf:"bytes,6,opt,name=staking_weight,json=stakingWeight,proto3" json:"staking_weight,omitempty"`
	ReferenceId       string                                   `protobuf:"bytes,7,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
}

func (m *RewardRecipient) Reset()         { *m = RewardRecipient{} }
func (m *RewardRecipient) String() string { return proto.CompactTextString(m) }
func (*RewardRecipient) ProtoMessage()    {}
func (*RewardRecipient) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{6}
}
func (m *RewardRecipient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardRecipient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardRecipient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardRecipient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardRecipient.Merge(m, src)
}
func (m *RewardRecipient) XXX_Size() int {
	return m.Size()
}
func (m *RewardRecipient) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardRecipient.DiscardUnknown(m)
}

var xxx_messageInfo_RewardRecipient proto.InternalMessageInfo

func (m *RewardRecipient) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RewardRecipient) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *RewardRecipient) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RewardRecipient) GetUsageUnits() uint64 {
	if m != nil {
		return m.UsageUnits
	}
	return 0
}

func (m *RewardRecipient) GetVerificationScore() uint32 {
	if m != nil {
		return m.VerificationScore
	}
	return 0
}

func (m *RewardRecipient) GetStakingWeight() string {
	if m != nil {
		return m.StakingWeight
	}
	return ""
}

func (m *RewardRecipient) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

// RewardDistribution represents a batch of rewards distributed.
type RewardDistribution struct {
	DistributionId    string                                   `protobuf:"bytes,1,opt,name=distribution_id,json=distributionId,proto3" json:"distribution_id,omitempty"`
	EpochNumber       uint64                                   `protobuf:"varint,2,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	TotalRewards      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=total_rewards,json=totalRewards,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_rewards"`
	Recipients        []RewardRecipient                        `protobuf:"bytes,4,rep,name=recipients,proto3" json:"recipients"`
	Source            string                                   `protobuf:"bytes,5,opt,name=source,proto3" json:"source,omitempty"`
	DistributedAt     int64                                    `protobuf:"varint,6,opt,name=distributed_at,json=distributedAt,proto3" json:"distributed_at,omitempty"`
	BlockHeight       int64                                    `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
	ReferenceTxHashes []string                                 `protobuf:"bytes,8,rep,name=reference_tx_hashes,json=referenceTxHashes,proto3" json:"reference_tx_hashes,omitempty"`
	Metadata          map[string]string                        `protobuf:"bytes,9,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *RewardDistribution) Reset()         { *m = RewardDistribution{} }
func (m *RewardDistribution) String() string { return proto.CompactTextString(m) }
func (*RewardDistribution) ProtoMessage()    {}
func (*RewardDistribution) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{7}
}
func (m *RewardDistribution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardDistribution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardDistribution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardDistribution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardDistribution.Merge(m, src)
}
func (m *RewardDistribution) XXX_Size() int {
	return m.Size()
}
func (m *RewardDistribution) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardDistribution.DiscardUnknown(m)
}

var xxx_messageInfo_RewardDistribution proto.InternalMessageInfo

func (m *RewardDistribution) GetDistributionId() string {
	if m != nil {
		return m.DistributionId
	}
	return ""
}

func (m *RewardDistribution) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *RewardDistribution) GetTotalRewards() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalRewards
	}
	return nil
}

func (m *RewardDistribution) GetRecipients() []RewardRecipient {
	if m != nil {
		return m.Recipients
	}
	return nil
}

func (m *RewardDistribution) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *RewardDistribution) GetDistributedAt() int64 {
	if m != nil {
		return m.DistributedAt
	}
	return 0
}

func (m *RewardDistribution) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *RewardDistribution) GetReferenceTxHashes() []string {
	if m != nil {
		return m.ReferenceTxHashes
	}
	return nil
}

func (m *RewardDistribution) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// RewardHistoryEntry represents a reward distribution entry for an address.
type RewardHistoryEntry struct {
	DistributionId string                                   `protobuf:"bytes,1,opt,name=distribution_id,json=distributionId,proto3" json:"distribution_id,omitempty"`
	EpochNumber    uint64                                   `protobuf:"varint,2,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
	Source         string                                   `protobuf:"bytes,3,opt,name=source,proto3" json:"source,omitempty"`
	Amount         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,4,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	Reason         string                                   `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason,omitempty"`
	UsageUnits     uint64                                   `protobuf:"varint,6,opt,name=usage_units,json=usageUnits,proto3" json:"usage_units,omitempty"`
	ReferenceId    string                                   `protobuf:"bytes,7,opt,name=reference_id,json=referenceId,proto3" json:"reference_id,omitempty"`
	DistributedAt  int64                                    `protobuf:"varint,8,opt,name=distributed_at,json=distributedAt,proto3" json:"distributed_at,omitempty"`
}

func (m *RewardHistoryEntry) Reset()         { *m = RewardHistoryEntry{} }
func (m *RewardHistoryEntry) String() string { return proto.CompactTextString(m) }
func (*RewardHistoryEntry) ProtoMessage()    {}
func (*RewardHistoryEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{8}
}
func (m *RewardHistoryEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardHistoryEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardHistoryEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardHistoryEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardHistoryEntry.Merge(m, src)
}
func (m *RewardHistoryEntry) XXX_Size() int {
	return m.Size()
}
func (m *RewardHistoryEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardHistoryEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RewardHistoryEntry proto.InternalMessageInfo

func (m *RewardHistoryEntry) GetDistributionId() string {
	if m != nil {
		return m.DistributionId
	}
	return ""
}

func (m *RewardHistoryEntry) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

func (m *RewardHistoryEntry) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *RewardHistoryEntry) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *RewardHistoryEntry) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *RewardHistoryEntry) GetUsageUnits() uint64 {
	if m != nil {
		return m.UsageUnits
	}
	return 0
}

func (m *RewardHistoryEntry) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

func (m *RewardHistoryEntry) GetDistributedAt() int64 {
	if m != nil {
		return m.DistributedAt
	}
	return 0
}

// RewardEntry represents a single claimable reward entry.
type RewardEntry struct {
	DistributionId string                                   `protobuf:"bytes,1,opt,name=distribution_id,json=distributionId,proto3" json:"distribution_id,omitempty"`
	Source         string                                   `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Amount         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,3,rep,name=amount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"amount"`
	CreatedAt      int64                                    `protobuf:"varint,4,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ExpiresAt      int64                                    `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	Reason         string                                   `protobuf:"bytes,6,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *RewardEntry) Reset()         { *m = RewardEntry{} }
func (m *RewardEntry) String() string { return proto.CompactTextString(m) }
func (*RewardEntry) ProtoMessage()    {}
func (*RewardEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{9}
}
func (m *RewardEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RewardEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RewardEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RewardEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RewardEntry.Merge(m, src)
}
func (m *RewardEntry) XXX_Size() int {
	return m.Size()
}
func (m *RewardEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_RewardEntry.DiscardUnknown(m)
}

var xxx_messageInfo_RewardEntry proto.InternalMessageInfo

func (m *RewardEntry) GetDistributionId() string {
	if m != nil {
		return m.DistributionId
	}
	return ""
}

func (m *RewardEntry) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *RewardEntry) GetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *RewardEntry) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *RewardEntry) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *RewardEntry) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// ClaimableRewards represents rewards that can be claimed by an address.
type ClaimableRewards struct {
	Address        string                                   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	TotalClaimable github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,2,rep,name=total_claimable,json=totalClaimable,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_claimable"`
	RewardEntries  []RewardEntry                            `protobuf:"bytes,3,rep,name=reward_entries,json=rewardEntries,proto3" json:"reward_entries"`
	LastUpdated    int64                                    `protobuf:"varint,4,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated,omitempty"`
	TotalClaimed   github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,5,rep,name=total_claimed,json=totalClaimed,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"total_claimed"`
}

func (m *ClaimableRewards) Reset()         { *m = ClaimableRewards{} }
func (m *ClaimableRewards) String() string { return proto.CompactTextString(m) }
func (*ClaimableRewards) ProtoMessage()    {}
func (*ClaimableRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{10}
}
func (m *ClaimableRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClaimableRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClaimableRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClaimableRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClaimableRewards.Merge(m, src)
}
func (m *ClaimableRewards) XXX_Size() int {
	return m.Size()
}
func (m *ClaimableRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_ClaimableRewards.DiscardUnknown(m)
}

var xxx_messageInfo_ClaimableRewards proto.InternalMessageInfo

func (m *ClaimableRewards) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ClaimableRewards) GetTotalClaimable() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalClaimable
	}
	return nil
}

func (m *ClaimableRewards) GetRewardEntries() []RewardEntry {
	if m != nil {
		return m.RewardEntries
	}
	return nil
}

func (m *ClaimableRewards) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

func (m *ClaimableRewards) GetTotalClaimed() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.TotalClaimed
	}
	return nil
}

// PayoutRecord represents a payout execution record.
type PayoutRecord struct {
	PayoutId          string                                   `protobuf:"bytes,1,opt,name=payout_id,json=payoutId,proto3" json:"payout_id,omitempty"`
	FiatConversionId  string                                   `protobuf:"bytes,2,opt,name=fiat_conversion_id,json=fiatConversionId,proto3" json:"fiat_conversion_id,omitempty"`
	InvoiceId         string                                   `protobuf:"bytes,3,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	SettlementId      string                                   `protobuf:"bytes,4,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	EscrowId          string                                   `protobuf:"bytes,5,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	OrderId           string                                   `protobuf:"bytes,6,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId           string                                   `protobuf:"bytes,7,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Provider          string                                   `protobuf:"bytes,8,opt,name=provider,proto3" json:"provider,omitempty"`
	Customer          string                                   `protobuf:"bytes,9,opt,name=customer,proto3" json:"customer,omitempty"`
	GrossAmount       github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,10,rep,name=gross_amount,json=grossAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"gross_amount"`
	PlatformFee       github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,11,rep,name=platform_fee,json=platformFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"platform_fee"`
	ValidatorFee      github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,12,rep,name=validator_fee,json=validatorFee,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"validator_fee"`
	HoldbackAmount    github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,13,rep,name=holdback_amount,json=holdbackAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"holdback_amount"`
	NetAmount         github_com_cosmos_cosmos_sdk_types.Coins `protobuf:"bytes,14,rep,name=net_amount,json=netAmount,proto3,castrepeated=github.com/cosmos/cosmos-sdk/types.Coins" json:"net_amount"`
	State             string                                   `protobuf:"bytes,15,opt,name=state,proto3" json:"state,omitempty"`
	DisputeId         string                                   `protobuf:"bytes,16,opt,name=dispute_id,json=disputeId,proto3" json:"dispute_id,omitempty"`
	HoldReason        string                                   `protobuf:"bytes,17,opt,name=hold_reason,json=holdReason,proto3" json:"hold_reason,omitempty"`
	IdempotencyKey    string                                   `protobuf:"bytes,18,opt,name=idempotency_key,json=idempotencyKey,proto3" json:"idempotency_key,omitempty"`
	ExecutionAttempts uint32                                   `protobuf:"varint,19,opt,name=execution_attempts,json=executionAttempts,proto3" json:"execution_attempts,omitempty"`
	LastAttemptAt     int64                                    `protobuf:"varint,20,opt,name=last_attempt_at,json=lastAttemptAt,proto3" json:"last_attempt_at,omitempty"`
	LastError         string                                   `protobuf:"bytes,21,opt,name=last_error,json=lastError,proto3" json:"last_error,omitempty"`
	TxHash            string                                   `protobuf:"bytes,22,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	CreatedAt         int64                                    `protobuf:"varint,23,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	ProcessedAt       int64                                    `protobuf:"varint,24,opt,name=processed_at,json=processedAt,proto3" json:"processed_at,omitempty"`
	CompletedAt       int64                                    `protobuf:"varint,25,opt,name=completed_at,json=completedAt,proto3" json:"completed_at,omitempty"`
	BlockHeight       int64                                    `protobuf:"varint,26,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *PayoutRecord) Reset()         { *m = PayoutRecord{} }
func (m *PayoutRecord) String() string { return proto.CompactTextString(m) }
func (*PayoutRecord) ProtoMessage()    {}
func (*PayoutRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{11}
}
func (m *PayoutRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PayoutRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PayoutRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PayoutRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PayoutRecord.Merge(m, src)
}
func (m *PayoutRecord) XXX_Size() int {
	return m.Size()
}
func (m *PayoutRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_PayoutRecord.DiscardUnknown(m)
}

var xxx_messageInfo_PayoutRecord proto.InternalMessageInfo

func (m *PayoutRecord) GetPayoutId() string {
	if m != nil {
		return m.PayoutId
	}
	return ""
}

func (m *PayoutRecord) GetFiatConversionId() string {
	if m != nil {
		return m.FiatConversionId
	}
	return ""
}

func (m *PayoutRecord) GetInvoiceId() string {
	if m != nil {
		return m.InvoiceId
	}
	return ""
}

func (m *PayoutRecord) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *PayoutRecord) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *PayoutRecord) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *PayoutRecord) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *PayoutRecord) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *PayoutRecord) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *PayoutRecord) GetGrossAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.GrossAmount
	}
	return nil
}

func (m *PayoutRecord) GetPlatformFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.PlatformFee
	}
	return nil
}

func (m *PayoutRecord) GetValidatorFee() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.ValidatorFee
	}
	return nil
}

func (m *PayoutRecord) GetHoldbackAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.HoldbackAmount
	}
	return nil
}

func (m *PayoutRecord) GetNetAmount() github_com_cosmos_cosmos_sdk_types.Coins {
	if m != nil {
		return m.NetAmount
	}
	return nil
}

func (m *PayoutRecord) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *PayoutRecord) GetDisputeId() string {
	if m != nil {
		return m.DisputeId
	}
	return ""
}

func (m *PayoutRecord) GetHoldReason() string {
	if m != nil {
		return m.HoldReason
	}
	return ""
}

func (m *PayoutRecord) GetIdempotencyKey() string {
	if m != nil {
		return m.IdempotencyKey
	}
	return ""
}

func (m *PayoutRecord) GetExecutionAttempts() uint32 {
	if m != nil {
		return m.ExecutionAttempts
	}
	return 0
}

func (m *PayoutRecord) GetLastAttemptAt() int64 {
	if m != nil {
		return m.LastAttemptAt
	}
	return 0
}

func (m *PayoutRecord) GetLastError() string {
	if m != nil {
		return m.LastError
	}
	return ""
}

func (m *PayoutRecord) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

func (m *PayoutRecord) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *PayoutRecord) GetProcessedAt() int64 {
	if m != nil {
		return m.ProcessedAt
	}
	return 0
}

func (m *PayoutRecord) GetCompletedAt() int64 {
	if m != nil {
		return m.CompletedAt
	}
	return 0
}

func (m *PayoutRecord) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// Params defines the parameters for the settlement module.
type Params struct {
	PlatformFeeRate                   string `protobuf:"bytes,1,opt,name=platform_fee_rate,json=platformFeeRate,proto3" json:"platform_fee_rate,omitempty"`
	ValidatorFeeRate                  string `protobuf:"bytes,2,opt,name=validator_fee_rate,json=validatorFeeRate,proto3" json:"validator_fee_rate,omitempty"`
	MinEscrowDuration                 uint64 `protobuf:"varint,3,opt,name=min_escrow_duration,json=minEscrowDuration,proto3" json:"min_escrow_duration,omitempty"`
	MaxEscrowDuration                 uint64 `protobuf:"varint,4,opt,name=max_escrow_duration,json=maxEscrowDuration,proto3" json:"max_escrow_duration,omitempty"`
	SettlementPeriod                  uint64 `protobuf:"varint,5,opt,name=settlement_period,json=settlementPeriod,proto3" json:"settlement_period,omitempty"`
	RewardClaimExpiry                 uint64 `protobuf:"varint,6,opt,name=reward_claim_expiry,json=rewardClaimExpiry,proto3" json:"reward_claim_expiry,omitempty"`
	MinSettlementAmount               string `protobuf:"bytes,7,opt,name=min_settlement_amount,json=minSettlementAmount,proto3" json:"min_settlement_amount,omitempty"`
	UsageGracePeriod                  uint64 `protobuf:"varint,8,opt,name=usage_grace_period,json=usageGracePeriod,proto3" json:"usage_grace_period,omitempty"`
	StakingRewardEpochLength          uint64 `protobuf:"varint,9,opt,name=staking_reward_epoch_length,json=stakingRewardEpochLength,proto3" json:"staking_reward_epoch_length,omitempty"`
	VerificationRewardAmount          string `protobuf:"bytes,10,opt,name=verification_reward_amount,json=verificationRewardAmount,proto3" json:"verification_reward_amount,omitempty"`
	PayoutHoldbackRate                string `protobuf:"bytes,11,opt,name=payout_holdback_rate,json=payoutHoldbackRate,proto3" json:"payout_holdback_rate,omitempty"`
	MaxPayoutRetries                  uint32 `protobuf:"varint,12,opt,name=max_payout_retries,json=maxPayoutRetries,proto3" json:"max_payout_retries,omitempty"`
	DisputeWindowDuration             uint64 `protobuf:"varint,13,opt,name=dispute_window_duration,json=disputeWindowDuration,proto3" json:"dispute_window_duration,omitempty"`
	UsageRewardRateBps                uint32 `protobuf:"varint,14,opt,name=usage_reward_rate_bps,json=usageRewardRateBps,proto3" json:"usage_reward_rate_bps,omitempty"`
	UsageRewardCpuMultiplierBps       uint32 `protobuf:"varint,15,opt,name=usage_reward_cpu_multiplier_bps,json=usageRewardCpuMultiplierBps,proto3" json:"usage_reward_cpu_multiplier_bps,omitempty"`
	UsageRewardMemoryMultiplierBps    uint32 `protobuf:"varint,16,opt,name=usage_reward_memory_multiplier_bps,json=usageRewardMemoryMultiplierBps,proto3" json:"usage_reward_memory_multiplier_bps,omitempty"`
	UsageRewardStorageMultiplierBps   uint32 `protobuf:"varint,17,opt,name=usage_reward_storage_multiplier_bps,json=usageRewardStorageMultiplierBps,proto3" json:"usage_reward_storage_multiplier_bps,omitempty"`
	UsageRewardGpuMultiplierBps       uint32 `protobuf:"varint,18,opt,name=usage_reward_gpu_multiplier_bps,json=usageRewardGpuMultiplierBps,proto3" json:"usage_reward_gpu_multiplier_bps,omitempty"`
	UsageRewardNetworkMultiplierBps   uint32 `protobuf:"varint,19,opt,name=usage_reward_network_multiplier_bps,json=usageRewardNetworkMultiplierBps,proto3" json:"usage_reward_network_multiplier_bps,omitempty"`
	UsageRewardSlaOntimeMultiplierBps uint32 `protobuf:"varint,20,opt,name=usage_reward_sla_ontime_multiplier_bps,json=usageRewardSlaOntimeMultiplierBps,proto3" json:"usage_reward_sla_ontime_multiplier_bps,omitempty"`
	UsageRewardSlaLateMultiplierBps   uint32 `protobuf:"varint,21,opt,name=usage_reward_sla_late_multiplier_bps,json=usageRewardSlaLateMultiplierBps,proto3" json:"usage_reward_sla_late_multiplier_bps,omitempty"`
	UsageRewardAckMultiplierBps       uint32 `protobuf:"varint,22,opt,name=usage_reward_ack_multiplier_bps,json=usageRewardAckMultiplierBps,proto3" json:"usage_reward_ack_multiplier_bps,omitempty"`
	UsageRewardUnackMultiplierBps     uint32 `protobuf:"varint,23,opt,name=usage_reward_unack_multiplier_bps,json=usageRewardUnackMultiplierBps,proto3" json:"usage_reward_unack_multiplier_bps,omitempty"`
	FiatConversionEnabled             bool   `protobuf:"varint,24,opt,name=fiat_conversion_enabled,json=fiatConversionEnabled,proto3" json:"fiat_conversion_enabled,omitempty"`
	FiatConversionMinAmount           string `protobuf:"bytes,25,opt,name=fiat_conversion_min_amount,json=fiatConversionMinAmount,proto3" json:"fiat_conversion_min_amount,omitempty"`
	FiatConversionMaxAmount           string `protobuf:"bytes,26,opt,name=fiat_conversion_max_amount,json=fiatConversionMaxAmount,proto3" json:"fiat_conversion_max_amount,omitempty"`
	FiatConversionDailyLimit          string `protobuf:"bytes,27,opt,name=fiat_conversion_daily_limit,json=fiatConversionDailyLimit,proto3" json:"fiat_conversion_daily_limit,omitempty"`
	FiatConversionStableDenom         string `protobuf:"bytes,28,opt,name=fiat_conversion_stable_denom,json=fiatConversionStableDenom,proto3" json:"fiat_conversion_stable_denom,omitempty"`
	FiatConversionStableSymbol        string `protobuf:"bytes,29,opt,name=fiat_conversion_stable_symbol,json=fiatConversionStableSymbol,proto3" json:"fiat_conversion_stable_symbol,omitempty"`
	FiatConversionStableDecimals      uint32 `protobuf:"varint,30,opt,name=fiat_conversion_stable_decimals,json=fiatConversionStableDecimals,proto3" json:"fiat_conversion_stable_decimals,omitempty"`
	FiatConversionDefaultFiat         string `protobuf:"bytes,31,opt,name=fiat_conversion_default_fiat,json=fiatConversionDefaultFiat,proto3" json:"fiat_conversion_default_fiat,omitempty"`
	FiatConversionDefaultMethod       string `protobuf:"bytes,32,opt,name=fiat_conversion_default_method,json=fiatConversionDefaultMethod,proto3" json:"fiat_conversion_default_method,omitempty"`
	FiatConversionMaxSlippage         string `protobuf:"bytes,33,opt,name=fiat_conversion_max_slippage,json=fiatConversionMaxSlippage,proto3" json:"fiat_conversion_max_slippage,omitempty"`
	FiatConversionRiskScoreThreshold  int32  `protobuf:"varint,34,opt,name=fiat_conversion_risk_score_threshold,json=fiatConversionRiskScoreThreshold,proto3" json:"fiat_conversion_risk_score_threshold,omitempty"`
	FiatConversionMinComplianceStatus string `protobuf:"bytes,35,opt,name=fiat_conversion_min_compliance_status,json=fiatConversionMinComplianceStatus,proto3" json:"fiat_conversion_min_compliance_status,omitempty"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{12}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetPlatformFeeRate() string {
	if m != nil {
		return m.PlatformFeeRate
	}
	return ""
}

func (m *Params) GetValidatorFeeRate() string {
	if m != nil {
		return m.ValidatorFeeRate
	}
	return ""
}

func (m *Params) GetMinEscrowDuration() uint64 {
	if m != nil {
		return m.MinEscrowDuration
	}
	return 0
}

func (m *Params) GetMaxEscrowDuration() uint64 {
	if m != nil {
		return m.MaxEscrowDuration
	}
	return 0
}

func (m *Params) GetSettlementPeriod() uint64 {
	if m != nil {
		return m.SettlementPeriod
	}
	return 0
}

func (m *Params) GetRewardClaimExpiry() uint64 {
	if m != nil {
		return m.RewardClaimExpiry
	}
	return 0
}

func (m *Params) GetMinSettlementAmount() string {
	if m != nil {
		return m.MinSettlementAmount
	}
	return ""
}

func (m *Params) GetUsageGracePeriod() uint64 {
	if m != nil {
		return m.UsageGracePeriod
	}
	return 0
}

func (m *Params) GetStakingRewardEpochLength() uint64 {
	if m != nil {
		return m.StakingRewardEpochLength
	}
	return 0
}

func (m *Params) GetVerificationRewardAmount() string {
	if m != nil {
		return m.VerificationRewardAmount
	}
	return ""
}

func (m *Params) GetPayoutHoldbackRate() string {
	if m != nil {
		return m.PayoutHoldbackRate
	}
	return ""
}

func (m *Params) GetMaxPayoutRetries() uint32 {
	if m != nil {
		return m.MaxPayoutRetries
	}
	return 0
}

func (m *Params) GetDisputeWindowDuration() uint64 {
	if m != nil {
		return m.DisputeWindowDuration
	}
	return 0
}

func (m *Params) GetUsageRewardRateBps() uint32 {
	if m != nil {
		return m.UsageRewardRateBps
	}
	return 0
}

func (m *Params) GetUsageRewardCpuMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardCpuMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardMemoryMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardMemoryMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardStorageMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardStorageMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardGpuMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardGpuMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardNetworkMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardNetworkMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardSlaOntimeMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardSlaOntimeMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardSlaLateMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardSlaLateMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardAckMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardAckMultiplierBps
	}
	return 0
}

func (m *Params) GetUsageRewardUnackMultiplierBps() uint32 {
	if m != nil {
		return m.UsageRewardUnackMultiplierBps
	}
	return 0
}

func (m *Params) GetFiatConversionEnabled() bool {
	if m != nil {
		return m.FiatConversionEnabled
	}
	return false
}

func (m *Params) GetFiatConversionMinAmount() string {
	if m != nil {
		return m.FiatConversionMinAmount
	}
	return ""
}

func (m *Params) GetFiatConversionMaxAmount() string {
	if m != nil {
		return m.FiatConversionMaxAmount
	}
	return ""
}

func (m *Params) GetFiatConversionDailyLimit() string {
	if m != nil {
		return m.FiatConversionDailyLimit
	}
	return ""
}

func (m *Params) GetFiatConversionStableDenom() string {
	if m != nil {
		return m.FiatConversionStableDenom
	}
	return ""
}

func (m *Params) GetFiatConversionStableSymbol() string {
	if m != nil {
		return m.FiatConversionStableSymbol
	}
	return ""
}

func (m *Params) GetFiatConversionStableDecimals() uint32 {
	if m != nil {
		return m.FiatConversionStableDecimals
	}
	return 0
}

func (m *Params) GetFiatConversionDefaultFiat() string {
	if m != nil {
		return m.FiatConversionDefaultFiat
	}
	return ""
}

func (m *Params) GetFiatConversionDefaultMethod() string {
	if m != nil {
		return m.FiatConversionDefaultMethod
	}
	return ""
}

func (m *Params) GetFiatConversionMaxSlippage() string {
	if m != nil {
		return m.FiatConversionMaxSlippage
	}
	return ""
}

func (m *Params) GetFiatConversionRiskScoreThreshold() int32 {
	if m != nil {
		return m.FiatConversionRiskScoreThreshold
	}
	return 0
}

func (m *Params) GetFiatConversionMinComplianceStatus() string {
	if m != nil {
		return m.FiatConversionMinComplianceStatus
	}
	return ""
}

// TokenSpec captures token metadata for swaps.
type TokenSpec struct {
	Symbol   string `protobuf:"bytes,1,opt,name=symbol,proto3" json:"symbol,omitempty"`
	Denom    string `protobuf:"bytes,2,opt,name=denom,proto3" json:"denom,omitempty"`
	Decimals uint32 `protobuf:"varint,3,opt,name=decimals,proto3" json:"decimals,omitempty"`
	ChainId  string `protobuf:"bytes,4,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TokenSpec) Reset()         { *m = TokenSpec{} }
func (m *TokenSpec) String() string { return proto.CompactTextString(m) }
func (*TokenSpec) ProtoMessage()    {}
func (*TokenSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{13}
}
func (m *TokenSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TokenSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TokenSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TokenSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TokenSpec.Merge(m, src)
}
func (m *TokenSpec) XXX_Size() int {
	return m.Size()
}
func (m *TokenSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TokenSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TokenSpec proto.InternalMessageInfo

func (m *TokenSpec) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *TokenSpec) GetDenom() string {
	if m != nil {
		return m.Denom
	}
	return ""
}

func (m *TokenSpec) GetDecimals() uint32 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *TokenSpec) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// FiatPayoutPreference configures provider fiat conversion preferences.
type FiatPayoutPreference struct {
	Provider          string    `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
	Enabled           bool      `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	FiatCurrency      string    `protobuf:"bytes,3,opt,name=fiat_currency,json=fiatCurrency,proto3" json:"fiat_currency,omitempty"`
	PaymentMethod     string    `protobuf:"bytes,4,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	DestinationRef    string    `protobuf:"bytes,5,opt,name=destination_ref,json=destinationRef,proto3" json:"destination_ref,omitempty"`
	DestinationHash   string    `protobuf:"bytes,6,opt,name=destination_hash,json=destinationHash,proto3" json:"destination_hash,omitempty"`
	DestinationRegion string    `protobuf:"bytes,7,opt,name=destination_region,json=destinationRegion,proto3" json:"destination_region,omitempty"`
	PreferredDex      string    `protobuf:"bytes,8,opt,name=preferred_dex,json=preferredDex,proto3" json:"preferred_dex,omitempty"`
	PreferredOffRamp  string    `protobuf:"bytes,9,opt,name=preferred_off_ramp,json=preferredOffRamp,proto3" json:"preferred_off_ramp,omitempty"`
	SlippageTolerance float64   `protobuf:"fixed64,10,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	CryptoToken       TokenSpec `protobuf:"bytes,11,opt,name=crypto_token,json=cryptoToken,proto3" json:"crypto_token"`
	StableToken       TokenSpec `protobuf:"bytes,12,opt,name=stable_token,json=stableToken,proto3" json:"stable_token"`
	CreatedAt         int64     `protobuf:"varint,13,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	UpdatedAt         int64     `protobuf:"varint,14,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
}

func (m *FiatPayoutPreference) Reset()         { *m = FiatPayoutPreference{} }
func (m *FiatPayoutPreference) String() string { return proto.CompactTextString(m) }
func (*FiatPayoutPreference) ProtoMessage()    {}
func (*FiatPayoutPreference) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{14}
}
func (m *FiatPayoutPreference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FiatPayoutPreference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FiatPayoutPreference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FiatPayoutPreference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FiatPayoutPreference.Merge(m, src)
}
func (m *FiatPayoutPreference) XXX_Size() int {
	return m.Size()
}
func (m *FiatPayoutPreference) XXX_DiscardUnknown() {
	xxx_messageInfo_FiatPayoutPreference.DiscardUnknown(m)
}

var xxx_messageInfo_FiatPayoutPreference proto.InternalMessageInfo

func (m *FiatPayoutPreference) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *FiatPayoutPreference) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *FiatPayoutPreference) GetFiatCurrency() string {
	if m != nil {
		return m.FiatCurrency
	}
	return ""
}

func (m *FiatPayoutPreference) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *FiatPayoutPreference) GetDestinationRef() string {
	if m != nil {
		return m.DestinationRef
	}
	return ""
}

func (m *FiatPayoutPreference) GetDestinationHash() string {
	if m != nil {
		return m.DestinationHash
	}
	return ""
}

func (m *FiatPayoutPreference) GetDestinationRegion() string {
	if m != nil {
		return m.DestinationRegion
	}
	return ""
}

func (m *FiatPayoutPreference) GetPreferredDex() string {
	if m != nil {
		return m.PreferredDex
	}
	return ""
}

func (m *FiatPayoutPreference) GetPreferredOffRamp() string {
	if m != nil {
		return m.PreferredOffRamp
	}
	return ""
}

func (m *FiatPayoutPreference) GetSlippageTolerance() float64 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *FiatPayoutPreference) GetCryptoToken() TokenSpec {
	if m != nil {
		return m.CryptoToken
	}
	return TokenSpec{}
}

func (m *FiatPayoutPreference) GetStableToken() TokenSpec {
	if m != nil {
		return m.StableToken
	}
	return TokenSpec{}
}

func (m *FiatPayoutPreference) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *FiatPayoutPreference) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

// FiatConversionAuditEntry is an audit log entry for conversions.
type FiatConversionAuditEntry struct {
	Action    string            `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	Actor     string            `protobuf:"bytes,2,opt,name=actor,proto3" json:"actor,omitempty"`
	Reason    string            `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Timestamp int64             `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Metadata  map[string]string `protobuf:"bytes,5,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *FiatConversionAuditEntry) Reset()         { *m = FiatConversionAuditEntry{} }
func (m *FiatConversionAuditEntry) String() string { return proto.CompactTextString(m) }
func (*FiatConversionAuditEntry) ProtoMessage()    {}
func (*FiatConversionAuditEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{15}
}
func (m *FiatConversionAuditEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FiatConversionAuditEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FiatConversionAuditEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FiatConversionAuditEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FiatConversionAuditEntry.Merge(m, src)
}
func (m *FiatConversionAuditEntry) XXX_Size() int {
	return m.Size()
}
func (m *FiatConversionAuditEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_FiatConversionAuditEntry.DiscardUnknown(m)
}

var xxx_messageInfo_FiatConversionAuditEntry proto.InternalMessageInfo

func (m *FiatConversionAuditEntry) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *FiatConversionAuditEntry) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *FiatConversionAuditEntry) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *FiatConversionAuditEntry) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *FiatConversionAuditEntry) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// FiatConversionRecord stores conversion details.
type FiatConversionRecord struct {
	ConversionId        string                     `protobuf:"bytes,1,opt,name=conversion_id,json=conversionId,proto3" json:"conversion_id,omitempty"`
	InvoiceId           string                     `protobuf:"bytes,2,opt,name=invoice_id,json=invoiceId,proto3" json:"invoice_id,omitempty"`
	SettlementId        string                     `protobuf:"bytes,3,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	PayoutId            string                     `protobuf:"bytes,4,opt,name=payout_id,json=payoutId,proto3" json:"payout_id,omitempty"`
	EscrowId            string                     `protobuf:"bytes,5,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	OrderId             string                     `protobuf:"bytes,6,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId             string                     `protobuf:"bytes,7,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Provider            string                     `protobuf:"bytes,8,opt,name=provider,proto3" json:"provider,omitempty"`
	Customer            string                     `protobuf:"bytes,9,opt,name=customer,proto3" json:"customer,omitempty"`
	RequestedBy         string                     `protobuf:"bytes,10,opt,name=requested_by,json=requestedBy,proto3" json:"requested_by,omitempty"`
	RequestedAt         int64                      `protobuf:"varint,11,opt,name=requested_at,json=requestedAt,proto3" json:"requested_at,omitempty"`
	UpdatedAt           int64                      `protobuf:"varint,12,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at,omitempty"`
	State               string                     `protobuf:"bytes,13,opt,name=state,proto3" json:"state,omitempty"`
	CryptoToken         TokenSpec                  `protobuf:"bytes,14,opt,name=crypto_token,json=cryptoToken,proto3" json:"crypto_token"`
	StableToken         TokenSpec                  `protobuf:"bytes,15,opt,name=stable_token,json=stableToken,proto3" json:"stable_token"`
	CryptoAmount        types.Coin                 `protobuf:"bytes,16,opt,name=crypto_amount,json=cryptoAmount,proto3" json:"crypto_amount"`
	StableAmount        types.Coin                 `protobuf:"bytes,17,opt,name=stable_amount,json=stableAmount,proto3" json:"stable_amount"`
	FiatCurrency        string                     `protobuf:"bytes,18,opt,name=fiat_currency,json=fiatCurrency,proto3" json:"fiat_currency,omitempty"`
	FiatAmount          string                     `protobuf:"bytes,19,opt,name=fiat_amount,json=fiatAmount,proto3" json:"fiat_amount,omitempty"`
	PaymentMethod       string                     `protobuf:"bytes,20,opt,name=payment_method,json=paymentMethod,proto3" json:"payment_method,omitempty"`
	DestinationRef      string                     `protobuf:"bytes,21,opt,name=destination_ref,json=destinationRef,proto3" json:"destination_ref,omitempty"`
	DestinationHash     string                     `protobuf:"bytes,22,opt,name=destination_hash,json=destinationHash,proto3" json:"destination_hash,omitempty"`
	DestinationRegion   string                     `protobuf:"bytes,23,opt,name=destination_region,json=destinationRegion,proto3" json:"destination_region,omitempty"`
	SlippageTolerance   float64                    `protobuf:"fixed64,24,opt,name=slippage_tolerance,json=slippageTolerance,proto3" json:"slippage_tolerance,omitempty"`
	DexAdapter          string                     `protobuf:"bytes,25,opt,name=dex_adapter,json=dexAdapter,proto3" json:"dex_adapter,omitempty"`
	SwapQuoteId         string                     `protobuf:"bytes,26,opt,name=swap_quote_id,json=swapQuoteId,proto3" json:"swap_quote_id,omitempty"`
	SwapTxHash          string                     `protobuf:"bytes,27,opt,name=swap_tx_hash,json=swapTxHash,proto3" json:"swap_tx_hash,omitempty"`
	SwapStatus          string                     `protobuf:"bytes,28,opt,name=swap_status,json=swapStatus,proto3" json:"swap_status,omitempty"`
	OffRampProvider     string                     `protobuf:"bytes,29,opt,name=off_ramp_provider,json=offRampProvider,proto3" json:"off_ramp_provider,omitempty"`
	OffRampQuoteId      string                     `protobuf:"bytes,30,opt,name=off_ramp_quote_id,json=offRampQuoteId,proto3" json:"off_ramp_quote_id,omitempty"`
	OffRampId           string                     `protobuf:"bytes,31,opt,name=off_ramp_id,json=offRampId,proto3" json:"off_ramp_id,omitempty"`
	OffRampStatus       string                     `protobuf:"bytes,32,opt,name=off_ramp_status,json=offRampStatus,proto3" json:"off_ramp_status,omitempty"`
	OffRampReference    string                     `protobuf:"bytes,33,opt,name=off_ramp_reference,json=offRampReference,proto3" json:"off_ramp_reference,omitempty"`
	ComplianceStatus    string                     `protobuf:"bytes,34,opt,name=compliance_status,json=complianceStatus,proto3" json:"compliance_status,omitempty"`
	ComplianceRiskScore int32                      `protobuf:"varint,35,opt,name=compliance_risk_score,json=complianceRiskScore,proto3" json:"compliance_risk_score,omitempty"`
	ComplianceCheckedAt int64                      `protobuf:"varint,36,opt,name=compliance_checked_at,json=complianceCheckedAt,proto3" json:"compliance_checked_at,omitempty"`
	FailureReason       string                     `protobuf:"bytes,37,opt,name=failure_reason,json=failureReason,proto3" json:"failure_reason,omitempty"`
	AuditTrail          []FiatConversionAuditEntry `protobuf:"bytes,38,rep,name=audit_trail,json=auditTrail,proto3" json:"audit_trail"`
}

func (m *FiatConversionRecord) Reset()         { *m = FiatConversionRecord{} }
func (m *FiatConversionRecord) String() string { return proto.CompactTextString(m) }
func (*FiatConversionRecord) ProtoMessage()    {}
func (*FiatConversionRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{16}
}
func (m *FiatConversionRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FiatConversionRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FiatConversionRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FiatConversionRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FiatConversionRecord.Merge(m, src)
}
func (m *FiatConversionRecord) XXX_Size() int {
	return m.Size()
}
func (m *FiatConversionRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_FiatConversionRecord.DiscardUnknown(m)
}

var xxx_messageInfo_FiatConversionRecord proto.InternalMessageInfo

func (m *FiatConversionRecord) GetConversionId() string {
	if m != nil {
		return m.ConversionId
	}
	return ""
}

func (m *FiatConversionRecord) GetInvoiceId() string {
	if m != nil {
		return m.InvoiceId
	}
	return ""
}

func (m *FiatConversionRecord) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *FiatConversionRecord) GetPayoutId() string {
	if m != nil {
		return m.PayoutId
	}
	return ""
}

func (m *FiatConversionRecord) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *FiatConversionRecord) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *FiatConversionRecord) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *FiatConversionRecord) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *FiatConversionRecord) GetCustomer() string {
	if m != nil {
		return m.Customer
	}
	return ""
}

func (m *FiatConversionRecord) GetRequestedBy() string {
	if m != nil {
		return m.RequestedBy
	}
	return ""
}

func (m *FiatConversionRecord) GetRequestedAt() int64 {
	if m != nil {
		return m.RequestedAt
	}
	return 0
}

func (m *FiatConversionRecord) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *FiatConversionRecord) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *FiatConversionRecord) GetCryptoToken() TokenSpec {
	if m != nil {
		return m.CryptoToken
	}
	return TokenSpec{}
}

func (m *FiatConversionRecord) GetStableToken() TokenSpec {
	if m != nil {
		return m.StableToken
	}
	return TokenSpec{}
}

func (m *FiatConversionRecord) GetCryptoAmount() types.Coin {
	if m != nil {
		return m.CryptoAmount
	}
	return types.Coin{}
}

func (m *FiatConversionRecord) GetStableAmount() types.Coin {
	if m != nil {
		return m.StableAmount
	}
	return types.Coin{}
}

func (m *FiatConversionRecord) GetFiatCurrency() string {
	if m != nil {
		return m.FiatCurrency
	}
	return ""
}

func (m *FiatConversionRecord) GetFiatAmount() string {
	if m != nil {
		return m.FiatAmount
	}
	return ""
}

func (m *FiatConversionRecord) GetPaymentMethod() string {
	if m != nil {
		return m.PaymentMethod
	}
	return ""
}

func (m *FiatConversionRecord) GetDestinationRef() string {
	if m != nil {
		return m.DestinationRef
	}
	return ""
}

func (m *FiatConversionRecord) GetDestinationHash() string {
	if m != nil {
		return m.DestinationHash
	}
	return ""
}

func (m *FiatConversionRecord) GetDestinationRegion() string {
	if m != nil {
		return m.DestinationRegion
	}
	return ""
}

func (m *FiatConversionRecord) GetSlippageTolerance() float64 {
	if m != nil {
		return m.SlippageTolerance
	}
	return 0
}

func (m *FiatConversionRecord) GetDexAdapter() string {
	if m != nil {
		return m.DexAdapter
	}
	return ""
}

func (m *FiatConversionRecord) GetSwapQuoteId() string {
	if m != nil {
		return m.SwapQuoteId
	}
	return ""
}

func (m *FiatConversionRecord) GetSwapTxHash() string {
	if m != nil {
		return m.SwapTxHash
	}
	return ""
}

func (m *FiatConversionRecord) GetSwapStatus() string {
	if m != nil {
		return m.SwapStatus
	}
	return ""
}

func (m *FiatConversionRecord) GetOffRampProvider() string {
	if m != nil {
		return m.OffRampProvider
	}
	return ""
}

func (m *FiatConversionRecord) GetOffRampQuoteId() string {
	if m != nil {
		return m.OffRampQuoteId
	}
	return ""
}

func (m *FiatConversionRecord) GetOffRampId() string {
	if m != nil {
		return m.OffRampId
	}
	return ""
}

func (m *FiatConversionRecord) GetOffRampStatus() string {
	if m != nil {
		return m.OffRampStatus
	}
	return ""
}

func (m *FiatConversionRecord) GetOffRampReference() string {
	if m != nil {
		return m.OffRampReference
	}
	return ""
}

func (m *FiatConversionRecord) GetComplianceStatus() string {
	if m != nil {
		return m.ComplianceStatus
	}
	return ""
}

func (m *FiatConversionRecord) GetComplianceRiskScore() int32 {
	if m != nil {
		return m.ComplianceRiskScore
	}
	return 0
}

func (m *FiatConversionRecord) GetComplianceCheckedAt() int64 {
	if m != nil {
		return m.ComplianceCheckedAt
	}
	return 0
}

func (m *FiatConversionRecord) GetFailureReason() string {
	if m != nil {
		return m.FailureReason
	}
	return ""
}

func (m *FiatConversionRecord) GetAuditTrail() []FiatConversionAuditEntry {
	if m != nil {
		return m.AuditTrail
	}
	return nil
}

// QueryEscrowRequest is the request for querying an escrow by ID.
type QueryEscrowRequest struct {
	EscrowId string `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
}

func (m *QueryEscrowRequest) Reset()         { *m = QueryEscrowRequest{} }
func (m *QueryEscrowRequest) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowRequest) ProtoMessage()    {}
func (*QueryEscrowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{17}
}
func (m *QueryEscrowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowRequest.Merge(m, src)
}
func (m *QueryEscrowRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowRequest proto.InternalMessageInfo

func (m *QueryEscrowRequest) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

// QueryEscrowResponse is the response for querying an escrow by ID.
type QueryEscrowResponse struct {
	Escrow *EscrowAccount `protobuf:"bytes,1,opt,name=escrow,proto3" json:"escrow,omitempty"`
}

func (m *QueryEscrowResponse) Reset()         { *m = QueryEscrowResponse{} }
func (m *QueryEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowResponse) ProtoMessage()    {}
func (*QueryEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{18}
}
func (m *QueryEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowResponse.Merge(m, src)
}
func (m *QueryEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowResponse proto.InternalMessageInfo

func (m *QueryEscrowResponse) GetEscrow() *EscrowAccount {
	if m != nil {
		return m.Escrow
	}
	return nil
}

// QueryEscrowsByOrderRequest is the request for querying escrows by order.
type QueryEscrowsByOrderRequest struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *QueryEscrowsByOrderRequest) Reset()         { *m = QueryEscrowsByOrderRequest{} }
func (m *QueryEscrowsByOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowsByOrderRequest) ProtoMessage()    {}
func (*QueryEscrowsByOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{19}
}
func (m *QueryEscrowsByOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowsByOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowsByOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowsByOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowsByOrderRequest.Merge(m, src)
}
func (m *QueryEscrowsByOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowsByOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowsByOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowsByOrderRequest proto.InternalMessageInfo

func (m *QueryEscrowsByOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

// QueryEscrowsByOrderResponse is the response for querying escrows by order.
type QueryEscrowsByOrderResponse struct {
	Escrows []EscrowAccount `protobuf:"bytes,1,rep,name=escrows,proto3" json:"escrows"`
}

func (m *QueryEscrowsByOrderResponse) Reset()         { *m = QueryEscrowsByOrderResponse{} }
func (m *QueryEscrowsByOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowsByOrderResponse) ProtoMessage()    {}
func (*QueryEscrowsByOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{20}
}
func (m *QueryEscrowsByOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowsByOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowsByOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowsByOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowsByOrderResponse.Merge(m, src)
}
func (m *QueryEscrowsByOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowsByOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowsByOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowsByOrderResponse proto.InternalMessageInfo

func (m *QueryEscrowsByOrderResponse) GetEscrows() []EscrowAccount {
	if m != nil {
		return m.Escrows
	}
	return nil
}

// QueryEscrowsByStateRequest is the request for querying escrows by state.
type QueryEscrowsByStateRequest struct {
	State string `protobuf:"bytes,1,opt,name=state,proto3" json:"state,omitempty"`
}

func (m *QueryEscrowsByStateRequest) Reset()         { *m = QueryEscrowsByStateRequest{} }
func (m *QueryEscrowsByStateRequest) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowsByStateRequest) ProtoMessage()    {}
func (*QueryEscrowsByStateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{21}
}
func (m *QueryEscrowsByStateRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowsByStateRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowsByStateRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowsByStateRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowsByStateRequest.Merge(m, src)
}
func (m *QueryEscrowsByStateRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowsByStateRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowsByStateRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowsByStateRequest proto.InternalMessageInfo

func (m *QueryEscrowsByStateRequest) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

// QueryEscrowsByStateResponse is the response for querying escrows by state.
type QueryEscrowsByStateResponse struct {
	Escrows []EscrowAccount `protobuf:"bytes,1,rep,name=escrows,proto3" json:"escrows"`
}

func (m *QueryEscrowsByStateResponse) Reset()         { *m = QueryEscrowsByStateResponse{} }
func (m *QueryEscrowsByStateResponse) String() string { return proto.CompactTextString(m) }
func (*QueryEscrowsByStateResponse) ProtoMessage()    {}
func (*QueryEscrowsByStateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{22}
}
func (m *QueryEscrowsByStateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryEscrowsByStateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryEscrowsByStateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryEscrowsByStateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryEscrowsByStateResponse.Merge(m, src)
}
func (m *QueryEscrowsByStateResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryEscrowsByStateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryEscrowsByStateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryEscrowsByStateResponse proto.InternalMessageInfo

func (m *QueryEscrowsByStateResponse) GetEscrows() []EscrowAccount {
	if m != nil {
		return m.Escrows
	}
	return nil
}

// QuerySettlementRequest is the request for querying a settlement by ID.
type QuerySettlementRequest struct {
	SettlementId string `protobuf:"bytes,1,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
}

func (m *QuerySettlementRequest) Reset()         { *m = QuerySettlementRequest{} }
func (m *QuerySettlementRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySettlementRequest) ProtoMessage()    {}
func (*QuerySettlementRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{23}
}
func (m *QuerySettlementRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySettlementRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySettlementRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySettlementRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySettlementRequest.Merge(m, src)
}
func (m *QuerySettlementRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySettlementRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySettlementRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySettlementRequest proto.InternalMessageInfo

func (m *QuerySettlementRequest) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

// QuerySettlementResponse is the response for querying a settlement by ID.
type QuerySettlementResponse struct {
	Settlement *SettlementRecord `protobuf:"bytes,1,opt,name=settlement,proto3" json:"settlement,omitempty"`
}

func (m *QuerySettlementResponse) Reset()         { *m = QuerySettlementResponse{} }
func (m *QuerySettlementResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySettlementResponse) ProtoMessage()    {}
func (*QuerySettlementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{24}
}
func (m *QuerySettlementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySettlementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySettlementResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySettlementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySettlementResponse.Merge(m, src)
}
func (m *QuerySettlementResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySettlementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySettlementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySettlementResponse proto.InternalMessageInfo

func (m *QuerySettlementResponse) GetSettlement() *SettlementRecord {
	if m != nil {
		return m.Settlement
	}
	return nil
}

// QuerySettlementsByOrderRequest is the request for querying settlements by order.
type QuerySettlementsByOrderRequest struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *QuerySettlementsByOrderRequest) Reset()         { *m = QuerySettlementsByOrderRequest{} }
func (m *QuerySettlementsByOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QuerySettlementsByOrderRequest) ProtoMessage()    {}
func (*QuerySettlementsByOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{25}
}
func (m *QuerySettlementsByOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySettlementsByOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySettlementsByOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySettlementsByOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySettlementsByOrderRequest.Merge(m, src)
}
func (m *QuerySettlementsByOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QuerySettlementsByOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySettlementsByOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySettlementsByOrderRequest proto.InternalMessageInfo

func (m *QuerySettlementsByOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

// QuerySettlementsByOrderResponse is the response for querying settlements by order.
type QuerySettlementsByOrderResponse struct {
	Settlements []SettlementRecord `protobuf:"bytes,1,rep,name=settlements,proto3" json:"settlements"`
}

func (m *QuerySettlementsByOrderResponse) Reset()         { *m = QuerySettlementsByOrderResponse{} }
func (m *QuerySettlementsByOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QuerySettlementsByOrderResponse) ProtoMessage()    {}
func (*QuerySettlementsByOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{26}
}
func (m *QuerySettlementsByOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuerySettlementsByOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuerySettlementsByOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuerySettlementsByOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuerySettlementsByOrderResponse.Merge(m, src)
}
func (m *QuerySettlementsByOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QuerySettlementsByOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QuerySettlementsByOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QuerySettlementsByOrderResponse proto.InternalMessageInfo

func (m *QuerySettlementsByOrderResponse) GetSettlements() []SettlementRecord {
	if m != nil {
		return m.Settlements
	}
	return nil
}

// QueryUsageRecordRequest is the request for querying a usage record by ID.
type QueryUsageRecordRequest struct {
	UsageId string `protobuf:"bytes,1,opt,name=usage_id,json=usageId,proto3" json:"usage_id,omitempty"`
}

func (m *QueryUsageRecordRequest) Reset()         { *m = QueryUsageRecordRequest{} }
func (m *QueryUsageRecordRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUsageRecordRequest) ProtoMessage()    {}
func (*QueryUsageRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{27}
}
func (m *QueryUsageRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageRecordRequest.Merge(m, src)
}
func (m *QueryUsageRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageRecordRequest proto.InternalMessageInfo

func (m *QueryUsageRecordRequest) GetUsageId() string {
	if m != nil {
		return m.UsageId
	}
	return ""
}

// QueryUsageRecordResponse is the response for querying a usage record by ID.
type QueryUsageRecordResponse struct {
	UsageRecord *UsageRecord `protobuf:"bytes,1,opt,name=usage_record,json=usageRecord,proto3" json:"usage_record,omitempty"`
}

func (m *QueryUsageRecordResponse) Reset()         { *m = QueryUsageRecordResponse{} }
func (m *QueryUsageRecordResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUsageRecordResponse) ProtoMessage()    {}
func (*QueryUsageRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{28}
}
func (m *QueryUsageRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageRecordResponse.Merge(m, src)
}
func (m *QueryUsageRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageRecordResponse proto.InternalMessageInfo

func (m *QueryUsageRecordResponse) GetUsageRecord() *UsageRecord {
	if m != nil {
		return m.UsageRecord
	}
	return nil
}

// QueryUsageRecordsByOrderRequest is the request for querying usage records by order.
type QueryUsageRecordsByOrderRequest struct {
	OrderId string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
}

func (m *QueryUsageRecordsByOrderRequest) Reset()         { *m = QueryUsageRecordsByOrderRequest{} }
func (m *QueryUsageRecordsByOrderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUsageRecordsByOrderRequest) ProtoMessage()    {}
func (*QueryUsageRecordsByOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{29}
}
func (m *QueryUsageRecordsByOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageRecordsByOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageRecordsByOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageRecordsByOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageRecordsByOrderRequest.Merge(m, src)
}
func (m *QueryUsageRecordsByOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageRecordsByOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageRecordsByOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageRecordsByOrderRequest proto.InternalMessageInfo

func (m *QueryUsageRecordsByOrderRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

// QueryUsageRecordsByOrderResponse is the response for querying usage records by order.
type QueryUsageRecordsByOrderResponse struct {
	UsageRecords []UsageRecord `protobuf:"bytes,1,rep,name=usage_records,json=usageRecords,proto3" json:"usage_records"`
}

func (m *QueryUsageRecordsByOrderResponse) Reset()         { *m = QueryUsageRecordsByOrderResponse{} }
func (m *QueryUsageRecordsByOrderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUsageRecordsByOrderResponse) ProtoMessage()    {}
func (*QueryUsageRecordsByOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{30}
}
func (m *QueryUsageRecordsByOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageRecordsByOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageRecordsByOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageRecordsByOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageRecordsByOrderResponse.Merge(m, src)
}
func (m *QueryUsageRecordsByOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageRecordsByOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageRecordsByOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageRecordsByOrderResponse proto.InternalMessageInfo

func (m *QueryUsageRecordsByOrderResponse) GetUsageRecords() []UsageRecord {
	if m != nil {
		return m.UsageRecords
	}
	return nil
}

// QueryUsageSummaryRequest is the request for querying usage summaries.
type QueryUsageSummaryRequest struct {
	OrderId     string `protobuf:"bytes,1,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Provider    string `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider,omitempty"`
	PeriodStart int64  `protobuf:"varint,3,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	PeriodEnd   int64  `protobuf:"varint,4,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
}

func (m *QueryUsageSummaryRequest) Reset()         { *m = QueryUsageSummaryRequest{} }
func (m *QueryUsageSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryUsageSummaryRequest) ProtoMessage()    {}
func (*QueryUsageSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{31}
}
func (m *QueryUsageSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageSummaryRequest.Merge(m, src)
}
func (m *QueryUsageSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageSummaryRequest proto.InternalMessageInfo

func (m *QueryUsageSummaryRequest) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *QueryUsageSummaryRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

func (m *QueryUsageSummaryRequest) GetPeriodStart() int64 {
	if m != nil {
		return m.PeriodStart
	}
	return 0
}

func (m *QueryUsageSummaryRequest) GetPeriodEnd() int64 {
	if m != nil {
		return m.PeriodEnd
	}
	return 0
}

// QueryUsageSummaryResponse is the response for querying usage summaries.
type QueryUsageSummaryResponse struct {
	Summary UsageSummary `protobuf:"bytes,1,opt,name=summary,proto3" json:"summary"`
}

func (m *QueryUsageSummaryResponse) Reset()         { *m = QueryUsageSummaryResponse{} }
func (m *QueryUsageSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryUsageSummaryResponse) ProtoMessage()    {}
func (*QueryUsageSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{32}
}
func (m *QueryUsageSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryUsageSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryUsageSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryUsageSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryUsageSummaryResponse.Merge(m, src)
}
func (m *QueryUsageSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryUsageSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryUsageSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryUsageSummaryResponse proto.InternalMessageInfo

func (m *QueryUsageSummaryResponse) GetSummary() UsageSummary {
	if m != nil {
		return m.Summary
	}
	return UsageSummary{}
}

// QueryRewardDistributionRequest is the request for querying a reward distribution by ID.
type QueryRewardDistributionRequest struct {
	DistributionId string `protobuf:"bytes,1,opt,name=distribution_id,json=distributionId,proto3" json:"distribution_id,omitempty"`
}

func (m *QueryRewardDistributionRequest) Reset()         { *m = QueryRewardDistributionRequest{} }
func (m *QueryRewardDistributionRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRewardDistributionRequest) ProtoMessage()    {}
func (*QueryRewardDistributionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{33}
}
func (m *QueryRewardDistributionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardDistributionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardDistributionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardDistributionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardDistributionRequest.Merge(m, src)
}
func (m *QueryRewardDistributionRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardDistributionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardDistributionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardDistributionRequest proto.InternalMessageInfo

func (m *QueryRewardDistributionRequest) GetDistributionId() string {
	if m != nil {
		return m.DistributionId
	}
	return ""
}

// QueryRewardDistributionResponse is the response for querying a reward distribution by ID.
type QueryRewardDistributionResponse struct {
	Distribution *RewardDistribution `protobuf:"bytes,1,opt,name=distribution,proto3" json:"distribution,omitempty"`
}

func (m *QueryRewardDistributionResponse) Reset()         { *m = QueryRewardDistributionResponse{} }
func (m *QueryRewardDistributionResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRewardDistributionResponse) ProtoMessage()    {}
func (*QueryRewardDistributionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{34}
}
func (m *QueryRewardDistributionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardDistributionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardDistributionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardDistributionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardDistributionResponse.Merge(m, src)
}
func (m *QueryRewardDistributionResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardDistributionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardDistributionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardDistributionResponse proto.InternalMessageInfo

func (m *QueryRewardDistributionResponse) GetDistribution() *RewardDistribution {
	if m != nil {
		return m.Distribution
	}
	return nil
}

// QueryRewardsByEpochRequest is the request for querying rewards by epoch.
type QueryRewardsByEpochRequest struct {
	EpochNumber uint64 `protobuf:"varint,1,opt,name=epoch_number,json=epochNumber,proto3" json:"epoch_number,omitempty"`
}

func (m *QueryRewardsByEpochRequest) Reset()         { *m = QueryRewardsByEpochRequest{} }
func (m *QueryRewardsByEpochRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRewardsByEpochRequest) ProtoMessage()    {}
func (*QueryRewardsByEpochRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{35}
}
func (m *QueryRewardsByEpochRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardsByEpochRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardsByEpochRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardsByEpochRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardsByEpochRequest.Merge(m, src)
}
func (m *QueryRewardsByEpochRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardsByEpochRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardsByEpochRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardsByEpochRequest proto.InternalMessageInfo

func (m *QueryRewardsByEpochRequest) GetEpochNumber() uint64 {
	if m != nil {
		return m.EpochNumber
	}
	return 0
}

// QueryRewardsByEpochResponse is the response for querying rewards by epoch.
type QueryRewardsByEpochResponse struct {
	Distributions []RewardDistribution `protobuf:"bytes,1,rep,name=distributions,proto3" json:"distributions"`
}

func (m *QueryRewardsByEpochResponse) Reset()         { *m = QueryRewardsByEpochResponse{} }
func (m *QueryRewardsByEpochResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRewardsByEpochResponse) ProtoMessage()    {}
func (*QueryRewardsByEpochResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{36}
}
func (m *QueryRewardsByEpochResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardsByEpochResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardsByEpochResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardsByEpochResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardsByEpochResponse.Merge(m, src)
}
func (m *QueryRewardsByEpochResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardsByEpochResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardsByEpochResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardsByEpochResponse proto.InternalMessageInfo

func (m *QueryRewardsByEpochResponse) GetDistributions() []RewardDistribution {
	if m != nil {
		return m.Distributions
	}
	return nil
}

// QueryRewardHistoryRequest is the request for querying reward history.
type QueryRewardHistoryRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	Source  string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
	Limit   uint32 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	Offset  uint32 `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
}

func (m *QueryRewardHistoryRequest) Reset()         { *m = QueryRewardHistoryRequest{} }
func (m *QueryRewardHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRewardHistoryRequest) ProtoMessage()    {}
func (*QueryRewardHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{37}
}
func (m *QueryRewardHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardHistoryRequest.Merge(m, src)
}
func (m *QueryRewardHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardHistoryRequest proto.InternalMessageInfo

func (m *QueryRewardHistoryRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *QueryRewardHistoryRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *QueryRewardHistoryRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *QueryRewardHistoryRequest) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// QueryRewardHistoryResponse is the response for querying reward history.
type QueryRewardHistoryResponse struct {
	Entries []RewardHistoryEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries"`
}

func (m *QueryRewardHistoryResponse) Reset()         { *m = QueryRewardHistoryResponse{} }
func (m *QueryRewardHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryRewardHistoryResponse) ProtoMessage()    {}
func (*QueryRewardHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{38}
}
func (m *QueryRewardHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryRewardHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryRewardHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryRewardHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryRewardHistoryResponse.Merge(m, src)
}
func (m *QueryRewardHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryRewardHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryRewardHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryRewardHistoryResponse proto.InternalMessageInfo

func (m *QueryRewardHistoryResponse) GetEntries() []RewardHistoryEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// QueryClaimableRewardsRequest is the request for querying claimable rewards.
type QueryClaimableRewardsRequest struct {
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *QueryClaimableRewardsRequest) Reset()         { *m = QueryClaimableRewardsRequest{} }
func (m *QueryClaimableRewardsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryClaimableRewardsRequest) ProtoMessage()    {}
func (*QueryClaimableRewardsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{39}
}
func (m *QueryClaimableRewardsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryClaimableRewardsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryClaimableRewardsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryClaimableRewardsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryClaimableRewardsRequest.Merge(m, src)
}
func (m *QueryClaimableRewardsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryClaimableRewardsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryClaimableRewardsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryClaimableRewardsRequest proto.InternalMessageInfo

func (m *QueryClaimableRewardsRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// QueryClaimableRewardsResponse is the response for querying claimable rewards.
type QueryClaimableRewardsResponse struct {
	Rewards *ClaimableRewards `protobuf:"bytes,1,opt,name=rewards,proto3" json:"rewards,omitempty"`
}

func (m *QueryClaimableRewardsResponse) Reset()         { *m = QueryClaimableRewardsResponse{} }
func (m *QueryClaimableRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryClaimableRewardsResponse) ProtoMessage()    {}
func (*QueryClaimableRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{40}
}
func (m *QueryClaimableRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryClaimableRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryClaimableRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryClaimableRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryClaimableRewardsResponse.Merge(m, src)
}
func (m *QueryClaimableRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryClaimableRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryClaimableRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryClaimableRewardsResponse proto.InternalMessageInfo

func (m *QueryClaimableRewardsResponse) GetRewards() *ClaimableRewards {
	if m != nil {
		return m.Rewards
	}
	return nil
}

// QueryPayoutRequest is the request for querying a payout by ID.
type QueryPayoutRequest struct {
	PayoutId string `protobuf:"bytes,1,opt,name=payout_id,json=payoutId,proto3" json:"payout_id,omitempty"`
}

func (m *QueryPayoutRequest) Reset()         { *m = QueryPayoutRequest{} }
func (m *QueryPayoutRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPayoutRequest) ProtoMessage()    {}
func (*QueryPayoutRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{41}
}
func (m *QueryPayoutRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPayoutRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPayoutRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPayoutRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPayoutRequest.Merge(m, src)
}
func (m *QueryPayoutRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPayoutRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPayoutRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPayoutRequest proto.InternalMessageInfo

func (m *QueryPayoutRequest) GetPayoutId() string {
	if m != nil {
		return m.PayoutId
	}
	return ""
}

// QueryPayoutResponse is the response for querying a payout by ID.
type QueryPayoutResponse struct {
	Payout *PayoutRecord `protobuf:"bytes,1,opt,name=payout,proto3" json:"payout,omitempty"`
}

func (m *QueryPayoutResponse) Reset()         { *m = QueryPayoutResponse{} }
func (m *QueryPayoutResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPayoutResponse) ProtoMessage()    {}
func (*QueryPayoutResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{42}
}
func (m *QueryPayoutResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPayoutResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPayoutResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPayoutResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPayoutResponse.Merge(m, src)
}
func (m *QueryPayoutResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPayoutResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPayoutResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPayoutResponse proto.InternalMessageInfo

func (m *QueryPayoutResponse) GetPayout() *PayoutRecord {
	if m != nil {
		return m.Payout
	}
	return nil
}

// QueryPayoutsByProviderRequest is the request for querying payouts by provider.
type QueryPayoutsByProviderRequest struct {
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
}

func (m *QueryPayoutsByProviderRequest) Reset()         { *m = QueryPayoutsByProviderRequest{} }
func (m *QueryPayoutsByProviderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryPayoutsByProviderRequest) ProtoMessage()    {}
func (*QueryPayoutsByProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{43}
}
func (m *QueryPayoutsByProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPayoutsByProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPayoutsByProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPayoutsByProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPayoutsByProviderRequest.Merge(m, src)
}
func (m *QueryPayoutsByProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryPayoutsByProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPayoutsByProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPayoutsByProviderRequest proto.InternalMessageInfo

func (m *QueryPayoutsByProviderRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

// QueryPayoutsByProviderResponse is the response for querying payouts by provider.
type QueryPayoutsByProviderResponse struct {
	Payouts []PayoutRecord `protobuf:"bytes,1,rep,name=payouts,proto3" json:"payouts"`
}

func (m *QueryPayoutsByProviderResponse) Reset()         { *m = QueryPayoutsByProviderResponse{} }
func (m *QueryPayoutsByProviderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryPayoutsByProviderResponse) ProtoMessage()    {}
func (*QueryPayoutsByProviderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{44}
}
func (m *QueryPayoutsByProviderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPayoutsByProviderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPayoutsByProviderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPayoutsByProviderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPayoutsByProviderResponse.Merge(m, src)
}
func (m *QueryPayoutsByProviderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryPayoutsByProviderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPayoutsByProviderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPayoutsByProviderResponse proto.InternalMessageInfo

func (m *QueryPayoutsByProviderResponse) GetPayouts() []PayoutRecord {
	if m != nil {
		return m.Payouts
	}
	return nil
}

// QueryParamsRequest is the request for querying module params.
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{45}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is the response for querying module params.
type QueryParamsResponse struct {
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{46}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// QueryFiatConversionRequest is the request for querying a fiat conversion by ID.
type QueryFiatConversionRequest struct {
	ConversionId string `protobuf:"bytes,1,opt,name=conversion_id,json=conversionId,proto3" json:"conversion_id,omitempty"`
}

func (m *QueryFiatConversionRequest) Reset()         { *m = QueryFiatConversionRequest{} }
func (m *QueryFiatConversionRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFiatConversionRequest) ProtoMessage()    {}
func (*QueryFiatConversionRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{47}
}
func (m *QueryFiatConversionRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatConversionRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatConversionRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatConversionRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatConversionRequest.Merge(m, src)
}
func (m *QueryFiatConversionRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatConversionRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatConversionRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatConversionRequest proto.InternalMessageInfo

func (m *QueryFiatConversionRequest) GetConversionId() string {
	if m != nil {
		return m.ConversionId
	}
	return ""
}

// QueryFiatConversionResponse is the response for querying a fiat conversion by ID.
type QueryFiatConversionResponse struct {
	Conversion *FiatConversionRecord `protobuf:"bytes,1,opt,name=conversion,proto3" json:"conversion,omitempty"`
}

func (m *QueryFiatConversionResponse) Reset()         { *m = QueryFiatConversionResponse{} }
func (m *QueryFiatConversionResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFiatConversionResponse) ProtoMessage()    {}
func (*QueryFiatConversionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{48}
}
func (m *QueryFiatConversionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatConversionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatConversionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatConversionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatConversionResponse.Merge(m, src)
}
func (m *QueryFiatConversionResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatConversionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatConversionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatConversionResponse proto.InternalMessageInfo

func (m *QueryFiatConversionResponse) GetConversion() *FiatConversionRecord {
	if m != nil {
		return m.Conversion
	}
	return nil
}

// QueryFiatConversionsByProviderRequest is the request for querying fiat conversions by provider.
type QueryFiatConversionsByProviderRequest struct {
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
}

func (m *QueryFiatConversionsByProviderRequest) Reset()         { *m = QueryFiatConversionsByProviderRequest{} }
func (m *QueryFiatConversionsByProviderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFiatConversionsByProviderRequest) ProtoMessage()    {}
func (*QueryFiatConversionsByProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{49}
}
func (m *QueryFiatConversionsByProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatConversionsByProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatConversionsByProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatConversionsByProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatConversionsByProviderRequest.Merge(m, src)
}
func (m *QueryFiatConversionsByProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatConversionsByProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatConversionsByProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatConversionsByProviderRequest proto.InternalMessageInfo

func (m *QueryFiatConversionsByProviderRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

// QueryFiatConversionsByProviderResponse is the response for querying fiat conversions by provider.
type QueryFiatConversionsByProviderResponse struct {
	Conversions []FiatConversionRecord `protobuf:"bytes,1,rep,name=conversions,proto3" json:"conversions"`
}

func (m *QueryFiatConversionsByProviderResponse) Reset() {
	*m = QueryFiatConversionsByProviderResponse{}
}
func (m *QueryFiatConversionsByProviderResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFiatConversionsByProviderResponse) ProtoMessage()    {}
func (*QueryFiatConversionsByProviderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{50}
}
func (m *QueryFiatConversionsByProviderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatConversionsByProviderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatConversionsByProviderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatConversionsByProviderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatConversionsByProviderResponse.Merge(m, src)
}
func (m *QueryFiatConversionsByProviderResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatConversionsByProviderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatConversionsByProviderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatConversionsByProviderResponse proto.InternalMessageInfo

func (m *QueryFiatConversionsByProviderResponse) GetConversions() []FiatConversionRecord {
	if m != nil {
		return m.Conversions
	}
	return nil
}

// QueryFiatPayoutPreferenceRequest is the request for querying fiat payout preference.
type QueryFiatPayoutPreferenceRequest struct {
	Provider string `protobuf:"bytes,1,opt,name=provider,proto3" json:"provider,omitempty"`
}

func (m *QueryFiatPayoutPreferenceRequest) Reset()         { *m = QueryFiatPayoutPreferenceRequest{} }
func (m *QueryFiatPayoutPreferenceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryFiatPayoutPreferenceRequest) ProtoMessage()    {}
func (*QueryFiatPayoutPreferenceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{51}
}
func (m *QueryFiatPayoutPreferenceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatPayoutPreferenceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatPayoutPreferenceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatPayoutPreferenceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatPayoutPreferenceRequest.Merge(m, src)
}
func (m *QueryFiatPayoutPreferenceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatPayoutPreferenceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatPayoutPreferenceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatPayoutPreferenceRequest proto.InternalMessageInfo

func (m *QueryFiatPayoutPreferenceRequest) GetProvider() string {
	if m != nil {
		return m.Provider
	}
	return ""
}

// QueryFiatPayoutPreferenceResponse is the response for querying fiat payout preference.
type QueryFiatPayoutPreferenceResponse struct {
	Preference *FiatPayoutPreference `protobuf:"bytes,1,opt,name=preference,proto3" json:"preference,omitempty"`
}

func (m *QueryFiatPayoutPreferenceResponse) Reset()         { *m = QueryFiatPayoutPreferenceResponse{} }
func (m *QueryFiatPayoutPreferenceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryFiatPayoutPreferenceResponse) ProtoMessage()    {}
func (*QueryFiatPayoutPreferenceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3435bfc41107fa05, []int{52}
}
func (m *QueryFiatPayoutPreferenceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryFiatPayoutPreferenceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryFiatPayoutPreferenceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryFiatPayoutPreferenceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryFiatPayoutPreferenceResponse.Merge(m, src)
}
func (m *QueryFiatPayoutPreferenceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryFiatPayoutPreferenceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryFiatPayoutPreferenceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryFiatPayoutPreferenceResponse proto.InternalMessageInfo

func (m *QueryFiatPayoutPreferenceResponse) GetPreference() *FiatPayoutPreference {
	if m != nil {
		return m.Preference
	}
	return nil
}

func init() {
	proto.RegisterType((*ReleaseCondition)(nil), "virtengine.settlement.v1.ReleaseCondition")
	proto.RegisterType((*EscrowAccount)(nil), "virtengine.settlement.v1.EscrowAccount")
	proto.RegisterType((*SettlementRecord)(nil), "virtengine.settlement.v1.SettlementRecord")
	proto.RegisterType((*UsageRecord)(nil), "virtengine.settlement.v1.UsageRecord")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.settlement.v1.UsageRecord.MetadataEntry")
	proto.RegisterType((*UsageTypeSummary)(nil), "virtengine.settlement.v1.UsageTypeSummary")
	proto.RegisterType((*UsageSummary)(nil), "virtengine.settlement.v1.UsageSummary")
	proto.RegisterType((*RewardRecipient)(nil), "virtengine.settlement.v1.RewardRecipient")
	proto.RegisterType((*RewardDistribution)(nil), "virtengine.settlement.v1.RewardDistribution")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.settlement.v1.RewardDistribution.MetadataEntry")
	proto.RegisterType((*RewardHistoryEntry)(nil), "virtengine.settlement.v1.RewardHistoryEntry")
	proto.RegisterType((*RewardEntry)(nil), "virtengine.settlement.v1.RewardEntry")
	proto.RegisterType((*ClaimableRewards)(nil), "virtengine.settlement.v1.ClaimableRewards")
	proto.RegisterType((*PayoutRecord)(nil), "virtengine.settlement.v1.PayoutRecord")
	proto.RegisterType((*Params)(nil), "virtengine.settlement.v1.Params")
	proto.RegisterType((*TokenSpec)(nil), "virtengine.settlement.v1.TokenSpec")
	proto.RegisterType((*FiatPayoutPreference)(nil), "virtengine.settlement.v1.FiatPayoutPreference")
	proto.RegisterType((*FiatConversionAuditEntry)(nil), "virtengine.settlement.v1.FiatConversionAuditEntry")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.settlement.v1.FiatConversionAuditEntry.MetadataEntry")
	proto.RegisterType((*FiatConversionRecord)(nil), "virtengine.settlement.v1.FiatConversionRecord")
	proto.RegisterType((*QueryEscrowRequest)(nil), "virtengine.settlement.v1.QueryEscrowRequest")
	proto.RegisterType((*QueryEscrowResponse)(nil), "virtengine.settlement.v1.QueryEscrowResponse")
	proto.RegisterType((*QueryEscrowsByOrderRequest)(nil), "virtengine.settlement.v1.QueryEscrowsByOrderRequest")
	proto.RegisterType((*QueryEscrowsByOrderResponse)(nil), "virtengine.settlement.v1.QueryEscrowsByOrderResponse")
	proto.RegisterType((*QueryEscrowsByStateRequest)(nil), "virtengine.settlement.v1.QueryEscrowsByStateRequest")
	proto.RegisterType((*QueryEscrowsByStateResponse)(nil), "virtengine.settlement.v1.QueryEscrowsByStateResponse")
	proto.RegisterType((*QuerySettlementRequest)(nil), "virtengine.settlement.v1.QuerySettlementRequest")
	proto.RegisterType((*QuerySettlementResponse)(nil), "virtengine.settlement.v1.QuerySettlementResponse")
	proto.RegisterType((*QuerySettlementsByOrderRequest)(nil), "virtengine.settlement.v1.QuerySettlementsByOrderRequest")
	proto.RegisterType((*QuerySettlementsByOrderResponse)(nil), "virtengine.settlement.v1.QuerySettlementsByOrderResponse")
	proto.RegisterType((*QueryUsageRecordRequest)(nil), "virtengine.settlement.v1.QueryUsageRecordRequest")
	proto.RegisterType((*QueryUsageRecordResponse)(nil), "virtengine.settlement.v1.QueryUsageRecordResponse")
	proto.RegisterType((*QueryUsageRecordsByOrderRequest)(nil), "virtengine.settlement.v1.QueryUsageRecordsByOrderRequest")
	proto.RegisterType((*QueryUsageRecordsByOrderResponse)(nil), "virtengine.settlement.v1.QueryUsageRecordsByOrderResponse")
	proto.RegisterType((*QueryUsageSummaryRequest)(nil), "virtengine.settlement.v1.QueryUsageSummaryRequest")
	proto.RegisterType((*QueryUsageSummaryResponse)(nil), "virtengine.settlement.v1.QueryUsageSummaryResponse")
	proto.RegisterType((*QueryRewardDistributionRequest)(nil), "virtengine.settlement.v1.QueryRewardDistributionRequest")
	proto.RegisterType((*QueryRewardDistributionResponse)(nil), "virtengine.settlement.v1.QueryRewardDistributionResponse")
	proto.RegisterType((*QueryRewardsByEpochRequest)(nil), "virtengine.settlement.v1.QueryRewardsByEpochRequest")
	proto.RegisterType((*QueryRewardsByEpochResponse)(nil), "virtengine.settlement.v1.QueryRewardsByEpochResponse")
	proto.RegisterType((*QueryRewardHistoryRequest)(nil), "virtengine.settlement.v1.QueryRewardHistoryRequest")
	proto.RegisterType((*QueryRewardHistoryResponse)(nil), "virtengine.settlement.v1.QueryRewardHistoryResponse")
	proto.RegisterType((*QueryClaimableRewardsRequest)(nil), "virtengine.settlement.v1.QueryClaimableRewardsRequest")
	proto.RegisterType((*QueryClaimableRewardsResponse)(nil), "virtengine.settlement.v1.QueryClaimableRewardsResponse")
	proto.RegisterType((*QueryPayoutRequest)(nil), "virtengine.settlement.v1.QueryPayoutRequest")
	proto.RegisterType((*QueryPayoutResponse)(nil), "virtengine.settlement.v1.QueryPayoutResponse")
	proto.RegisterType((*QueryPayoutsByProviderRequest)(nil), "virtengine.settlement.v1.QueryPayoutsByProviderRequest")
	proto.RegisterType((*QueryPayoutsByProviderResponse)(nil), "virtengine.settlement.v1.QueryPayoutsByProviderResponse")
	proto.RegisterType((*QueryParamsRequest)(nil), "virtengine.settlement.v1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "virtengine.settlement.v1.QueryParamsResponse")
	proto.RegisterType((*QueryFiatConversionRequest)(nil), "virtengine.settlement.v1.QueryFiatConversionRequest")
	proto.RegisterType((*QueryFiatConversionResponse)(nil), "virtengine.settlement.v1.QueryFiatConversionResponse")
	proto.RegisterType((*QueryFiatConversionsByProviderRequest)(nil), "virtengine.settlement.v1.QueryFiatConversionsByProviderRequest")
	proto.RegisterType((*QueryFiatConversionsByProviderResponse)(nil), "virtengine.settlement.v1.QueryFiatConversionsByProviderResponse")
	proto.RegisterType((*QueryFiatPayoutPreferenceRequest)(nil), "virtengine.settlement.v1.QueryFiatPayoutPreferenceRequest")
	proto.RegisterType((*QueryFiatPayoutPreferenceResponse)(nil), "virtengine.settlement.v1.QueryFiatPayoutPreferenceResponse")
}

func init() {
	proto.RegisterFile("virtengine/settlement/v1/query.proto", fileDescriptor_3435bfc41107fa05)
}

var fileDescriptor_3435bfc41107fa05 = []byte{
	// 4833 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x3c, 0x5d, 0x6f, 0x1c, 0x59,
	0x56, 0xd3, 0xfe, 0xee, 0xd3, 0xdd, 0xfe, 0xb8, 0x71, 0x92, 0x8a, 0x93, 0x38, 0x4e, 0xcd, 0x24,
	0xf1, 0xcc, 0x26, 0xee, 0x8d, 0x33, 0x9f, 0xc9, 0xce, 0xce, 0x74, 0xec, 0xcc, 0xc4, 0x4b, 0x32,
	0x93, 0x29, 0x27, 0xb3, 0x0b, 0x02, 0x95, 0xca, 0x55, 0xd7, 0x76, 0x8d, 0xbb, 0xab, 0x7a, 0xaa,
	0x6e, 0x3b, 0x6e, 0x45, 0x96, 0x10, 0x6f, 0xfb, 0x04, 0x08, 0x78, 0x40, 0xe2, 0x85, 0x07, 0x10,
	0x42, 0x42, 0xe2, 0x01, 0x09, 0x21, 0xa1, 0x95, 0xe0, 0x69, 0x40, 0x68, 0xb5, 0x02, 0x1e, 0x00,
	0x21, 0x58, 0xcd, 0xf0, 0x82, 0xf8, 0x11, 0xa0, 0x7b, 0xef, 0xb9, 0x55, 0xb7, 0xaa, 0xab, 0xdd,
	0x6d, 0x4f, 0xbc, 0x12, 0x4f, 0x93, 0x3a, 0xf7, 0x9c, 0x73, 0xcf, 0x3d, 0xf7, 0x7c, 0xf7, 0xf5,
	0xc0, 0x6b, 0xfb, 0x7e, 0xc4, 0x68, 0xb0, 0xe3, 0x07, 0xb4, 0x1e, 0x53, 0xc6, 0x9a, 0xb4, 0x45,
	0x03, 0x56, 0xdf, 0xbf, 0x5d, 0xff, 0xb2, 0x43, 0xa3, 0xee, 0x4a, 0x3b, 0x0a, 0x59, 0x48, 0x8c,
	0x14, 0x6b, 0x25, 0xc5, 0x5a, 0xd9, 0xbf, 0xbd, 0x70, 0x69, 0x27, 0x0c, 0x77, 0x9a, 0xb4, 0xee,
	0xb4, 0xfd, 0xba, 0x13, 0x04, 0x21, 0x73, 0x98, 0x1f, 0x06, 0xb1, 0xa4, 0x5b, 0x98, 0xdf, 0x09,
	0x77, 0x42, 0xf1, 0xcf, 0x3a, 0xff, 0x17, 0x42, 0x2f, 0xb8, 0x61, 0xdc, 0x0a, 0x63, 0x5b, 0x2e,
	0xc8, 0x0f, 0x5c, 0x5a, 0x94, 0x5f, 0xf5, 0x2d, 0x27, 0xa6, 0xf5, 0xfd, 0xdb, 0x5b, 0x94, 0x39,
	0xb7, 0xeb, 0x6e, 0xe8, 0x07, 0x72, 0xdd, 0xfc, 0xe9, 0x08, 0xcc, 0x5a, 0xb4, 0x49, 0x9d, 0x98,
	0xae, 0x85, 0x81, 0xe7, 0xf3, 0xcd, 0x08, 0x81, 0x31, 0xd6, 0x6d, 0x53, 0xa3, 0xb4, 0x54, 0x5a,
	0x2e, 0x5b, 0xe2, 0xdf, 0xe4, 0x2a, 0x54, 0x3b, 0x41, 0x33, 0x74, 0xf7, 0x6c, 0x67, 0x9b, 0xd1,
	0xc8, 0x18, 0x59, 0x2a, 0x2d, 0x8f, 0x5a, 0x15, 0x09, 0x6b, 0x70, 0x10, 0x79, 0x1d, 0x66, 0x23,
	0xfa, 0x65, 0xc7, 0x8f, 0xa8, 0x67, 0xc7, 0xfe, 0x4e, 0x40, 0xa3, 0xd8, 0x18, 0x5d, 0x1a, 0x5d,
	0x2e, 0x5b, 0x33, 0x0a, 0xbe, 0x29, 0xc1, 0xa4, 0x0e, 0x67, 0x38, 0x86, 0xc3, 0x3a, 0x11, 0xb5,
	0xd9, 0x6e, 0x44, 0xe3, 0xdd, 0xb0, 0xe9, 0x19, 0x63, 0x4b, 0xa5, 0xe5, 0x9a, 0x45, 0x92, 0xa5,
	0xa7, 0x6a, 0x85, 0x5c, 0x87, 0x99, 0x96, 0x1f, 0xd8, 0x9d, 0xd8, 0xd9, 0xa1, 0x76, 0x27, 0xf0,
	0x59, 0x6c, 0x8c, 0x2f, 0x95, 0x96, 0xc7, 0xac, 0x5a, 0xcb, 0x0f, 0x9e, 0x71, 0xe8, 0x33, 0x0e,
	0x24, 0xdf, 0x87, 0x8b, 0x89, 0x0c, 0xfb, 0x34, 0xf2, 0xb7, 0x7d, 0x57, 0x28, 0xd0, 0x8e, 0xdd,
	0x30, 0xa2, 0xc6, 0x84, 0xd8, 0xe0, 0x82, 0x42, 0xf9, 0x5c, 0xc3, 0xd8, 0xe4, 0x08, 0xe4, 0x12,
	0x94, 0x63, 0x87, 0xf9, 0xf1, 0xb6, 0x4f, 0x3d, 0x63, 0x72, 0xa9, 0xb4, 0x3c, 0x65, 0xa5, 0x00,
	0xae, 0x84, 0xe4, 0xc3, 0x76, 0x98, 0x31, 0x25, 0x95, 0x90, 0xc0, 0x1a, 0xcc, 0xfc, 0x9f, 0x09,
	0xa8, 0x3d, 0x88, 0xdd, 0x28, 0x7c, 0xde, 0x70, 0xdd, 0xb0, 0x13, 0x30, 0x72, 0x11, 0xca, 0x54,
	0x00, 0x6c, 0xdf, 0x43, 0x95, 0x4e, 0x49, 0xc0, 0x86, 0x47, 0x2e, 0xc0, 0x54, 0x18, 0x79, 0x34,
	0xe2, 0x6b, 0x23, 0x62, 0x6d, 0x52, 0x7c, 0xcb, 0x25, 0x71, 0x2f, 0x7c, 0x69, 0x54, 0x2e, 0x89,
	0xef, 0x0d, 0x8f, 0xbc, 0x0d, 0x65, 0x8f, 0xb6, 0xc3, 0xd8, 0x67, 0x61, 0x24, 0x94, 0x56, 0xbe,
	0x6f, 0xfc, 0xe3, 0x5f, 0xdc, 0x9a, 0xc7, 0xab, 0x6f, 0x78, 0x5e, 0x44, 0xe3, 0x78, 0x93, 0x45,
	0x7e, 0xb0, 0x63, 0xa5, 0xa8, 0x9c, 0x2e, 0xa2, 0xae, 0xdf, 0xf6, 0x69, 0xc0, 0x84, 0xfe, 0x8e,
	0xa4, 0x4b, 0x50, 0x89, 0x0b, 0x13, 0x4e, 0x8b, 0x1f, 0xc6, 0x98, 0x58, 0x1a, 0x5d, 0xae, 0xac,
	0x5e, 0x58, 0x41, 0x0a, 0x6e, 0x56, 0x2b, 0x68, 0x56, 0x2b, 0x6b, 0xa1, 0x1f, 0xdc, 0xff, 0xee,
	0x57, 0xff, 0x71, 0xe5, 0x95, 0x3f, 0xfd, 0xcf, 0x2b, 0xcb, 0x3b, 0x3e, 0xdb, 0xed, 0x6c, 0xad,
	0xb8, 0x61, 0x0b, 0x2d, 0x12, 0xff, 0x73, 0x2b, 0xf6, 0xf6, 0xea, 0xdc, 0xa4, 0x62, 0x41, 0x10,
	0x5b, 0xc8, 0x9a, 0x50, 0x98, 0xdc, 0x72, 0x9a, 0x4e, 0xe0, 0x52, 0x63, 0xf2, 0xe5, 0xef, 0xa2,
	0x78, 0x93, 0x79, 0x18, 0x8f, 0x99, 0xc3, 0xa8, 0xb8, 0xbc, 0xb2, 0x25, 0x3f, 0xc8, 0x13, 0x00,
	0x57, 0xd9, 0x7f, 0x6c, 0x94, 0xc5, 0xfe, 0x6f, 0xac, 0xf4, 0xf3, 0xd2, 0x95, 0xbc, 0xcb, 0xdc,
	0x1f, 0xe3, 0x02, 0x59, 0x1a, 0x0f, 0x72, 0x19, 0xc0, 0x8d, 0xa8, 0xc3, 0xa4, 0xa5, 0x80, 0xb0,
	0x94, 0x32, 0x42, 0x1a, 0x8c, 0x2f, 0xd3, 0x83, 0xb6, 0x1f, 0xd1, 0x98, 0x2f, 0x57, 0xe4, 0x32,
	0x42, 0x1a, 0x8c, 0x5b, 0x9a, 0xe3, 0x32, 0x7f, 0x5f, 0xd1, 0x57, 0xa5, 0xa5, 0x25, 0xb0, 0x86,
	0xb0, 0x2b, 0xb7, 0x19, 0xc6, 0x72, 0xbd, 0x26, 0xd6, 0xa7, 0x24, 0xa0, 0xc1, 0xc8, 0x35, 0x98,
	0xe6, 0xff, 0xe6, 0xee, 0x15, 0x51, 0x27, 0x0e, 0x03, 0x63, 0x5a, 0x1c, 0xb7, 0x86, 0x50, 0x4b,
	0x00, 0x49, 0x1b, 0x6a, 0x2c, 0x64, 0x4e, 0xd3, 0x96, 0xc7, 0xf3, 0x8c, 0x99, 0x97, 0xaf, 0xf9,
	0xaa, 0xd8, 0x61, 0x53, 0x6e, 0xc0, 0x83, 0x44, 0xaa, 0x4a, 0x5b, 0x78, 0x88, 0x31, 0x2b, 0xbc,
	0x72, 0x26, 0x85, 0xaf, 0x09, 0x83, 0xb8, 0x0a, 0xd5, 0x2d, 0x11, 0x71, 0x76, 0xa9, 0xbf, 0xb3,
	0xcb, 0x8c, 0x39, 0xa9, 0x03, 0x01, 0x7b, 0x28, 0x40, 0xe6, 0xbf, 0x4d, 0xc2, 0xec, 0x66, 0x42,
	0x66, 0x51, 0x37, 0x8c, 0x3c, 0xf2, 0x2a, 0xd4, 0xb4, 0x2d, 0x12, 0xa7, 0xab, 0xa6, 0xc0, 0x0d,
	0x2f, 0xeb, 0x95, 0x23, 0x47, 0x78, 0xe5, 0x68, 0x7f, 0xaf, 0x1c, 0xcb, 0x7a, 0xe5, 0x9b, 0x30,
	0xd5, 0x8e, 0xc2, 0x7d, 0xdf, 0xa3, 0xd1, 0x40, 0xe7, 0x4a, 0x30, 0x39, 0x95, 0xdb, 0x89, 0x59,
	0xd8, 0xa2, 0x91, 0x08, 0x4f, 0x47, 0x52, 0x29, 0x4c, 0x12, 0x80, 0x54, 0xab, 0x8d, 0x7e, 0x79,
	0x0a, 0x1e, 0x53, 0x11, 0x1b, 0x34, 0xa4, 0x73, 0x46, 0x30, 0xad, 0x24, 0xb6, 0xe3, 0x5d, 0x27,
	0xe2, 0xee, 0xf3, 0xd2, 0x77, 0xac, 0xa9, 0x2d, 0x36, 0xf9, 0x0e, 0xfc, 0x8c, 0xed, 0xa6, 0xc3,
	0xb6, 0xc3, 0xa8, 0x65, 0x6f, 0x53, 0x8a, 0x5e, 0xf9, 0x72, 0xcf, 0xa8, 0x36, 0xf8, 0x88, 0x52,
	0xee, 0x0c, 0xfb, 0x4e, 0xd3, 0xf7, 0x1c, 0x16, 0x46, 0x62, 0x43, 0x38, 0x05, 0x67, 0x48, 0x76,
	0xe0, 0x3b, 0x5e, 0x06, 0x40, 0xc7, 0xd3, 0x82, 0x00, 0x42, 0x1a, 0x8c, 0x2c, 0xc3, 0xac, 0x4c,
	0x78, 0x91, 0x30, 0x6c, 0xdb, 0xf7, 0x62, 0xa3, 0x2a, 0x12, 0xea, 0xb4, 0x80, 0x4b, 0x7b, 0xdf,
	0xf0, 0x62, 0xf2, 0x06, 0xcc, 0x49, 0x73, 0xd0, 0x13, 0x64, 0x4d, 0x24, 0xc8, 0x19, 0xb1, 0xa0,
	0xa5, 0xc8, 0xab, 0x50, 0x6d, 0xd3, 0xc8, 0x0f, 0x3d, 0x3b, 0x66, 0x4e, 0xc4, 0x44, 0x60, 0x18,
	0xb5, 0x2a, 0x12, 0xb6, 0xc9, 0x41, 0x5c, 0x2e, 0x44, 0xa1, 0x01, 0x8f, 0x09, 0x42, 0x2e, 0x09,
	0x79, 0x10, 0x78, 0x3d, 0x8e, 0x39, 0xdb, 0xe3, 0x98, 0xe4, 0x06, 0x68, 0xee, 0x6c, 0x8b, 0x6a,
	0x62, 0x4e, 0x78, 0xcb, 0x74, 0x0a, 0x7e, 0xca, 0xeb, 0x8a, 0x0b, 0x30, 0xe5, 0xc7, 0xf6, 0xb6,
	0x1f, 0x38, 0x4d, 0x83, 0x88, 0x7c, 0x3b, 0xe9, 0xc7, 0x1f, 0xf1, 0x4f, 0xf3, 0x0f, 0x27, 0xa1,
	0xf2, 0x2c, 0x3d, 0x27, 0x47, 0x95, 0xc7, 0x4b, 0x5c, 0x7a, 0x52, 0x7c, 0x9f, 0x38, 0x8d, 0xea,
	0x0e, 0x3b, 0x76, 0x22, 0x87, 0x1d, 0x1f, 0xda, 0x61, 0xaf, 0x40, 0x45, 0xbf, 0x9b, 0x09, 0x71,
	0x37, 0xd0, 0x49, 0xaf, 0xe5, 0x32, 0xc8, 0x2f, 0xa9, 0xac, 0x49, 0x21, 0x69, 0x59, 0x40, 0x9e,
	0x62, 0xfd, 0x95, 0xb9, 0xb5, 0xa9, 0x41, 0xb7, 0x56, 0xce, 0xdf, 0x5a, 0x03, 0x80, 0xef, 0x6d,
	0xb7, 0x23, 0xdf, 0xa5, 0x22, 0x21, 0x55, 0x56, 0x2f, 0x15, 0xda, 0xf6, 0x3a, 0x75, 0x85, 0x79,
	0xcb, 0xa4, 0x56, 0xe6, 0x54, 0x4f, 0x38, 0x11, 0xf9, 0x02, 0x40, 0x9a, 0x99, 0x1b, 0xc6, 0xdc,
	0x5e, 0x5f, 0xba, 0x7b, 0x94, 0x05, 0xfb, 0xb5, 0x30, 0x66, 0xe4, 0x16, 0x90, 0x34, 0xe2, 0xa8,
	0x82, 0x50, 0xe4, 0xc1, 0xaa, 0x35, 0x97, 0x04, 0x0a, 0xb5, 0x40, 0xee, 0xc0, 0x59, 0xa5, 0x6b,
	0xdb, 0x71, 0xf7, 0x82, 0xf0, 0x79, 0x93, 0x7a, 0x3b, 0xd4, 0x13, 0x5e, 0x30, 0x65, 0xcd, 0xab,
	0xc5, 0x86, 0xb6, 0xc6, 0xf7, 0x48, 0x88, 0xd2, 0x3d, 0xa6, 0xe5, 0x1e, 0x6a, 0x25, 0xdd, 0xc3,
	0x80, 0xc9, 0x34, 0x4f, 0x0a, 0x53, 0xc5, 0xcf, 0xde, 0x94, 0x33, 0x5b, 0x90, 0x72, 0x78, 0xf5,
	0xd8, 0xd9, 0x6a, 0xf9, 0x0c, 0x73, 0x3a, 0xe6, 0xb3, 0x04, 0xd6, 0xe8, 0x4d, 0x79, 0xa4, 0xd7,
	0xb3, 0x3e, 0x85, 0xa9, 0x16, 0x65, 0x8e, 0xe7, 0x30, 0xc7, 0x38, 0x23, 0x6e, 0xe0, 0x4e, 0xff,
	0x3a, 0x45, 0x73, 0x9f, 0x95, 0xc7, 0x48, 0xf5, 0x20, 0x60, 0x51, 0xd7, 0x4a, 0x98, 0x2c, 0xdc,
	0x83, 0x5a, 0x66, 0x89, 0xcc, 0xc2, 0xe8, 0x1e, 0xed, 0xa2, 0x8b, 0xf1, 0x7f, 0xf2, 0x9a, 0x69,
	0xdf, 0x69, 0x76, 0x28, 0xfa, 0x96, 0xfc, 0xb8, 0x3b, 0xf2, 0x6e, 0xc9, 0xfc, 0x49, 0x09, 0x66,
	0x9f, 0x29, 0x23, 0xdd, 0xec, 0xb4, 0x5a, 0x4e, 0xd4, 0xcd, 0x99, 0x72, 0x29, 0x6f, 0xca, 0x39,
	0x57, 0x18, 0xe9, 0x71, 0x85, 0xac, 0x99, 0x8d, 0x9e, 0xa6, 0x99, 0x99, 0xff, 0x3b, 0x0a, 0x55,
	0x71, 0x00, 0x25, 0xbc, 0x1e, 0x14, 0x4a, 0x43, 0x07, 0x85, 0x23, 0x02, 0x50, 0xde, 0x73, 0x47,
	0x07, 0x79, 0xee, 0x58, 0xde, 0x73, 0x0b, 0xa3, 0xfb, 0x78, 0x71, 0x74, 0xcf, 0xea, 0x6e, 0xe2,
	0x54, 0x5d, 0xf4, 0x29, 0xd4, 0xb6, 0xba, 0x76, 0x26, 0x6a, 0x0d, 0xa8, 0x9b, 0xf3, 0xa6, 0x82,
	0x21, 0xa6, 0xb2, 0xd5, 0x7d, 0xa6, 0x47, 0xba, 0x1d, 0x1a, 0xd0, 0x48, 0x95, 0xbe, 0x18, 0xe9,
	0x12, 0x58, 0x81, 0x9b, 0x94, 0x7b, 0xdd, 0xa4, 0x28, 0x77, 0x42, 0x51, 0xee, 0x34, 0xff, 0x7d,
	0x04, 0x66, 0x2c, 0xfa, 0xdc, 0x89, 0x3c, 0x2b, 0x69, 0x78, 0x56, 0x61, 0xd2, 0x91, 0x37, 0x3d,
	0xd0, 0x06, 0x14, 0xa2, 0xd6, 0x24, 0x8d, 0x9c, 0x5e, 0x93, 0x74, 0x0e, 0x26, 0xb0, 0x9e, 0x97,
	0xb9, 0x0c, 0xbf, 0xf2, 0x3e, 0x35, 0xd6, 0xe3, 0x53, 0xb7, 0x80, 0x14, 0xf4, 0xc3, 0xe3, 0xa2,
	0xf2, 0x9e, 0xdb, 0xef, 0xe9, 0x83, 0xaf, 0xc1, 0x74, 0xcc, 0x9c, 0x3d, 0x3f, 0xd8, 0xb1, 0x9f,
	0x4b, 0x1d, 0x4f, 0xc8, 0xfe, 0x01, 0xa1, 0x3f, 0x94, 0x5a, 0xbe, 0x0a, 0xd5, 0x88, 0x6e, 0xd3,
	0x88, 0x06, 0xae, 0x48, 0xb0, 0x32, 0x6d, 0x55, 0x12, 0xd8, 0x86, 0x67, 0xfe, 0xfd, 0x18, 0x10,
	0xa9, 0xde, 0x75, 0x3f, 0x66, 0x91, 0xbf, 0xd5, 0x11, 0x33, 0x86, 0x1b, 0x30, 0xe3, 0x69, 0xdf,
	0x69, 0x4e, 0x9f, 0xd6, 0xc1, 0xd2, 0x7d, 0x68, 0x3b, 0x74, 0x77, 0xed, 0xa0, 0xd3, 0xda, 0xc2,
	0xc1, 0xc3, 0x98, 0x55, 0x11, 0xb0, 0x4f, 0x04, 0x28, 0xed, 0x62, 0x22, 0xb1, 0x4f, 0x7c, 0x1a,
	0x21, 0x43, 0x96, 0xdb, 0xf2, 0x20, 0x31, 0xf9, 0x14, 0x20, 0xe9, 0x8e, 0xb9, 0xb6, 0xf9, 0x76,
	0xaf, 0x1f, 0xd5, 0x2e, 0x66, 0xcc, 0x4b, 0x75, 0x8b, 0x29, 0x0b, 0x7e, 0xaf, 0x71, 0xd8, 0x89,
	0x5c, 0x79, 0x25, 0x65, 0x0b, 0xbf, 0xf8, 0x3d, 0x24, 0xfa, 0x90, 0xee, 0x30, 0x21, 0x6c, 0xbd,
	0xa6, 0x41, 0x0b, 0x1c, 0x62, 0xb2, 0xd7, 0x21, 0x56, 0xe0, 0x4c, 0x7a, 0x55, 0xec, 0xc0, 0xde,
	0x75, 0xe2, 0x5d, 0x1a, 0x8b, 0x32, 0xbe, 0x6c, 0xcd, 0x25, 0x4b, 0x4f, 0x0f, 0x1e, 0x8a, 0x05,
	0xf2, 0xb9, 0x96, 0x67, 0x64, 0xe5, 0x7d, 0x77, 0xd0, 0x01, 0xf5, 0x0b, 0x3e, 0x9d, 0x74, 0xf3,
	0xf3, 0x11, 0x65, 0x4c, 0x0f, 0xfd, 0x98, 0x85, 0x51, 0x57, 0xb2, 0x78, 0x99, 0xc6, 0x94, 0xde,
	0xc4, 0x68, 0xe6, 0x26, 0x52, 0xf7, 0x1e, 0xfb, 0x45, 0xb8, 0xf7, 0xf8, 0x51, 0xee, 0xdd, 0x5b,
	0x3d, 0x0e, 0x76, 0xc4, 0x02, 0x53, 0x9a, 0x2a, 0x30, 0x25, 0xf3, 0xc7, 0x23, 0x50, 0x91, 0x2a,
	0x3e, 0xa6, 0x6e, 0x53, 0xc5, 0x8d, 0xf4, 0x51, 0xdc, 0xe8, 0xe9, 0x29, 0x2e, 0x3b, 0x6d, 0x19,
	0x3b, 0x7a, 0xda, 0x32, 0x9e, 0x9f, 0xb6, 0xa4, 0x6a, 0x9f, 0xd0, 0xd5, 0x6e, 0xfe, 0xd1, 0x28,
	0xcc, 0xae, 0x35, 0x1d, 0xbf, 0xe5, 0x6c, 0x35, 0xa9, 0xf2, 0xfd, 0x93, 0xe4, 0x06, 0x06, 0x33,
	0x98, 0x95, 0x15, 0xb7, 0xd3, 0x48, 0x12, 0xd3, 0x32, 0x35, 0xab, 0x2d, 0x88, 0x05, 0xd3, 0x32,
	0x22, 0xda, 0x34, 0x60, 0x91, 0x4f, 0x55, 0x60, 0xbc, 0x36, 0xc8, 0x91, 0xc5, 0xcd, 0x63, 0x94,
	0xaa, 0x45, 0x09, 0xc8, 0xa7, 0xc2, 0xd0, 0x9a, 0x4e, 0xcc, 0xec, 0x4e, 0xdb, 0xe3, 0xba, 0x45,
	0x55, 0x57, 0x38, 0xec, 0x99, 0x04, 0xa5, 0xe1, 0x58, 0x1c, 0x96, 0x7a, 0xc6, 0xf8, 0x69, 0x85,
	0xe3, 0x35, 0xb9, 0x81, 0xf9, 0xc7, 0x00, 0xd5, 0x27, 0x4e, 0x37, 0xec, 0xa8, 0x11, 0xd0, 0x45,
	0x28, 0xb7, 0xc5, 0xb7, 0x36, 0x73, 0x95, 0x80, 0x0d, 0x8f, 0xdc, 0x04, 0xb2, 0xed, 0x3b, 0xcc,
	0x76, 0xc3, 0x60, 0x9f, 0x46, 0x31, 0x1a, 0xb5, 0x34, 0xda, 0x59, 0xbe, 0xb2, 0x96, 0x2c, 0x6c,
	0x78, 0xdc, 0x74, 0xfc, 0x60, 0x3f, 0xf4, 0x5d, 0xad, 0x83, 0x2c, 0x23, 0x64, 0xa3, 0xa0, 0xf2,
	0x1f, 0x1b, 0x34, 0x6c, 0x1a, 0x3f, 0x62, 0xd8, 0x34, 0xd1, 0xbf, 0x77, 0x9d, 0xec, 0xdf, 0xbb,
	0x4e, 0x9d, 0xa8, 0x77, 0x2d, 0x1f, 0x67, 0xd8, 0xb4, 0x13, 0x85, 0x71, 0xac, 0x86, 0x4d, 0xa7,
	0x30, 0x17, 0xa9, 0x88, 0x0d, 0x70, 0xd8, 0x94, 0x1f, 0xfc, 0x54, 0x7e, 0xd1, 0x83, 0x9f, 0xea,
	0x69, 0x0f, 0x7e, 0x18, 0xcc, 0xec, 0x86, 0x4d, 0x6f, 0xcb, 0x71, 0xf7, 0x94, 0x52, 0x6b, 0xa7,
	0x10, 0x0f, 0xd4, 0x1e, 0xa8, 0xd7, 0x2f, 0x00, 0x02, 0xca, 0xd4, 0x86, 0xd3, 0xa7, 0xd0, 0x1b,
	0x04, 0x94, 0xe1, 0x5e, 0xc9, 0x98, 0x7d, 0x46, 0x1f, 0xb3, 0x5f, 0x06, 0xf0, 0xfc, 0xb8, 0xdd,
	0x61, 0x34, 0x6d, 0x92, 0xcb, 0x08, 0xd9, 0xf0, 0x78, 0x9a, 0xe3, 0x22, 0xab, 0x91, 0xb5, 0x9c,
	0x18, 0x01, 0x07, 0xe1, 0xbc, 0xfa, 0x06, 0xcc, 0xf8, 0x1e, 0x6d, 0xb5, 0x43, 0x46, 0x03, 0xb7,
	0x6b, 0xf3, 0xba, 0x81, 0xc8, 0x64, 0xa4, 0x81, 0x7f, 0x89, 0x76, 0x79, 0xb9, 0x4b, 0x0f, 0xa8,
	0x2b, 0x53, 0x96, 0xc3, 0x18, 0x6d, 0xb5, 0x59, 0x6c, 0x9c, 0x91, 0xe5, 0x6e, 0xb2, 0xd2, 0xc0,
	0x05, 0x72, 0x1d, 0x66, 0x44, 0x54, 0x43, 0x4c, 0x9e, 0x24, 0xe6, 0x65, 0x72, 0xe4, 0x60, 0x44,
	0x93, 0x79, 0x44, 0xe0, 0xd1, 0x28, 0x0a, 0x23, 0xe3, 0xac, 0x94, 0x9f, 0x43, 0x1e, 0x70, 0x00,
	0x39, 0x0f, 0x93, 0x58, 0x59, 0x19, 0xe7, 0x64, 0x22, 0x61, 0xa2, 0x9c, 0xca, 0xa5, 0xa7, 0xf3,
	0xf9, 0xf4, 0xc4, 0x5b, 0xc4, 0x28, 0x74, 0x69, 0x8c, 0xd3, 0x7c, 0x03, 0x5b, 0x44, 0x05, 0x93,
	0x28, 0x6e, 0xd8, 0x6a, 0x37, 0x29, 0xf2, 0xb8, 0x20, 0x51, 0x12, 0x58, 0x41, 0x11, 0xb8, 0xd0,
	0x3b, 0x2f, 0xff, 0xdd, 0x39, 0x98, 0x78, 0xe2, 0x44, 0x4e, 0x4b, 0x8c, 0x0c, 0x75, 0x27, 0xb3,
	0x79, 0x6f, 0x85, 0xa1, 0x72, 0x46, 0x73, 0x0e, 0x8b, 0x5f, 0xdb, 0x4d, 0x20, 0x19, 0x07, 0x91,
	0xc8, 0x18, 0x31, 0x75, 0xc3, 0x16, 0xd8, 0x2b, 0x70, 0xa6, 0xe5, 0x07, 0x36, 0x46, 0x3c, 0xaf,
	0x13, 0x89, 0xbe, 0x42, 0x84, 0xce, 0x31, 0x6b, 0xae, 0xe5, 0x07, 0xf2, 0xf7, 0xb1, 0x75, 0x5c,
	0x10, 0xf8, 0xce, 0x41, 0x0f, 0xfe, 0x18, 0xe2, 0x3b, 0x07, 0x39, 0xfc, 0xef, 0xc0, 0x9c, 0x16,
	0x72, 0x65, 0x9b, 0x8c, 0xed, 0xb0, 0xf6, 0xdb, 0xc2, 0x13, 0x01, 0x97, 0x65, 0xaf, 0xc8, 0x81,
	0x22, 0x1b, 0xd9, 0x22, 0xe9, 0x77, 0xb1, 0x82, 0x9a, 0x93, 0x4b, 0x22, 0x8d, 0x3c, 0x10, 0x0b,
	0x64, 0x15, 0xce, 0x72, 0xe1, 0xb5, 0x0d, 0x92, 0x09, 0x3b, 0x3f, 0x2d, 0x3f, 0x59, 0xfa, 0x83,
	0x03, 0xda, 0xfa, 0x4d, 0x20, 0xb2, 0x3a, 0xdb, 0x89, 0x1c, 0x97, 0x2a, 0x89, 0xa6, 0xa4, 0x44,
	0x62, 0xe5, 0x63, 0xbe, 0x80, 0x12, 0xbd, 0x0f, 0x17, 0x55, 0x6b, 0xa5, 0xb2, 0xb3, 0x28, 0x49,
	0x9b, 0x34, 0xd8, 0x61, 0xbb, 0x22, 0x2c, 0x8f, 0x59, 0x06, 0xa2, 0x60, 0x3e, 0xe6, 0x08, 0x8f,
	0xc4, 0x3a, 0xf9, 0x1e, 0x2c, 0x64, 0x1a, 0x39, 0xe4, 0x91, 0x84, 0x66, 0x2e, 0xa5, 0xa1, 0x63,
	0x48, 0x16, 0x28, 0xea, 0x77, 0x61, 0x1e, 0x13, 0x63, 0x12, 0x7f, 0xc4, 0x5d, 0x56, 0x04, 0x1d,
	0x91, 0x6b, 0x0f, 0x71, 0x49, 0xdd, 0x3d, 0xbf, 0x1d, 0xa4, 0x8a, 0xa8, 0x2c, 0x24, 0xaa, 0xc2,
	0x93, 0x66, 0x5b, 0xce, 0x81, 0xca, 0xbb, 0xb2, 0x3c, 0x78, 0x1b, 0xce, 0x2b, 0x07, 0x7f, 0xee,
	0x07, 0x9e, 0x7e, 0x9f, 0x72, 0x1c, 0x7d, 0x16, 0x97, 0x7f, 0x28, 0x56, 0x93, 0x3b, 0xbd, 0x0d,
	0x67, 0x55, 0xbb, 0x2e, 0x8e, 0xc3, 0x85, 0xb2, 0xb7, 0xda, 0xb1, 0x18, 0xc6, 0xd5, 0x2c, 0x82,
	0x3d, 0xbb, 0x68, 0xa3, 0x1c, 0x46, 0xef, 0xb7, 0x63, 0xb2, 0x0e, 0x57, 0x32, 0x24, 0x6e, 0xbb,
	0x63, 0xb7, 0x3a, 0x4d, 0xe6, 0xb7, 0x9b, 0x3e, 0x8d, 0x04, 0xf1, 0x8c, 0x20, 0xbe, 0xa8, 0x11,
	0xaf, 0xb5, 0x3b, 0x8f, 0x13, 0x1c, 0xce, 0xe5, 0x07, 0x60, 0x66, 0xb8, 0xb4, 0x68, 0x2b, 0x8c,
	0xba, 0x79, 0x46, 0xf2, 0x17, 0xaa, 0x45, 0x8d, 0xd1, 0x63, 0x81, 0x97, 0xe5, 0xf5, 0x08, 0x5e,
	0xcd, 0xf0, 0xe2, 0x1d, 0x0a, 0xff, 0xcc, 0x31, 0x9b, 0x13, 0xcc, 0xae, 0x68, 0xcc, 0x36, 0x25,
	0x62, 0x96, 0x5b, 0xfe, 0x7c, 0x3b, 0xbd, 0xe7, 0x23, 0x3d, 0xe7, 0xfb, 0x38, 0x7f, 0xbe, 0xbc,
	0x4c, 0x01, 0x65, 0xcf, 0xc3, 0x68, 0x2f, 0xcf, 0xe9, 0x4c, 0x8f, 0x4c, 0x9f, 0x48, 0xc4, 0x2c,
	0xb7, 0xcf, 0xe0, 0x7a, 0xf6, 0x84, 0x4d, 0xc7, 0x0e, 0x03, 0xe6, 0xb7, 0x7a, 0x0e, 0x39, 0x2f,
	0x18, 0x5e, 0xd5, 0x0f, 0xd9, 0x74, 0x3e, 0x15, 0xa8, 0x59, 0x96, 0x8f, 0xe1, 0xb5, 0x1e, 0x96,
	0x4d, 0x7e, 0xfb, 0x39, 0x86, 0x67, 0x7b, 0xb5, 0xd6, 0x74, 0x1e, 0x39, 0x6c, 0x80, 0xd6, 0xb8,
	0x85, 0xe7, 0x38, 0x9d, 0xeb, 0xd1, 0x5a, 0xc3, 0xcd, 0x9d, 0xf3, 0x21, 0x5c, 0xcd, 0x70, 0xe9,
	0x04, 0x05, 0x7c, 0xce, 0x0b, 0x3e, 0x97, 0x35, 0x3e, 0xcf, 0x38, 0x5a, 0x96, 0xd3, 0xdb, 0x70,
	0x3e, 0x5f, 0x6c, 0xd2, 0x80, 0x57, 0xe7, 0x9e, 0x88, 0xf2, 0x53, 0xd6, 0xd9, 0x6c, 0xc5, 0xf9,
	0x40, 0x2e, 0x92, 0x7b, 0xb0, 0x90, 0xa7, 0xe3, 0x71, 0x09, 0xdd, 0xfc, 0x82, 0x70, 0xd7, 0xf3,
	0x59, 0xd2, 0xc7, 0x7e, 0x80, 0x5e, 0x5e, 0x44, 0xec, 0x1c, 0x28, 0xe2, 0x85, 0x42, 0x62, 0xe7,
	0x00, 0x89, 0xdf, 0x87, 0x8b, 0x79, 0x62, 0xcf, 0xf1, 0x9b, 0x5d, 0xbb, 0xe9, 0xb7, 0x7c, 0x66,
	0x5c, 0x94, 0x11, 0x26, 0x4b, 0xbd, 0xce, 0x11, 0x1e, 0xf1, 0x75, 0xf2, 0x01, 0x5c, 0xca, 0x93,
	0xc7, 0x8c, 0x9f, 0xc9, 0xf6, 0x68, 0x10, 0xb6, 0x8c, 0x4b, 0x82, 0xfe, 0x42, 0x96, 0x7e, 0x53,
	0x60, 0xac, 0x73, 0x04, 0xd2, 0x80, 0xcb, 0x7d, 0x18, 0xc4, 0xdd, 0xd6, 0x56, 0xd8, 0x34, 0x2e,
	0x0b, 0x0e, 0x0b, 0x45, 0x1c, 0x36, 0x05, 0x06, 0x79, 0x00, 0x57, 0xfa, 0xca, 0xe0, 0xfa, 0x2d,
	0xa7, 0x19, 0x1b, 0x8b, 0xe2, 0xf2, 0x2e, 0x15, 0x8b, 0x21, 0x71, 0x8a, 0x8e, 0xe2, 0xd1, 0x6d,
	0xa7, 0xd3, 0x64, 0x36, 0x87, 0x1b, 0x57, 0x8a, 0x8e, 0xb2, 0x2e, 0x31, 0x3e, 0xf2, 0x1d, 0x46,
	0xd6, 0x60, 0xb1, 0x1f, 0x83, 0x16, 0x65, 0xbb, 0xa1, 0x67, 0x2c, 0x09, 0x16, 0x17, 0x0b, 0x59,
	0x3c, 0x16, 0x28, 0x45, 0x52, 0xf0, 0xcb, 0x8c, 0x9b, 0x7e, 0xbb, 0xed, 0xec, 0x50, 0xe3, 0x6a,
	0x91, 0x14, 0x8f, 0x9d, 0x83, 0x4d, 0x44, 0x20, 0x9f, 0xc0, 0x6b, 0x79, 0x06, 0x91, 0x1f, 0xef,
	0xc9, 0x11, 0xa0, 0xf6, 0xfa, 0xc6, 0x5c, 0x2a, 0x2d, 0x8f, 0x5b, 0x4b, 0x59, 0x46, 0x96, 0x1f,
	0xef, 0x89, 0x91, 0x60, 0xfa, 0x16, 0xe7, 0x09, 0x5c, 0x2b, 0x32, 0x4d, 0x51, 0x8a, 0xf8, 0x4e,
	0xe0, 0x52, 0xae, 0x6c, 0xd6, 0x89, 0x8d, 0x57, 0x85, 0x64, 0x57, 0x7b, 0xac, 0x74, 0x2d, 0xc1,
	0xdc, 0x14, 0x88, 0x66, 0x1b, 0xca, 0x4f, 0xc3, 0x3d, 0x1a, 0x6c, 0xb6, 0xa9, 0x2b, 0xe6, 0x08,
	0xf2, 0xa2, 0x4b, 0x38, 0x47, 0x90, 0x97, 0x3a, 0x0f, 0xe3, 0xd2, 0x82, 0x70, 0x2a, 0x24, 0x3e,
	0xc8, 0x02, 0x4c, 0x25, 0x77, 0x3a, 0x2a, 0xee, 0x34, 0xf9, 0xe6, 0xed, 0x93, 0xbb, 0xeb, 0xf8,
	0x81, 0xf6, 0x5b, 0xbd, 0xf8, 0xde, 0xf0, 0xcc, 0xdf, 0x1e, 0x87, 0x79, 0x7e, 0x45, 0x32, 0x7b,
	0x3d, 0x49, 0xe6, 0x24, 0x27, 0x1c, 0xff, 0x1b, 0x30, 0xa9, 0xbc, 0x7a, 0x44, 0xfe, 0x32, 0x84,
	0x9f, 0xbc, 0x3f, 0x94, 0xca, 0xea, 0x44, 0x7c, 0x83, 0x2e, 0x76, 0x90, 0x55, 0xa1, 0x14, 0x84,
	0x91, 0x6b, 0x30, 0xdd, 0x76, 0xba, 0xa2, 0xda, 0x40, 0xbb, 0x90, 0xe2, 0xd6, 0x10, 0x8a, 0x96,
	0x70, 0x03, 0x66, 0x3c, 0x1a, 0x33, 0x3f, 0x50, 0x99, 0x7f, 0x1b, 0x9b, 0xc9, 0x69, 0x0d, 0x6c,
	0xd1, 0x6d, 0xf2, 0x3a, 0xcc, 0xea, 0x88, 0xa2, 0x20, 0x95, 0xad, 0xa5, 0xce, 0x40, 0x54, 0xa6,
	0xb7, 0x80, 0x64, 0x79, 0xee, 0xf0, 0x5c, 0x2d, 0x8b, 0x9d, 0xb9, 0x0c, 0x5b, 0xbe, 0xc0, 0x8f,
	0xd3, 0x16, 0xca, 0x8a, 0xa8, 0x67, 0x7b, 0xf4, 0x00, 0x5f, 0xd1, 0x54, 0x13, 0xe0, 0x3a, 0x3d,
	0xe0, 0x25, 0x43, 0x8a, 0x14, 0x6e, 0x6f, 0xdb, 0x91, 0xd3, 0x6a, 0xcb, 0x7e, 0xd3, 0x9a, 0x4d,
	0x56, 0x3e, 0xdd, 0xde, 0xb6, 0x9c, 0x56, 0x9b, 0x4b, 0xa0, 0x6c, 0xd9, 0x66, 0x61, 0x93, 0x46,
	0xe2, 0x09, 0x10, 0x2f, 0x64, 0x4a, 0xd6, 0x9c, 0x5a, 0x79, 0xaa, 0x16, 0xc8, 0x23, 0xa8, 0xba,
	0x51, 0xb7, 0xcd, 0x42, 0x9b, 0x71, 0x93, 0x11, 0x95, 0x4b, 0x65, 0xf5, 0xd5, 0xfe, 0x23, 0x8d,
	0xc4, 0xb2, 0xd4, 0x8f, 0x0d, 0x92, 0x5c, 0x80, 0x39, 0x37, 0x8c, 0x0c, 0x92, 0x5b, 0xf5, 0xd8,
	0xdc, 0x24, 0xb9, 0xe4, 0x96, 0x2d, 0xf3, 0x6b, 0x05, 0x53, 0x28, 0x1c, 0x9b, 0xf0, 0x65, 0xf9,
	0xbb, 0x7b, 0x19, 0x21, 0x0d, 0x66, 0xfe, 0xfe, 0x08, 0x18, 0x1f, 0x65, 0x7c, 0xa5, 0xd1, 0xf1,
	0x7c, 0x26, 0xc7, 0x70, 0xe7, 0x60, 0xc2, 0x71, 0x45, 0x1d, 0x85, 0x5e, 0x21, 0xbf, 0xb8, 0x57,
	0x38, 0x2e, 0x0b, 0x23, 0xe5, 0x15, 0xe2, 0xa3, 0xef, 0xcf, 0x04, 0x97, 0xa0, 0xcc, 0x33, 0x70,
	0xcc, 0xf8, 0x85, 0xe0, 0x94, 0x2c, 0x01, 0x90, 0x5f, 0xd5, 0x46, 0xbe, 0x72, 0x66, 0xf3, 0x61,
	0x7f, 0x45, 0xf4, 0x93, 0xf4, 0x74, 0x06, 0xbf, 0x3f, 0xae, 0x49, 0x7f, 0xd5, 0x02, 0x53, 0xf2,
	0xd8, 0x27, 0x3b, 0xc7, 0xc1, 0xc7, 0x3e, 0x6e, 0xff, 0x19, 0xce, 0xc8, 0xc0, 0x19, 0xce, 0x68,
	0xf1, 0x0c, 0x27, 0x1d, 0x29, 0x8d, 0xe5, 0x46, 0x4a, 0xff, 0xcf, 0x07, 0x3c, 0x62, 0x7a, 0xfc,
	0x65, 0x87, 0xc6, 0xdc, 0x34, 0xb7, 0xba, 0xd8, 0x45, 0x54, 0x12, 0xd8, 0xfd, 0x6e, 0x16, 0x25,
	0x79, 0xac, 0x92, 0xa2, 0xf4, 0x98, 0x77, 0x35, 0x67, 0xde, 0xe9, 0x44, 0xa0, 0xa6, 0x4f, 0x04,
	0xf2, 0xee, 0x3c, 0xfd, 0x52, 0xdd, 0x79, 0xe6, 0x5b, 0xb9, 0xf3, 0x3a, 0xd4, 0x50, 0x36, 0xac,
	0x9c, 0x66, 0x05, 0xbb, 0x23, 0x46, 0x26, 0x92, 0x09, 0x9e, 0x08, 0xeb, 0xa9, 0x75, 0xa8, 0xa1,
	0x4c, 0xc8, 0x65, 0x6e, 0x48, 0x2e, 0x92, 0x0a, 0xb9, 0xf4, 0xe4, 0x11, 0x52, 0x90, 0x47, 0xae,
	0x40, 0x45, 0x20, 0xe1, 0x46, 0x67, 0xe4, 0xfc, 0x84, 0x83, 0x90, 0x4b, 0x6f, 0xa2, 0x99, 0x1f,
	0x32, 0xd1, 0x9c, 0x1d, 0x3a, 0xd1, 0x9c, 0x3b, 0x4e, 0xa2, 0x39, 0xdf, 0x2f, 0xd1, 0x14, 0x67,
	0x05, 0xa3, 0x5f, 0x56, 0xb8, 0x02, 0x15, 0x8f, 0x1e, 0xd8, 0x8e, 0xe7, 0xb4, 0x19, 0x8d, 0xb0,
	0x3e, 0x06, 0x8f, 0x1e, 0x34, 0x24, 0x84, 0x98, 0x50, 0x8b, 0x9f, 0x3b, 0x6d, 0xfb, 0xcb, 0x4e,
	0x28, 0x87, 0x4f, 0xb2, 0x0a, 0xae, 0x70, 0xe0, 0x67, 0x1c, 0xb6, 0xe1, 0x91, 0x25, 0xa8, 0x0a,
	0x1c, 0x35, 0xc3, 0x91, 0xa5, 0x2e, 0x70, 0x98, 0xfc, 0x59, 0x8c, 0x6f, 0x23, 0x30, 0xb0, 0xc0,
	0xb9, 0x94, 0x22, 0xc8, 0x4a, 0x86, 0xbc, 0x01, 0x73, 0x2a, 0xe1, 0xd9, 0x89, 0xfb, 0xca, 0x82,
	0x75, 0x26, 0x94, 0x09, 0xef, 0x89, 0xf2, 0xd5, 0xd7, 0x35, 0xdc, 0x44, 0xac, 0x45, 0xa9, 0x67,
	0xc4, 0x55, 0x92, 0x2d, 0x42, 0x25, 0x41, 0xf5, 0x3d, 0x2c, 0x3c, 0xcb, 0x88, 0xb4, 0x21, 0x9e,
	0x47, 0x27, 0xeb, 0x28, 0x9b, 0xac, 0x2c, 0x6b, 0x88, 0x83, 0xe2, 0xdd, 0x04, 0x92, 0xe0, 0x25,
	0x35, 0x0f, 0x56, 0x90, 0xb3, 0x88, 0x6a, 0x25, 0xb5, 0xd0, 0x77, 0x60, 0xae, 0xb7, 0xa8, 0x33,
	0x25, 0xb2, 0x9b, 0xab, 0xe1, 0xc8, 0x2a, 0x9c, 0xd5, 0x90, 0xd3, 0x02, 0x53, 0x54, 0x81, 0xe3,
	0xd6, 0x99, 0x74, 0x31, 0x29, 0x29, 0x73, 0x34, 0xee, 0x2e, 0x75, 0xf7, 0x64, 0xf0, 0x78, 0x4d,
	0x04, 0x0f, 0x8d, 0x66, 0x4d, 0xae, 0xc9, 0x97, 0xad, 0xdb, 0x8e, 0xdf, 0xd4, 0x5e, 0xb6, 0x5e,
	0x93, 0x27, 0x45, 0x28, 0x4e, 0x0a, 0x7f, 0x19, 0x2a, 0x0e, 0xcf, 0x49, 0x36, 0x8b, 0x1c, 0xbf,
	0x69, 0x5c, 0x17, 0xe9, 0x6c, 0xf5, 0xf8, 0xe9, 0x4c, 0xfd, 0x56, 0x2b, 0x98, 0x3d, 0xe5, 0xbc,
	0xcc, 0xdb, 0x40, 0x3e, 0xeb, 0xd0, 0xa8, 0x2b, 0xc7, 0x52, 0x96, 0x8c, 0x80, 0x47, 0x3e, 0xf3,
	0x36, 0x3f, 0x87, 0x33, 0x19, 0x92, 0xb8, 0x1d, 0x06, 0x31, 0x25, 0x1f, 0xc0, 0x84, 0x44, 0x11,
	0x04, 0x95, 0xd5, 0x1b, 0xfd, 0xe5, 0xcb, 0xbc, 0x29, 0xb7, 0x90, 0xcc, 0x7c, 0x07, 0x16, 0x34,
	0xbe, 0xf1, 0xfd, 0xee, 0xa7, 0x3c, 0xb1, 0x28, 0x91, 0xf4, 0xc4, 0x53, 0xca, 0x24, 0x1e, 0x73,
	0x1b, 0x2e, 0x16, 0x12, 0xa2, 0x60, 0x1f, 0xc3, 0xa4, 0xdc, 0x21, 0x36, 0x4a, 0x42, 0x73, 0xc3,
	0x4a, 0x86, 0xea, 0x52, 0xd4, 0xe6, 0x6a, 0x5e, 0x40, 0x6e, 0x2d, 0x54, 0x09, 0x98, 0xa4, 0x84,
	0x92, 0x96, 0x12, 0x7a, 0x65, 0x43, 0x9a, 0x97, 0x2d, 0xdb, 0xfb, 0x70, 0x4e, 0xec, 0xa3, 0x3f,
	0x20, 0x96, 0x72, 0x0d, 0xf3, 0x82, 0xd8, 0xa4, 0x70, 0xbe, 0x87, 0x1c, 0x45, 0xfc, 0x81, 0x7a,
	0xd7, 0xc9, 0xa1, 0x78, 0xb7, 0x47, 0xbc, 0x8a, 0xc9, 0xbf, 0x60, 0xb6, 0x34, 0x6a, 0xf3, 0x1e,
	0x2c, 0xe6, 0xb6, 0x39, 0xc6, 0x35, 0x77, 0xe0, 0x4a, 0x5f, 0x62, 0x94, 0xd5, 0x82, 0x4a, 0xba,
	0x9b, 0x52, 0xe9, 0x31, 0x84, 0x4d, 0x12, 0x67, 0xca, 0xc4, 0x7c, 0x13, 0x55, 0xa3, 0x3d, 0x3f,
	0xd3, 0x84, 0xed, 0xf3, 0x88, 0xd3, 0xf4, 0xc0, 0xe8, 0xa5, 0x42, 0x29, 0x1f, 0x42, 0x55, 0x7f,
	0xce, 0x83, 0x3a, 0xbd, 0x36, 0xd4, 0xcb, 0x37, 0xab, 0xa2, 0xbd, 0xf8, 0x31, 0xbf, 0x87, 0x2a,
	0xd1, 0x10, 0x8e, 0xa1, 0x50, 0x06, 0x4b, 0xfd, 0xa9, 0x51, 0xd6, 0x27, 0x50, 0xd3, 0x65, 0x55,
	0x3a, 0x1d, 0x4e, 0x58, 0x95, 0xfc, 0x35, 0x91, 0x63, 0xf3, 0xcf, 0x4a, 0xba, 0x6a, 0xf0, 0xed,
	0xd4, 0x60, 0x69, 0x33, 0x35, 0xe4, 0xc8, 0xd0, 0x35, 0xe4, 0xb7, 0x7e, 0xb0, 0x66, 0xba, 0x70,
	0xa1, 0x40, 0x5c, 0x54, 0xcf, 0x47, 0x30, 0x19, 0x4b, 0x10, 0xde, 0xe2, 0xf5, 0x01, 0x8a, 0xc9,
	0xbe, 0x15, 0x53, 0xc4, 0xe6, 0x06, 0x3a, 0x46, 0xef, 0xdb, 0x13, 0xa5, 0x99, 0x61, 0x9f, 0x2e,
	0x98, 0x31, 0xda, 0x44, 0x11, 0xab, 0xe4, 0x52, 0xab, 0x3a, 0x11, 0x8a, 0x7e, 0xf3, 0x38, 0x4f,
	0x62, 0xac, 0x0c, 0x07, 0xf3, 0x03, 0x0c, 0x8d, 0xf8, 0xae, 0xe0, 0x7e, 0x57, 0x4c, 0xf9, 0x95,
	0xec, 0xf9, 0x97, 0x2a, 0xa5, 0x9e, 0x97, 0x2a, 0xe6, 0x73, 0x8c, 0x93, 0x79, 0x06, 0x28, 0xf1,
	0x8f, 0xa0, 0xa6, 0xef, 0xa7, 0xcc, 0xf0, 0x58, 0x22, 0xab, 0x37, 0x00, 0x19, 0x46, 0xe6, 0xef,
	0x95, 0xf0, 0x7e, 0x33, 0x4f, 0x71, 0x94, 0xe4, 0x27, 0x79, 0x1f, 0xd1, 0xef, 0xed, 0xc8, 0x3c,
	0x8c, 0xcb, 0xa9, 0xa3, 0x1c, 0xed, 0xc8, 0x0f, 0x8e, 0x1d, 0x6e, 0x6f, 0xc7, 0x94, 0xe1, 0x1f,
	0x8c, 0xe1, 0x97, 0xf9, 0x45, 0x46, 0xa3, 0x89, 0x58, 0xa8, 0x8f, 0x47, 0x30, 0xa9, 0x9e, 0x41,
	0x0c, 0xa9, 0x09, 0xfd, 0x8d, 0x51, 0x92, 0x3c, 0x24, 0x0b, 0xd3, 0x82, 0x4b, 0x62, 0xaf, 0xfc,
	0xf3, 0x90, 0x6f, 0xa1, 0x05, 0x93, 0xc2, 0xe5, 0x3e, 0x3c, 0xf1, 0x08, 0xeb, 0x30, 0xa9, 0x9e,
	0xb8, 0x0d, 0x4c, 0x2a, 0x3d, 0x4c, 0x14, 0x69, 0x52, 0xbf, 0xa8, 0x5f, 0x6e, 0x92, 0xfa, 0xa5,
	0xef, 0x93, 0x09, 0xf3, 0x19, 0xd6, 0x2f, 0x8a, 0x04, 0xe5, 0xf9, 0x3e, 0x4c, 0x48, 0x94, 0xc1,
	0x9e, 0xac, 0x3f, 0xcf, 0xb0, 0x90, 0xca, 0x7c, 0x86, 0x07, 0x96, 0x8b, 0xf1, 0xfd, 0xae, 0xaa,
	0x8d, 0x95, 0x50, 0x27, 0x9a, 0xc6, 0x99, 0xbb, 0x18, 0x19, 0x0a, 0xd8, 0xa6, 0x31, 0x48, 0x8a,
	0xa0, 0x6c, 0x61, 0x48, 0xc9, 0x95, 0x15, 0x20, 0xb1, 0x39, 0x9f, 0xa8, 0x32, 0x72, 0x5a, 0xea,
	0xee, 0x35, 0x6d, 0x49, 0xa8, 0xae, 0x2d, 0x0e, 0x41, 0x6d, 0x2d, 0x1d, 0xb5, 0x27, 0xc7, 0xc3,
	0xdd, 0x90, 0xca, 0x6c, 0xa0, 0x79, 0xe7, 0xe7, 0x20, 0x49, 0xcd, 0x32, 0x70, 0x10, 0x62, 0xb6,
	0x30, 0x64, 0xe4, 0x59, 0xa0, 0x84, 0x9f, 0x88, 0xbf, 0x82, 0x43, 0x28, 0x4a, 0xb9, 0x32, 0x6c,
	0xcd, 0xac, 0x6a, 0x97, 0x94, 0x83, 0xf9, 0x6b, 0x70, 0xad, 0x60, 0xbb, 0x97, 0x76, 0xcf, 0xbf,
	0x5e, 0x82, 0xeb, 0x83, 0xf8, 0xe3, 0xc9, 0x3e, 0x87, 0x4a, 0x2a, 0x97, 0xba, 0xf4, 0x63, 0x1e,
	0x2d, 0x19, 0x38, 0xa4, 0x8c, 0xcc, 0x1f, 0x61, 0x3d, 0x50, 0x34, 0x4b, 0xfe, 0x76, 0x87, 0x8b,
	0xe1, 0xea, 0x11, 0x9c, 0xd3, 0x0b, 0x6b, 0xa7, 0x7d, 0xdc, 0x50, 0x17, 0xd6, 0xc3, 0x4b, 0xe3,
	0xb0, 0xfa, 0xaf, 0x0b, 0x30, 0x2e, 0x76, 0x25, 0x7f, 0x50, 0x82, 0x09, 0x59, 0x3d, 0x93, 0x23,
	0xe2, 0x64, 0x6f, 0x1f, 0xb4, 0x70, 0x6b, 0x48, 0x6c, 0x79, 0x02, 0xf3, 0xad, 0xdf, 0xf8, 0xa7,
	0xff, 0xfa, 0x9d, 0x91, 0x3a, 0xb9, 0x55, 0xef, 0xfb, 0x87, 0xd3, 0x58, 0xaf, 0xd7, 0x5f, 0x24,
	0xfd, 0xd5, 0x21, 0xf9, 0xeb, 0x12, 0x4c, 0x67, 0x7b, 0x17, 0xf2, 0xe6, 0x50, 0x1b, 0xe7, 0x6a,
	0xbd, 0x85, 0xb7, 0x8e, 0x49, 0x85, 0x62, 0xbf, 0x2f, 0xc4, 0x7e, 0x87, 0xbc, 0x35, 0x58, 0xec,
	0xad, 0xee, 0x2d, 0x51, 0x8f, 0xd5, 0x5f, 0xa8, 0x32, 0xed, 0x90, 0xfc, 0x95, 0x2e, 0xbe, 0x68,
	0x6f, 0x86, 0x17, 0x5f, 0xef, 0xa0, 0x86, 0x17, 0x3f, 0xd3, 0x43, 0x99, 0x77, 0x85, 0xf8, 0x6f,
	0x92, 0xd5, 0xa1, 0xc4, 0x17, 0x6d, 0x59, 0xfd, 0x85, 0xf8, 0xcf, 0x21, 0xf9, 0xf3, 0x12, 0x40,
	0xda, 0x04, 0x90, 0xef, 0x0e, 0x90, 0xa0, 0xa7, 0xbb, 0x5a, 0xb8, 0x7d, 0x0c, 0x8a, 0xe1, 0xd5,
	0xad, 0xf5, 0x1f, 0xf5, 0x17, 0x99, 0xee, 0xed, 0x90, 0xfc, 0x43, 0x09, 0x48, 0x6f, 0x0b, 0x44,
	0xde, 0x1d, 0x5a, 0x90, 0xbc, 0xd5, 0xbc, 0x77, 0x02, 0x4a, 0x3c, 0x4a, 0x43, 0x1c, 0xe5, 0x1e,
	0x79, 0x6f, 0xb8, 0xa3, 0x14, 0x59, 0xcf, 0x9f, 0x94, 0xb2, 0x7f, 0x18, 0x37, 0x48, 0xa1, 0xbd,
	0x6d, 0xd8, 0xc2, 0xea, 0x71, 0x48, 0x50, 0xf2, 0x55, 0x21, 0xf9, 0x4d, 0xf2, 0x46, 0x7f, 0xc9,
	0x45, 0xd7, 0x52, 0x7f, 0xa1, 0x3a, 0xbc, 0x43, 0xf2, 0x77, 0x25, 0x38, 0x53, 0xd0, 0x2b, 0x91,
	0xf7, 0x86, 0xdf, 0x3f, 0xaf, 0xfb, 0xbb, 0x27, 0x21, 0xc5, 0x23, 0xdc, 0x13, 0x47, 0x78, 0x8b,
	0xdc, 0x19, 0x74, 0x84, 0x3e, 0x6a, 0xcf, 0xfe, 0xa9, 0xd0, 0x50, 0x4a, 0xcc, 0x76, 0x6b, 0x0b,
	0x77, 0x8e, 0x45, 0x83, 0x62, 0xd7, 0x85, 0xd8, 0xaf, 0x93, 0x1b, 0x83, 0xc4, 0xc6, 0xde, 0x88,
	0xfc, 0x73, 0xa9, 0xf0, 0x8f, 0x2e, 0x06, 0x19, 0x7c, 0xdf, 0x56, 0x6a, 0xa0, 0xc1, 0xf7, 0xef,
	0x9c, 0xcc, 0x0d, 0x21, 0xfc, 0x1a, 0x69, 0xf4, 0x17, 0x1e, 0x2b, 0xd3, 0x7a, 0xa6, 0xcd, 0xa8,
	0xbf, 0xc8, 0x35, 0x6f, 0x87, 0xe4, 0x27, 0x25, 0x98, 0xce, 0x76, 0x3b, 0x03, 0xc3, 0x66, 0x61,
	0x77, 0x35, 0x30, 0x6c, 0x16, 0xb7, 0x54, 0xe6, 0x07, 0xe2, 0x28, 0xef, 0x91, 0x77, 0x06, 0x1f,
	0x45, 0x34, 0x6a, 0x3c, 0x67, 0x69, 0x4d, 0xdc, 0x21, 0xf9, 0xcb, 0x12, 0xd4, 0x32, 0xbd, 0x05,
	0xb9, 0x33, 0x94, 0x24, 0xd9, 0x16, 0x6b, 0xe1, 0xcd, 0xe3, 0x11, 0x0d, 0x6f, 0xfc, 0x4a, 0xfa,
	0x5d, 0x49, 0x5a, 0x7f, 0x81, 0xad, 0xc9, 0x21, 0xf9, 0xdb, 0x52, 0xc1, 0x53, 0xf8, 0xb7, 0x07,
	0xc8, 0xd1, 0xa7, 0x39, 0x5a, 0x78, 0xe7, 0xd8, 0x74, 0xc3, 0xe7, 0x01, 0x75, 0x84, 0xe4, 0xa5,
	0xbd, 0x76, 0x08, 0x5e, 0xd4, 0xc8, 0xfa, 0x67, 0x60, 0x51, 0x93, 0x69, 0x8e, 0x06, 0x16, 0x35,
	0xd9, 0xbe, 0x68, 0x98, 0xa2, 0x06, 0x3b, 0x88, 0xfa, 0x8b, 0xa4, 0xe9, 0x3a, 0x24, 0x5f, 0x95,
	0x60, 0xae, 0xa7, 0x67, 0x21, 0xef, 0x0c, 0xb5, 0x77, 0x6f, 0x51, 0xbd, 0xf0, 0xee, 0xf1, 0x09,
	0x51, 0xfe, 0x0f, 0x85, 0xfc, 0x77, 0xc9, 0xbb, 0x83, 0xe5, 0xdf, 0xea, 0xde, 0x52, 0x25, 0x6b,
	0xfd, 0x85, 0xfa, 0xd7, 0x21, 0xf9, 0xcd, 0x52, 0xf2, 0xd0, 0x74, 0xb0, 0xa6, 0xb5, 0xde, 0x69,
	0x08, 0x4d, 0xeb, 0x3d, 0x95, 0xb9, 0x2c, 0x24, 0x35, 0xc9, 0xd2, 0x51, 0x92, 0x0a, 0x31, 0xfe,
	0xa6, 0x04, 0xd3, 0xd9, 0xaa, 0x7e, 0x60, 0xec, 0x28, 0x6c, 0xb4, 0x06, 0xc6, 0x8e, 0xe2, 0xde,
	0xca, 0xbc, 0x2f, 0x24, 0xfd, 0x1e, 0xb9, 0xdb, 0x5f, 0xd2, 0x6d, 0xdf, 0x61, 0x75, 0xad, 0xbb,
	0xa8, 0xbf, 0xc8, 0x74, 0x74, 0x87, 0xe4, 0xbf, 0x4b, 0x70, 0xa1, 0x6f, 0xaf, 0x43, 0x3e, 0x38,
	0x96, 0x60, 0x05, 0x06, 0xf3, 0xe1, 0xc9, 0x19, 0x0c, 0x1f, 0xeb, 0x7b, 0x0e, 0xd9, 0xc7, 0x82,
	0x7e, 0x5a, 0xea, 0xf3, 0x42, 0xe7, 0xee, 0x10, 0x52, 0xf6, 0x69, 0xc5, 0x16, 0xee, 0x9d, 0x88,
	0x76, 0xf8, 0xe0, 0x23, 0x0e, 0x97, 0xf6, 0x53, 0xb1, 0x76, 0xa0, 0xfb, 0x4f, 0xbf, 0xfa, 0x7a,
	0xb1, 0xf4, 0xb3, 0xaf, 0x17, 0x4b, 0x3f, 0xff, 0x7a, 0xb1, 0xf4, 0x5b, 0xdf, 0x2c, 0xbe, 0xf2,
	0xb3, 0x6f, 0x16, 0x5f, 0xf9, 0x97, 0x6f, 0x16, 0x5f, 0xf9, 0x95, 0xbb, 0xda, 0x03, 0x7b, 0x8d,
	0xb5, 0xbe, 0x8b, 0xb7, 0x57, 0xdf, 0x09, 0xeb, 0x41, 0xe8, 0xe5, 0x76, 0xdc, 0x9a, 0x10, 0xff,
	0x1f, 0xa7, 0x3b, 0xff, 0x17, 0x00, 0x00, 0xff, 0xff, 0xce, 0x7a, 0xb6, 0xeb, 0x78, 0x4a, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	Escrow(ctx context.Context, in *QueryEscrowRequest, opts ...grpc.CallOption) (*QueryEscrowResponse, error)
	EscrowsByOrder(ctx context.Context, in *QueryEscrowsByOrderRequest, opts ...grpc.CallOption) (*QueryEscrowsByOrderResponse, error)
	EscrowsByState(ctx context.Context, in *QueryEscrowsByStateRequest, opts ...grpc.CallOption) (*QueryEscrowsByStateResponse, error)
	Settlement(ctx context.Context, in *QuerySettlementRequest, opts ...grpc.CallOption) (*QuerySettlementResponse, error)
	SettlementsByOrder(ctx context.Context, in *QuerySettlementsByOrderRequest, opts ...grpc.CallOption) (*QuerySettlementsByOrderResponse, error)
	UsageRecord(ctx context.Context, in *QueryUsageRecordRequest, opts ...grpc.CallOption) (*QueryUsageRecordResponse, error)
	UsageRecordsByOrder(ctx context.Context, in *QueryUsageRecordsByOrderRequest, opts ...grpc.CallOption) (*QueryUsageRecordsByOrderResponse, error)
	UsageSummary(ctx context.Context, in *QueryUsageSummaryRequest, opts ...grpc.CallOption) (*QueryUsageSummaryResponse, error)
	RewardDistribution(ctx context.Context, in *QueryRewardDistributionRequest, opts ...grpc.CallOption) (*QueryRewardDistributionResponse, error)
	RewardsByEpoch(ctx context.Context, in *QueryRewardsByEpochRequest, opts ...grpc.CallOption) (*QueryRewardsByEpochResponse, error)
	RewardHistory(ctx context.Context, in *QueryRewardHistoryRequest, opts ...grpc.CallOption) (*QueryRewardHistoryResponse, error)
	ClaimableRewards(ctx context.Context, in *QueryClaimableRewardsRequest, opts ...grpc.CallOption) (*QueryClaimableRewardsResponse, error)
	Payout(ctx context.Context, in *QueryPayoutRequest, opts ...grpc.CallOption) (*QueryPayoutResponse, error)
	PayoutsByProvider(ctx context.Context, in *QueryPayoutsByProviderRequest, opts ...grpc.CallOption) (*QueryPayoutsByProviderResponse, error)
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	FiatConversion(ctx context.Context, in *QueryFiatConversionRequest, opts ...grpc.CallOption) (*QueryFiatConversionResponse, error)
	FiatConversionsByProvider(ctx context.Context, in *QueryFiatConversionsByProviderRequest, opts ...grpc.CallOption) (*QueryFiatConversionsByProviderResponse, error)
	FiatPayoutPreference(ctx context.Context, in *QueryFiatPayoutPreferenceRequest, opts ...grpc.CallOption) (*QueryFiatPayoutPreferenceResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) Escrow(ctx context.Context, in *QueryEscrowRequest, opts ...grpc.CallOption) (*QueryEscrowResponse, error) {
	out := new(QueryEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/Escrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EscrowsByOrder(ctx context.Context, in *QueryEscrowsByOrderRequest, opts ...grpc.CallOption) (*QueryEscrowsByOrderResponse, error) {
	out := new(QueryEscrowsByOrderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/EscrowsByOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) EscrowsByState(ctx context.Context, in *QueryEscrowsByStateRequest, opts ...grpc.CallOption) (*QueryEscrowsByStateResponse, error) {
	out := new(QueryEscrowsByStateResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/EscrowsByState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Settlement(ctx context.Context, in *QuerySettlementRequest, opts ...grpc.CallOption) (*QuerySettlementResponse, error) {
	out := new(QuerySettlementResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/Settlement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) SettlementsByOrder(ctx context.Context, in *QuerySettlementsByOrderRequest, opts ...grpc.CallOption) (*QuerySettlementsByOrderResponse, error) {
	out := new(QuerySettlementsByOrderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/SettlementsByOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsageRecord(ctx context.Context, in *QueryUsageRecordRequest, opts ...grpc.CallOption) (*QueryUsageRecordResponse, error) {
	out := new(QueryUsageRecordResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/UsageRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsageRecordsByOrder(ctx context.Context, in *QueryUsageRecordsByOrderRequest, opts ...grpc.CallOption) (*QueryUsageRecordsByOrderResponse, error) {
	out := new(QueryUsageRecordsByOrderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/UsageRecordsByOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) UsageSummary(ctx context.Context, in *QueryUsageSummaryRequest, opts ...grpc.CallOption) (*QueryUsageSummaryResponse, error) {
	out := new(QueryUsageSummaryResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/UsageSummary", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RewardDistribution(ctx context.Context, in *QueryRewardDistributionRequest, opts ...grpc.CallOption) (*QueryRewardDistributionResponse, error) {
	out := new(QueryRewardDistributionResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/RewardDistribution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RewardsByEpoch(ctx context.Context, in *QueryRewardsByEpochRequest, opts ...grpc.CallOption) (*QueryRewardsByEpochResponse, error) {
	out := new(QueryRewardsByEpochResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/RewardsByEpoch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) RewardHistory(ctx context.Context, in *QueryRewardHistoryRequest, opts ...grpc.CallOption) (*QueryRewardHistoryResponse, error) {
	out := new(QueryRewardHistoryResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/RewardHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ClaimableRewards(ctx context.Context, in *QueryClaimableRewardsRequest, opts ...grpc.CallOption) (*QueryClaimableRewardsResponse, error) {
	out := new(QueryClaimableRewardsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/ClaimableRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Payout(ctx context.Context, in *QueryPayoutRequest, opts ...grpc.CallOption) (*QueryPayoutResponse, error) {
	out := new(QueryPayoutResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/Payout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) PayoutsByProvider(ctx context.Context, in *QueryPayoutsByProviderRequest, opts ...grpc.CallOption) (*QueryPayoutsByProviderResponse, error) {
	out := new(QueryPayoutsByProviderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/PayoutsByProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FiatConversion(ctx context.Context, in *QueryFiatConversionRequest, opts ...grpc.CallOption) (*QueryFiatConversionResponse, error) {
	out := new(QueryFiatConversionResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/FiatConversion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FiatConversionsByProvider(ctx context.Context, in *QueryFiatConversionsByProviderRequest, opts ...grpc.CallOption) (*QueryFiatConversionsByProviderResponse, error) {
	out := new(QueryFiatConversionsByProviderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/FiatConversionsByProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) FiatPayoutPreference(ctx context.Context, in *QueryFiatPayoutPreferenceRequest, opts ...grpc.CallOption) (*QueryFiatPayoutPreferenceResponse, error) {
	out := new(QueryFiatPayoutPreferenceResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Query/FiatPayoutPreference", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	Escrow(context.Context, *QueryEscrowRequest) (*QueryEscrowResponse, error)
	EscrowsByOrder(context.Context, *QueryEscrowsByOrderRequest) (*QueryEscrowsByOrderResponse, error)
	EscrowsByState(context.Context, *QueryEscrowsByStateRequest) (*QueryEscrowsByStateResponse, error)
	Settlement(context.Context, *QuerySettlementRequest) (*QuerySettlementResponse, error)
	SettlementsByOrder(context.Context, *QuerySettlementsByOrderRequest) (*QuerySettlementsByOrderResponse, error)
	UsageRecord(context.Context, *QueryUsageRecordRequest) (*QueryUsageRecordResponse, error)
	UsageRecordsByOrder(context.Context, *QueryUsageRecordsByOrderRequest) (*QueryUsageRecordsByOrderResponse, error)
	UsageSummary(context.Context, *QueryUsageSummaryRequest) (*QueryUsageSummaryResponse, error)
	RewardDistribution(context.Context, *QueryRewardDistributionRequest) (*QueryRewardDistributionResponse, error)
	RewardsByEpoch(context.Context, *QueryRewardsByEpochRequest) (*QueryRewardsByEpochResponse, error)
	RewardHistory(context.Context, *QueryRewardHistoryRequest) (*QueryRewardHistoryResponse, error)
	ClaimableRewards(context.Context, *QueryClaimableRewardsRequest) (*QueryClaimableRewardsResponse, error)
	Payout(context.Context, *QueryPayoutRequest) (*QueryPayoutResponse, error)
	PayoutsByProvider(context.Context, *QueryPayoutsByProviderRequest) (*QueryPayoutsByProviderResponse, error)
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	FiatConversion(context.Context, *QueryFiatConversionRequest) (*QueryFiatConversionResponse, error)
	FiatConversionsByProvider(context.Context, *QueryFiatConversionsByProviderRequest) (*QueryFiatConversionsByProviderResponse, error)
	FiatPayoutPreference(context.Context, *QueryFiatPayoutPreferenceRequest) (*QueryFiatPayoutPreferenceResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) Escrow(ctx context.Context, req *QueryEscrowRequest) (*QueryEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Escrow not implemented")
}
func (*UnimplementedQueryServer) EscrowsByOrder(ctx context.Context, req *QueryEscrowsByOrderRequest) (*QueryEscrowsByOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EscrowsByOrder not implemented")
}
func (*UnimplementedQueryServer) EscrowsByState(ctx context.Context, req *QueryEscrowsByStateRequest) (*QueryEscrowsByStateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EscrowsByState not implemented")
}
func (*UnimplementedQueryServer) Settlement(ctx context.Context, req *QuerySettlementRequest) (*QuerySettlementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Settlement not implemented")
}
func (*UnimplementedQueryServer) SettlementsByOrder(ctx context.Context, req *QuerySettlementsByOrderRequest) (*QuerySettlementsByOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettlementsByOrder not implemented")
}
func (*UnimplementedQueryServer) UsageRecord(ctx context.Context, req *QueryUsageRecordRequest) (*QueryUsageRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsageRecord not implemented")
}
func (*UnimplementedQueryServer) UsageRecordsByOrder(ctx context.Context, req *QueryUsageRecordsByOrderRequest) (*QueryUsageRecordsByOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsageRecordsByOrder not implemented")
}
func (*UnimplementedQueryServer) UsageSummary(ctx context.Context, req *QueryUsageSummaryRequest) (*QueryUsageSummaryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UsageSummary not implemented")
}
func (*UnimplementedQueryServer) RewardDistribution(ctx context.Context, req *QueryRewardDistributionRequest) (*QueryRewardDistributionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardDistribution not implemented")
}
func (*UnimplementedQueryServer) RewardsByEpoch(ctx context.Context, req *QueryRewardsByEpochRequest) (*QueryRewardsByEpochResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardsByEpoch not implemented")
}
func (*UnimplementedQueryServer) RewardHistory(ctx context.Context, req *QueryRewardHistoryRequest) (*QueryRewardHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RewardHistory not implemented")
}
func (*UnimplementedQueryServer) ClaimableRewards(ctx context.Context, req *QueryClaimableRewardsRequest) (*QueryClaimableRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimableRewards not implemented")
}
func (*UnimplementedQueryServer) Payout(ctx context.Context, req *QueryPayoutRequest) (*QueryPayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Payout not implemented")
}
func (*UnimplementedQueryServer) PayoutsByProvider(ctx context.Context, req *QueryPayoutsByProviderRequest) (*QueryPayoutsByProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PayoutsByProvider not implemented")
}
func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) FiatConversion(ctx context.Context, req *QueryFiatConversionRequest) (*QueryFiatConversionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FiatConversion not implemented")
}
func (*UnimplementedQueryServer) FiatConversionsByProvider(ctx context.Context, req *QueryFiatConversionsByProviderRequest) (*QueryFiatConversionsByProviderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FiatConversionsByProvider not implemented")
}
func (*UnimplementedQueryServer) FiatPayoutPreference(ctx context.Context, req *QueryFiatPayoutPreferenceRequest) (*QueryFiatPayoutPreferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FiatPayoutPreference not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_Escrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEscrowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Escrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/Escrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Escrow(ctx, req.(*QueryEscrowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EscrowsByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEscrowsByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EscrowsByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/EscrowsByOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EscrowsByOrder(ctx, req.(*QueryEscrowsByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_EscrowsByState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryEscrowsByStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).EscrowsByState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/EscrowsByState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).EscrowsByState(ctx, req.(*QueryEscrowsByStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Settlement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySettlementRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Settlement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/Settlement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Settlement(ctx, req.(*QuerySettlementRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_SettlementsByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QuerySettlementsByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).SettlementsByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/SettlementsByOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).SettlementsByOrder(ctx, req.(*QuerySettlementsByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsageRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUsageRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsageRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/UsageRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsageRecord(ctx, req.(*QueryUsageRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsageRecordsByOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUsageRecordsByOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsageRecordsByOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/UsageRecordsByOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsageRecordsByOrder(ctx, req.(*QueryUsageRecordsByOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_UsageSummary_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryUsageSummaryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).UsageSummary(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/UsageSummary",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).UsageSummary(ctx, req.(*QueryUsageSummaryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RewardDistribution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardDistributionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RewardDistribution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/RewardDistribution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RewardDistribution(ctx, req.(*QueryRewardDistributionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RewardsByEpoch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardsByEpochRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RewardsByEpoch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/RewardsByEpoch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RewardsByEpoch(ctx, req.(*QueryRewardsByEpochRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_RewardHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryRewardHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).RewardHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/RewardHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).RewardHistory(ctx, req.(*QueryRewardHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ClaimableRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryClaimableRewardsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ClaimableRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/ClaimableRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ClaimableRewards(ctx, req.(*QueryClaimableRewardsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Payout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Payout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/Payout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Payout(ctx, req.(*QueryPayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_PayoutsByProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryPayoutsByProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).PayoutsByProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/PayoutsByProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).PayoutsByProvider(ctx, req.(*QueryPayoutsByProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FiatConversion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFiatConversionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FiatConversion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/FiatConversion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FiatConversion(ctx, req.(*QueryFiatConversionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FiatConversionsByProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFiatConversionsByProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FiatConversionsByProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/FiatConversionsByProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FiatConversionsByProvider(ctx, req.(*QueryFiatConversionsByProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_FiatPayoutPreference_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryFiatPayoutPreferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).FiatPayoutPreference(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Query/FiatPayoutPreference",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).FiatPayoutPreference(ctx, req.(*QueryFiatPayoutPreferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.settlement.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Escrow",
			Handler:    _Query_Escrow_Handler,
		},
		{
			MethodName: "EscrowsByOrder",
			Handler:    _Query_EscrowsByOrder_Handler,
		},
		{
			MethodName: "EscrowsByState",
			Handler:    _Query_EscrowsByState_Handler,
		},
		{
			MethodName: "Settlement",
			Handler:    _Query_Settlement_Handler,
		},
		{
			MethodName: "SettlementsByOrder",
			Handler:    _Query_SettlementsByOrder_Handler,
		},
		{
			MethodName: "UsageRecord",
			Handler:    _Query_UsageRecord_Handler,
		},
		{
			MethodName: "UsageRecordsByOrder",
			Handler:    _Query_UsageRecordsByOrder_Handler,
		},
		{
			MethodName: "UsageSummary",
			Handler:    _Query_UsageSummary_Handler,
		},
		{
			MethodName: "RewardDistribution",
			Handler:    _Query_RewardDistribution_Handler,
		},
		{
			MethodName: "RewardsByEpoch",
			Handler:    _Query_RewardsByEpoch_Handler,
		},
		{
			MethodName: "RewardHistory",
			Handler:    _Query_RewardHistory_Handler,
		},
		{
			MethodName: "ClaimableRewards",
			Handler:    _Query_ClaimableRewards_Handler,
		},
		{
			MethodName: "Payout",
			Handler:    _Query_Payout_Handler,
		},
		{
			MethodName: "PayoutsByProvider",
			Handler:    _Query_PayoutsByProvider_Handler,
		},
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "FiatConversion",
			Handler:    _Query_FiatConversion_Handler,
		},
		{
			MethodName: "FiatConversionsByProvider",
			Handler:    _Query_FiatConversionsByProvider_Handler,
		},
		{
			MethodName: "FiatPayoutPreference",
			Handler:    _Query_FiatPayoutPreference_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/settlement/v1/query.proto",
}

func (m *ReleaseCondition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReleaseCondition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReleaseCondition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SatisfiedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SatisfiedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.Satisfied {
		i--
		if m.Satisfied {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.RequiredVerificationScore != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.RequiredVerificationScore))
		i--
		dAtA[i] = 0x30
	}
	if m.MinUsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MinUsageUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.SignatureThreshold != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SignatureThreshold))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RequiredSigners) > 0 {
		for iNdEx := len(m.RequiredSigners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequiredSigners[iNdEx])
			copy(dAtA[i:], m.RequiredSigners[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.RequiredSigners[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.UnlockAfter != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UnlockAfter))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EscrowAccount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EscrowAccount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EscrowAccount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.SettlementCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SettlementCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.TotalSettled) > 0 {
		for iNdEx := len(m.TotalSettled) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalSettled[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x7a
		}
	}
	if len(m.ClosureReason) > 0 {
		i -= len(m.ClosureReason)
		copy(dAtA[i:], m.ClosureReason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ClosureReason)))
		i--
		dAtA[i] = 0x72
	}
	if m.ClosedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ClosedAt))
		i--
		dAtA[i] = 0x68
	}
	if m.ActivatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ActivatedAt))
		i--
		dAtA[i] = 0x60
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x58
	}
	if m.CreatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x50
	}
	if len(m.Conditions) > 0 {
		for iNdEx := len(m.Conditions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conditions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Balance) > 0 {
		for iNdEx := len(m.Balance) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Balance[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Depositor) > 0 {
		i -= len(m.Depositor)
		copy(dAtA[i:], m.Depositor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Depositor)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SettlementRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SettlementRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SettlementRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFinal {
		i--
		if m.IsFinal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if len(m.SettlementType) > 0 {
		i -= len(m.SettlementType)
		copy(dAtA[i:], m.SettlementType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementType)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.PeriodEnd != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodEnd))
		i--
		dAtA[i] = 0x78
	}
	if m.PeriodStart != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodStart))
		i--
		dAtA[i] = 0x70
	}
	if m.TotalUsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalUsageUnits))
		i--
		dAtA[i] = 0x68
	}
	if len(m.UsageRecordIds) > 0 {
		for iNdEx := len(m.UsageRecordIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UsageRecordIds[iNdEx])
			copy(dAtA[i:], m.UsageRecordIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageRecordIds[iNdEx])))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.SettledAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SettledAt))
		i--
		dAtA[i] = 0x58
	}
	if len(m.ValidatorFee) > 0 {
		for iNdEx := len(m.ValidatorFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.PlatformFee) > 0 {
		for iNdEx := len(m.PlatformFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlatformFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ProviderShare) > 0 {
		for iNdEx := len(m.ProviderShare) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ProviderShare[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.TotalAmount) > 0 {
		for iNdEx := len(m.TotalAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQuery(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.SubmittedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Settled {
		i--
		if m.Settled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.CustomerSignature) > 0 {
		i -= len(m.CustomerSignature)
		copy(dAtA[i:], m.CustomerSignature)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CustomerSignature)))
		i--
		dAtA[i] = 0x72
	}
	if m.CustomerAcknowledged {
		i--
		if m.CustomerAcknowledged {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if len(m.ProviderSignature) > 0 {
		i -= len(m.ProviderSignature)
		copy(dAtA[i:], m.ProviderSignature)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ProviderSignature)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.TotalCost) > 0 {
		for iNdEx := len(m.TotalCost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalCost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	{
		size, err := m.UnitPrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	if m.PeriodEnd != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodEnd))
		i--
		dAtA[i] = 0x48
	}
	if m.PeriodStart != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodStart))
		i--
		dAtA[i] = 0x40
	}
	if len(m.UsageType) > 0 {
		i -= len(m.UsageType)
		copy(dAtA[i:], m.UsageType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageType)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageUnits))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UsageId) > 0 {
		i -= len(m.UsageId)
		copy(dAtA[i:], m.UsageId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageTypeSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageTypeSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageTypeSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalCost) > 0 {
		for iNdEx := len(m.TotalCost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalCost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.UsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageUnits))
		i--
		dAtA[i] = 0x10
	}
	if len(m.UsageType) > 0 {
		i -= len(m.UsageType)
		copy(dAtA[i:], m.UsageType)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UsageSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsageSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsageSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsageRecordIds) > 0 {
		for iNdEx := len(m.UsageRecordIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UsageRecordIds[iNdEx])
			copy(dAtA[i:], m.UsageRecordIds[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageRecordIds[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x48
	}
	if m.GeneratedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.GeneratedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ByUsageType) > 0 {
		for iNdEx := len(m.ByUsageType) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ByUsageType[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.TotalCost) > 0 {
		for iNdEx := len(m.TotalCost) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalCost[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.TotalUsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalUsageUnits))
		i--
		dAtA[i] = 0x28
	}
	if m.PeriodEnd != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.PeriodStart != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodStart))
		i--
		dAtA[i] = 0x18
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardRecipient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardRecipient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardRecipient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.StakingWeight) > 0 {
		i -= len(m.StakingWeight)
		copy(dAtA[i:], m.StakingWeight)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.StakingWeight)))
		i--
		dAtA[i] = 0x32
	}
	if m.VerificationScore != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.VerificationScore))
		i--
		dAtA[i] = 0x28
	}
	if m.UsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageUnits))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardDistribution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardDistribution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardDistribution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQuery(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x4a
		}
	}
	if len(m.ReferenceTxHashes) > 0 {
		for iNdEx := len(m.ReferenceTxHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ReferenceTxHashes[iNdEx])
			copy(dAtA[i:], m.ReferenceTxHashes[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.ReferenceTxHashes[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.DistributedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DistributedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Recipients) > 0 {
		for iNdEx := len(m.Recipients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Recipients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.TotalRewards) > 0 {
		for iNdEx := len(m.TotalRewards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalRewards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.EpochNumber != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DistributionId) > 0 {
		i -= len(m.DistributionId)
		copy(dAtA[i:], m.DistributionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DistributionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardHistoryEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardHistoryEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardHistoryEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DistributedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DistributedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.UsageUnits != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageUnits))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x1a
	}
	if m.EpochNumber != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.DistributionId) > 0 {
		i -= len(m.DistributionId)
		copy(dAtA[i:], m.DistributionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DistributionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RewardEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RewardEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RewardEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.CreatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DistributionId) > 0 {
		i -= len(m.DistributionId)
		copy(dAtA[i:], m.DistributionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DistributionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ClaimableRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClaimableRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClaimableRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TotalClaimed) > 0 {
		for iNdEx := len(m.TotalClaimed) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalClaimed[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.LastUpdated != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x20
	}
	if len(m.RewardEntries) > 0 {
		for iNdEx := len(m.RewardEntries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RewardEntries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TotalClaimable) > 0 {
		for iNdEx := len(m.TotalClaimable) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TotalClaimable[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PayoutRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PayoutRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PayoutRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd0
	}
	if m.CompletedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CompletedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.ProcessedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ProcessedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.CreatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.LastError) > 0 {
		i -= len(m.LastError)
		copy(dAtA[i:], m.LastError)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LastError)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if m.LastAttemptAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastAttemptAt))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.ExecutionAttempts != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ExecutionAttempts))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if len(m.IdempotencyKey) > 0 {
		i -= len(m.IdempotencyKey)
		copy(dAtA[i:], m.IdempotencyKey)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.IdempotencyKey)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if len(m.HoldReason) > 0 {
		i -= len(m.HoldReason)
		copy(dAtA[i:], m.HoldReason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.HoldReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	if len(m.DisputeId) > 0 {
		i -= len(m.DisputeId)
		copy(dAtA[i:], m.DisputeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DisputeId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x7a
	}
	if len(m.NetAmount) > 0 {
		for iNdEx := len(m.NetAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NetAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.HoldbackAmount) > 0 {
		for iNdEx := len(m.HoldbackAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HoldbackAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.ValidatorFee) > 0 {
		for iNdEx := len(m.ValidatorFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ValidatorFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x62
		}
	}
	if len(m.PlatformFee) > 0 {
		for iNdEx := len(m.PlatformFee) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PlatformFee[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.GrossAmount) > 0 {
		for iNdEx := len(m.GrossAmount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.GrossAmount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.InvoiceId) > 0 {
		i -= len(m.InvoiceId)
		copy(dAtA[i:], m.InvoiceId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.InvoiceId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FiatConversionId) > 0 {
		i -= len(m.FiatConversionId)
		copy(dAtA[i:], m.FiatConversionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PayoutId) > 0 {
		i -= len(m.PayoutId)
		copy(dAtA[i:], m.PayoutId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PayoutId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FiatConversionMinComplianceStatus) > 0 {
		i -= len(m.FiatConversionMinComplianceStatus)
		copy(dAtA[i:], m.FiatConversionMinComplianceStatus)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionMinComplianceStatus)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x9a
	}
	if m.FiatConversionRiskScoreThreshold != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.FiatConversionRiskScoreThreshold))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x90
	}
	if len(m.FiatConversionMaxSlippage) > 0 {
		i -= len(m.FiatConversionMaxSlippage)
		copy(dAtA[i:], m.FiatConversionMaxSlippage)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionMaxSlippage)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.FiatConversionDefaultMethod) > 0 {
		i -= len(m.FiatConversionDefaultMethod)
		copy(dAtA[i:], m.FiatConversionDefaultMethod)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionDefaultMethod)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.FiatConversionDefaultFiat) > 0 {
		i -= len(m.FiatConversionDefaultFiat)
		copy(dAtA[i:], m.FiatConversionDefaultFiat)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionDefaultFiat)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if m.FiatConversionStableDecimals != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.FiatConversionStableDecimals))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf0
	}
	if len(m.FiatConversionStableSymbol) > 0 {
		i -= len(m.FiatConversionStableSymbol)
		copy(dAtA[i:], m.FiatConversionStableSymbol)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionStableSymbol)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.FiatConversionStableDenom) > 0 {
		i -= len(m.FiatConversionStableDenom)
		copy(dAtA[i:], m.FiatConversionStableDenom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionStableDenom)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.FiatConversionDailyLimit) > 0 {
		i -= len(m.FiatConversionDailyLimit)
		copy(dAtA[i:], m.FiatConversionDailyLimit)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionDailyLimit)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.FiatConversionMaxAmount) > 0 {
		i -= len(m.FiatConversionMaxAmount)
		copy(dAtA[i:], m.FiatConversionMaxAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionMaxAmount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.FiatConversionMinAmount) > 0 {
		i -= len(m.FiatConversionMinAmount)
		copy(dAtA[i:], m.FiatConversionMinAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatConversionMinAmount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.FiatConversionEnabled {
		i--
		if m.FiatConversionEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc0
	}
	if m.UsageRewardUnackMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardUnackMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if m.UsageRewardAckMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardAckMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.UsageRewardSlaLateMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardSlaLateMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.UsageRewardSlaOntimeMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardSlaOntimeMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.UsageRewardNetworkMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardNetworkMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.UsageRewardGpuMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardGpuMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.UsageRewardStorageMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardStorageMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.UsageRewardMemoryMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardMemoryMultiplierBps))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.UsageRewardCpuMultiplierBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardCpuMultiplierBps))
		i--
		dAtA[i] = 0x78
	}
	if m.UsageRewardRateBps != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageRewardRateBps))
		i--
		dAtA[i] = 0x70
	}
	if m.DisputeWindowDuration != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.DisputeWindowDuration))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxPayoutRetries != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxPayoutRetries))
		i--
		dAtA[i] = 0x60
	}
	if len(m.PayoutHoldbackRate) > 0 {
		i -= len(m.PayoutHoldbackRate)
		copy(dAtA[i:], m.PayoutHoldbackRate)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PayoutHoldbackRate)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.VerificationRewardAmount) > 0 {
		i -= len(m.VerificationRewardAmount)
		copy(dAtA[i:], m.VerificationRewardAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.VerificationRewardAmount)))
		i--
		dAtA[i] = 0x52
	}
	if m.StakingRewardEpochLength != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.StakingRewardEpochLength))
		i--
		dAtA[i] = 0x48
	}
	if m.UsageGracePeriod != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UsageGracePeriod))
		i--
		dAtA[i] = 0x40
	}
	if len(m.MinSettlementAmount) > 0 {
		i -= len(m.MinSettlementAmount)
		copy(dAtA[i:], m.MinSettlementAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.MinSettlementAmount)))
		i--
		dAtA[i] = 0x3a
	}
	if m.RewardClaimExpiry != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.RewardClaimExpiry))
		i--
		dAtA[i] = 0x30
	}
	if m.SettlementPeriod != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.SettlementPeriod))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxEscrowDuration != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MaxEscrowDuration))
		i--
		dAtA[i] = 0x20
	}
	if m.MinEscrowDuration != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.MinEscrowDuration))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ValidatorFeeRate) > 0 {
		i -= len(m.ValidatorFeeRate)
		copy(dAtA[i:], m.ValidatorFeeRate)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ValidatorFeeRate)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PlatformFeeRate) > 0 {
		i -= len(m.PlatformFeeRate)
		copy(dAtA[i:], m.PlatformFeeRate)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PlatformFeeRate)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TokenSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TokenSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TokenSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x22
	}
	if m.Decimals != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Decimals))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Denom) > 0 {
		i -= len(m.Denom)
		copy(dAtA[i:], m.Denom)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Denom)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Symbol) > 0 {
		i -= len(m.Symbol)
		copy(dAtA[i:], m.Symbol)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Symbol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FiatPayoutPreference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiatPayoutPreference) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FiatPayoutPreference) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x70
	}
	if m.CreatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x68
	}
	{
		size, err := m.StableToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.CryptoToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.SlippageTolerance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SlippageTolerance))))
		i--
		dAtA[i] = 0x51
	}
	if len(m.PreferredOffRamp) > 0 {
		i -= len(m.PreferredOffRamp)
		copy(dAtA[i:], m.PreferredOffRamp)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PreferredOffRamp)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.PreferredDex) > 0 {
		i -= len(m.PreferredDex)
		copy(dAtA[i:], m.PreferredDex)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PreferredDex)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DestinationRegion) > 0 {
		i -= len(m.DestinationRegion)
		copy(dAtA[i:], m.DestinationRegion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationRegion)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.DestinationHash) > 0 {
		i -= len(m.DestinationHash)
		copy(dAtA[i:], m.DestinationHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DestinationRef) > 0 {
		i -= len(m.DestinationRef)
		copy(dAtA[i:], m.DestinationRef)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationRef)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.FiatCurrency) > 0 {
		i -= len(m.FiatCurrency)
		copy(dAtA[i:], m.FiatCurrency)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatCurrency)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FiatConversionAuditEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiatConversionAuditEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FiatConversionAuditEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintQuery(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Timestamp != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FiatConversionRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FiatConversionRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FiatConversionRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuditTrail) > 0 {
		for iNdEx := len(m.AuditTrail) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AuditTrail[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2
			i--
			dAtA[i] = 0xb2
		}
	}
	if len(m.FailureReason) > 0 {
		i -= len(m.FailureReason)
		copy(dAtA[i:], m.FailureReason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FailureReason)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xaa
	}
	if m.ComplianceCheckedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ComplianceCheckedAt))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0xa0
	}
	if m.ComplianceRiskScore != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ComplianceRiskScore))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x98
	}
	if len(m.ComplianceStatus) > 0 {
		i -= len(m.ComplianceStatus)
		copy(dAtA[i:], m.ComplianceStatus)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ComplianceStatus)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x92
	}
	if len(m.OffRampReference) > 0 {
		i -= len(m.OffRampReference)
		copy(dAtA[i:], m.OffRampReference)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OffRampReference)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x8a
	}
	if len(m.OffRampStatus) > 0 {
		i -= len(m.OffRampStatus)
		copy(dAtA[i:], m.OffRampStatus)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OffRampStatus)))
		i--
		dAtA[i] = 0x2
		i--
		dAtA[i] = 0x82
	}
	if len(m.OffRampId) > 0 {
		i -= len(m.OffRampId)
		copy(dAtA[i:], m.OffRampId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OffRampId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xfa
	}
	if len(m.OffRampQuoteId) > 0 {
		i -= len(m.OffRampQuoteId)
		copy(dAtA[i:], m.OffRampQuoteId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OffRampQuoteId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if len(m.OffRampProvider) > 0 {
		i -= len(m.OffRampProvider)
		copy(dAtA[i:], m.OffRampProvider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OffRampProvider)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if len(m.SwapStatus) > 0 {
		i -= len(m.SwapStatus)
		copy(dAtA[i:], m.SwapStatus)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SwapStatus)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xe2
	}
	if len(m.SwapTxHash) > 0 {
		i -= len(m.SwapTxHash)
		copy(dAtA[i:], m.SwapTxHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SwapTxHash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xda
	}
	if len(m.SwapQuoteId) > 0 {
		i -= len(m.SwapQuoteId)
		copy(dAtA[i:], m.SwapQuoteId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SwapQuoteId)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xd2
	}
	if len(m.DexAdapter) > 0 {
		i -= len(m.DexAdapter)
		copy(dAtA[i:], m.DexAdapter)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DexAdapter)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xca
	}
	if m.SlippageTolerance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.SlippageTolerance))))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc1
	}
	if len(m.DestinationRegion) > 0 {
		i -= len(m.DestinationRegion)
		copy(dAtA[i:], m.DestinationRegion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationRegion)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xba
	}
	if len(m.DestinationHash) > 0 {
		i -= len(m.DestinationHash)
		copy(dAtA[i:], m.DestinationHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationHash)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb2
	}
	if len(m.DestinationRef) > 0 {
		i -= len(m.DestinationRef)
		copy(dAtA[i:], m.DestinationRef)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DestinationRef)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xaa
	}
	if len(m.PaymentMethod) > 0 {
		i -= len(m.PaymentMethod)
		copy(dAtA[i:], m.PaymentMethod)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PaymentMethod)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa2
	}
	if len(m.FiatAmount) > 0 {
		i -= len(m.FiatAmount)
		copy(dAtA[i:], m.FiatAmount)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatAmount)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.FiatCurrency) > 0 {
		i -= len(m.FiatCurrency)
		copy(dAtA[i:], m.FiatCurrency)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FiatCurrency)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	{
		size, err := m.StableAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.CryptoAmount.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size, err := m.StableToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.CryptoToken.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x6a
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x60
	}
	if m.RequestedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.RequestedAt))
		i--
		dAtA[i] = 0x58
	}
	if len(m.RequestedBy) > 0 {
		i -= len(m.RequestedBy)
		copy(dAtA[i:], m.RequestedBy)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.RequestedBy)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.Customer) > 0 {
		i -= len(m.Customer)
		copy(dAtA[i:], m.Customer)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Customer)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.PayoutId) > 0 {
		i -= len(m.PayoutId)
		copy(dAtA[i:], m.PayoutId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PayoutId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InvoiceId) > 0 {
		i -= len(m.InvoiceId)
		copy(dAtA[i:], m.InvoiceId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.InvoiceId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ConversionId) > 0 {
		i -= len(m.ConversionId)
		copy(dAtA[i:], m.ConversionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ConversionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Escrow != nil {
		{
			size, err := m.Escrow.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowsByOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowsByOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowsByOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowsByOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowsByOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowsByOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Escrows) > 0 {
		for iNdEx := len(m.Escrows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Escrows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowsByStateRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowsByStateRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowsByStateRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryEscrowsByStateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryEscrowsByStateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryEscrowsByStateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Escrows) > 0 {
		for iNdEx := len(m.Escrows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Escrows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QuerySettlementRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySettlementRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySettlementRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySettlementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySettlementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySettlementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Settlement != nil {
		{
			size, err := m.Settlement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySettlementsByOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySettlementsByOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySettlementsByOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QuerySettlementsByOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuerySettlementsByOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuerySettlementsByOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Settlements) > 0 {
		for iNdEx := len(m.Settlements) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Settlements[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageRecordRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsageId) > 0 {
		i -= len(m.UsageId)
		copy(dAtA[i:], m.UsageId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.UsageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageRecordResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UsageRecord != nil {
		{
			size, err := m.UsageRecord.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageRecordsByOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageRecordsByOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageRecordsByOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageRecordsByOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageRecordsByOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageRecordsByOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsageRecords) > 0 {
		for iNdEx := len(m.UsageRecords) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UsageRecords[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeriodEnd != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodEnd))
		i--
		dAtA[i] = 0x20
	}
	if m.PeriodStart != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PeriodStart))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryUsageSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryUsageSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryUsageSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryRewardDistributionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardDistributionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardDistributionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DistributionId) > 0 {
		i -= len(m.DistributionId)
		copy(dAtA[i:], m.DistributionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DistributionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardDistributionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardDistributionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardDistributionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Distribution != nil {
		{
			size, err := m.Distribution.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardsByEpochRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardsByEpochRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardsByEpochRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EpochNumber != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.EpochNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardsByEpochResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardsByEpochResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardsByEpochResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Distributions) > 0 {
		for iNdEx := len(m.Distributions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Distributions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Limit != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryRewardHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryRewardHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryRewardHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryClaimableRewardsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryClaimableRewardsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryClaimableRewardsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryClaimableRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryClaimableRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryClaimableRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rewards != nil {
		{
			size, err := m.Rewards.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPayoutRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPayoutRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPayoutRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PayoutId) > 0 {
		i -= len(m.PayoutId)
		copy(dAtA[i:], m.PayoutId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.PayoutId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPayoutResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPayoutResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPayoutResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payout != nil {
		{
			size, err := m.Payout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPayoutsByProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPayoutsByProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPayoutsByProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryPayoutsByProviderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPayoutsByProviderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPayoutsByProviderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payouts) > 0 {
		for iNdEx := len(m.Payouts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Payouts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryFiatConversionRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatConversionRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatConversionRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ConversionId) > 0 {
		i -= len(m.ConversionId)
		copy(dAtA[i:], m.ConversionId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ConversionId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFiatConversionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatConversionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatConversionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Conversion != nil {
		{
			size, err := m.Conversion.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFiatConversionsByProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatConversionsByProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatConversionsByProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFiatConversionsByProviderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatConversionsByProviderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatConversionsByProviderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conversions) > 0 {
		for iNdEx := len(m.Conversions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Conversions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryFiatPayoutPreferenceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatPayoutPreferenceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatPayoutPreferenceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Provider) > 0 {
		i -= len(m.Provider)
		copy(dAtA[i:], m.Provider)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Provider)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryFiatPayoutPreferenceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryFiatPayoutPreferenceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryFiatPayoutPreferenceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Preference != nil {
		{
			size, err := m.Preference.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ReleaseCondition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UnlockAfter != 0 {
		n += 1 + sovQuery(uint64(m.UnlockAfter))
	}
	if len(m.RequiredSigners) > 0 {
		for _, s := range m.RequiredSigners {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.SignatureThreshold != 0 {
		n += 1 + sovQuery(uint64(m.SignatureThreshold))
	}
	if m.MinUsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.MinUsageUnits))
	}
	if m.RequiredVerificationScore != 0 {
		n += 1 + sovQuery(uint64(m.RequiredVerificationScore))
	}
	if m.Satisfied {
		n += 2
	}
	if m.SatisfiedAt != 0 {
		n += 1 + sovQuery(uint64(m.SatisfiedAt))
	}
	return n
}

func (m *EscrowAccount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Depositor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Balance) > 0 {
		for _, e := range m.Balance {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Conditions) > 0 {
		for _, e := range m.Conditions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovQuery(uint64(m.CreatedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovQuery(uint64(m.ExpiresAt))
	}
	if m.ActivatedAt != 0 {
		n += 1 + sovQuery(uint64(m.ActivatedAt))
	}
	if m.ClosedAt != 0 {
		n += 1 + sovQuery(uint64(m.ClosedAt))
	}
	l = len(m.ClosureReason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.TotalSettled) > 0 {
		for _, e := range m.TotalSettled {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.SettlementCount != 0 {
		n += 2 + sovQuery(uint64(m.SettlementCount))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovQuery(uint64(m.BlockHeight))
	}
	return n
}

func (m *SettlementRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.TotalAmount) > 0 {
		for _, e := range m.TotalAmount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ProviderShare) > 0 {
		for _, e := range m.ProviderShare {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.PlatformFee) > 0 {
		for _, e := range m.PlatformFee {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ValidatorFee) > 0 {
		for _, e := range m.ValidatorFee {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.SettledAt != 0 {
		n += 1 + sovQuery(uint64(m.SettledAt))
	}
	if len(m.UsageRecordIds) > 0 {
		for _, s := range m.UsageRecordIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.TotalUsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.TotalUsageUnits))
	}
	if m.PeriodStart != 0 {
		n += 1 + sovQuery(uint64(m.PeriodStart))
	}
	if m.PeriodEnd != 0 {
		n += 1 + sovQuery(uint64(m.PeriodEnd))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovQuery(uint64(m.BlockHeight))
	}
	l = len(m.SettlementType)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.IsFinal {
		n += 3
	}
	return n
}

func (m *UsageRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.UsageUnits))
	}
	l = len(m.UsageType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PeriodStart != 0 {
		n += 1 + sovQuery(uint64(m.PeriodStart))
	}
	if m.PeriodEnd != 0 {
		n += 1 + sovQuery(uint64(m.PeriodEnd))
	}
	l = m.UnitPrice.Size()
	n += 1 + l + sovQuery(uint64(l))
	if len(m.TotalCost) > 0 {
		for _, e := range m.TotalCost {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.ProviderSignature)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.CustomerAcknowledged {
		n += 2
	}
	l = len(m.CustomerSignature)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Settled {
		n += 2
	}
	l = len(m.SettlementId)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.SubmittedAt != 0 {
		n += 2 + sovQuery(uint64(m.SubmittedAt))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovQuery(uint64(m.BlockHeight))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + 1 + len(v) + sovQuery(uint64(len(v)))
			n += mapEntrySize + 2 + sovQuery(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UsageTypeSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageType)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.UsageUnits))
	}
	if len(m.TotalCost) > 0 {
		for _, e := range m.TotalCost {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *UsageSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PeriodStart != 0 {
		n += 1 + sovQuery(uint64(m.PeriodStart))
	}
	if m.PeriodEnd != 0 {
		n += 1 + sovQuery(uint64(m.PeriodEnd))
	}
	if m.TotalUsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.TotalUsageUnits))
	}
	if len(m.TotalCost) > 0 {
		for _, e := range m.TotalCost {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ByUsageType) > 0 {
		for _, e := range m.ByUsageType {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.GeneratedAt != 0 {
		n += 1 + sovQuery(uint64(m.GeneratedAt))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	if len(m.UsageRecordIds) > 0 {
		for _, s := range m.UsageRecordIds {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *RewardRecipient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.UsageUnits))
	}
	if m.VerificationScore != 0 {
		n += 1 + sovQuery(uint64(m.VerificationScore))
	}
	l = len(m.StakingWeight)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *RewardDistribution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DistributionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.EpochNumber != 0 {
		n += 1 + sovQuery(uint64(m.EpochNumber))
	}
	if len(m.TotalRewards) > 0 {
		for _, e := range m.TotalRewards {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Recipients) > 0 {
		for _, e := range m.Recipients {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DistributedAt != 0 {
		n += 1 + sovQuery(uint64(m.DistributedAt))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	if len(m.ReferenceTxHashes) > 0 {
		for _, s := range m.ReferenceTxHashes {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + 1 + len(v) + sovQuery(uint64(len(v)))
			n += mapEntrySize + 1 + sovQuery(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *RewardHistoryEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DistributionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.EpochNumber != 0 {
		n += 1 + sovQuery(uint64(m.EpochNumber))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UsageUnits != 0 {
		n += 1 + sovQuery(uint64(m.UsageUnits))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.DistributedAt != 0 {
		n += 1 + sovQuery(uint64(m.DistributedAt))
	}
	return n
}

func (m *RewardEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DistributionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovQuery(uint64(m.CreatedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovQuery(uint64(m.ExpiresAt))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *ClaimableRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.TotalClaimable) > 0 {
		for _, e := range m.TotalClaimable {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.RewardEntries) > 0 {
		for _, e := range m.RewardEntries {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.LastUpdated != 0 {
		n += 1 + sovQuery(uint64(m.LastUpdated))
	}
	if len(m.TotalClaimed) > 0 {
		for _, e := range m.TotalClaimed {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *PayoutRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PayoutId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.InvoiceId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.GrossAmount) > 0 {
		for _, e := range m.GrossAmount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.PlatformFee) > 0 {
		for _, e := range m.PlatformFee {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.ValidatorFee) > 0 {
		for _, e := range m.ValidatorFee {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.HoldbackAmount) > 0 {
		for _, e := range m.HoldbackAmount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if len(m.NetAmount) > 0 {
		for _, e := range m.NetAmount {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DisputeId)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.HoldReason)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.IdempotencyKey)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.ExecutionAttempts != 0 {
		n += 2 + sovQuery(uint64(m.ExecutionAttempts))
	}
	if m.LastAttemptAt != 0 {
		n += 2 + sovQuery(uint64(m.LastAttemptAt))
	}
	l = len(m.LastError)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 2 + sovQuery(uint64(m.CreatedAt))
	}
	if m.ProcessedAt != 0 {
		n += 2 + sovQuery(uint64(m.ProcessedAt))
	}
	if m.CompletedAt != 0 {
		n += 2 + sovQuery(uint64(m.CompletedAt))
	}
	if m.BlockHeight != 0 {
		n += 2 + sovQuery(uint64(m.BlockHeight))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PlatformFeeRate)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ValidatorFeeRate)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MinEscrowDuration != 0 {
		n += 1 + sovQuery(uint64(m.MinEscrowDuration))
	}
	if m.MaxEscrowDuration != 0 {
		n += 1 + sovQuery(uint64(m.MaxEscrowDuration))
	}
	if m.SettlementPeriod != 0 {
		n += 1 + sovQuery(uint64(m.SettlementPeriod))
	}
	if m.RewardClaimExpiry != 0 {
		n += 1 + sovQuery(uint64(m.RewardClaimExpiry))
	}
	l = len(m.MinSettlementAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.UsageGracePeriod != 0 {
		n += 1 + sovQuery(uint64(m.UsageGracePeriod))
	}
	if m.StakingRewardEpochLength != 0 {
		n += 1 + sovQuery(uint64(m.StakingRewardEpochLength))
	}
	l = len(m.VerificationRewardAmount)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PayoutHoldbackRate)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.MaxPayoutRetries != 0 {
		n += 1 + sovQuery(uint64(m.MaxPayoutRetries))
	}
	if m.DisputeWindowDuration != 0 {
		n += 1 + sovQuery(uint64(m.DisputeWindowDuration))
	}
	if m.UsageRewardRateBps != 0 {
		n += 1 + sovQuery(uint64(m.UsageRewardRateBps))
	}
	if m.UsageRewardCpuMultiplierBps != 0 {
		n += 1 + sovQuery(uint64(m.UsageRewardCpuMultiplierBps))
	}
	if m.UsageRewardMemoryMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardMemoryMultiplierBps))
	}
	if m.UsageRewardStorageMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardStorageMultiplierBps))
	}
	if m.UsageRewardGpuMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardGpuMultiplierBps))
	}
	if m.UsageRewardNetworkMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardNetworkMultiplierBps))
	}
	if m.UsageRewardSlaOntimeMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardSlaOntimeMultiplierBps))
	}
	if m.UsageRewardSlaLateMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardSlaLateMultiplierBps))
	}
	if m.UsageRewardAckMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardAckMultiplierBps))
	}
	if m.UsageRewardUnackMultiplierBps != 0 {
		n += 2 + sovQuery(uint64(m.UsageRewardUnackMultiplierBps))
	}
	if m.FiatConversionEnabled {
		n += 3
	}
	l = len(m.FiatConversionMinAmount)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionMaxAmount)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionDailyLimit)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionStableDenom)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionStableSymbol)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.FiatConversionStableDecimals != 0 {
		n += 2 + sovQuery(uint64(m.FiatConversionStableDecimals))
	}
	l = len(m.FiatConversionDefaultFiat)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionDefaultMethod)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatConversionMaxSlippage)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.FiatConversionRiskScoreThreshold != 0 {
		n += 2 + sovQuery(uint64(m.FiatConversionRiskScoreThreshold))
	}
	l = len(m.FiatConversionMinComplianceStatus)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *TokenSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Symbol)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Denom)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Decimals != 0 {
		n += 1 + sovQuery(uint64(m.Decimals))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *FiatPayoutPreference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Enabled {
		n += 2
	}
	l = len(m.FiatCurrency)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationRef)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationRegion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PreferredDex)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PreferredOffRamp)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 9
	}
	l = m.CryptoToken.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.StableToken.Size()
	n += 1 + l + sovQuery(uint64(l))
	if m.CreatedAt != 0 {
		n += 1 + sovQuery(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovQuery(uint64(m.UpdatedAt))
	}
	return n
}

func (m *FiatConversionAuditEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovQuery(uint64(m.Timestamp))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + 1 + len(v) + sovQuery(uint64(len(v)))
			n += mapEntrySize + 1 + sovQuery(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *FiatConversionRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConversionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.InvoiceId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.PayoutId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Customer)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.RequestedBy)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.RequestedAt != 0 {
		n += 1 + sovQuery(uint64(m.RequestedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovQuery(uint64(m.UpdatedAt))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = m.CryptoToken.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.StableToken.Size()
	n += 1 + l + sovQuery(uint64(l))
	l = m.CryptoAmount.Size()
	n += 2 + l + sovQuery(uint64(l))
	l = m.StableAmount.Size()
	n += 2 + l + sovQuery(uint64(l))
	l = len(m.FiatCurrency)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.FiatAmount)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.PaymentMethod)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationRef)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationHash)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.DestinationRegion)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.SlippageTolerance != 0 {
		n += 10
	}
	l = len(m.DexAdapter)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.SwapQuoteId)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.SwapTxHash)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.SwapStatus)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.OffRampProvider)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.OffRampQuoteId)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.OffRampId)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.OffRampStatus)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.OffRampReference)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	l = len(m.ComplianceStatus)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if m.ComplianceRiskScore != 0 {
		n += 2 + sovQuery(uint64(m.ComplianceRiskScore))
	}
	if m.ComplianceCheckedAt != 0 {
		n += 2 + sovQuery(uint64(m.ComplianceCheckedAt))
	}
	l = len(m.FailureReason)
	if l > 0 {
		n += 2 + l + sovQuery(uint64(l))
	}
	if len(m.AuditTrail) > 0 {
		for _, e := range m.AuditTrail {
			l = e.Size()
			n += 2 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryEscrowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Escrow != nil {
		l = m.Escrow.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryEscrowsByOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryEscrowsByOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Escrows) > 0 {
		for _, e := range m.Escrows {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryEscrowsByStateRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryEscrowsByStateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Escrows) > 0 {
		for _, e := range m.Escrows {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QuerySettlementRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySettlementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Settlement != nil {
		l = m.Settlement.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySettlementsByOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QuerySettlementsByOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Settlements) > 0 {
		for _, e := range m.Settlements {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryUsageRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUsageRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UsageRecord != nil {
		l = m.UsageRecord.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUsageRecordsByOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryUsageRecordsByOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UsageRecords) > 0 {
		for _, e := range m.UsageRecords {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryUsageSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.PeriodStart != 0 {
		n += 1 + sovQuery(uint64(m.PeriodStart))
	}
	if m.PeriodEnd != 0 {
		n += 1 + sovQuery(uint64(m.PeriodEnd))
	}
	return n
}

func (m *QueryUsageSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Summary.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryRewardDistributionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DistributionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryRewardDistributionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Distribution != nil {
		l = m.Distribution.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryRewardsByEpochRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochNumber != 0 {
		n += 1 + sovQuery(uint64(m.EpochNumber))
	}
	return n
}

func (m *QueryRewardsByEpochResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Distributions) > 0 {
		for _, e := range m.Distributions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryRewardHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovQuery(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovQuery(uint64(m.Offset))
	}
	return n
}

func (m *QueryRewardHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryClaimableRewardsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryClaimableRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rewards != nil {
		l = m.Rewards.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPayoutRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PayoutId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPayoutResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payout != nil {
		l = m.Payout.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPayoutsByProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryPayoutsByProviderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Payouts) > 0 {
		for _, e := range m.Payouts {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryFiatConversionRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ConversionId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryFiatConversionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conversion != nil {
		l = m.Conversion.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryFiatConversionsByProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryFiatConversionsByProviderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Conversions) > 0 {
		for _, e := range m.Conversions {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryFiatPayoutPreferenceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Provider)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryFiatPayoutPreferenceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Preference != nil {
		l = m.Preference.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ReleaseCondition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReleaseCondition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReleaseCondition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnlockAfter", wireType)
			}
			m.UnlockAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnlockAfter |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredSigners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredSigners = append(m.RequiredSigners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureThreshold", wireType)
			}
			m.SignatureThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SignatureThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinUsageUnits", wireType)
			}
			m.MinUsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinUsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredVerificationScore", wireType)
			}
			m.RequiredVerificationScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredVerificationScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Satisfied", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Satisfied = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SatisfiedAt", wireType)
			}
			m.SatisfiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SatisfiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EscrowAccount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EscrowAccount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EscrowAccount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Depositor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Depositor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Balance = append(m.Balance, types.Coin{})
			if err := m.Balance[len(m.Balance)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conditions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conditions = append(m.Conditions, ReleaseCondition{})
			if err := m.Conditions[len(m.Conditions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			m.ActivatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosedAt", wireType)
			}
			m.ClosedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClosedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClosureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClosureReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalSettled", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalSettled = append(m.TotalSettled, types.Coin{})
			if err := m.TotalSettled[len(m.TotalSettled)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementCount", wireType)
			}
			m.SettlementCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SettlementRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SettlementRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SettlementRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = append(m.TotalAmount, types.Coin{})
			if err := m.TotalAmount[len(m.TotalAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderShare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderShare = append(m.ProviderShare, types.Coin{})
			if err := m.ProviderShare[len(m.ProviderShare)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFee = append(m.PlatformFee, types.Coin{})
			if err := m.PlatformFee[len(m.PlatformFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorFee = append(m.ValidatorFee, types.Coin{})
			if err := m.ValidatorFee[len(m.ValidatorFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledAt", wireType)
			}
			m.SettledAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettledAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRecordIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageRecordIds = append(m.UsageRecordIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsageUnits", wireType)
			}
			m.TotalUsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			m.PeriodStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			m.PeriodEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFinal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUnits", wireType)
			}
			m.UsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			m.PeriodStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			m.PeriodEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalCost = append(m.TotalCost, types.Coin{})
			if err := m.TotalCost[len(m.TotalCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderSignature = append(m.ProviderSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ProviderSignature == nil {
				m.ProviderSignature = []byte{}
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAcknowledged", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CustomerAcknowledged = bool(v != 0)
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerSignature = append(m.CustomerSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.CustomerSignature == nil {
				m.CustomerSignature = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Settled = bool(v != 0)
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageTypeSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageTypeSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageTypeSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUnits", wireType)
			}
			m.UsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalCost = append(m.TotalCost, types.Coin{})
			if err := m.TotalCost[len(m.TotalCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsageSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsageSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsageSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			m.PeriodStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			m.PeriodEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalUsageUnits", wireType)
			}
			m.TotalUsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalUsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalCost = append(m.TotalCost, types.Coin{})
			if err := m.TotalCost[len(m.TotalCost)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByUsageType", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ByUsageType = append(m.ByUsageType, UsageTypeSummary{})
			if err := m.ByUsageType[len(m.ByUsageType)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeneratedAt", wireType)
			}
			m.GeneratedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GeneratedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRecordIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageRecordIds = append(m.UsageRecordIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardRecipient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardRecipient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardRecipient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUnits", wireType)
			}
			m.UsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationScore", wireType)
			}
			m.VerificationScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingWeight", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingWeight = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardDistribution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardDistribution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardDistribution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalRewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalRewards = append(m.TotalRewards, types.Coin{})
			if err := m.TotalRewards[len(m.TotalRewards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipients = append(m.Recipients, RewardRecipient{})
			if err := m.Recipients[len(m.Recipients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributedAt", wireType)
			}
			m.DistributedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceTxHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceTxHashes = append(m.ReferenceTxHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardHistoryEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardHistoryEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardHistoryEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUnits", wireType)
			}
			m.UsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributedAt", wireType)
			}
			m.DistributedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DistributedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RewardEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RewardEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RewardEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClaimableRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClaimableRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClaimableRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalClaimable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalClaimable = append(m.TotalClaimable, types.Coin{})
			if err := m.TotalClaimable[len(m.TotalClaimable)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardEntries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RewardEntries = append(m.RewardEntries, RewardEntry{})
			if err := m.RewardEntries[len(m.RewardEntries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalClaimed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalClaimed = append(m.TotalClaimed, types.Coin{})
			if err := m.TotalClaimed[len(m.TotalClaimed)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PayoutRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PayoutRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PayoutRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrossAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GrossAmount = append(m.GrossAmount, types.Coin{})
			if err := m.GrossAmount[len(m.GrossAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFee = append(m.PlatformFee, types.Coin{})
			if err := m.PlatformFee[len(m.PlatformFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorFee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorFee = append(m.ValidatorFee, types.Coin{})
			if err := m.ValidatorFee[len(m.ValidatorFee)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldbackAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoldbackAmount = append(m.HoldbackAmount, types.Coin{})
			if err := m.HoldbackAmount[len(m.HoldbackAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetAmount = append(m.NetAmount, types.Coin{})
			if err := m.NetAmount[len(m.NetAmount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisputeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HoldReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HoldReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdempotencyKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IdempotencyKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionAttempts", wireType)
			}
			m.ExecutionAttempts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExecutionAttempts |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastAttemptAt", wireType)
			}
			m.LastAttemptAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastAttemptAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastError", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastError = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessedAt", wireType)
			}
			m.ProcessedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProcessedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			m.CompletedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 26:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorFeeRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorFeeRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinEscrowDuration", wireType)
			}
			m.MinEscrowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinEscrowDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxEscrowDuration", wireType)
			}
			m.MaxEscrowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxEscrowDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementPeriod", wireType)
			}
			m.SettlementPeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettlementPeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RewardClaimExpiry", wireType)
			}
			m.RewardClaimExpiry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RewardClaimExpiry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinSettlementAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MinSettlementAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageGracePeriod", wireType)
			}
			m.UsageGracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageGracePeriod |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingRewardEpochLength", wireType)
			}
			m.StakingRewardEpochLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StakingRewardEpochLength |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationRewardAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerificationRewardAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutHoldbackRate", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutHoldbackRate = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPayoutRetries", wireType)
			}
			m.MaxPayoutRetries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPayoutRetries |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputeWindowDuration", wireType)
			}
			m.DisputeWindowDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputeWindowDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardRateBps", wireType)
			}
			m.UsageRewardRateBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardRateBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardCpuMultiplierBps", wireType)
			}
			m.UsageRewardCpuMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardCpuMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardMemoryMultiplierBps", wireType)
			}
			m.UsageRewardMemoryMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardMemoryMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardStorageMultiplierBps", wireType)
			}
			m.UsageRewardStorageMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardStorageMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardGpuMultiplierBps", wireType)
			}
			m.UsageRewardGpuMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardGpuMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardNetworkMultiplierBps", wireType)
			}
			m.UsageRewardNetworkMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardNetworkMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardSlaOntimeMultiplierBps", wireType)
			}
			m.UsageRewardSlaOntimeMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardSlaOntimeMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardSlaLateMultiplierBps", wireType)
			}
			m.UsageRewardSlaLateMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardSlaLateMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardAckMultiplierBps", wireType)
			}
			m.UsageRewardAckMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardAckMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRewardUnackMultiplierBps", wireType)
			}
			m.UsageRewardUnackMultiplierBps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageRewardUnackMultiplierBps |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 24:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.FiatConversionEnabled = bool(v != 0)
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionMinAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionMinAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionMaxAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionMaxAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionDailyLimit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionDailyLimit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionStableDenom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionStableDenom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionStableSymbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionStableSymbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionStableDecimals", wireType)
			}
			m.FiatConversionStableDecimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FiatConversionStableDecimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionDefaultFiat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionDefaultFiat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionDefaultMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionDefaultMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionMaxSlippage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionMaxSlippage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionRiskScoreThreshold", wireType)
			}
			m.FiatConversionRiskScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FiatConversionRiskScoreThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 35:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatConversionMinComplianceStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatConversionMinComplianceStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TokenSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TokenSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TokenSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Denom", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Denom = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decimals", wireType)
			}
			m.Decimals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Decimals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiatPayoutPreference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FiatPayoutPreference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FiatPayoutPreference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredDex", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreferredDex = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreferredOffRamp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreferredOffRamp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SlippageTolerance = float64(math.Float64frombits(v))
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CryptoToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StableToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiatConversionAuditEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FiatConversionAuditEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FiatConversionAuditEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FiatConversionRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FiatConversionRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FiatConversionRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConversionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvoiceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvoiceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Customer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Customer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequestedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequestedAt", wireType)
			}
			m.RequestedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequestedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CryptoToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableToken", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StableToken.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CryptoAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CryptoAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StableAmount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StableAmount.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatCurrency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatCurrency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FiatAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FiatAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PaymentMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PaymentMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestinationRegion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestinationRegion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 24:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field SlippageTolerance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.SlippageTolerance = float64(math.Float64frombits(v))
		case 25:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DexAdapter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DexAdapter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 26:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapQuoteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapQuoteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 27:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapTxHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapTxHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 28:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SwapStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SwapStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffRampProvider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffRampProvider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffRampQuoteId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffRampQuoteId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffRampId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffRampId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffRampStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffRampStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OffRampReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OffRampReference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 34:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplianceStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ComplianceStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 35:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplianceRiskScore", wireType)
			}
			m.ComplianceRiskScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplianceRiskScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 36:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComplianceCheckedAt", wireType)
			}
			m.ComplianceCheckedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComplianceCheckedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 37:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FailureReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FailureReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 38:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuditTrail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuditTrail = append(m.AuditTrail, FiatConversionAuditEntry{})
			if err := m.AuditTrail[len(m.AuditTrail)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escrow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Escrow == nil {
				m.Escrow = &EscrowAccount{}
			}
			if err := m.Escrow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowsByOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowsByOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowsByOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowsByOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowsByOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowsByOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escrows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Escrows = append(m.Escrows, EscrowAccount{})
			if err := m.Escrows[len(m.Escrows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowsByStateRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowsByStateRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowsByStateRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryEscrowsByStateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryEscrowsByStateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryEscrowsByStateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Escrows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Escrows = append(m.Escrows, EscrowAccount{})
			if err := m.Escrows[len(m.Escrows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySettlementRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySettlementRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySettlementRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySettlementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySettlementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySettlementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settlement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Settlement == nil {
				m.Settlement = &SettlementRecord{}
			}
			if err := m.Settlement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySettlementsByOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySettlementsByOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySettlementsByOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QuerySettlementsByOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuerySettlementsByOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuerySettlementsByOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settlements", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Settlements = append(m.Settlements, SettlementRecord{})
			if err := m.Settlements[len(m.Settlements)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsageRecord == nil {
				m.UsageRecord = &UsageRecord{}
			}
			if err := m.UsageRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageRecordsByOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageRecordsByOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageRecordsByOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageRecordsByOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageRecordsByOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageRecordsByOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRecords", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageRecords = append(m.UsageRecords, UsageRecord{})
			if err := m.UsageRecords[len(m.UsageRecords)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			m.PeriodStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			m.PeriodEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryUsageSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryUsageSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryUsageSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardDistributionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardDistributionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardDistributionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DistributionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DistributionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardDistributionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardDistributionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardDistributionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distribution", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Distribution == nil {
				m.Distribution = &RewardDistribution{}
			}
			if err := m.Distribution.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardsByEpochRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardsByEpochRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardsByEpochRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochNumber", wireType)
			}
			m.EpochNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardsByEpochResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardsByEpochResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardsByEpochResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Distributions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Distributions = append(m.Distributions, RewardDistribution{})
			if err := m.Distributions[len(m.Distributions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryRewardHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryRewardHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryRewardHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, RewardHistoryEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryClaimableRewardsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryClaimableRewardsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryClaimableRewardsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryClaimableRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryClaimableRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryClaimableRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rewards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rewards == nil {
				m.Rewards = &ClaimableRewards{}
			}
			if err := m.Rewards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPayoutRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPayoutRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPayoutRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayoutId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayoutId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPayoutResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPayoutResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPayoutResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payout == nil {
				m.Payout = &PayoutRecord{}
			}
			if err := m.Payout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPayoutsByProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPayoutsByProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPayoutsByProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPayoutsByProviderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPayoutsByProviderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPayoutsByProviderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payouts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payouts = append(m.Payouts, PayoutRecord{})
			if err := m.Payouts[len(m.Payouts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatConversionRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatConversionRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatConversionRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConversionId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ConversionId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatConversionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatConversionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatConversionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conversion", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conversion == nil {
				m.Conversion = &FiatConversionRecord{}
			}
			if err := m.Conversion.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatConversionsByProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatConversionsByProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatConversionsByProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatConversionsByProviderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatConversionsByProviderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatConversionsByProviderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conversions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conversions = append(m.Conversions, FiatConversionRecord{})
			if err := m.Conversions[len(m.Conversions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatPayoutPreferenceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatPayoutPreferenceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatPayoutPreferenceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Provider = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryFiatPayoutPreferenceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryFiatPayoutPreferenceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryFiatPayoutPreferenceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Preference == nil {
				m.Preference = &FiatPayoutPreference{}
			}
			if err := m.Preference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
