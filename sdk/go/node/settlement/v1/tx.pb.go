// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/settlement/v1/tx.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgCreateEscrow creates a new escrow account
type MsgCreateEscrow struct {
	Sender    string       `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	OrderId   string       `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	Amount    []types.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
	ExpiresIn uint64       `protobuf:"varint,4,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
}

func (m *MsgCreateEscrow) Reset()         { *m = MsgCreateEscrow{} }
func (m *MsgCreateEscrow) String() string { return proto.CompactTextString(m) }
func (*MsgCreateEscrow) ProtoMessage()    {}
func (*MsgCreateEscrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{0}
}
func (m *MsgCreateEscrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateEscrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateEscrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateEscrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateEscrow.Merge(m, src)
}
func (m *MsgCreateEscrow) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateEscrow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateEscrow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateEscrow proto.InternalMessageInfo

func (m *MsgCreateEscrow) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgCreateEscrow) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *MsgCreateEscrow) GetAmount() []types.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgCreateEscrow) GetExpiresIn() uint64 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

// MsgCreateEscrowResponse is the response for MsgCreateEscrow
type MsgCreateEscrowResponse struct {
	EscrowId  string `protobuf:"bytes,1,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	CreatedAt int64  `protobuf:"varint,2,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
}

func (m *MsgCreateEscrowResponse) Reset()         { *m = MsgCreateEscrowResponse{} }
func (m *MsgCreateEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgCreateEscrowResponse) ProtoMessage()    {}
func (*MsgCreateEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{1}
}
func (m *MsgCreateEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgCreateEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgCreateEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgCreateEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgCreateEscrowResponse.Merge(m, src)
}
func (m *MsgCreateEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgCreateEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgCreateEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgCreateEscrowResponse proto.InternalMessageInfo

func (m *MsgCreateEscrowResponse) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *MsgCreateEscrowResponse) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

// MsgActivateEscrow activates an escrow when a lease is created
type MsgActivateEscrow struct {
	Sender    string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	EscrowId  string `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	LeaseId   string `protobuf:"bytes,3,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	Recipient string `protobuf:"bytes,4,opt,name=recipient,proto3" json:"recipient,omitempty"`
}

func (m *MsgActivateEscrow) Reset()         { *m = MsgActivateEscrow{} }
func (m *MsgActivateEscrow) String() string { return proto.CompactTextString(m) }
func (*MsgActivateEscrow) ProtoMessage()    {}
func (*MsgActivateEscrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{2}
}
func (m *MsgActivateEscrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateEscrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateEscrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateEscrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateEscrow.Merge(m, src)
}
func (m *MsgActivateEscrow) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateEscrow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateEscrow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateEscrow proto.InternalMessageInfo

func (m *MsgActivateEscrow) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgActivateEscrow) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *MsgActivateEscrow) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *MsgActivateEscrow) GetRecipient() string {
	if m != nil {
		return m.Recipient
	}
	return ""
}

// MsgActivateEscrowResponse is the response for MsgActivateEscrow
type MsgActivateEscrowResponse struct {
	ActivatedAt int64 `protobuf:"varint,1,opt,name=activated_at,json=activatedAt,proto3" json:"activated_at,omitempty"`
}

func (m *MsgActivateEscrowResponse) Reset()         { *m = MsgActivateEscrowResponse{} }
func (m *MsgActivateEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateEscrowResponse) ProtoMessage()    {}
func (*MsgActivateEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{3}
}
func (m *MsgActivateEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateEscrowResponse.Merge(m, src)
}
func (m *MsgActivateEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateEscrowResponse proto.InternalMessageInfo

func (m *MsgActivateEscrowResponse) GetActivatedAt() int64 {
	if m != nil {
		return m.ActivatedAt
	}
	return 0
}

// MsgReleaseEscrow releases escrow funds to the recipient
type MsgReleaseEscrow struct {
	Sender   string       `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	EscrowId string       `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	Amount   []types.Coin `protobuf:"bytes,3,rep,name=amount,proto3" json:"amount"`
	Reason   string       `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgReleaseEscrow) Reset()         { *m = MsgReleaseEscrow{} }
func (m *MsgReleaseEscrow) String() string { return proto.CompactTextString(m) }
func (*MsgReleaseEscrow) ProtoMessage()    {}
func (*MsgReleaseEscrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{4}
}
func (m *MsgReleaseEscrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReleaseEscrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReleaseEscrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReleaseEscrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReleaseEscrow.Merge(m, src)
}
func (m *MsgReleaseEscrow) XXX_Size() int {
	return m.Size()
}
func (m *MsgReleaseEscrow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReleaseEscrow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReleaseEscrow proto.InternalMessageInfo

func (m *MsgReleaseEscrow) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgReleaseEscrow) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *MsgReleaseEscrow) GetAmount() []types.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *MsgReleaseEscrow) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgReleaseEscrowResponse is the response for MsgReleaseEscrow
type MsgReleaseEscrowResponse struct {
	ReleasedAmount string `protobuf:"bytes,1,opt,name=released_amount,json=releasedAmount,proto3" json:"released_amount,omitempty"`
	ReleasedAt     int64  `protobuf:"varint,2,opt,name=released_at,json=releasedAt,proto3" json:"released_at,omitempty"`
}

func (m *MsgReleaseEscrowResponse) Reset()         { *m = MsgReleaseEscrowResponse{} }
func (m *MsgReleaseEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReleaseEscrowResponse) ProtoMessage()    {}
func (*MsgReleaseEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{5}
}
func (m *MsgReleaseEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReleaseEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReleaseEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReleaseEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReleaseEscrowResponse.Merge(m, src)
}
func (m *MsgReleaseEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReleaseEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReleaseEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReleaseEscrowResponse proto.InternalMessageInfo

func (m *MsgReleaseEscrowResponse) GetReleasedAmount() string {
	if m != nil {
		return m.ReleasedAmount
	}
	return ""
}

func (m *MsgReleaseEscrowResponse) GetReleasedAt() int64 {
	if m != nil {
		return m.ReleasedAt
	}
	return 0
}

// MsgRefundEscrow refunds escrow funds to the depositor
type MsgRefundEscrow struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	EscrowId string `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	Reason   string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
}

func (m *MsgRefundEscrow) Reset()         { *m = MsgRefundEscrow{} }
func (m *MsgRefundEscrow) String() string { return proto.CompactTextString(m) }
func (*MsgRefundEscrow) ProtoMessage()    {}
func (*MsgRefundEscrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{6}
}
func (m *MsgRefundEscrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRefundEscrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRefundEscrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRefundEscrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRefundEscrow.Merge(m, src)
}
func (m *MsgRefundEscrow) XXX_Size() int {
	return m.Size()
}
func (m *MsgRefundEscrow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRefundEscrow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRefundEscrow proto.InternalMessageInfo

func (m *MsgRefundEscrow) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgRefundEscrow) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *MsgRefundEscrow) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRefundEscrowResponse is the response for MsgRefundEscrow
type MsgRefundEscrowResponse struct {
	RefundedAmount string `protobuf:"bytes,1,opt,name=refunded_amount,json=refundedAmount,proto3" json:"refunded_amount,omitempty"`
	RefundedAt     int64  `protobuf:"varint,2,opt,name=refunded_at,json=refundedAt,proto3" json:"refunded_at,omitempty"`
}

func (m *MsgRefundEscrowResponse) Reset()         { *m = MsgRefundEscrowResponse{} }
func (m *MsgRefundEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRefundEscrowResponse) ProtoMessage()    {}
func (*MsgRefundEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{7}
}
func (m *MsgRefundEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRefundEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRefundEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRefundEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRefundEscrowResponse.Merge(m, src)
}
func (m *MsgRefundEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRefundEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRefundEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRefundEscrowResponse proto.InternalMessageInfo

func (m *MsgRefundEscrowResponse) GetRefundedAmount() string {
	if m != nil {
		return m.RefundedAmount
	}
	return ""
}

func (m *MsgRefundEscrowResponse) GetRefundedAt() int64 {
	if m != nil {
		return m.RefundedAt
	}
	return 0
}

// MsgDisputeEscrow marks an escrow as disputed
type MsgDisputeEscrow struct {
	Sender   string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	EscrowId string `protobuf:"bytes,2,opt,name=escrow_id,json=escrowId,proto3" json:"escrow_id,omitempty"`
	Reason   string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Evidence string `protobuf:"bytes,4,opt,name=evidence,proto3" json:"evidence,omitempty"`
}

func (m *MsgDisputeEscrow) Reset()         { *m = MsgDisputeEscrow{} }
func (m *MsgDisputeEscrow) String() string { return proto.CompactTextString(m) }
func (*MsgDisputeEscrow) ProtoMessage()    {}
func (*MsgDisputeEscrow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{8}
}
func (m *MsgDisputeEscrow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisputeEscrow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisputeEscrow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisputeEscrow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisputeEscrow.Merge(m, src)
}
func (m *MsgDisputeEscrow) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisputeEscrow) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisputeEscrow.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisputeEscrow proto.InternalMessageInfo

func (m *MsgDisputeEscrow) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgDisputeEscrow) GetEscrowId() string {
	if m != nil {
		return m.EscrowId
	}
	return ""
}

func (m *MsgDisputeEscrow) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgDisputeEscrow) GetEvidence() string {
	if m != nil {
		return m.Evidence
	}
	return ""
}

// MsgDisputeEscrowResponse is the response for MsgDisputeEscrow
type MsgDisputeEscrowResponse struct {
	DisputedAt int64 `protobuf:"varint,1,opt,name=disputed_at,json=disputedAt,proto3" json:"disputed_at,omitempty"`
}

func (m *MsgDisputeEscrowResponse) Reset()         { *m = MsgDisputeEscrowResponse{} }
func (m *MsgDisputeEscrowResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDisputeEscrowResponse) ProtoMessage()    {}
func (*MsgDisputeEscrowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{9}
}
func (m *MsgDisputeEscrowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDisputeEscrowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDisputeEscrowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDisputeEscrowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDisputeEscrowResponse.Merge(m, src)
}
func (m *MsgDisputeEscrowResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDisputeEscrowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDisputeEscrowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDisputeEscrowResponse proto.InternalMessageInfo

func (m *MsgDisputeEscrowResponse) GetDisputedAt() int64 {
	if m != nil {
		return m.DisputedAt
	}
	return 0
}

// MsgSettleOrder settles an order based on usage records
type MsgSettleOrder struct {
	Sender         string   `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	OrderId        string   `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	UsageRecordIds []string `protobuf:"bytes,3,rep,name=usage_record_ids,json=usageRecordIds,proto3" json:"usage_record_ids,omitempty"`
	IsFinal        bool     `protobuf:"varint,4,opt,name=is_final,json=isFinal,proto3" json:"is_final,omitempty"`
}

func (m *MsgSettleOrder) Reset()         { *m = MsgSettleOrder{} }
func (m *MsgSettleOrder) String() string { return proto.CompactTextString(m) }
func (*MsgSettleOrder) ProtoMessage()    {}
func (*MsgSettleOrder) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{10}
}
func (m *MsgSettleOrder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSettleOrder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSettleOrder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSettleOrder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSettleOrder.Merge(m, src)
}
func (m *MsgSettleOrder) XXX_Size() int {
	return m.Size()
}
func (m *MsgSettleOrder) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSettleOrder.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSettleOrder proto.InternalMessageInfo

func (m *MsgSettleOrder) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgSettleOrder) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *MsgSettleOrder) GetUsageRecordIds() []string {
	if m != nil {
		return m.UsageRecordIds
	}
	return nil
}

func (m *MsgSettleOrder) GetIsFinal() bool {
	if m != nil {
		return m.IsFinal
	}
	return false
}

// MsgSettleOrderResponse is the response for MsgSettleOrder
type MsgSettleOrderResponse struct {
	SettlementId  string `protobuf:"bytes,1,opt,name=settlement_id,json=settlementId,proto3" json:"settlement_id,omitempty"`
	TotalAmount   string `protobuf:"bytes,2,opt,name=total_amount,json=totalAmount,proto3" json:"total_amount,omitempty"`
	ProviderShare string `protobuf:"bytes,3,opt,name=provider_share,json=providerShare,proto3" json:"provider_share,omitempty"`
	PlatformFee   string `protobuf:"bytes,4,opt,name=platform_fee,json=platformFee,proto3" json:"platform_fee,omitempty"`
	SettledAt     int64  `protobuf:"varint,5,opt,name=settled_at,json=settledAt,proto3" json:"settled_at,omitempty"`
}

func (m *MsgSettleOrderResponse) Reset()         { *m = MsgSettleOrderResponse{} }
func (m *MsgSettleOrderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSettleOrderResponse) ProtoMessage()    {}
func (*MsgSettleOrderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{11}
}
func (m *MsgSettleOrderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSettleOrderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSettleOrderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSettleOrderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSettleOrderResponse.Merge(m, src)
}
func (m *MsgSettleOrderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSettleOrderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSettleOrderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSettleOrderResponse proto.InternalMessageInfo

func (m *MsgSettleOrderResponse) GetSettlementId() string {
	if m != nil {
		return m.SettlementId
	}
	return ""
}

func (m *MsgSettleOrderResponse) GetTotalAmount() string {
	if m != nil {
		return m.TotalAmount
	}
	return ""
}

func (m *MsgSettleOrderResponse) GetProviderShare() string {
	if m != nil {
		return m.ProviderShare
	}
	return ""
}

func (m *MsgSettleOrderResponse) GetPlatformFee() string {
	if m != nil {
		return m.PlatformFee
	}
	return ""
}

func (m *MsgSettleOrderResponse) GetSettledAt() int64 {
	if m != nil {
		return m.SettledAt
	}
	return 0
}

// MsgRecordUsage records usage from a provider
type MsgRecordUsage struct {
	Sender      string        `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	OrderId     string        `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id,omitempty"`
	LeaseId     string        `protobuf:"bytes,3,opt,name=lease_id,json=leaseId,proto3" json:"lease_id,omitempty"`
	UsageUnits  uint64        `protobuf:"varint,4,opt,name=usage_units,json=usageUnits,proto3" json:"usage_units,omitempty"`
	UsageType   string        `protobuf:"bytes,5,opt,name=usage_type,json=usageType,proto3" json:"usage_type,omitempty"`
	PeriodStart int64         `protobuf:"varint,6,opt,name=period_start,json=periodStart,proto3" json:"period_start,omitempty"`
	PeriodEnd   int64         `protobuf:"varint,7,opt,name=period_end,json=periodEnd,proto3" json:"period_end,omitempty"`
	UnitPrice   types.DecCoin `protobuf:"bytes,8,opt,name=unit_price,json=unitPrice,proto3" json:"unit_price"`
	Signature   []byte        `protobuf:"bytes,9,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgRecordUsage) Reset()         { *m = MsgRecordUsage{} }
func (m *MsgRecordUsage) String() string { return proto.CompactTextString(m) }
func (*MsgRecordUsage) ProtoMessage()    {}
func (*MsgRecordUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{12}
}
func (m *MsgRecordUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecordUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRecordUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRecordUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecordUsage.Merge(m, src)
}
func (m *MsgRecordUsage) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecordUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecordUsage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecordUsage proto.InternalMessageInfo

func (m *MsgRecordUsage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgRecordUsage) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *MsgRecordUsage) GetLeaseId() string {
	if m != nil {
		return m.LeaseId
	}
	return ""
}

func (m *MsgRecordUsage) GetUsageUnits() uint64 {
	if m != nil {
		return m.UsageUnits
	}
	return 0
}

func (m *MsgRecordUsage) GetUsageType() string {
	if m != nil {
		return m.UsageType
	}
	return ""
}

func (m *MsgRecordUsage) GetPeriodStart() int64 {
	if m != nil {
		return m.PeriodStart
	}
	return 0
}

func (m *MsgRecordUsage) GetPeriodEnd() int64 {
	if m != nil {
		return m.PeriodEnd
	}
	return 0
}

func (m *MsgRecordUsage) GetUnitPrice() types.DecCoin {
	if m != nil {
		return m.UnitPrice
	}
	return types.DecCoin{}
}

func (m *MsgRecordUsage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgRecordUsageResponse is the response for MsgRecordUsage
type MsgRecordUsageResponse struct {
	UsageId    string `protobuf:"bytes,1,opt,name=usage_id,json=usageId,proto3" json:"usage_id,omitempty"`
	TotalCost  string `protobuf:"bytes,2,opt,name=total_cost,json=totalCost,proto3" json:"total_cost,omitempty"`
	RecordedAt int64  `protobuf:"varint,3,opt,name=recorded_at,json=recordedAt,proto3" json:"recorded_at,omitempty"`
}

func (m *MsgRecordUsageResponse) Reset()         { *m = MsgRecordUsageResponse{} }
func (m *MsgRecordUsageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRecordUsageResponse) ProtoMessage()    {}
func (*MsgRecordUsageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{13}
}
func (m *MsgRecordUsageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRecordUsageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRecordUsageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRecordUsageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRecordUsageResponse.Merge(m, src)
}
func (m *MsgRecordUsageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRecordUsageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRecordUsageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRecordUsageResponse proto.InternalMessageInfo

func (m *MsgRecordUsageResponse) GetUsageId() string {
	if m != nil {
		return m.UsageId
	}
	return ""
}

func (m *MsgRecordUsageResponse) GetTotalCost() string {
	if m != nil {
		return m.TotalCost
	}
	return ""
}

func (m *MsgRecordUsageResponse) GetRecordedAt() int64 {
	if m != nil {
		return m.RecordedAt
	}
	return 0
}

// MsgAcknowledgeUsage acknowledges a usage record
type MsgAcknowledgeUsage struct {
	Sender    string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	UsageId   string `protobuf:"bytes,2,opt,name=usage_id,json=usageId,proto3" json:"usage_id,omitempty"`
	Signature []byte `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *MsgAcknowledgeUsage) Reset()         { *m = MsgAcknowledgeUsage{} }
func (m *MsgAcknowledgeUsage) String() string { return proto.CompactTextString(m) }
func (*MsgAcknowledgeUsage) ProtoMessage()    {}
func (*MsgAcknowledgeUsage) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{14}
}
func (m *MsgAcknowledgeUsage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAcknowledgeUsage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAcknowledgeUsage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAcknowledgeUsage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAcknowledgeUsage.Merge(m, src)
}
func (m *MsgAcknowledgeUsage) XXX_Size() int {
	return m.Size()
}
func (m *MsgAcknowledgeUsage) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAcknowledgeUsage.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAcknowledgeUsage proto.InternalMessageInfo

func (m *MsgAcknowledgeUsage) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgAcknowledgeUsage) GetUsageId() string {
	if m != nil {
		return m.UsageId
	}
	return ""
}

func (m *MsgAcknowledgeUsage) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

// MsgAcknowledgeUsageResponse is the response for MsgAcknowledgeUsage
type MsgAcknowledgeUsageResponse struct {
	AcknowledgedAt int64 `protobuf:"varint,1,opt,name=acknowledged_at,json=acknowledgedAt,proto3" json:"acknowledged_at,omitempty"`
}

func (m *MsgAcknowledgeUsageResponse) Reset()         { *m = MsgAcknowledgeUsageResponse{} }
func (m *MsgAcknowledgeUsageResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAcknowledgeUsageResponse) ProtoMessage()    {}
func (*MsgAcknowledgeUsageResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{15}
}
func (m *MsgAcknowledgeUsageResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAcknowledgeUsageResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAcknowledgeUsageResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAcknowledgeUsageResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAcknowledgeUsageResponse.Merge(m, src)
}
func (m *MsgAcknowledgeUsageResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAcknowledgeUsageResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAcknowledgeUsageResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAcknowledgeUsageResponse proto.InternalMessageInfo

func (m *MsgAcknowledgeUsageResponse) GetAcknowledgedAt() int64 {
	if m != nil {
		return m.AcknowledgedAt
	}
	return 0
}

// MsgClaimRewards claims accumulated rewards
type MsgClaimRewards struct {
	Sender string `protobuf:"bytes,1,opt,name=sender,proto3" json:"sender,omitempty"`
	Source string `protobuf:"bytes,2,opt,name=source,proto3" json:"source,omitempty"`
}

func (m *MsgClaimRewards) Reset()         { *m = MsgClaimRewards{} }
func (m *MsgClaimRewards) String() string { return proto.CompactTextString(m) }
func (*MsgClaimRewards) ProtoMessage()    {}
func (*MsgClaimRewards) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{16}
}
func (m *MsgClaimRewards) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimRewards) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimRewards.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimRewards) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimRewards.Merge(m, src)
}
func (m *MsgClaimRewards) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimRewards) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimRewards.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimRewards proto.InternalMessageInfo

func (m *MsgClaimRewards) GetSender() string {
	if m != nil {
		return m.Sender
	}
	return ""
}

func (m *MsgClaimRewards) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

// MsgClaimRewardsResponse is the response for MsgClaimRewards
type MsgClaimRewardsResponse struct {
	ClaimedAmount string `protobuf:"bytes,1,opt,name=claimed_amount,json=claimedAmount,proto3" json:"claimed_amount,omitempty"`
	ClaimedAt     int64  `protobuf:"varint,2,opt,name=claimed_at,json=claimedAt,proto3" json:"claimed_at,omitempty"`
}

func (m *MsgClaimRewardsResponse) Reset()         { *m = MsgClaimRewardsResponse{} }
func (m *MsgClaimRewardsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimRewardsResponse) ProtoMessage()    {}
func (*MsgClaimRewardsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d6906bdc9b679707, []int{17}
}
func (m *MsgClaimRewardsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimRewardsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimRewardsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimRewardsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimRewardsResponse.Merge(m, src)
}
func (m *MsgClaimRewardsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimRewardsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimRewardsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimRewardsResponse proto.InternalMessageInfo

func (m *MsgClaimRewardsResponse) GetClaimedAmount() string {
	if m != nil {
		return m.ClaimedAmount
	}
	return ""
}

func (m *MsgClaimRewardsResponse) GetClaimedAt() int64 {
	if m != nil {
		return m.ClaimedAt
	}
	return 0
}

func init() {
	proto.RegisterType((*MsgCreateEscrow)(nil), "virtengine.settlement.v1.MsgCreateEscrow")
	proto.RegisterType((*MsgCreateEscrowResponse)(nil), "virtengine.settlement.v1.MsgCreateEscrowResponse")
	proto.RegisterType((*MsgActivateEscrow)(nil), "virtengine.settlement.v1.MsgActivateEscrow")
	proto.RegisterType((*MsgActivateEscrowResponse)(nil), "virtengine.settlement.v1.MsgActivateEscrowResponse")
	proto.RegisterType((*MsgReleaseEscrow)(nil), "virtengine.settlement.v1.MsgReleaseEscrow")
	proto.RegisterType((*MsgReleaseEscrowResponse)(nil), "virtengine.settlement.v1.MsgReleaseEscrowResponse")
	proto.RegisterType((*MsgRefundEscrow)(nil), "virtengine.settlement.v1.MsgRefundEscrow")
	proto.RegisterType((*MsgRefundEscrowResponse)(nil), "virtengine.settlement.v1.MsgRefundEscrowResponse")
	proto.RegisterType((*MsgDisputeEscrow)(nil), "virtengine.settlement.v1.MsgDisputeEscrow")
	proto.RegisterType((*MsgDisputeEscrowResponse)(nil), "virtengine.settlement.v1.MsgDisputeEscrowResponse")
	proto.RegisterType((*MsgSettleOrder)(nil), "virtengine.settlement.v1.MsgSettleOrder")
	proto.RegisterType((*MsgSettleOrderResponse)(nil), "virtengine.settlement.v1.MsgSettleOrderResponse")
	proto.RegisterType((*MsgRecordUsage)(nil), "virtengine.settlement.v1.MsgRecordUsage")
	proto.RegisterType((*MsgRecordUsageResponse)(nil), "virtengine.settlement.v1.MsgRecordUsageResponse")
	proto.RegisterType((*MsgAcknowledgeUsage)(nil), "virtengine.settlement.v1.MsgAcknowledgeUsage")
	proto.RegisterType((*MsgAcknowledgeUsageResponse)(nil), "virtengine.settlement.v1.MsgAcknowledgeUsageResponse")
	proto.RegisterType((*MsgClaimRewards)(nil), "virtengine.settlement.v1.MsgClaimRewards")
	proto.RegisterType((*MsgClaimRewardsResponse)(nil), "virtengine.settlement.v1.MsgClaimRewardsResponse")
}

func init() { proto.RegisterFile("virtengine/settlement/v1/tx.proto", fileDescriptor_d6906bdc9b679707) }

var fileDescriptor_d6906bdc9b679707 = []byte{
	// 1273 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x3f, 0x6f, 0x1b, 0x37,
	0x14, 0xf7, 0x45, 0x89, 0xac, 0xa3, 0x6c, 0x25, 0x51, 0x83, 0x44, 0x52, 0x52, 0xd9, 0xb9, 0x22,
	0xa8, 0xe2, 0xc2, 0x3a, 0xdb, 0x41, 0x5b, 0xc0, 0x05, 0x0a, 0xc8, 0x4e, 0x0c, 0x68, 0x30, 0x5a,
	0x9c, 0xe3, 0xa5, 0xcb, 0xe1, 0x7c, 0xa4, 0x2f, 0x44, 0xa4, 0xa3, 0x40, 0x52, 0xb2, 0xb3, 0x15,
	0x1d, 0xd3, 0xa5, 0x1f, 0xa1, 0x63, 0x47, 0x0f, 0xf9, 0x0c, 0x45, 0xba, 0xa5, 0x9d, 0x3a, 0x15,
	0x85, 0x0d, 0xd4, 0xfd, 0x10, 0x1d, 0x0a, 0xfe, 0xd1, 0xdd, 0x51, 0x51, 0x24, 0xe5, 0x8f, 0x17,
	0xc3, 0xfc, 0xf1, 0x47, 0xf2, 0xbd, 0x1f, 0x1f, 0xdf, 0x7b, 0x3a, 0x70, 0x77, 0x80, 0x29, 0x47,
	0x71, 0x84, 0x63, 0xe4, 0x32, 0xc4, 0x79, 0x07, 0x75, 0x51, 0xcc, 0xdd, 0xc1, 0xba, 0xcb, 0x8f,
	0x9b, 0x3d, 0x4a, 0x38, 0x29, 0x57, 0x52, 0x4a, 0x33, 0xa5, 0x34, 0x07, 0xeb, 0xb5, 0x1b, 0x11,
	0x89, 0x88, 0x24, 0xb9, 0xe2, 0x3f, 0xc5, 0xaf, 0x55, 0x43, 0xc2, 0xba, 0x84, 0xf9, 0x6a, 0x42,
	0x0d, 0xf4, 0xd4, 0x2d, 0x35, 0x72, 0xbb, 0x2c, 0x12, 0x47, 0x74, 0x59, 0xa4, 0x27, 0xae, 0x07,
	0x5d, 0x1c, 0x13, 0x57, 0xfe, 0xd5, 0x50, 0x5d, 0x73, 0x0f, 0x02, 0x86, 0xdc, 0xc1, 0xfa, 0x01,
	0xe2, 0xc1, 0xba, 0x1b, 0x12, 0x1c, 0xab, 0x79, 0xe7, 0x1f, 0x0b, 0x5c, 0xdd, 0x65, 0xd1, 0x36,
	0x45, 0x01, 0x47, 0x8f, 0x58, 0x48, 0xc9, 0x51, 0x79, 0x0d, 0xe4, 0x19, 0x8a, 0x21, 0xa2, 0x15,
	0x6b, 0xd9, 0x6a, 0xd8, 0x5b, 0x95, 0x3f, 0x5e, 0xac, 0xde, 0xd0, 0x16, 0xb4, 0x20, 0xa4, 0x88,
	0xb1, 0x3d, 0x4e, 0x71, 0x1c, 0x79, 0x9a, 0x57, 0xae, 0x82, 0x02, 0xa1, 0x10, 0x51, 0x1f, 0xc3,
	0xca, 0x25, 0xb1, 0xc6, 0x9b, 0x97, 0xe3, 0x36, 0x2c, 0x7f, 0x09, 0xf2, 0x41, 0x97, 0xf4, 0x63,
	0x5e, 0xc9, 0x2d, 0xe7, 0x1a, 0xc5, 0x8d, 0x6a, 0x53, 0xef, 0x24, 0x2c, 0x6a, 0x6a, 0x8b, 0x9a,
	0xdb, 0x04, 0xc7, 0x5b, 0x97, 0x5f, 0xfe, 0xb5, 0x34, 0xe7, 0x69, 0x7a, 0xf9, 0x63, 0x00, 0xd0,
	0x71, 0x0f, 0x53, 0xc4, 0x7c, 0x1c, 0x57, 0x2e, 0x2f, 0x5b, 0x8d, 0xcb, 0x9e, 0xad, 0x91, 0x76,
	0xbc, 0xd9, 0xfc, 0xf7, 0xe7, 0xa5, 0xb9, 0x1f, 0xce, 0x4f, 0x56, 0xb4, 0x0d, 0xcf, 0xcf, 0x4f,
	0x56, 0x6a, 0x19, 0xed, 0x47, 0x9c, 0x72, 0xf6, 0xc1, 0xad, 0x11, 0xc8, 0x43, 0xac, 0x47, 0x62,
	0x86, 0xca, 0xb7, 0x81, 0x8d, 0x24, 0x22, 0xcc, 0x97, 0x2e, 0x7b, 0x05, 0x05, 0xb4, 0xa1, 0x30,
	0x23, 0x94, 0x8b, 0xa0, 0x1f, 0x70, 0xe9, 0x5c, 0xce, 0xb3, 0x35, 0xd2, 0xe2, 0xce, 0xb9, 0x05,
	0xae, 0xef, 0xb2, 0xa8, 0x15, 0x72, 0x3c, 0x78, 0x1f, 0x05, 0x0d, 0x1b, 0x2e, 0x8d, 0xd8, 0x50,
	0x05, 0x85, 0x0e, 0x0a, 0x18, 0x12, 0x73, 0x39, 0x25, 0xaf, 0x1c, 0xb7, 0x61, 0xf9, 0x0b, 0x60,
	0x53, 0x14, 0xe2, 0x1e, 0x46, 0x31, 0x97, 0x22, 0x4d, 0x3a, 0x2c, 0xa5, 0x6e, 0xae, 0x8d, 0x91,
	0xef, 0x8e, 0x29, 0x9f, 0xe9, 0x93, 0xf3, 0x35, 0xa8, 0xbe, 0x06, 0x26, 0x12, 0xde, 0x05, 0x0b,
	0x81, 0x9e, 0x91, 0x3a, 0x59, 0x52, 0xa7, 0x62, 0x82, 0xb5, 0xb8, 0x73, 0x66, 0x81, 0x6b, 0xbb,
	0x2c, 0xf2, 0x90, 0x34, 0xfd, 0x62, 0x84, 0x7a, 0xe7, 0x60, 0xbb, 0x09, 0xf2, 0x14, 0x05, 0x8c,
	0xa8, 0x40, 0xb3, 0x3d, 0x3d, 0xda, 0x74, 0xc7, 0xc8, 0x74, 0xdb, 0x94, 0xc9, 0x70, 0xc8, 0x81,
	0xa0, 0x32, 0x8a, 0x25, 0x22, 0x7d, 0x0a, 0xae, 0x52, 0x35, 0x01, 0x7d, 0x6d, 0xa6, 0x8a, 0xb6,
	0xd2, 0x10, 0x6e, 0x29, 0x6b, 0x96, 0x40, 0x31, 0x25, 0x0e, 0x83, 0x0e, 0x24, 0x24, 0xee, 0xfc,
	0xa2, 0x5e, 0xad, 0x87, 0x0e, 0xfb, 0x31, 0xbc, 0x18, 0x29, 0x53, 0x45, 0x72, 0x86, 0x22, 0x33,
	0xbc, 0xbb, 0xac, 0x59, 0x4e, 0x28, 0xdf, 0x5d, 0x16, 0x32, 0xf5, 0x10, 0xf8, 0x18, 0x3d, 0x14,
	0x9c, 0xd5, 0x63, 0x48, 0xcc, 0xe8, 0xa1, 0x49, 0xdc, 0xf9, 0x55, 0xc5, 0xd6, 0x43, 0xcc, 0x7a,
	0xfd, 0x8b, 0x7a, 0x84, 0x6f, 0x10, 0xa4, 0x5c, 0x03, 0x05, 0x34, 0xc0, 0x10, 0xc5, 0x21, 0xd2,
	0xc1, 0x93, 0x8c, 0x67, 0x09, 0x1f, 0xc3, 0x66, 0xe7, 0x2b, 0x19, 0x3e, 0x06, 0x96, 0xc8, 0xb5,
	0x04, 0x8a, 0x50, 0x4d, 0x64, 0x9e, 0x18, 0x18, 0x42, 0x2d, 0xee, 0xfc, 0x6e, 0x81, 0xd2, 0x2e,
	0x8b, 0xf6, 0xe4, 0xfe, 0xdf, 0x88, 0xfc, 0xfb, 0x61, 0x53, 0x79, 0x03, 0x5c, 0xeb, 0xb3, 0x20,
	0x42, 0x3e, 0x45, 0x21, 0xa1, 0xd0, 0xc7, 0x90, 0xc9, 0x77, 0x66, 0x7b, 0x25, 0x89, 0x7b, 0x12,
	0x6e, 0x43, 0x26, 0x36, 0xc1, 0xcc, 0x3f, 0xc4, 0x71, 0xd0, 0x91, 0x9a, 0x14, 0xbc, 0x79, 0xcc,
	0x76, 0xc4, 0x70, 0x73, 0x75, 0x8c, 0x24, 0x55, 0x53, 0x92, 0x8c, 0x03, 0xce, 0x6f, 0x16, 0xb8,
	0x69, 0x42, 0x89, 0x1e, 0x9f, 0x80, 0xc5, 0x74, 0x5d, 0x9a, 0xba, 0x17, 0x52, 0xb0, 0x0d, 0x45,
	0x62, 0xe2, 0x84, 0x07, 0x9d, 0x61, 0x80, 0x29, 0x97, 0x8a, 0x12, 0xd3, 0xd1, 0x75, 0x0f, 0x94,
	0x7a, 0x94, 0x88, 0x2b, 0xa3, 0x3e, 0x7b, 0x12, 0x50, 0xa4, 0x2f, 0x78, 0x71, 0x88, 0xee, 0x09,
	0x50, 0xec, 0xd4, 0xeb, 0x04, 0xfc, 0x90, 0xd0, 0xae, 0x7f, 0x88, 0x86, 0x77, 0x5d, 0x1c, 0x62,
	0x3b, 0x08, 0x89, 0x5a, 0xa1, 0x0e, 0x97, 0x17, 0x74, 0x45, 0xd5, 0x0a, 0x8d, 0xb4, 0xb8, 0xf3,
	0x3c, 0x27, 0xef, 0x47, 0xc9, 0xb4, 0x2f, 0x14, 0xfb, 0xb0, 0xf7, 0x33, 0xa1, 0x4c, 0x2c, 0x81,
	0xa2, 0xba, 0xba, 0x7e, 0x8c, 0x39, 0xd3, 0xd5, 0x14, 0x48, 0x68, 0x5f, 0x20, 0xc2, 0x74, 0x45,
	0xe0, 0xcf, 0x7a, 0x48, 0x9a, 0x6e, 0x7b, 0xb6, 0x44, 0x1e, 0x3f, 0xeb, 0x29, 0xe7, 0x11, 0xc5,
	0x04, 0xfa, 0x8c, 0x07, 0x94, 0x57, 0xf2, 0x2a, 0xbf, 0x2b, 0x6c, 0x4f, 0x40, 0x62, 0x07, 0x4d,
	0x41, 0x31, 0xac, 0xcc, 0x2b, 0xe7, 0x15, 0xf2, 0x28, 0x86, 0xe5, 0x16, 0x00, 0xe2, 0x6c, 0xbf,
	0x47, 0x71, 0x88, 0x2a, 0x85, 0x65, 0xab, 0x51, 0xdc, 0xb8, 0x33, 0x36, 0x3d, 0x3f, 0x44, 0x61,
	0x26, 0x43, 0xdb, 0x62, 0xd5, 0xb7, 0x62, 0x51, 0xf9, 0x0e, 0xb0, 0x19, 0x8e, 0xe2, 0x80, 0xf7,
	0x29, 0xaa, 0xd8, 0xcb, 0x56, 0x63, 0xc1, 0x4b, 0x81, 0x59, 0x02, 0x2b, 0xa3, 0xbc, 0xc3, 0x64,
	0x5c, 0x65, 0x90, 0x24, 0xae, 0xaa, 0xa0, 0xa0, 0xa4, 0x48, 0x42, 0x6a, 0x5e, 0x8e, 0x55, 0x33,
	0xa0, 0xa2, 0x29, 0x24, 0x6c, 0x18, 0x4b, 0xb6, 0x44, 0xb6, 0x09, 0xd3, 0x79, 0x4a, 0x6c, 0xa8,
	0x02, 0x20, 0x37, 0xcc, 0x53, 0x0a, 0x6a, 0x71, 0xe7, 0x85, 0x05, 0x3e, 0x92, 0x45, 0xf4, 0x69,
	0x4c, 0x8e, 0x3a, 0x08, 0x46, 0xe8, 0x3d, 0xc2, 0x20, 0x31, 0xf2, 0x92, 0x69, 0xa4, 0x21, 0x53,
	0x6e, 0x54, 0xa6, 0x8d, 0x31, 0x32, 0xd5, 0x47, 0x0b, 0xbf, 0x69, 0x9e, 0xb3, 0x03, 0x6e, 0x8f,
	0x81, 0xb3, 0x79, 0x3c, 0x48, 0xe7, 0x32, 0xc9, 0xa9, 0x94, 0x85, 0x5b, 0xdc, 0xf9, 0x51, 0x37,
	0x9b, 0x9d, 0x00, 0x77, 0x3d, 0x74, 0x14, 0x50, 0xc8, 0xde, 0xc1, 0xf5, 0x9b, 0x20, 0xcf, 0x48,
	0x9f, 0x86, 0x48, 0x3b, 0xae, 0x47, 0x33, 0x75, 0x84, 0x99, 0x93, 0x1d, 0x5f, 0x75, 0x84, 0x19,
	0x28, 0xf1, 0xe8, 0x1e, 0x28, 0x85, 0x02, 0x1f, 0x2d, 0x4c, 0x8b, 0x1a, 0x6d, 0x25, 0x2d, 0x6a,
	0x42, 0x4b, 0x7b, 0x43, 0x4d, 0xe1, 0x1b, 0xff, 0xcd, 0x83, 0xdc, 0x2e, 0x8b, 0xca, 0x1d, 0xb0,
	0x60, 0xf4, 0xd7, 0xf7, 0x9b, 0x6f, 0xfa, 0x2d, 0xd0, 0x1c, 0x69, 0x51, 0x6b, 0xeb, 0x33, 0x53,
	0x13, 0xdb, 0x29, 0x28, 0x8d, 0x74, 0xa3, 0x9f, 0x4d, 0xdc, 0xc4, 0x24, 0xd7, 0x1e, 0xbc, 0x05,
	0x39, 0x39, 0x93, 0x80, 0x45, 0xb3, 0xaf, 0x5b, 0x99, 0xb8, 0x8b, 0xc1, 0xad, 0x6d, 0xcc, 0xce,
	0x4d, 0x0e, 0xec, 0x80, 0x05, 0xa3, 0xf9, 0xb9, 0x3f, 0x65, 0x8f, 0x94, 0x3a, 0x45, 0xd2, 0xb1,
	0x8d, 0x0a, 0x01, 0x8b, 0x66, 0x6b, 0x31, 0xd9, 0x3d, 0x83, 0x3b, 0xc5, 0xbd, 0xf1, 0xa5, 0x1e,
	0x83, 0x62, 0xb6, 0x8a, 0x37, 0x26, 0x6e, 0x91, 0x61, 0xd6, 0xd6, 0x66, 0x65, 0x66, 0x8f, 0xca,
	0x16, 0xa4, 0xc6, 0x14, 0x75, 0x12, 0xe6, 0x94, 0xa3, 0xc6, 0x25, 0xd6, 0x63, 0x70, 0xed, 0xb5,
	0xcc, 0xb7, 0x3a, 0x25, 0xdc, 0x4c, 0x7a, 0xed, 0xf3, 0xb7, 0xa2, 0x67, 0xc3, 0xc5, 0x48, 0x3a,
	0x53, 0x5e, 0x60, 0x86, 0x3a, 0xed, 0x05, 0x8e, 0xc9, 0x1e, 0xb5, 0x2b, 0xdf, 0x9f, 0x9f, 0xac,
	0x58, 0x5b, 0x8f, 0x5f, 0x9e, 0xd6, 0xad, 0x57, 0xa7, 0x75, 0xeb, 0xef, 0xd3, 0xba, 0xf5, 0xd3,
	0x59, 0x7d, 0xee, 0xd5, 0x59, 0x7d, 0xee, 0xcf, 0xb3, 0xfa, 0xdc, 0x77, 0x9b, 0x11, 0xe6, 0x4f,
	0xfa, 0x07, 0xcd, 0x90, 0x74, 0xdd, 0xcc, 0x97, 0x83, 0xec, 0x47, 0x04, 0xf8, 0xd4, 0x8d, 0x88,
	0x1b, 0x13, 0x38, 0xf2, 0x41, 0xe1, 0x20, 0x2f, 0x7f, 0xb7, 0x3f, 0xf8, 0x3f, 0x00, 0x00, 0xff,
	0xff, 0x29, 0x27, 0x33, 0x59, 0x73, 0x10, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// CreateEscrow creates a new escrow account
	CreateEscrow(ctx context.Context, in *MsgCreateEscrow, opts ...grpc.CallOption) (*MsgCreateEscrowResponse, error)
	// ActivateEscrow activates an escrow when a lease is created
	ActivateEscrow(ctx context.Context, in *MsgActivateEscrow, opts ...grpc.CallOption) (*MsgActivateEscrowResponse, error)
	// ReleaseEscrow releases escrow funds to the recipient
	ReleaseEscrow(ctx context.Context, in *MsgReleaseEscrow, opts ...grpc.CallOption) (*MsgReleaseEscrowResponse, error)
	// RefundEscrow refunds escrow funds to the depositor
	RefundEscrow(ctx context.Context, in *MsgRefundEscrow, opts ...grpc.CallOption) (*MsgRefundEscrowResponse, error)
	// DisputeEscrow marks an escrow as disputed
	DisputeEscrow(ctx context.Context, in *MsgDisputeEscrow, opts ...grpc.CallOption) (*MsgDisputeEscrowResponse, error)
	// SettleOrder settles an order based on usage records
	SettleOrder(ctx context.Context, in *MsgSettleOrder, opts ...grpc.CallOption) (*MsgSettleOrderResponse, error)
	// RecordUsage records usage from a provider
	RecordUsage(ctx context.Context, in *MsgRecordUsage, opts ...grpc.CallOption) (*MsgRecordUsageResponse, error)
	// AcknowledgeUsage acknowledges a usage record
	AcknowledgeUsage(ctx context.Context, in *MsgAcknowledgeUsage, opts ...grpc.CallOption) (*MsgAcknowledgeUsageResponse, error)
	// ClaimRewards claims accumulated rewards
	ClaimRewards(ctx context.Context, in *MsgClaimRewards, opts ...grpc.CallOption) (*MsgClaimRewardsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) CreateEscrow(ctx context.Context, in *MsgCreateEscrow, opts ...grpc.CallOption) (*MsgCreateEscrowResponse, error) {
	out := new(MsgCreateEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/CreateEscrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ActivateEscrow(ctx context.Context, in *MsgActivateEscrow, opts ...grpc.CallOption) (*MsgActivateEscrowResponse, error) {
	out := new(MsgActivateEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/ActivateEscrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ReleaseEscrow(ctx context.Context, in *MsgReleaseEscrow, opts ...grpc.CallOption) (*MsgReleaseEscrowResponse, error) {
	out := new(MsgReleaseEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/ReleaseEscrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RefundEscrow(ctx context.Context, in *MsgRefundEscrow, opts ...grpc.CallOption) (*MsgRefundEscrowResponse, error) {
	out := new(MsgRefundEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/RefundEscrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) DisputeEscrow(ctx context.Context, in *MsgDisputeEscrow, opts ...grpc.CallOption) (*MsgDisputeEscrowResponse, error) {
	out := new(MsgDisputeEscrowResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/DisputeEscrow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) SettleOrder(ctx context.Context, in *MsgSettleOrder, opts ...grpc.CallOption) (*MsgSettleOrderResponse, error) {
	out := new(MsgSettleOrderResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/SettleOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RecordUsage(ctx context.Context, in *MsgRecordUsage, opts ...grpc.CallOption) (*MsgRecordUsageResponse, error) {
	out := new(MsgRecordUsageResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/RecordUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) AcknowledgeUsage(ctx context.Context, in *MsgAcknowledgeUsage, opts ...grpc.CallOption) (*MsgAcknowledgeUsageResponse, error) {
	out := new(MsgAcknowledgeUsageResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/AcknowledgeUsage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ClaimRewards(ctx context.Context, in *MsgClaimRewards, opts ...grpc.CallOption) (*MsgClaimRewardsResponse, error) {
	out := new(MsgClaimRewardsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.settlement.v1.Msg/ClaimRewards", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// CreateEscrow creates a new escrow account
	CreateEscrow(context.Context, *MsgCreateEscrow) (*MsgCreateEscrowResponse, error)
	// ActivateEscrow activates an escrow when a lease is created
	ActivateEscrow(context.Context, *MsgActivateEscrow) (*MsgActivateEscrowResponse, error)
	// ReleaseEscrow releases escrow funds to the recipient
	ReleaseEscrow(context.Context, *MsgReleaseEscrow) (*MsgReleaseEscrowResponse, error)
	// RefundEscrow refunds escrow funds to the depositor
	RefundEscrow(context.Context, *MsgRefundEscrow) (*MsgRefundEscrowResponse, error)
	// DisputeEscrow marks an escrow as disputed
	DisputeEscrow(context.Context, *MsgDisputeEscrow) (*MsgDisputeEscrowResponse, error)
	// SettleOrder settles an order based on usage records
	SettleOrder(context.Context, *MsgSettleOrder) (*MsgSettleOrderResponse, error)
	// RecordUsage records usage from a provider
	RecordUsage(context.Context, *MsgRecordUsage) (*MsgRecordUsageResponse, error)
	// AcknowledgeUsage acknowledges a usage record
	AcknowledgeUsage(context.Context, *MsgAcknowledgeUsage) (*MsgAcknowledgeUsageResponse, error)
	// ClaimRewards claims accumulated rewards
	ClaimRewards(context.Context, *MsgClaimRewards) (*MsgClaimRewardsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) CreateEscrow(ctx context.Context, req *MsgCreateEscrow) (*MsgCreateEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateEscrow not implemented")
}
func (*UnimplementedMsgServer) ActivateEscrow(ctx context.Context, req *MsgActivateEscrow) (*MsgActivateEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivateEscrow not implemented")
}
func (*UnimplementedMsgServer) ReleaseEscrow(ctx context.Context, req *MsgReleaseEscrow) (*MsgReleaseEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseEscrow not implemented")
}
func (*UnimplementedMsgServer) RefundEscrow(ctx context.Context, req *MsgRefundEscrow) (*MsgRefundEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefundEscrow not implemented")
}
func (*UnimplementedMsgServer) DisputeEscrow(ctx context.Context, req *MsgDisputeEscrow) (*MsgDisputeEscrowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisputeEscrow not implemented")
}
func (*UnimplementedMsgServer) SettleOrder(ctx context.Context, req *MsgSettleOrder) (*MsgSettleOrderResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SettleOrder not implemented")
}
func (*UnimplementedMsgServer) RecordUsage(ctx context.Context, req *MsgRecordUsage) (*MsgRecordUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordUsage not implemented")
}
func (*UnimplementedMsgServer) AcknowledgeUsage(ctx context.Context, req *MsgAcknowledgeUsage) (*MsgAcknowledgeUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AcknowledgeUsage not implemented")
}
func (*UnimplementedMsgServer) ClaimRewards(ctx context.Context, req *MsgClaimRewards) (*MsgClaimRewardsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClaimRewards not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_CreateEscrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgCreateEscrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).CreateEscrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/CreateEscrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).CreateEscrow(ctx, req.(*MsgCreateEscrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ActivateEscrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgActivateEscrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ActivateEscrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/ActivateEscrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ActivateEscrow(ctx, req.(*MsgActivateEscrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ReleaseEscrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReleaseEscrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ReleaseEscrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/ReleaseEscrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ReleaseEscrow(ctx, req.(*MsgReleaseEscrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RefundEscrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRefundEscrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RefundEscrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/RefundEscrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RefundEscrow(ctx, req.(*MsgRefundEscrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_DisputeEscrow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgDisputeEscrow)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).DisputeEscrow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/DisputeEscrow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).DisputeEscrow(ctx, req.(*MsgDisputeEscrow))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_SettleOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgSettleOrder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).SettleOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/SettleOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).SettleOrder(ctx, req.(*MsgSettleOrder))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RecordUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRecordUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RecordUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/RecordUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RecordUsage(ctx, req.(*MsgRecordUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_AcknowledgeUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgAcknowledgeUsage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).AcknowledgeUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/AcknowledgeUsage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).AcknowledgeUsage(ctx, req.(*MsgAcknowledgeUsage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ClaimRewards_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgClaimRewards)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ClaimRewards(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.settlement.v1.Msg/ClaimRewards",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ClaimRewards(ctx, req.(*MsgClaimRewards))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.settlement.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateEscrow",
			Handler:    _Msg_CreateEscrow_Handler,
		},
		{
			MethodName: "ActivateEscrow",
			Handler:    _Msg_ActivateEscrow_Handler,
		},
		{
			MethodName: "ReleaseEscrow",
			Handler:    _Msg_ReleaseEscrow_Handler,
		},
		{
			MethodName: "RefundEscrow",
			Handler:    _Msg_RefundEscrow_Handler,
		},
		{
			MethodName: "DisputeEscrow",
			Handler:    _Msg_DisputeEscrow_Handler,
		},
		{
			MethodName: "SettleOrder",
			Handler:    _Msg_SettleOrder_Handler,
		},
		{
			MethodName: "RecordUsage",
			Handler:    _Msg_RecordUsage_Handler,
		},
		{
			MethodName: "AcknowledgeUsage",
			Handler:    _Msg_AcknowledgeUsage_Handler,
		},
		{
			MethodName: "ClaimRewards",
			Handler:    _Msg_ClaimRewards_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/settlement/v1/tx.proto",
}

func (m *MsgCreateEscrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateEscrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateEscrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresIn != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpiresIn))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgCreateEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgCreateEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgCreateEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateEscrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateEscrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateEscrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Recipient) > 0 {
		i -= len(m.Recipient)
		copy(dAtA[i:], m.Recipient)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Recipient)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivatedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ActivatedAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReleaseEscrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReleaseEscrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReleaseEscrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Amount) > 0 {
		for iNdEx := len(m.Amount) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Amount[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTx(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReleaseEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReleaseEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReleaseEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReleasedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ReleasedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ReleasedAmount) > 0 {
		i -= len(m.ReleasedAmount)
		copy(dAtA[i:], m.ReleasedAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ReleasedAmount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRefundEscrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRefundEscrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRefundEscrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRefundEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRefundEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRefundEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RefundedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RefundedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RefundedAmount) > 0 {
		i -= len(m.RefundedAmount)
		copy(dAtA[i:], m.RefundedAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.RefundedAmount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisputeEscrow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisputeEscrow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisputeEscrow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Evidence) > 0 {
		i -= len(m.Evidence)
		copy(dAtA[i:], m.Evidence)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Evidence)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EscrowId) > 0 {
		i -= len(m.EscrowId)
		copy(dAtA[i:], m.EscrowId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EscrowId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDisputeEscrowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDisputeEscrowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDisputeEscrowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DisputedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.DisputedAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSettleOrder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSettleOrder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSettleOrder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsFinal {
		i--
		if m.IsFinal {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.UsageRecordIds) > 0 {
		for iNdEx := len(m.UsageRecordIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.UsageRecordIds[iNdEx])
			copy(dAtA[i:], m.UsageRecordIds[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.UsageRecordIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSettleOrderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSettleOrderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSettleOrderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SettledAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.SettledAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.PlatformFee) > 0 {
		i -= len(m.PlatformFee)
		copy(dAtA[i:], m.PlatformFee)
		i = encodeVarintTx(dAtA, i, uint64(len(m.PlatformFee)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProviderShare) > 0 {
		i -= len(m.ProviderShare)
		copy(dAtA[i:], m.ProviderShare)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ProviderShare)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TotalAmount) > 0 {
		i -= len(m.TotalAmount)
		copy(dAtA[i:], m.TotalAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TotalAmount)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SettlementId) > 0 {
		i -= len(m.SettlementId)
		copy(dAtA[i:], m.SettlementId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SettlementId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRecordUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecordUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecordUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x4a
	}
	{
		size, err := m.UnitPrice.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if m.PeriodEnd != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PeriodEnd))
		i--
		dAtA[i] = 0x38
	}
	if m.PeriodStart != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.PeriodStart))
		i--
		dAtA[i] = 0x30
	}
	if len(m.UsageType) > 0 {
		i -= len(m.UsageType)
		copy(dAtA[i:], m.UsageType)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UsageType)))
		i--
		dAtA[i] = 0x2a
	}
	if m.UsageUnits != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.UsageUnits))
		i--
		dAtA[i] = 0x20
	}
	if len(m.LeaseId) > 0 {
		i -= len(m.LeaseId)
		copy(dAtA[i:], m.LeaseId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.LeaseId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRecordUsageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRecordUsageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRecordUsageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecordedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.RecordedAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TotalCost) > 0 {
		i -= len(m.TotalCost)
		copy(dAtA[i:], m.TotalCost)
		i = encodeVarintTx(dAtA, i, uint64(len(m.TotalCost)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UsageId) > 0 {
		i -= len(m.UsageId)
		copy(dAtA[i:], m.UsageId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UsageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAcknowledgeUsage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAcknowledgeUsage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAcknowledgeUsage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.UsageId) > 0 {
		i -= len(m.UsageId)
		copy(dAtA[i:], m.UsageId)
		i = encodeVarintTx(dAtA, i, uint64(len(m.UsageId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAcknowledgeUsageResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAcknowledgeUsageResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAcknowledgeUsageResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AcknowledgedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.AcknowledgedAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimRewards) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimRewards) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimRewards) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Source) > 0 {
		i -= len(m.Source)
		copy(dAtA[i:], m.Source)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Source)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Sender) > 0 {
		i -= len(m.Sender)
		copy(dAtA[i:], m.Sender)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Sender)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimRewardsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimRewardsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimRewardsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimedAt != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ClaimedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ClaimedAmount) > 0 {
		i -= len(m.ClaimedAmount)
		copy(dAtA[i:], m.ClaimedAmount)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ClaimedAmount)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgCreateEscrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovTx(uint64(m.ExpiresIn))
	}
	return n
}

func (m *MsgCreateEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTx(uint64(m.CreatedAt))
	}
	return n
}

func (m *MsgActivateEscrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Recipient)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgActivateEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActivatedAt != 0 {
		n += 1 + sovTx(uint64(m.ActivatedAt))
	}
	return n
}

func (m *MsgReleaseEscrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.Amount) > 0 {
		for _, e := range m.Amount {
			l = e.Size()
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgReleaseEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ReleasedAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ReleasedAt != 0 {
		n += 1 + sovTx(uint64(m.ReleasedAt))
	}
	return n
}

func (m *MsgRefundEscrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRefundEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RefundedAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RefundedAt != 0 {
		n += 1 + sovTx(uint64(m.RefundedAt))
	}
	return n
}

func (m *MsgDisputeEscrow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EscrowId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Evidence)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgDisputeEscrowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DisputedAt != 0 {
		n += 1 + sovTx(uint64(m.DisputedAt))
	}
	return n
}

func (m *MsgSettleOrder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.UsageRecordIds) > 0 {
		for _, s := range m.UsageRecordIds {
			l = len(s)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.IsFinal {
		n += 2
	}
	return n
}

func (m *MsgSettleOrderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SettlementId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TotalAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.ProviderShare)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.PlatformFee)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.SettledAt != 0 {
		n += 1 + sovTx(uint64(m.SettledAt))
	}
	return n
}

func (m *MsgRecordUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.LeaseId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.UsageUnits != 0 {
		n += 1 + sovTx(uint64(m.UsageUnits))
	}
	l = len(m.UsageType)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.PeriodStart != 0 {
		n += 1 + sovTx(uint64(m.PeriodStart))
	}
	if m.PeriodEnd != 0 {
		n += 1 + sovTx(uint64(m.PeriodEnd))
	}
	l = m.UnitPrice.Size()
	n += 1 + l + sovTx(uint64(l))
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRecordUsageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UsageId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.TotalCost)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.RecordedAt != 0 {
		n += 1 + sovTx(uint64(m.RecordedAt))
	}
	return n
}

func (m *MsgAcknowledgeUsage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.UsageId)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgAcknowledgeUsageResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AcknowledgedAt != 0 {
		n += 1 + sovTx(uint64(m.AcknowledgedAt))
	}
	return n
}

func (m *MsgClaimRewards) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Sender)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Source)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgClaimRewardsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClaimedAmount)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ClaimedAt != 0 {
		n += 1 + sovTx(uint64(m.ClaimedAt))
	}
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgCreateEscrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateEscrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateEscrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgCreateEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgCreateEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgCreateEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateEscrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateEscrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateEscrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Recipient", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Recipient = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			m.ActivatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReleaseEscrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReleaseEscrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReleaseEscrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = append(m.Amount, types.Coin{})
			if err := m.Amount[len(m.Amount)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReleaseEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReleaseEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReleaseEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleasedAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleasedAt", wireType)
			}
			m.ReleasedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReleasedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRefundEscrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRefundEscrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRefundEscrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRefundEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRefundEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRefundEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefundedAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefundedAt", wireType)
			}
			m.RefundedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RefundedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisputeEscrow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisputeEscrow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisputeEscrow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EscrowId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Evidence", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Evidence = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDisputeEscrowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDisputeEscrowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDisputeEscrowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisputedAt", wireType)
			}
			m.DisputedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DisputedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSettleOrder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSettleOrder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSettleOrder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRecordIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageRecordIds = append(m.UsageRecordIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsFinal", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsFinal = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSettleOrderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSettleOrderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSettleOrderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlementId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlementId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderShare", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderShare = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformFee", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformFee = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettledAt", wireType)
			}
			m.SettledAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SettledAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecordUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecordUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecordUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaseId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LeaseId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageUnits", wireType)
			}
			m.UsageUnits = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsageUnits |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodStart", wireType)
			}
			m.PeriodStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodStart |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeriodEnd", wireType)
			}
			m.PeriodEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeriodEnd |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnitPrice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UnitPrice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRecordUsageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRecordUsageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRecordUsageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCost", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TotalCost = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordedAt", wireType)
			}
			m.RecordedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAcknowledgeUsage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAcknowledgeUsage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAcknowledgeUsage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAcknowledgeUsageResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAcknowledgeUsageResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAcknowledgeUsageResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcknowledgedAt", wireType)
			}
			m.AcknowledgedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcknowledgedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimRewards) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimRewards: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimRewards: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimRewardsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimRewardsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimRewardsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAmount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClaimedAmount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAt", wireType)
			}
			m.ClaimedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)
