// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/enclave/v1/events.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// EventEnclaveIdentityRegistered is emitted when an enclave identity is registered
type EventEnclaveIdentityRegistered struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// TEEType is the type of TEE
	TeeType string `protobuf:"bytes,2,opt,name=tee_type,json=teeType,proto3" json:"tee_type" yaml:"tee_type"`
	// MeasurementHash is the enclave measurement hash (hex-encoded)
	MeasurementHash string `protobuf:"bytes,3,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// EncryptionKeyID is the encryption key identifier
	EncryptionKeyId string `protobuf:"bytes,4,opt,name=encryption_key_id,json=encryptionKeyId,proto3" json:"encryption_key_id" yaml:"encryption_key_id"`
	// SigningKeyID is the signing key identifier
	SigningKeyId string `protobuf:"bytes,5,opt,name=signing_key_id,json=signingKeyId,proto3" json:"signing_key_id" yaml:"signing_key_id"`
	// Epoch is the registration epoch
	Epoch uint64 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch" yaml:"epoch"`
	// ExpiryHeight is the block height when this identity expires
	ExpiryHeight int64 `protobuf:"varint,7,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height" yaml:"expiry_height"`
}

func (m *EventEnclaveIdentityRegistered) Reset()         { *m = EventEnclaveIdentityRegistered{} }
func (m *EventEnclaveIdentityRegistered) String() string { return proto.CompactTextString(m) }
func (*EventEnclaveIdentityRegistered) ProtoMessage()    {}
func (*EventEnclaveIdentityRegistered) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{0}
}
func (m *EventEnclaveIdentityRegistered) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEnclaveIdentityRegistered) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEnclaveIdentityRegistered.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEnclaveIdentityRegistered) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEnclaveIdentityRegistered.Merge(m, src)
}
func (m *EventEnclaveIdentityRegistered) XXX_Size() int {
	return m.Size()
}
func (m *EventEnclaveIdentityRegistered) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEnclaveIdentityRegistered.DiscardUnknown(m)
}

var xxx_messageInfo_EventEnclaveIdentityRegistered proto.InternalMessageInfo

func (m *EventEnclaveIdentityRegistered) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEnclaveIdentityRegistered) GetTeeType() string {
	if m != nil {
		return m.TeeType
	}
	return ""
}

func (m *EventEnclaveIdentityRegistered) GetMeasurementHash() string {
	if m != nil {
		return m.MeasurementHash
	}
	return ""
}

func (m *EventEnclaveIdentityRegistered) GetEncryptionKeyId() string {
	if m != nil {
		return m.EncryptionKeyId
	}
	return ""
}

func (m *EventEnclaveIdentityRegistered) GetSigningKeyId() string {
	if m != nil {
		return m.SigningKeyId
	}
	return ""
}

func (m *EventEnclaveIdentityRegistered) GetEpoch() uint64 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *EventEnclaveIdentityRegistered) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

// EventEnclaveIdentityUpdated is emitted when an enclave identity is updated
type EventEnclaveIdentityUpdated struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// Status is the new status
	Status string `protobuf:"bytes,2,opt,name=status,proto3" json:"status" yaml:"status"`
}

func (m *EventEnclaveIdentityUpdated) Reset()         { *m = EventEnclaveIdentityUpdated{} }
func (m *EventEnclaveIdentityUpdated) String() string { return proto.CompactTextString(m) }
func (*EventEnclaveIdentityUpdated) ProtoMessage()    {}
func (*EventEnclaveIdentityUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{1}
}
func (m *EventEnclaveIdentityUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEnclaveIdentityUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEnclaveIdentityUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEnclaveIdentityUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEnclaveIdentityUpdated.Merge(m, src)
}
func (m *EventEnclaveIdentityUpdated) XXX_Size() int {
	return m.Size()
}
func (m *EventEnclaveIdentityUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEnclaveIdentityUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_EventEnclaveIdentityUpdated proto.InternalMessageInfo

func (m *EventEnclaveIdentityUpdated) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEnclaveIdentityUpdated) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

// EventEnclaveIdentityRevoked is emitted when an enclave identity is revoked
type EventEnclaveIdentityRevoked struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// Reason is the reason for revocation
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *EventEnclaveIdentityRevoked) Reset()         { *m = EventEnclaveIdentityRevoked{} }
func (m *EventEnclaveIdentityRevoked) String() string { return proto.CompactTextString(m) }
func (*EventEnclaveIdentityRevoked) ProtoMessage()    {}
func (*EventEnclaveIdentityRevoked) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{2}
}
func (m *EventEnclaveIdentityRevoked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEnclaveIdentityRevoked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEnclaveIdentityRevoked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEnclaveIdentityRevoked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEnclaveIdentityRevoked.Merge(m, src)
}
func (m *EventEnclaveIdentityRevoked) XXX_Size() int {
	return m.Size()
}
func (m *EventEnclaveIdentityRevoked) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEnclaveIdentityRevoked.DiscardUnknown(m)
}

var xxx_messageInfo_EventEnclaveIdentityRevoked proto.InternalMessageInfo

func (m *EventEnclaveIdentityRevoked) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEnclaveIdentityRevoked) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EventEnclaveIdentityExpired is emitted when an enclave identity expires
type EventEnclaveIdentityExpired struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// ExpiryHeight is the height at which the identity expired
	ExpiryHeight int64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height" yaml:"expiry_height"`
}

func (m *EventEnclaveIdentityExpired) Reset()         { *m = EventEnclaveIdentityExpired{} }
func (m *EventEnclaveIdentityExpired) String() string { return proto.CompactTextString(m) }
func (*EventEnclaveIdentityExpired) ProtoMessage()    {}
func (*EventEnclaveIdentityExpired) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{3}
}
func (m *EventEnclaveIdentityExpired) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEnclaveIdentityExpired) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEnclaveIdentityExpired.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEnclaveIdentityExpired) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEnclaveIdentityExpired.Merge(m, src)
}
func (m *EventEnclaveIdentityExpired) XXX_Size() int {
	return m.Size()
}
func (m *EventEnclaveIdentityExpired) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEnclaveIdentityExpired.DiscardUnknown(m)
}

var xxx_messageInfo_EventEnclaveIdentityExpired proto.InternalMessageInfo

func (m *EventEnclaveIdentityExpired) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEnclaveIdentityExpired) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

// EventEnclaveKeyRotated is emitted when a key rotation is initiated
type EventEnclaveKeyRotated struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// OldKeyFingerprint is the fingerprint of the old key
	OldKeyFingerprint string `protobuf:"bytes,2,opt,name=old_key_fingerprint,json=oldKeyFingerprint,proto3" json:"old_key_fingerprint" yaml:"old_key_fingerprint"`
	// NewKeyFingerprint is the fingerprint of the new key
	NewKeyFingerprint string `protobuf:"bytes,3,opt,name=new_key_fingerprint,json=newKeyFingerprint,proto3" json:"new_key_fingerprint" yaml:"new_key_fingerprint"`
	// OverlapStartHeight is when both keys become valid
	OverlapStartHeight int64 `protobuf:"varint,4,opt,name=overlap_start_height,json=overlapStartHeight,proto3" json:"overlap_start_height" yaml:"overlap_start_height"`
	// OverlapEndHeight is when the old key becomes invalid
	OverlapEndHeight int64 `protobuf:"varint,5,opt,name=overlap_end_height,json=overlapEndHeight,proto3" json:"overlap_end_height" yaml:"overlap_end_height"`
}

func (m *EventEnclaveKeyRotated) Reset()         { *m = EventEnclaveKeyRotated{} }
func (m *EventEnclaveKeyRotated) String() string { return proto.CompactTextString(m) }
func (*EventEnclaveKeyRotated) ProtoMessage()    {}
func (*EventEnclaveKeyRotated) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{4}
}
func (m *EventEnclaveKeyRotated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventEnclaveKeyRotated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventEnclaveKeyRotated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventEnclaveKeyRotated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventEnclaveKeyRotated.Merge(m, src)
}
func (m *EventEnclaveKeyRotated) XXX_Size() int {
	return m.Size()
}
func (m *EventEnclaveKeyRotated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventEnclaveKeyRotated.DiscardUnknown(m)
}

var xxx_messageInfo_EventEnclaveKeyRotated proto.InternalMessageInfo

func (m *EventEnclaveKeyRotated) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventEnclaveKeyRotated) GetOldKeyFingerprint() string {
	if m != nil {
		return m.OldKeyFingerprint
	}
	return ""
}

func (m *EventEnclaveKeyRotated) GetNewKeyFingerprint() string {
	if m != nil {
		return m.NewKeyFingerprint
	}
	return ""
}

func (m *EventEnclaveKeyRotated) GetOverlapStartHeight() int64 {
	if m != nil {
		return m.OverlapStartHeight
	}
	return 0
}

func (m *EventEnclaveKeyRotated) GetOverlapEndHeight() int64 {
	if m != nil {
		return m.OverlapEndHeight
	}
	return 0
}

// EventKeyRotationCompleted is emitted when a key rotation completes
type EventKeyRotationCompleted struct {
	// Validator is the validator address
	Validator string `protobuf:"bytes,1,opt,name=validator,proto3" json:"validator" yaml:"validator"`
	// NewKeyFingerprint is the fingerprint of the new active key
	NewKeyFingerprint string `protobuf:"bytes,2,opt,name=new_key_fingerprint,json=newKeyFingerprint,proto3" json:"new_key_fingerprint" yaml:"new_key_fingerprint"`
}

func (m *EventKeyRotationCompleted) Reset()         { *m = EventKeyRotationCompleted{} }
func (m *EventKeyRotationCompleted) String() string { return proto.CompactTextString(m) }
func (*EventKeyRotationCompleted) ProtoMessage()    {}
func (*EventKeyRotationCompleted) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{5}
}
func (m *EventKeyRotationCompleted) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventKeyRotationCompleted) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventKeyRotationCompleted.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventKeyRotationCompleted) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventKeyRotationCompleted.Merge(m, src)
}
func (m *EventKeyRotationCompleted) XXX_Size() int {
	return m.Size()
}
func (m *EventKeyRotationCompleted) XXX_DiscardUnknown() {
	xxx_messageInfo_EventKeyRotationCompleted.DiscardUnknown(m)
}

var xxx_messageInfo_EventKeyRotationCompleted proto.InternalMessageInfo

func (m *EventKeyRotationCompleted) GetValidator() string {
	if m != nil {
		return m.Validator
	}
	return ""
}

func (m *EventKeyRotationCompleted) GetNewKeyFingerprint() string {
	if m != nil {
		return m.NewKeyFingerprint
	}
	return ""
}

// EventMeasurementAdded is emitted when a measurement is added to the allowlist
type EventMeasurementAdded struct {
	// MeasurementHash is the measurement hash (hex-encoded)
	MeasurementHash string `protobuf:"bytes,1,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// TEEType is the TEE type
	TeeType string `protobuf:"bytes,2,opt,name=tee_type,json=teeType,proto3" json:"tee_type" yaml:"tee_type"`
	// Description is the measurement description
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description" yaml:"description"`
	// MinISVSVN is the minimum security version
	MinIsvSvn uint32 `protobuf:"varint,4,opt,name=min_isv_svn,json=minIsvSvn,proto3" json:"min_isv_svn" yaml:"min_isv_svn"`
}

func (m *EventMeasurementAdded) Reset()         { *m = EventMeasurementAdded{} }
func (m *EventMeasurementAdded) String() string { return proto.CompactTextString(m) }
func (*EventMeasurementAdded) ProtoMessage()    {}
func (*EventMeasurementAdded) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{6}
}
func (m *EventMeasurementAdded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMeasurementAdded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMeasurementAdded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMeasurementAdded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMeasurementAdded.Merge(m, src)
}
func (m *EventMeasurementAdded) XXX_Size() int {
	return m.Size()
}
func (m *EventMeasurementAdded) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMeasurementAdded.DiscardUnknown(m)
}

var xxx_messageInfo_EventMeasurementAdded proto.InternalMessageInfo

func (m *EventMeasurementAdded) GetMeasurementHash() string {
	if m != nil {
		return m.MeasurementHash
	}
	return ""
}

func (m *EventMeasurementAdded) GetTeeType() string {
	if m != nil {
		return m.TeeType
	}
	return ""
}

func (m *EventMeasurementAdded) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *EventMeasurementAdded) GetMinIsvSvn() uint32 {
	if m != nil {
		return m.MinIsvSvn
	}
	return 0
}

// EventMeasurementRevoked is emitted when a measurement is revoked
type EventMeasurementRevoked struct {
	// MeasurementHash is the measurement hash (hex-encoded)
	MeasurementHash string `protobuf:"bytes,1,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// Reason is the reason for revocation
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *EventMeasurementRevoked) Reset()         { *m = EventMeasurementRevoked{} }
func (m *EventMeasurementRevoked) String() string { return proto.CompactTextString(m) }
func (*EventMeasurementRevoked) ProtoMessage()    {}
func (*EventMeasurementRevoked) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{7}
}
func (m *EventMeasurementRevoked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventMeasurementRevoked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventMeasurementRevoked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventMeasurementRevoked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventMeasurementRevoked.Merge(m, src)
}
func (m *EventMeasurementRevoked) XXX_Size() int {
	return m.Size()
}
func (m *EventMeasurementRevoked) XXX_DiscardUnknown() {
	xxx_messageInfo_EventMeasurementRevoked.DiscardUnknown(m)
}

var xxx_messageInfo_EventMeasurementRevoked proto.InternalMessageInfo

func (m *EventMeasurementRevoked) GetMeasurementHash() string {
	if m != nil {
		return m.MeasurementHash
	}
	return ""
}

func (m *EventMeasurementRevoked) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EventVEIDScoreComputedAttested is emitted when a VEID score is computed with attestation
type EventVEIDScoreComputedAttested struct {
	// ScopeID is the identity scope
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// AccountAddress is the account that owns the identity
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Score is the computed score
	Score uint32 `protobuf:"varint,3,opt,name=score,proto3" json:"score" yaml:"score"`
	// Status is the verification status
	Status string `protobuf:"bytes,4,opt,name=status,proto3" json:"status" yaml:"status"`
	// BlockHeight is the block height
	BlockHeight int64 `protobuf:"varint,5,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *EventVEIDScoreComputedAttested) Reset()         { *m = EventVEIDScoreComputedAttested{} }
func (m *EventVEIDScoreComputedAttested) String() string { return proto.CompactTextString(m) }
func (*EventVEIDScoreComputedAttested) ProtoMessage()    {}
func (*EventVEIDScoreComputedAttested) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{8}
}
func (m *EventVEIDScoreComputedAttested) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVEIDScoreComputedAttested) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVEIDScoreComputedAttested.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVEIDScoreComputedAttested) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVEIDScoreComputedAttested.Merge(m, src)
}
func (m *EventVEIDScoreComputedAttested) XXX_Size() int {
	return m.Size()
}
func (m *EventVEIDScoreComputedAttested) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVEIDScoreComputedAttested.DiscardUnknown(m)
}

var xxx_messageInfo_EventVEIDScoreComputedAttested proto.InternalMessageInfo

func (m *EventVEIDScoreComputedAttested) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *EventVEIDScoreComputedAttested) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventVEIDScoreComputedAttested) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *EventVEIDScoreComputedAttested) GetStatus() string {
	if m != nil {
		return m.Status
	}
	return ""
}

func (m *EventVEIDScoreComputedAttested) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// EventVEIDScoreRejectedAttestation is emitted when a VEID score fails attestation verification
type EventVEIDScoreRejectedAttestation struct {
	// ScopeID is the identity scope
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// AccountAddress is the account that owns the identity
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ProposedScore is the score proposed by the proposer
	ProposedScore uint32 `protobuf:"varint,3,opt,name=proposed_score,json=proposedScore,proto3" json:"proposed_score" yaml:"proposed_score"`
	// ComputedScore is the locally computed score
	ComputedScore uint32 `protobuf:"varint,4,opt,name=computed_score,json=computedScore,proto3" json:"computed_score" yaml:"computed_score"`
	// Reason is the reason for rejection
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *EventVEIDScoreRejectedAttestation) Reset()         { *m = EventVEIDScoreRejectedAttestation{} }
func (m *EventVEIDScoreRejectedAttestation) String() string { return proto.CompactTextString(m) }
func (*EventVEIDScoreRejectedAttestation) ProtoMessage()    {}
func (*EventVEIDScoreRejectedAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{9}
}
func (m *EventVEIDScoreRejectedAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventVEIDScoreRejectedAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventVEIDScoreRejectedAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventVEIDScoreRejectedAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventVEIDScoreRejectedAttestation.Merge(m, src)
}
func (m *EventVEIDScoreRejectedAttestation) XXX_Size() int {
	return m.Size()
}
func (m *EventVEIDScoreRejectedAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_EventVEIDScoreRejectedAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_EventVEIDScoreRejectedAttestation proto.InternalMessageInfo

func (m *EventVEIDScoreRejectedAttestation) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *EventVEIDScoreRejectedAttestation) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *EventVEIDScoreRejectedAttestation) GetProposedScore() uint32 {
	if m != nil {
		return m.ProposedScore
	}
	return 0
}

func (m *EventVEIDScoreRejectedAttestation) GetComputedScore() uint32 {
	if m != nil {
		return m.ComputedScore
	}
	return 0
}

func (m *EventVEIDScoreRejectedAttestation) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EventConsensusVerificationFailed is emitted when consensus verification fails
type EventConsensusVerificationFailed struct {
	// ScopeID is the identity scope
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// ProposedScore is the score proposed
	ProposedScore uint32 `protobuf:"varint,2,opt,name=proposed_score,json=proposedScore,proto3" json:"proposed_score" yaml:"proposed_score"`
	// ComputedScore is the locally recomputed score
	ComputedScore uint32 `protobuf:"varint,3,opt,name=computed_score,json=computedScore,proto3" json:"computed_score" yaml:"computed_score"`
	// ScoreDifference is the absolute difference between scores
	ScoreDifference int32 `protobuf:"varint,4,opt,name=score_difference,json=scoreDifference,proto3" json:"score_difference" yaml:"score_difference"`
	// Reason is the failure reason
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *EventConsensusVerificationFailed) Reset()         { *m = EventConsensusVerificationFailed{} }
func (m *EventConsensusVerificationFailed) String() string { return proto.CompactTextString(m) }
func (*EventConsensusVerificationFailed) ProtoMessage()    {}
func (*EventConsensusVerificationFailed) Descriptor() ([]byte, []int) {
	return fileDescriptor_8ab725e40f4b9139, []int{10}
}
func (m *EventConsensusVerificationFailed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventConsensusVerificationFailed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventConsensusVerificationFailed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventConsensusVerificationFailed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventConsensusVerificationFailed.Merge(m, src)
}
func (m *EventConsensusVerificationFailed) XXX_Size() int {
	return m.Size()
}
func (m *EventConsensusVerificationFailed) XXX_DiscardUnknown() {
	xxx_messageInfo_EventConsensusVerificationFailed.DiscardUnknown(m)
}

var xxx_messageInfo_EventConsensusVerificationFailed proto.InternalMessageInfo

func (m *EventConsensusVerificationFailed) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *EventConsensusVerificationFailed) GetProposedScore() uint32 {
	if m != nil {
		return m.ProposedScore
	}
	return 0
}

func (m *EventConsensusVerificationFailed) GetComputedScore() uint32 {
	if m != nil {
		return m.ComputedScore
	}
	return 0
}

func (m *EventConsensusVerificationFailed) GetScoreDifference() int32 {
	if m != nil {
		return m.ScoreDifference
	}
	return 0
}

func (m *EventConsensusVerificationFailed) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func init() {
	proto.RegisterType((*EventEnclaveIdentityRegistered)(nil), "virtengine.enclave.v1.EventEnclaveIdentityRegistered")
	proto.RegisterType((*EventEnclaveIdentityUpdated)(nil), "virtengine.enclave.v1.EventEnclaveIdentityUpdated")
	proto.RegisterType((*EventEnclaveIdentityRevoked)(nil), "virtengine.enclave.v1.EventEnclaveIdentityRevoked")
	proto.RegisterType((*EventEnclaveIdentityExpired)(nil), "virtengine.enclave.v1.EventEnclaveIdentityExpired")
	proto.RegisterType((*EventEnclaveKeyRotated)(nil), "virtengine.enclave.v1.EventEnclaveKeyRotated")
	proto.RegisterType((*EventKeyRotationCompleted)(nil), "virtengine.enclave.v1.EventKeyRotationCompleted")
	proto.RegisterType((*EventMeasurementAdded)(nil), "virtengine.enclave.v1.EventMeasurementAdded")
	proto.RegisterType((*EventMeasurementRevoked)(nil), "virtengine.enclave.v1.EventMeasurementRevoked")
	proto.RegisterType((*EventVEIDScoreComputedAttested)(nil), "virtengine.enclave.v1.EventVEIDScoreComputedAttested")
	proto.RegisterType((*EventVEIDScoreRejectedAttestation)(nil), "virtengine.enclave.v1.EventVEIDScoreRejectedAttestation")
	proto.RegisterType((*EventConsensusVerificationFailed)(nil), "virtengine.enclave.v1.EventConsensusVerificationFailed")
}

func init() {
	proto.RegisterFile("virtengine/enclave/v1/events.proto", fileDescriptor_8ab725e40f4b9139)
}

var fileDescriptor_8ab725e40f4b9139 = []byte{
	// 1126 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x97, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0xc7, 0xbb, 0xb1, 0xd3, 0x3f, 0xd3, 0xa4, 0x49, 0xb7, 0x69, 0xeb, 0xb4, 0x92, 0x27, 0xbf,
	0x91, 0x7e, 0xa2, 0x08, 0x11, 0xab, 0xaa, 0x50, 0x45, 0x6e, 0x4d, 0xeb, 0xd2, 0x50, 0x81, 0xd4,
	0x09, 0x14, 0xa9, 0x12, 0x5a, 0x6d, 0x77, 0x9f, 0xd8, 0x43, 0xec, 0x99, 0xd5, 0xce, 0xc4, 0xc5,
	0x77, 0x5e, 0x00, 0x12, 0x67, 0x24, 0x5e, 0x02, 0x20, 0xde, 0x02, 0x12, 0x42, 0x1c, 0x2a, 0x4e,
	0x9c, 0x46, 0xd0, 0x5e, 0xd0, 0x1e, 0xf7, 0x15, 0x20, 0xcf, 0xcc, 0x66, 0x77, 0x6d, 0x57, 0x80,
	0x52, 0x1f, 0xb8, 0x79, 0x3e, 0xdf, 0xf1, 0xf7, 0x99, 0x99, 0xe7, 0x99, 0x3f, 0x8b, 0xc8, 0x88,
	0xa5, 0x0a, 0x78, 0x8f, 0x71, 0xe8, 0x00, 0x8f, 0x06, 0xe1, 0x08, 0x3a, 0xa3, 0x9b, 0x1d, 0x18,
	0x01, 0x57, 0x72, 0x3b, 0x49, 0x85, 0x12, 0xfe, 0xe5, 0xb2, 0xcf, 0xb6, 0xeb, 0xb3, 0x3d, 0xba,
	0x79, 0x6d, 0xa3, 0x27, 0x7a, 0xc2, 0xf4, 0xe8, 0x4c, 0x7e, 0xd9, 0xce, 0xd7, 0x36, 0x23, 0x21,
	0x87, 0x42, 0x06, 0x56, 0xb0, 0x0d, 0x2b, 0x91, 0x9f, 0x9b, 0xa8, 0xdd, 0x9d, 0x18, 0x77, 0xad,
	0xc9, 0x5e, 0x0c, 0x5c, 0x31, 0x35, 0xa6, 0xd0, 0x63, 0x52, 0x41, 0x0a, 0xb1, 0xff, 0x09, 0x3a,
	0x37, 0x0a, 0x07, 0x2c, 0x0e, 0x95, 0x48, 0x5b, 0xde, 0x96, 0x77, 0xe3, 0xdc, 0xee, 0xbb, 0x99,
	0xc6, 0x25, 0xcc, 0x35, 0x5e, 0x1f, 0x87, 0xc3, 0xc1, 0x0e, 0x39, 0x46, 0xe4, 0xd7, 0x1f, 0xde,
	0xde, 0x70, 0x81, 0xee, 0xc4, 0x71, 0x0a, 0x52, 0xee, 0xab, 0x94, 0xf1, 0x1e, 0x2d, 0xff, 0xe6,
	0xef, 0xa0, 0xb3, 0x0a, 0x20, 0x50, 0xe3, 0x04, 0x5a, 0x4b, 0xc6, 0x17, 0x67, 0x1a, 0x1f, 0xb3,
	0x5c, 0xe3, 0x35, 0x6b, 0x5b, 0x10, 0x42, 0xcf, 0x28, 0x80, 0x8f, 0xc6, 0x09, 0xf8, 0x4f, 0xd0,
	0xfa, 0x10, 0x42, 0x79, 0x94, 0xc2, 0x10, 0xb8, 0x0a, 0xfa, 0xa1, 0xec, 0xb7, 0x1a, 0xc6, 0xa3,
	0x93, 0x69, 0x3c, 0xa3, 0xe5, 0x1a, 0x5f, 0xb5, 0x5e, 0xd3, 0x0a, 0xa1, 0x6b, 0x15, 0xf4, 0x20,
	0x94, 0x7d, 0xff, 0x53, 0x74, 0x11, 0x78, 0x94, 0x8e, 0x13, 0xc5, 0x04, 0x0f, 0x0e, 0x61, 0x1c,
	0xb0, 0xb8, 0xd5, 0x34, 0xe6, 0x37, 0x33, 0x8d, 0x67, 0xc5, 0x5c, 0xe3, 0x96, 0x75, 0x9f, 0x91,
	0x08, 0x5d, 0x2b, 0xd9, 0x43, 0x18, 0xef, 0xc5, 0xfe, 0x23, 0x74, 0x41, 0xb2, 0x1e, 0x67, 0xbc,
	0x57, 0x78, 0x2f, 0x1b, 0xef, 0xb7, 0x32, 0x8d, 0xa7, 0x94, 0x5c, 0xe3, 0xcb, 0xd6, 0xb8, 0xce,
	0x09, 0x5d, 0x71, 0xc0, 0x5a, 0x76, 0xd0, 0x32, 0x24, 0x22, 0xea, 0xb7, 0x4e, 0x6f, 0x79, 0x37,
	0x9a, 0xbb, 0x9b, 0x99, 0xc6, 0x16, 0xe4, 0x1a, 0xaf, 0xb8, 0x91, 0x4d, 0x9a, 0x84, 0x5a, 0xec,
	0x7f, 0x88, 0x56, 0xe1, 0xf3, 0x84, 0xa5, 0xe3, 0xa0, 0x0f, 0xac, 0xd7, 0x57, 0xad, 0x33, 0x5b,
	0xde, 0x8d, 0xc6, 0xee, 0x9b, 0x99, 0xc6, 0x75, 0x21, 0xd7, 0x78, 0xc3, 0x19, 0x54, 0x31, 0xa1,
	0x2b, 0xb6, 0xfd, 0xc0, 0x34, 0x77, 0x9a, 0x7f, 0x7e, 0x83, 0x3d, 0xf2, 0x9d, 0x87, 0xae, 0xcf,
	0x2b, 0xa6, 0x8f, 0x93, 0x38, 0x54, 0x8b, 0xac, 0xa4, 0x5b, 0xe8, 0xb4, 0x54, 0xa1, 0x3a, 0x92,
	0xae, 0x8e, 0xae, 0x67, 0x1a, 0x3b, 0x92, 0x6b, 0xbc, 0xea, 0x96, 0xd0, 0xb4, 0x09, 0x75, 0xc2,
	0xdf, 0x8c, 0x99, 0xc2, 0x48, 0x1c, 0x2e, 0x78, 0xcc, 0x29, 0x84, 0x52, 0xf0, 0xea, 0x98, 0x2d,
	0x29, 0xc7, 0x6c, 0xdb, 0x84, 0x3a, 0xc1, 0x8d, 0xf9, 0x97, 0x57, 0x8c, 0xb9, 0x3b, 0x49, 0xc9,
	0x22, 0xc7, 0x3c, 0x53, 0x36, 0x4b, 0xaf, 0xa3, 0x6c, 0xbe, 0x6a, 0xa2, 0x2b, 0xd5, 0xe9, 0x3c,
	0x84, 0x31, 0x15, 0x6a, 0xb1, 0x15, 0x03, 0xe8, 0x92, 0x18, 0xc4, 0x66, 0x3b, 0x1d, 0x30, 0xde,
	0x83, 0x34, 0x49, 0x19, 0x57, 0x2e, 0x15, 0xef, 0x64, 0x1a, 0xcf, 0x93, 0x73, 0x8d, 0xaf, 0xd9,
	0x60, 0x73, 0x44, 0x42, 0x2f, 0x8a, 0x41, 0xfc, 0x10, 0xc6, 0xf7, 0x4b, 0x36, 0x09, 0xc3, 0xe1,
	0xd9, 0x4c, 0x98, 0x46, 0x19, 0x66, 0x8e, 0x5c, 0x86, 0x99, 0x23, 0x12, 0x7a, 0x91, 0xc3, 0xb3,
	0xa9, 0x30, 0x0c, 0x6d, 0x88, 0x11, 0xa4, 0x83, 0x30, 0x09, 0xa4, 0x0a, 0x53, 0x55, 0xa4, 0xa7,
	0x69, 0xd2, 0x73, 0x3b, 0xd3, 0x78, 0xae, 0x9e, 0x6b, 0x7c, 0xdd, 0xcd, 0x67, 0x8e, 0x4a, 0xa8,
	0xef, 0xf0, 0xfe, 0x84, 0xda, 0x94, 0xf9, 0x21, 0x2a, 0x68, 0x00, 0x3c, 0x2e, 0x02, 0x2d, 0x9b,
	0x40, 0xb7, 0x32, 0x8d, 0xe7, 0xa8, 0xb9, 0xc6, 0x9b, 0xf5, 0x30, 0xa5, 0x46, 0xe8, 0xba, 0x83,
	0x5d, 0x1e, 0xd7, 0xaa, 0xe2, 0x0f, 0x0f, 0x6d, 0x9a, 0xaa, 0x28, 0xca, 0x81, 0x09, 0x7e, 0x57,
	0x0c, 0x93, 0x01, 0x2c, 0xba, 0x30, 0xe6, 0x65, 0x6c, 0xe9, 0xf5, 0x66, 0xcc, 0xcd, 0xf1, 0xc7,
	0x25, 0x74, 0xd9, 0xcc, 0xf1, 0x83, 0xf2, 0x0a, 0xba, 0x13, 0xc7, 0x10, 0xcf, 0xbd, 0xdf, 0xbc,
	0xd7, 0x74, 0xbf, 0x9d, 0xe4, 0xde, 0x7d, 0x0f, 0x9d, 0x8f, 0x41, 0x46, 0x29, 0x33, 0x17, 0x9a,
	0x2b, 0xe4, 0xff, 0x67, 0x1a, 0x57, 0x71, 0xae, 0xb1, 0x6f, 0x1d, 0x2a, 0x90, 0xd0, 0x6a, 0x17,
	0xbf, 0x8b, 0xce, 0x0f, 0x19, 0x0f, 0x98, 0x1c, 0x05, 0x72, 0xc4, 0x4d, 0xa5, 0xae, 0x5a, 0xa3,
	0x0a, 0x2e, 0x8d, 0x2a, 0x90, 0xd0, 0x73, 0x43, 0xc6, 0xf7, 0xe4, 0x68, 0x7f, 0x54, 0x1c, 0x88,
	0xdf, 0x7a, 0xe8, 0xea, 0xf4, 0x3a, 0x16, 0x07, 0xf8, 0x22, 0x57, 0xf2, 0x04, 0x67, 0xf8, 0x17,
	0x0d, 0xf7, 0xf0, 0x7a, 0xdc, 0xdd, 0xbb, 0xb7, 0x1f, 0x89, 0x14, 0x26, 0xc5, 0x7d, 0xa4, 0x20,
	0xbe, 0xa3, 0x14, 0xc8, 0x49, 0x8d, 0xef, 0xa0, 0xb3, 0x32, 0x12, 0x09, 0x4c, 0x9e, 0x08, 0x5e,
	0x99, 0xa7, 0x82, 0x95, 0x79, 0x2a, 0x08, 0xa1, 0x67, 0xcc, 0xcf, 0xbd, 0xd8, 0xe7, 0x68, 0x2d,
	0x8c, 0x22, 0x71, 0xc4, 0x55, 0x10, 0xda, 0x52, 0x77, 0x43, 0xec, 0x66, 0x1a, 0x4f, 0x4b, 0xb9,
	0xc6, 0x57, 0xac, 0xd3, 0x94, 0xf0, 0xea, 0x1d, 0x73, 0xc1, 0xf5, 0x74, 0x74, 0xf2, 0x02, 0x91,
	0x93, 0x49, 0x98, 0x8a, 0x58, 0xb5, 0x2f, 0x10, 0x03, 0xca, 0x17, 0x88, 0x69, 0x12, 0x6a, 0x71,
	0xe5, 0xca, 0x6e, 0xfe, 0xe3, 0x2b, 0xdb, 0x7f, 0x1f, 0xad, 0x3c, 0x1d, 0x88, 0xe8, 0xb0, 0x7e,
	0xec, 0xbc, 0x91, 0x69, 0x5c, 0xe3, 0xb9, 0xc6, 0x97, 0xac, 0x41, 0x95, 0x12, 0x7a, 0xde, 0x34,
	0x6b, 0xa7, 0xcc, 0xf7, 0x0d, 0xf4, 0xbf, 0x7a, 0x1a, 0x28, 0x7c, 0x06, 0xd1, 0x71, 0x1a, 0xcc,
	0xb1, 0xf3, 0x9f, 0xca, 0x04, 0x45, 0x17, 0x92, 0x54, 0x24, 0x42, 0x42, 0x1c, 0x54, 0x53, 0x62,
	0x9e, 0x97, 0x75, 0xa5, 0x7c, 0x5e, 0xd6, 0x39, 0xa1, 0xab, 0x05, 0x30, 0x4b, 0x32, 0xf1, 0x8c,
	0x5c, 0x75, 0x3a, 0xcf, 0x66, 0xe9, 0x59, 0x57, 0x4a, 0xcf, 0x3a, 0x27, 0x74, 0xb5, 0x00, 0xfb,
	0x45, 0x01, 0xb8, 0xbd, 0xb3, 0xfc, 0x6f, 0xf7, 0xce, 0xd7, 0x0d, 0xb4, 0x65, 0x92, 0x76, 0x57,
	0x70, 0x09, 0x5c, 0x1e, 0xc9, 0xc7, 0x90, 0xb2, 0x03, 0x16, 0x99, 0x6c, 0xdd, 0x0f, 0xd9, 0xe0,
	0x84, 0xbb, 0x67, 0x76, 0x0d, 0x97, 0x16, 0xb0, 0x86, 0x8d, 0x13, 0xaf, 0xe1, 0x13, 0xb4, 0x6e,
	0x84, 0x20, 0x66, 0x07, 0x07, 0x90, 0x02, 0x8f, 0x6c, 0x66, 0x96, 0xed, 0xd9, 0x36, 0xad, 0x95,
	0x67, 0xdb, 0xb4, 0x42, 0xe8, 0x9a, 0x41, 0xf7, 0x8e, 0xc9, 0x09, 0xf2, 0xb3, 0xfb, 0xe8, 0xa7,
	0x17, 0x6d, 0xef, 0xf9, 0x8b, 0xb6, 0xf7, 0xfb, 0x8b, 0xb6, 0xf7, 0xe5, 0xcb, 0xf6, 0xa9, 0xe7,
	0x2f, 0xdb, 0xa7, 0x7e, 0x7b, 0xd9, 0x3e, 0xf5, 0xe4, 0x76, 0x8f, 0xa9, 0xfe, 0xd1, 0xd3, 0xed,
	0x48, 0x0c, 0x3b, 0x95, 0xaf, 0xdc, 0xca, 0x4f, 0x19, 0x1f, 0x76, 0x7a, 0xa2, 0xc3, 0x45, 0x5c,
	0xfd, 0xf8, 0x7d, 0x7a, 0xda, 0x7c, 0xae, 0xde, 0xfa, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x42,
	0xb6, 0x41, 0x1c, 0x0f, 0x00, 0x00,
}

func (this *EventEnclaveIdentityRegistered) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventEnclaveIdentityRegistered)
	if !ok {
		that2, ok := that.(EventEnclaveIdentityRegistered)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.TeeType != that1.TeeType {
		return false
	}
	if this.MeasurementHash != that1.MeasurementHash {
		return false
	}
	if this.EncryptionKeyId != that1.EncryptionKeyId {
		return false
	}
	if this.SigningKeyId != that1.SigningKeyId {
		return false
	}
	if this.Epoch != that1.Epoch {
		return false
	}
	if this.ExpiryHeight != that1.ExpiryHeight {
		return false
	}
	return true
}
func (this *EventEnclaveIdentityUpdated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventEnclaveIdentityUpdated)
	if !ok {
		that2, ok := that.(EventEnclaveIdentityUpdated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *EventEnclaveIdentityRevoked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventEnclaveIdentityRevoked)
	if !ok {
		that2, ok := that.(EventEnclaveIdentityRevoked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *EventEnclaveIdentityExpired) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventEnclaveIdentityExpired)
	if !ok {
		that2, ok := that.(EventEnclaveIdentityExpired)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.ExpiryHeight != that1.ExpiryHeight {
		return false
	}
	return true
}
func (this *EventEnclaveKeyRotated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventEnclaveKeyRotated)
	if !ok {
		that2, ok := that.(EventEnclaveKeyRotated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.OldKeyFingerprint != that1.OldKeyFingerprint {
		return false
	}
	if this.NewKeyFingerprint != that1.NewKeyFingerprint {
		return false
	}
	if this.OverlapStartHeight != that1.OverlapStartHeight {
		return false
	}
	if this.OverlapEndHeight != that1.OverlapEndHeight {
		return false
	}
	return true
}
func (this *EventKeyRotationCompleted) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventKeyRotationCompleted)
	if !ok {
		that2, ok := that.(EventKeyRotationCompleted)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Validator != that1.Validator {
		return false
	}
	if this.NewKeyFingerprint != that1.NewKeyFingerprint {
		return false
	}
	return true
}
func (this *EventMeasurementAdded) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventMeasurementAdded)
	if !ok {
		that2, ok := that.(EventMeasurementAdded)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MeasurementHash != that1.MeasurementHash {
		return false
	}
	if this.TeeType != that1.TeeType {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.MinIsvSvn != that1.MinIsvSvn {
		return false
	}
	return true
}
func (this *EventMeasurementRevoked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventMeasurementRevoked)
	if !ok {
		that2, ok := that.(EventMeasurementRevoked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MeasurementHash != that1.MeasurementHash {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *EventVEIDScoreComputedAttested) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventVEIDScoreComputedAttested)
	if !ok {
		that2, ok := that.(EventVEIDScoreComputedAttested)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	return true
}
func (this *EventVEIDScoreRejectedAttestation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventVEIDScoreRejectedAttestation)
	if !ok {
		that2, ok := that.(EventVEIDScoreRejectedAttestation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.ProposedScore != that1.ProposedScore {
		return false
	}
	if this.ComputedScore != that1.ComputedScore {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *EventConsensusVerificationFailed) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventConsensusVerificationFailed)
	if !ok {
		that2, ok := that.(EventConsensusVerificationFailed)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.ProposedScore != that1.ProposedScore {
		return false
	}
	if this.ComputedScore != that1.ComputedScore {
		return false
	}
	if this.ScoreDifference != that1.ScoreDifference {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (m *EventEnclaveIdentityRegistered) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEnclaveIdentityRegistered) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEnclaveIdentityRegistered) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.Epoch != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x30
	}
	if len(m.SigningKeyId) > 0 {
		i -= len(m.SigningKeyId)
		copy(dAtA[i:], m.SigningKeyId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.SigningKeyId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.EncryptionKeyId) > 0 {
		i -= len(m.EncryptionKeyId)
		copy(dAtA[i:], m.EncryptionKeyId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.EncryptionKeyId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TeeType) > 0 {
		i -= len(m.TeeType)
		copy(dAtA[i:], m.TeeType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TeeType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEnclaveIdentityUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEnclaveIdentityUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEnclaveIdentityUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEnclaveIdentityRevoked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEnclaveIdentityRevoked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEnclaveIdentityRevoked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEnclaveIdentityExpired) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEnclaveIdentityExpired) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEnclaveIdentityExpired) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventEnclaveKeyRotated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventEnclaveKeyRotated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventEnclaveKeyRotated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapEndHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OverlapEndHeight))
		i--
		dAtA[i] = 0x28
	}
	if m.OverlapStartHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.OverlapStartHeight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.NewKeyFingerprint) > 0 {
		i -= len(m.NewKeyFingerprint)
		copy(dAtA[i:], m.NewKeyFingerprint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewKeyFingerprint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OldKeyFingerprint) > 0 {
		i -= len(m.OldKeyFingerprint)
		copy(dAtA[i:], m.OldKeyFingerprint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.OldKeyFingerprint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventKeyRotationCompleted) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventKeyRotationCompleted) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventKeyRotationCompleted) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewKeyFingerprint) > 0 {
		i -= len(m.NewKeyFingerprint)
		copy(dAtA[i:], m.NewKeyFingerprint)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.NewKeyFingerprint)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Validator) > 0 {
		i -= len(m.Validator)
		copy(dAtA[i:], m.Validator)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Validator)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMeasurementAdded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMeasurementAdded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMeasurementAdded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinIsvSvn != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.MinIsvSvn))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TeeType) > 0 {
		i -= len(m.TeeType)
		copy(dAtA[i:], m.TeeType)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TeeType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventMeasurementRevoked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventMeasurementRevoked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventMeasurementRevoked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVEIDScoreComputedAttested) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVEIDScoreComputedAttested) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVEIDScoreComputedAttested) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Status) > 0 {
		i -= len(m.Status)
		copy(dAtA[i:], m.Status)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Status)))
		i--
		dAtA[i] = 0x22
	}
	if m.Score != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventVEIDScoreRejectedAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventVEIDScoreRejectedAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventVEIDScoreRejectedAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ComputedScore != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ComputedScore))
		i--
		dAtA[i] = 0x20
	}
	if m.ProposedScore != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposedScore))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventConsensusVerificationFailed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventConsensusVerificationFailed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventConsensusVerificationFailed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if m.ScoreDifference != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ScoreDifference))
		i--
		dAtA[i] = 0x20
	}
	if m.ComputedScore != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ComputedScore))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposedScore != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.ProposedScore))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventEnclaveIdentityRegistered) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TeeType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.EncryptionKeyId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.SigningKeyId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovEvents(uint64(m.Epoch))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovEvents(uint64(m.ExpiryHeight))
	}
	return n
}

func (m *EventEnclaveIdentityUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventEnclaveIdentityRevoked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventEnclaveIdentityExpired) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovEvents(uint64(m.ExpiryHeight))
	}
	return n
}

func (m *EventEnclaveKeyRotated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.OldKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.OverlapStartHeight != 0 {
		n += 1 + sovEvents(uint64(m.OverlapStartHeight))
	}
	if m.OverlapEndHeight != 0 {
		n += 1 + sovEvents(uint64(m.OverlapEndHeight))
	}
	return n
}

func (m *EventKeyRotationCompleted) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Validator)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.NewKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventMeasurementAdded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TeeType)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.MinIsvSvn != 0 {
		n += 1 + sovEvents(uint64(m.MinIsvSvn))
	}
	return n
}

func (m *EventMeasurementRevoked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventVEIDScoreComputedAttested) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovEvents(uint64(m.Score))
	}
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovEvents(uint64(m.BlockHeight))
	}
	return n
}

func (m *EventVEIDScoreRejectedAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProposedScore != 0 {
		n += 1 + sovEvents(uint64(m.ProposedScore))
	}
	if m.ComputedScore != 0 {
		n += 1 + sovEvents(uint64(m.ComputedScore))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func (m *EventConsensusVerificationFailed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.ProposedScore != 0 {
		n += 1 + sovEvents(uint64(m.ProposedScore))
	}
	if m.ComputedScore != 0 {
		n += 1 + sovEvents(uint64(m.ComputedScore))
	}
	if m.ScoreDifference != 0 {
		n += 1 + sovEvents(uint64(m.ScoreDifference))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventEnclaveIdentityRegistered) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEnclaveIdentityRegistered: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEnclaveIdentityRegistered: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningKeyId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningKeyId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEnclaveIdentityUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEnclaveIdentityUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEnclaveIdentityUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEnclaveIdentityRevoked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEnclaveIdentityRevoked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEnclaveIdentityRevoked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEnclaveIdentityExpired) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEnclaveIdentityExpired: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEnclaveIdentityExpired: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventEnclaveKeyRotated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventEnclaveKeyRotated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventEnclaveKeyRotated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapStartHeight", wireType)
			}
			m.OverlapStartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapStartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapEndHeight", wireType)
			}
			m.OverlapEndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapEndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventKeyRotationCompleted) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventKeyRotationCompleted: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventKeyRotationCompleted: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMeasurementAdded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMeasurementAdded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMeasurementAdded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TeeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIsvSvn", wireType)
			}
			m.MinIsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinIsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventMeasurementRevoked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventMeasurementRevoked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventMeasurementRevoked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVEIDScoreComputedAttested) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVEIDScoreComputedAttested: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVEIDScoreComputedAttested: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventVEIDScoreRejectedAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventVEIDScoreRejectedAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventVEIDScoreRejectedAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedScore", wireType)
			}
			m.ProposedScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputedScore", wireType)
			}
			m.ComputedScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputedScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventConsensusVerificationFailed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventConsensusVerificationFailed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventConsensusVerificationFailed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedScore", wireType)
			}
			m.ProposedScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ComputedScore", wireType)
			}
			m.ComputedScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ComputedScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreDifference", wireType)
			}
			m.ScoreDifference = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreDifference |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)

