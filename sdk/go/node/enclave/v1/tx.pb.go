// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/enclave/v1/tx.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// MsgRegisterEnclaveIdentity registers a new enclave identity for a validator
type MsgRegisterEnclaveIdentity struct {
	// ValidatorAddress is the validator operator address (sender must be the validator operator)
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// TEEType is the type of TEE
	TeeType TEEType `protobuf:"varint,2,opt,name=tee_type,json=teeType,proto3,enum=virtengine.enclave.v1.TEEType" json:"tee_type" yaml:"tee_type"`
	// MeasurementHash is the enclave measurement hash
	MeasurementHash []byte `protobuf:"bytes,3,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// SignerHash is the signer measurement (MRSIGNER)
	SignerHash []byte `protobuf:"bytes,4,opt,name=signer_hash,json=signerHash,proto3" json:"signer_hash,omitempty" yaml:"signer_hash"`
	// EncryptionPubKey is the enclave's public key for encryption
	EncryptionPubKey []byte `protobuf:"bytes,5,opt,name=encryption_pub_key,json=encryptionPubKey,proto3" json:"encryption_pub_key" yaml:"encryption_pub_key"`
	// SigningPubKey is the enclave's public key for signing
	SigningPubKey []byte `protobuf:"bytes,6,opt,name=signing_pub_key,json=signingPubKey,proto3" json:"signing_pub_key" yaml:"signing_pub_key"`
	// AttestationQuote is the raw attestation quote
	AttestationQuote []byte `protobuf:"bytes,7,opt,name=attestation_quote,json=attestationQuote,proto3" json:"attestation_quote" yaml:"attestation_quote"`
	// AttestationChain is the certificate chain
	AttestationChain [][]byte `protobuf:"bytes,8,rep,name=attestation_chain,json=attestationChain,proto3" json:"attestation_chain" yaml:"attestation_chain"`
	// ISVProdID is the product ID
	IsvProdId uint32 `protobuf:"varint,9,opt,name=isv_prod_id,json=isvProdId,proto3" json:"isv_prod_id" yaml:"isv_prod_id"`
	// ISVSVN is the security version number
	IsvSvn uint32 `protobuf:"varint,10,opt,name=isv_svn,json=isvSvn,proto3" json:"isv_svn" yaml:"isv_svn"`
	// QuoteVersion is the quote format version
	QuoteVersion uint32 `protobuf:"varint,11,opt,name=quote_version,json=quoteVersion,proto3" json:"quote_version" yaml:"quote_version"`
}

func (m *MsgRegisterEnclaveIdentity) Reset()         { *m = MsgRegisterEnclaveIdentity{} }
func (m *MsgRegisterEnclaveIdentity) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterEnclaveIdentity) ProtoMessage()    {}
func (*MsgRegisterEnclaveIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{0}
}
func (m *MsgRegisterEnclaveIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterEnclaveIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterEnclaveIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterEnclaveIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterEnclaveIdentity.Merge(m, src)
}
func (m *MsgRegisterEnclaveIdentity) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterEnclaveIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterEnclaveIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterEnclaveIdentity proto.InternalMessageInfo

func (m *MsgRegisterEnclaveIdentity) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgRegisterEnclaveIdentity) GetTeeType() TEEType {
	if m != nil {
		return m.TeeType
	}
	return TEETypeUnspecified
}

func (m *MsgRegisterEnclaveIdentity) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetSignerHash() []byte {
	if m != nil {
		return m.SignerHash
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetEncryptionPubKey() []byte {
	if m != nil {
		return m.EncryptionPubKey
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetSigningPubKey() []byte {
	if m != nil {
		return m.SigningPubKey
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetAttestationQuote() []byte {
	if m != nil {
		return m.AttestationQuote
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetAttestationChain() [][]byte {
	if m != nil {
		return m.AttestationChain
	}
	return nil
}

func (m *MsgRegisterEnclaveIdentity) GetIsvProdId() uint32 {
	if m != nil {
		return m.IsvProdId
	}
	return 0
}

func (m *MsgRegisterEnclaveIdentity) GetIsvSvn() uint32 {
	if m != nil {
		return m.IsvSvn
	}
	return 0
}

func (m *MsgRegisterEnclaveIdentity) GetQuoteVersion() uint32 {
	if m != nil {
		return m.QuoteVersion
	}
	return 0
}

// MsgRegisterEnclaveIdentityResponse is the response for MsgRegisterEnclaveIdentity
type MsgRegisterEnclaveIdentityResponse struct {
	// KeyFingerprint is the fingerprint of the registered key
	KeyFingerprint string `protobuf:"bytes,1,opt,name=key_fingerprint,json=keyFingerprint,proto3" json:"key_fingerprint" yaml:"key_fingerprint"`
	// ExpiryHeight is the block height when the identity expires
	ExpiryHeight int64 `protobuf:"varint,2,opt,name=expiry_height,json=expiryHeight,proto3" json:"expiry_height" yaml:"expiry_height"`
}

func (m *MsgRegisterEnclaveIdentityResponse) Reset()         { *m = MsgRegisterEnclaveIdentityResponse{} }
func (m *MsgRegisterEnclaveIdentityResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterEnclaveIdentityResponse) ProtoMessage()    {}
func (*MsgRegisterEnclaveIdentityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{1}
}
func (m *MsgRegisterEnclaveIdentityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterEnclaveIdentityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterEnclaveIdentityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterEnclaveIdentityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterEnclaveIdentityResponse.Merge(m, src)
}
func (m *MsgRegisterEnclaveIdentityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterEnclaveIdentityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterEnclaveIdentityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterEnclaveIdentityResponse proto.InternalMessageInfo

func (m *MsgRegisterEnclaveIdentityResponse) GetKeyFingerprint() string {
	if m != nil {
		return m.KeyFingerprint
	}
	return ""
}

func (m *MsgRegisterEnclaveIdentityResponse) GetExpiryHeight() int64 {
	if m != nil {
		return m.ExpiryHeight
	}
	return 0
}

// MsgRotateEnclaveIdentity initiates a key rotation for a validator's enclave
type MsgRotateEnclaveIdentity struct {
	// ValidatorAddress is the validator operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// NewEncryptionPubKey is the new enclave encryption public key
	NewEncryptionPubKey []byte `protobuf:"bytes,2,opt,name=new_encryption_pub_key,json=newEncryptionPubKey,proto3" json:"new_encryption_pub_key" yaml:"new_encryption_pub_key"`
	// NewSigningPubKey is the new enclave signing public key
	NewSigningPubKey []byte `protobuf:"bytes,3,opt,name=new_signing_pub_key,json=newSigningPubKey,proto3" json:"new_signing_pub_key" yaml:"new_signing_pub_key"`
	// NewAttestationQuote is the new attestation quote
	NewAttestationQuote []byte `protobuf:"bytes,4,opt,name=new_attestation_quote,json=newAttestationQuote,proto3" json:"new_attestation_quote" yaml:"new_attestation_quote"`
	// NewAttestationChain is the new certificate chain
	NewAttestationChain [][]byte `protobuf:"bytes,5,rep,name=new_attestation_chain,json=newAttestationChain,proto3" json:"new_attestation_chain" yaml:"new_attestation_chain"`
	// NewMeasurementHash is the new measurement hash (if enclave was upgraded)
	NewMeasurementHash []byte `protobuf:"bytes,6,opt,name=new_measurement_hash,json=newMeasurementHash,proto3" json:"new_measurement_hash,omitempty" yaml:"new_measurement_hash"`
	// NewISVSVN is the new security version
	NewIsvSvn uint32 `protobuf:"varint,7,opt,name=new_isv_svn,json=newIsvSvn,proto3" json:"new_isv_svn" yaml:"new_isv_svn"`
	// OverlapBlocks is the number of blocks for which both keys are valid
	OverlapBlocks int64 `protobuf:"varint,8,opt,name=overlap_blocks,json=overlapBlocks,proto3" json:"overlap_blocks" yaml:"overlap_blocks"`
}

func (m *MsgRotateEnclaveIdentity) Reset()         { *m = MsgRotateEnclaveIdentity{} }
func (m *MsgRotateEnclaveIdentity) String() string { return proto.CompactTextString(m) }
func (*MsgRotateEnclaveIdentity) ProtoMessage()    {}
func (*MsgRotateEnclaveIdentity) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{2}
}
func (m *MsgRotateEnclaveIdentity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRotateEnclaveIdentity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRotateEnclaveIdentity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRotateEnclaveIdentity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRotateEnclaveIdentity.Merge(m, src)
}
func (m *MsgRotateEnclaveIdentity) XXX_Size() int {
	return m.Size()
}
func (m *MsgRotateEnclaveIdentity) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRotateEnclaveIdentity.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRotateEnclaveIdentity proto.InternalMessageInfo

func (m *MsgRotateEnclaveIdentity) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgRotateEnclaveIdentity) GetNewEncryptionPubKey() []byte {
	if m != nil {
		return m.NewEncryptionPubKey
	}
	return nil
}

func (m *MsgRotateEnclaveIdentity) GetNewSigningPubKey() []byte {
	if m != nil {
		return m.NewSigningPubKey
	}
	return nil
}

func (m *MsgRotateEnclaveIdentity) GetNewAttestationQuote() []byte {
	if m != nil {
		return m.NewAttestationQuote
	}
	return nil
}

func (m *MsgRotateEnclaveIdentity) GetNewAttestationChain() [][]byte {
	if m != nil {
		return m.NewAttestationChain
	}
	return nil
}

func (m *MsgRotateEnclaveIdentity) GetNewMeasurementHash() []byte {
	if m != nil {
		return m.NewMeasurementHash
	}
	return nil
}

func (m *MsgRotateEnclaveIdentity) GetNewIsvSvn() uint32 {
	if m != nil {
		return m.NewIsvSvn
	}
	return 0
}

func (m *MsgRotateEnclaveIdentity) GetOverlapBlocks() int64 {
	if m != nil {
		return m.OverlapBlocks
	}
	return 0
}

// MsgRotateEnclaveIdentityResponse is the response for MsgRotateEnclaveIdentity
type MsgRotateEnclaveIdentityResponse struct {
	// NewKeyFingerprint is the fingerprint of the new key
	NewKeyFingerprint string `protobuf:"bytes,1,opt,name=new_key_fingerprint,json=newKeyFingerprint,proto3" json:"new_key_fingerprint" yaml:"new_key_fingerprint"`
	// OverlapStartHeight is when both keys become valid
	OverlapStartHeight int64 `protobuf:"varint,2,opt,name=overlap_start_height,json=overlapStartHeight,proto3" json:"overlap_start_height" yaml:"overlap_start_height"`
	// OverlapEndHeight is when the old key becomes invalid
	OverlapEndHeight int64 `protobuf:"varint,3,opt,name=overlap_end_height,json=overlapEndHeight,proto3" json:"overlap_end_height" yaml:"overlap_end_height"`
}

func (m *MsgRotateEnclaveIdentityResponse) Reset()         { *m = MsgRotateEnclaveIdentityResponse{} }
func (m *MsgRotateEnclaveIdentityResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRotateEnclaveIdentityResponse) ProtoMessage()    {}
func (*MsgRotateEnclaveIdentityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{3}
}
func (m *MsgRotateEnclaveIdentityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRotateEnclaveIdentityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRotateEnclaveIdentityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRotateEnclaveIdentityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRotateEnclaveIdentityResponse.Merge(m, src)
}
func (m *MsgRotateEnclaveIdentityResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRotateEnclaveIdentityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRotateEnclaveIdentityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRotateEnclaveIdentityResponse proto.InternalMessageInfo

func (m *MsgRotateEnclaveIdentityResponse) GetNewKeyFingerprint() string {
	if m != nil {
		return m.NewKeyFingerprint
	}
	return ""
}

func (m *MsgRotateEnclaveIdentityResponse) GetOverlapStartHeight() int64 {
	if m != nil {
		return m.OverlapStartHeight
	}
	return 0
}

func (m *MsgRotateEnclaveIdentityResponse) GetOverlapEndHeight() int64 {
	if m != nil {
		return m.OverlapEndHeight
	}
	return 0
}

// MsgProposeMeasurement proposes a new enclave measurement for the allowlist
type MsgProposeMeasurement struct {
	// Authority is the governance authority address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// MeasurementHash is the enclave measurement hash to add
	MeasurementHash []byte `protobuf:"bytes,2,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// TEEType is the TEE type this measurement is for
	TeeType TEEType `protobuf:"varint,3,opt,name=tee_type,json=teeType,proto3,enum=virtengine.enclave.v1.TEEType" json:"tee_type" yaml:"tee_type"`
	// Description is a human-readable description
	Description string `protobuf:"bytes,4,opt,name=description,proto3" json:"description" yaml:"description"`
	// MinISVSVN is the minimum required security version
	MinIsvSvn uint32 `protobuf:"varint,5,opt,name=min_isv_svn,json=minIsvSvn,proto3" json:"min_isv_svn" yaml:"min_isv_svn"`
	// ExpiryBlocks is the number of blocks until expiry (0 for no expiry)
	ExpiryBlocks int64 `protobuf:"varint,6,opt,name=expiry_blocks,json=expiryBlocks,proto3" json:"expiry_blocks,omitempty" yaml:"expiry_blocks"`
}

func (m *MsgProposeMeasurement) Reset()         { *m = MsgProposeMeasurement{} }
func (m *MsgProposeMeasurement) String() string { return proto.CompactTextString(m) }
func (*MsgProposeMeasurement) ProtoMessage()    {}
func (*MsgProposeMeasurement) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{4}
}
func (m *MsgProposeMeasurement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeMeasurement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeMeasurement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeMeasurement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeMeasurement.Merge(m, src)
}
func (m *MsgProposeMeasurement) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeMeasurement) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeMeasurement.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeMeasurement proto.InternalMessageInfo

func (m *MsgProposeMeasurement) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgProposeMeasurement) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *MsgProposeMeasurement) GetTeeType() TEEType {
	if m != nil {
		return m.TeeType
	}
	return TEETypeUnspecified
}

func (m *MsgProposeMeasurement) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MsgProposeMeasurement) GetMinIsvSvn() uint32 {
	if m != nil {
		return m.MinIsvSvn
	}
	return 0
}

func (m *MsgProposeMeasurement) GetExpiryBlocks() int64 {
	if m != nil {
		return m.ExpiryBlocks
	}
	return 0
}

// MsgProposeMeasurementResponse is the response for MsgProposeMeasurement
type MsgProposeMeasurementResponse struct {
	// MeasurementHash is the hash of the added measurement (hex-encoded)
	MeasurementHash string `protobuf:"bytes,1,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
}

func (m *MsgProposeMeasurementResponse) Reset()         { *m = MsgProposeMeasurementResponse{} }
func (m *MsgProposeMeasurementResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeMeasurementResponse) ProtoMessage()    {}
func (*MsgProposeMeasurementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{5}
}
func (m *MsgProposeMeasurementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeMeasurementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeMeasurementResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeMeasurementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeMeasurementResponse.Merge(m, src)
}
func (m *MsgProposeMeasurementResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeMeasurementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeMeasurementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeMeasurementResponse proto.InternalMessageInfo

func (m *MsgProposeMeasurementResponse) GetMeasurementHash() string {
	if m != nil {
		return m.MeasurementHash
	}
	return ""
}

// MsgRevokeMeasurement revokes an enclave measurement from the allowlist
type MsgRevokeMeasurement struct {
	// Authority is the governance authority address
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// MeasurementHash is the enclave measurement hash to revoke
	MeasurementHash []byte `protobuf:"bytes,2,opt,name=measurement_hash,json=measurementHash,proto3" json:"measurement_hash" yaml:"measurement_hash"`
	// Reason is the reason for revocation
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *MsgRevokeMeasurement) Reset()         { *m = MsgRevokeMeasurement{} }
func (m *MsgRevokeMeasurement) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeMeasurement) ProtoMessage()    {}
func (*MsgRevokeMeasurement) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{6}
}
func (m *MsgRevokeMeasurement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeMeasurement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeMeasurement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeMeasurement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeMeasurement.Merge(m, src)
}
func (m *MsgRevokeMeasurement) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeMeasurement) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeMeasurement.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeMeasurement proto.InternalMessageInfo

func (m *MsgRevokeMeasurement) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRevokeMeasurement) GetMeasurementHash() []byte {
	if m != nil {
		return m.MeasurementHash
	}
	return nil
}

func (m *MsgRevokeMeasurement) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRevokeMeasurementResponse is the response for MsgRevokeMeasurement
type MsgRevokeMeasurementResponse struct {
}

func (m *MsgRevokeMeasurementResponse) Reset()         { *m = MsgRevokeMeasurementResponse{} }
func (m *MsgRevokeMeasurementResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeMeasurementResponse) ProtoMessage()    {}
func (*MsgRevokeMeasurementResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{7}
}
func (m *MsgRevokeMeasurementResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeMeasurementResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeMeasurementResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeMeasurementResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeMeasurementResponse.Merge(m, src)
}
func (m *MsgRevokeMeasurementResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeMeasurementResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeMeasurementResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeMeasurementResponse proto.InternalMessageInfo

// MsgUpdateParams is the message for updating module parameters
type MsgUpdateParams struct {
	// Authority is the address that controls the module (x/gov module account)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// Params are the new module parameters
	Params Params `protobuf:"bytes,2,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *MsgUpdateParams) Reset()         { *m = MsgUpdateParams{} }
func (m *MsgUpdateParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParams) ProtoMessage()    {}
func (*MsgUpdateParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{8}
}
func (m *MsgUpdateParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParams.Merge(m, src)
}
func (m *MsgUpdateParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParams proto.InternalMessageInfo

func (m *MsgUpdateParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateParams) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// MsgUpdateParamsResponse is the response for MsgUpdateParams
type MsgUpdateParamsResponse struct {
}

func (m *MsgUpdateParamsResponse) Reset()         { *m = MsgUpdateParamsResponse{} }
func (m *MsgUpdateParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateParamsResponse) ProtoMessage()    {}
func (*MsgUpdateParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_19832e20f2c64e0a, []int{9}
}
func (m *MsgUpdateParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateParamsResponse.Merge(m, src)
}
func (m *MsgUpdateParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateParamsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*MsgRegisterEnclaveIdentity)(nil), "virtengine.enclave.v1.MsgRegisterEnclaveIdentity")
	proto.RegisterType((*MsgRegisterEnclaveIdentityResponse)(nil), "virtengine.enclave.v1.MsgRegisterEnclaveIdentityResponse")
	proto.RegisterType((*MsgRotateEnclaveIdentity)(nil), "virtengine.enclave.v1.MsgRotateEnclaveIdentity")
	proto.RegisterType((*MsgRotateEnclaveIdentityResponse)(nil), "virtengine.enclave.v1.MsgRotateEnclaveIdentityResponse")
	proto.RegisterType((*MsgProposeMeasurement)(nil), "virtengine.enclave.v1.MsgProposeMeasurement")
	proto.RegisterType((*MsgProposeMeasurementResponse)(nil), "virtengine.enclave.v1.MsgProposeMeasurementResponse")
	proto.RegisterType((*MsgRevokeMeasurement)(nil), "virtengine.enclave.v1.MsgRevokeMeasurement")
	proto.RegisterType((*MsgRevokeMeasurementResponse)(nil), "virtengine.enclave.v1.MsgRevokeMeasurementResponse")
	proto.RegisterType((*MsgUpdateParams)(nil), "virtengine.enclave.v1.MsgUpdateParams")
	proto.RegisterType((*MsgUpdateParamsResponse)(nil), "virtengine.enclave.v1.MsgUpdateParamsResponse")
}

func init() { proto.RegisterFile("virtengine/enclave/v1/tx.proto", fileDescriptor_19832e20f2c64e0a) }

var fileDescriptor_19832e20f2c64e0a = []byte{
	// 1465 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4b, 0x6f, 0x1c, 0xc5,
	0x16, 0xf6, 0xd8, 0xf1, 0x63, 0xca, 0xef, 0xbe, 0x76, 0x3c, 0x99, 0xc4, 0x53, 0xbe, 0x25, 0xdd,
	0x2b, 0x93, 0xc7, 0x8c, 0x1c, 0x07, 0xa2, 0x98, 0x05, 0xf2, 0x20, 0x43, 0xac, 0xc8, 0xc8, 0x69,
	0x27, 0x01, 0x65, 0xc1, 0xa8, 0xed, 0xae, 0xf4, 0xb4, 0xec, 0xa9, 0x6e, 0xba, 0x6a, 0xda, 0x19,
	0xb1, 0x01, 0x36, 0x48, 0xac, 0xd8, 0xb2, 0x63, 0xcd, 0x2a, 0x0b, 0xf8, 0x0f, 0x59, 0xb0, 0x88,
	0xd8, 0xc0, 0xaa, 0x84, 0x92, 0x45, 0x50, 0x2f, 0x9b, 0x3f, 0x80, 0xba, 0xaa, 0xdf, 0xdd, 0x13,
	0x61, 0x11, 0x24, 0xd8, 0x44, 0xae, 0xef, 0x3b, 0x75, 0x4e, 0xf5, 0xa9, 0xfa, 0xbe, 0xaa, 0x0c,
	0x68, 0xb8, 0xa6, 0xc3, 0x30, 0x31, 0x4c, 0x82, 0x5b, 0x98, 0x1c, 0x9d, 0x68, 0x2e, 0x6e, 0xb9,
	0x1b, 0x2d, 0xf6, 0xb8, 0x69, 0x3b, 0x16, 0xb3, 0x94, 0xe5, 0x84, 0x6f, 0x86, 0x7c, 0xd3, 0xdd,
	0xa8, 0x2f, 0x19, 0x96, 0x61, 0x89, 0x88, 0x56, 0xf0, 0x97, 0x0c, 0xae, 0x5f, 0x38, 0xb2, 0x68,
	0xcf, 0xa2, 0x1d, 0x49, 0xc8, 0x41, 0x48, 0xad, 0xc8, 0x51, 0xab, 0x47, 0x8d, 0x20, 0x7f, 0x8f,
	0x1a, 0x21, 0xb1, 0xa8, 0xf5, 0x4c, 0x62, 0xb5, 0xc4, 0xbf, 0x21, 0xf4, 0xdf, 0x21, 0x6b, 0x1a,
	0xd8, 0x38, 0x4c, 0x87, 0xbe, 0x9b, 0x02, 0xf5, 0x3d, 0x6a, 0xa8, 0xd8, 0x30, 0x29, 0xc3, 0xce,
	0x8e, 0x8c, 0xda, 0xd5, 0x31, 0x61, 0x26, 0x1b, 0x28, 0x2e, 0x58, 0x74, 0xb5, 0x13, 0x53, 0xd7,
	0x98, 0xe5, 0x74, 0x34, 0x5d, 0x77, 0x30, 0xa5, 0xb5, 0xca, 0x5a, 0x65, 0xbd, 0xda, 0xde, 0xf5,
	0x38, 0x2c, 0x92, 0x3e, 0x87, 0xb5, 0x81, 0xd6, 0x3b, 0xd9, 0x42, 0x05, 0x0a, 0xfd, 0xf4, 0xfd,
	0xb5, 0xa5, 0xf0, 0x5b, 0xb6, 0x25, 0x74, 0xc0, 0x1c, 0x93, 0x18, 0xea, 0x42, 0x1c, 0x1b, 0xe2,
	0xca, 0x43, 0x30, 0xc5, 0x30, 0xee, 0x04, 0x2b, 0xad, 0x8d, 0xae, 0x55, 0xd6, 0xe7, 0xae, 0x37,
	0x9a, 0xa5, 0x0d, 0x6c, 0xde, 0xdb, 0xd9, 0xb9, 0x37, 0xb0, 0x71, 0x1b, 0x7a, 0x1c, 0xc6, 0x73,
	0x7c, 0x0e, 0xe7, 0xe5, 0x2a, 0x22, 0x04, 0xa9, 0x93, 0x0c, 0xe3, 0x20, 0x52, 0x79, 0x08, 0x16,
	0x7a, 0x58, 0xa3, 0x7d, 0x07, 0xf7, 0x30, 0x61, 0x9d, 0xae, 0x46, 0xbb, 0xb5, 0xb1, 0xb5, 0xca,
	0xfa, 0x4c, 0xbb, 0xe5, 0x71, 0x58, 0xe0, 0x7c, 0x0e, 0x57, 0x64, 0xae, 0x3c, 0x83, 0xd4, 0xf9,
	0x14, 0x74, 0x5b, 0xa3, 0x5d, 0x65, 0x1f, 0x4c, 0x53, 0xd3, 0x20, 0xd8, 0x91, 0x69, 0xcf, 0xc5,
	0x69, 0x97, 0x53, 0xf0, 0x55, 0xab, 0x67, 0x32, 0xdc, 0xb3, 0xd9, 0xc0, 0xe7, 0x50, 0x91, 0xb9,
	0x53, 0x34, 0x52, 0x81, 0x1c, 0x89, 0x8c, 0x1a, 0x50, 0x30, 0x39, 0x72, 0x06, 0x36, 0x33, 0x2d,
	0xd2, 0xb1, 0xfb, 0x87, 0x9d, 0x63, 0x3c, 0xa8, 0x8d, 0x8b, 0xc4, 0x9b, 0x1e, 0x87, 0x25, 0xac,
	0xcf, 0xe1, 0x05, 0x99, 0xb5, 0xc8, 0x21, 0x75, 0x21, 0x01, 0xf7, 0xfb, 0x87, 0x77, 0xf0, 0x40,
	0xb9, 0x0f, 0xe6, 0x83, 0x82, 0x26, 0x31, 0xe2, 0xfc, 0x13, 0x22, 0xff, 0x35, 0x8f, 0xc3, 0x3c,
	0xe5, 0x73, 0x78, 0x3e, 0x59, 0x72, 0x8a, 0x40, 0xea, 0x6c, 0x88, 0x84, 0x69, 0x3f, 0x06, 0x8b,
	0x1a, 0x63, 0x98, 0x32, 0x4d, 0x2c, 0xe0, 0x93, 0xbe, 0xc5, 0x70, 0x6d, 0x52, 0x24, 0xde, 0x08,
	0xce, 0x4e, 0x81, 0x4c, 0xce, 0x4e, 0x81, 0x42, 0xea, 0x42, 0x0a, 0xbb, 0x1b, 0x40, 0xf9, 0xfc,
	0x47, 0x5d, 0xcd, 0x24, 0xb5, 0xa9, 0xb5, 0xb1, 0xb2, 0xfc, 0x82, 0x2c, 0xcf, 0x2f, 0xa8, 0x6c,
	0xfe, 0x77, 0x03, 0x48, 0xd9, 0x01, 0xd3, 0x26, 0x75, 0x03, 0x0d, 0xea, 0x1d, 0x53, 0xaf, 0x55,
	0xd7, 0x2a, 0xeb, 0xb3, 0xed, 0xff, 0x79, 0x1c, 0xa6, 0xe1, 0x64, 0x07, 0x53, 0x20, 0x52, 0xab,
	0x26, 0x75, 0xf7, 0x1d, 0x4b, 0xdf, 0xd5, 0x95, 0xb7, 0xc0, 0x64, 0x40, 0x51, 0x97, 0xd4, 0x80,
	0x48, 0xb1, 0xea, 0x71, 0x18, 0x41, 0x3e, 0x87, 0x73, 0xc9, 0x74, 0xea, 0x12, 0xa4, 0x4e, 0x98,
	0xd4, 0x3d, 0x70, 0x89, 0xf2, 0x01, 0x98, 0x15, 0x9f, 0xde, 0x71, 0xb1, 0x43, 0x4d, 0x8b, 0xd4,
	0xa6, 0xc5, 0xec, 0x37, 0x3c, 0x0e, 0xb3, 0x84, 0xcf, 0xe1, 0x92, 0xcc, 0x91, 0x81, 0x91, 0x3a,
	0x23, 0xc6, 0x0f, 0xe4, 0x70, 0x6b, 0xfb, 0xb7, 0x6f, 0xe1, 0xc8, 0x17, 0x2f, 0x9f, 0x5c, 0x2e,
	0x8a, 0xf6, 0xab, 0x97, 0x4f, 0x2e, 0xa3, 0xc8, 0x20, 0x86, 0xbb, 0x01, 0xfa, 0xb1, 0x02, 0xd0,
	0x70, 0x5a, 0xc5, 0xd4, 0xb6, 0x08, 0xc5, 0xca, 0x03, 0x30, 0x7f, 0x8c, 0x07, 0x9d, 0x47, 0x26,
	0x31, 0xb0, 0x63, 0x3b, 0x26, 0x61, 0xa1, 0x65, 0x88, 0xf3, 0x94, 0xa3, 0x92, 0xf3, 0x94, 0x23,
	0x90, 0x3a, 0x77, 0x8c, 0x07, 0xef, 0x25, 0x40, 0xd0, 0x11, 0xfc, 0xd8, 0x36, 0x9d, 0x41, 0xa7,
	0x8b, 0x4d, 0xa3, 0xcb, 0x84, 0x33, 0x8c, 0xc9, 0x8e, 0x64, 0x88, 0xa4, 0x23, 0x19, 0x18, 0xa9,
	0x33, 0x72, 0x7c, 0x5b, 0x0e, 0xbf, 0x99, 0x04, 0xb5, 0xe0, 0x73, 0x2c, 0xa6, 0x31, 0xfc, 0x4f,
	0x71, 0x3e, 0x1b, 0x9c, 0x27, 0xf8, 0xb4, 0x53, 0xa2, 0xf9, 0x51, 0x21, 0x9d, 0xb7, 0x3d, 0x0e,
	0x87, 0x44, 0xf8, 0x1c, 0xae, 0xca, 0x15, 0x94, 0xf3, 0x48, 0xfd, 0x0f, 0xc1, 0xa7, 0x3b, 0x79,
	0xf9, 0xeb, 0x20, 0x80, 0x3b, 0x79, 0x0b, 0x90, 0x96, 0xf8, 0xa6, 0xc7, 0x61, 0x19, 0xed, 0x73,
	0x58, 0x4f, 0x6a, 0x15, 0xac, 0x60, 0x81, 0xe0, 0xd3, 0x83, 0x8c, 0x1b, 0xf4, 0xc0, 0x72, 0x10,
	0x59, 0x74, 0x04, 0xe9, 0x91, 0xb7, 0x02, 0x8f, 0x2c, 0x0d, 0xf0, 0x39, 0xbc, 0x94, 0x54, 0x2a,
	0x71, 0x86, 0x60, 0x79, 0xdb, 0x79, 0x73, 0x28, 0x29, 0x27, 0x0d, 0x62, 0x5c, 0x18, 0x44, 0x69,
	0xb9, 0xc8, 0x24, 0x86, 0x94, 0x0b, 0x8d, 0x22, 0x57, 0x4e, 0x7a, 0x05, 0x05, 0x4b, 0x41, 0x78,
	0xe1, 0x5e, 0x91, 0x3e, 0xba, 0xed, 0x71, 0xd8, 0x28, 0xe3, 0x33, 0x37, 0xc1, 0xc5, 0xa4, 0x6c,
	0xf1, 0xa6, 0x51, 0x08, 0x3e, 0xdd, 0xcb, 0x5d, 0x36, 0x3b, 0x60, 0x3a, 0x08, 0x8e, 0xdc, 0x65,
	0x32, 0x31, 0xa8, 0x14, 0x9c, 0x18, 0x54, 0x0a, 0x44, 0x6a, 0x95, 0xe0, 0xd3, 0x5d, 0x69, 0x34,
	0x2a, 0x98, 0xb3, 0x5c, 0xec, 0x9c, 0x68, 0x76, 0xe7, 0xf0, 0xc4, 0x3a, 0x3a, 0xa6, 0xb5, 0x29,
	0xa1, 0xab, 0x2b, 0x1e, 0x87, 0x39, 0xc6, 0xe7, 0x70, 0x59, 0x26, 0xcb, 0xe2, 0x48, 0x9d, 0x0d,
	0x81, 0xb6, 0x18, 0x6f, 0xbd, 0xf3, 0x6a, 0xb3, 0x59, 0x4b, 0x9b, 0x4d, 0x99, 0xfc, 0xd0, 0xcf,
	0xa3, 0x60, 0x6d, 0x18, 0x19, 0x1b, 0x0d, 0x96, 0x27, 0xb7, 0xdc, 0x6c, 0xe2, 0x93, 0x5b, 0x34,
	0x9c, 0xd4, 0xc9, 0x2d, 0x98, 0xce, 0x22, 0xc1, 0xa7, 0x77, 0xb2, 0xbe, 0x63, 0x82, 0xa5, 0xe8,
	0x73, 0x29, 0xd3, 0x1c, 0x96, 0xb5, 0x9f, 0x9b, 0x1e, 0x87, 0xa5, 0x7c, 0xb2, 0xa5, 0x65, 0x2c,
	0x52, 0x95, 0x10, 0x3e, 0x08, 0x50, 0x69, 0x49, 0xc1, 0x6d, 0x1f, 0x05, 0x63, 0xa2, 0x47, 0x85,
	0xc6, 0x44, 0x21, 0x71, 0xdb, 0x17, 0xd9, 0xe4, 0xb6, 0x2f, 0x72, 0x48, 0x5d, 0x08, 0xc1, 0x1d,
	0xa2, 0x87, 0xae, 0xf7, 0xf4, 0x1c, 0x58, 0xde, 0xa3, 0xc6, 0xbe, 0x63, 0xd9, 0x16, 0xc5, 0xa9,
	0x33, 0xa5, 0x7c, 0x08, 0xaa, 0x5a, 0x9f, 0x75, 0x2d, 0xc7, 0x64, 0x83, 0xb0, 0x89, 0x81, 0x4e,
	0x12, 0xd0, 0xe7, 0x70, 0x21, 0xbc, 0x40, 0x23, 0x68, 0xb8, 0xb5, 0x25, 0xd3, 0x4a, 0x5f, 0x5c,
	0xa3, 0xaf, 0xe9, 0xc5, 0x95, 0x7e, 0x29, 0x8e, 0xbd, 0xe6, 0x97, 0xe2, 0xfb, 0x60, 0x5a, 0xc7,
	0xf4, 0xc8, 0x31, 0x85, 0x5d, 0x0a, 0xa7, 0xaa, 0x4a, 0x81, 0xa5, 0xe0, 0x44, 0x60, 0x29, 0x10,
	0xa9, 0xe9, 0x90, 0x40, 0xa9, 0x3d, 0x93, 0xc4, 0x4a, 0x1d, 0x4f, 0x94, 0x9a, 0x82, 0x93, 0x44,
	0x29, 0x10, 0xa9, 0xd5, 0x9e, 0x49, 0x42, 0xa5, 0x7e, 0x14, 0x5f, 0x80, 0xa1, 0x50, 0x27, 0xe2,
	0x83, 0xb1, 0x92, 0x21, 0x32, 0xbe, 0x92, 0xbd, 0x0a, 0x23, 0xc1, 0x86, 0x57, 0x61, 0xa8, 0xd7,
	0x1b, 0x91, 0x5e, 0x93, 0x5d, 0x0b, 0x74, 0xba, 0x9a, 0xd2, 0x69, 0xf1, 0xc0, 0xa0, 0x4f, 0xc1,
	0x6a, 0x29, 0x11, 0x0b, 0xb4, 0x6c, 0xe3, 0xe5, 0xc1, 0xfa, 0xcb, 0x1b, 0x8f, 0x7e, 0x18, 0x05,
	0x4b, 0xe2, 0x31, 0xe2, 0x5a, 0xc7, 0xff, 0xfe, 0x63, 0xbc, 0x09, 0x26, 0x1c, 0xac, 0x51, 0x8b,
	0x88, 0x43, 0x5c, 0x6d, 0x5f, 0xf4, 0x38, 0x0c, 0x11, 0x9f, 0xc3, 0x59, 0x99, 0x47, 0x8e, 0x91,
	0x1a, 0x12, 0x5b, 0x9b, 0xe5, 0xbb, 0x76, 0x29, 0xf3, 0x94, 0xcb, 0xb5, 0x07, 0x35, 0xc0, 0xa5,
	0x32, 0x3c, 0xda, 0x33, 0xe4, 0x57, 0xc0, 0xfc, 0x1e, 0x35, 0xee, 0xdb, 0xba, 0xc6, 0xf0, 0xbe,
	0xe6, 0x68, 0x3d, 0xfa, 0xf7, 0xb5, 0xf4, 0x01, 0x98, 0xb0, 0x45, 0x09, 0xd1, 0xc8, 0xe9, 0xeb,
	0xab, 0x43, 0xb4, 0x2b, 0xd7, 0xd1, 0x86, 0x4f, 0x39, 0x1c, 0x09, 0x3a, 0x23, 0x27, 0x25, 0x9d,
	0x91, 0x63, 0xa4, 0x86, 0xc4, 0x56, 0xb3, 0xbc, 0x33, 0x2b, 0xa9, 0xce, 0xa4, 0x3f, 0x10, 0x5d,
	0x00, 0x2b, 0x39, 0x28, 0xea, 0xc7, 0xf5, 0xdf, 0xcf, 0x81, 0xb1, 0x3d, 0x6a, 0x28, 0x5f, 0x56,
	0xc0, 0xca, 0xb0, 0xff, 0x26, 0x6f, 0x0c, 0x59, 0xf6, 0xf0, 0xc7, 0x72, 0xfd, 0xd6, 0x99, 0xa7,
	0xc4, 0xaa, 0xfa, 0xbc, 0x02, 0x96, 0xcb, 0x1f, 0xad, 0xad, 0x57, 0x24, 0x2d, 0x9b, 0x50, 0xbf,
	0x79, 0xc6, 0x09, 0xf1, 0x1a, 0x1e, 0x03, 0xa5, 0xe4, 0x06, 0xb9, 0x3a, 0x3c, 0x5d, 0x31, 0xba,
	0x7e, 0xe3, 0x2c, 0xd1, 0x71, 0xe5, 0x3e, 0x58, 0x2c, 0x6a, 0xfe, 0xca, 0xab, 0xba, 0x99, 0x0b,
	0xae, 0x6f, 0x9e, 0x21, 0x38, 0x2e, 0xfb, 0x08, 0xcc, 0x64, 0x24, 0xf1, 0xff, 0xe1, 0x49, 0xd2,
	0x71, 0xf5, 0xe6, 0x9f, 0x8b, 0x8b, 0xea, 0xd4, 0xc7, 0x3f, 0x7b, 0xf9, 0xe4, 0x72, 0xa5, 0x7d,
	0xf7, 0xe9, 0xf3, 0x46, 0xe5, 0xd9, 0xf3, 0x46, 0xe5, 0xd7, 0xe7, 0x8d, 0xca, 0xd7, 0x2f, 0x1a,
	0x23, 0xcf, 0x5e, 0x34, 0x46, 0x7e, 0x79, 0xd1, 0x18, 0x79, 0x78, 0xd3, 0x30, 0x59, 0xb7, 0x7f,
	0xd8, 0x3c, 0xb2, 0x7a, 0xad, 0xd4, 0xef, 0x3b, 0xa9, 0x3f, 0xa9, 0x7e, 0xdc, 0x32, 0xac, 0x16,
	0xb1, 0xf4, 0xf4, 0xcf, 0x3e, 0x87, 0x13, 0xe2, 0x17, 0x9f, 0xcd, 0x3f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0xa1, 0x48, 0xb9, 0x7d, 0xaa, 0x12, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MsgClient is the client API for Msg service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MsgClient interface {
	// RegisterEnclaveIdentity registers a new enclave identity for a validator
	RegisterEnclaveIdentity(ctx context.Context, in *MsgRegisterEnclaveIdentity, opts ...grpc.CallOption) (*MsgRegisterEnclaveIdentityResponse, error)
	// RotateEnclaveIdentity initiates a key rotation for a validator's enclave
	RotateEnclaveIdentity(ctx context.Context, in *MsgRotateEnclaveIdentity, opts ...grpc.CallOption) (*MsgRotateEnclaveIdentityResponse, error)
	// ProposeMeasurement proposes a new enclave measurement for the allowlist
	ProposeMeasurement(ctx context.Context, in *MsgProposeMeasurement, opts ...grpc.CallOption) (*MsgProposeMeasurementResponse, error)
	// RevokeMeasurement revokes an enclave measurement from the allowlist
	RevokeMeasurement(ctx context.Context, in *MsgRevokeMeasurement, opts ...grpc.CallOption) (*MsgRevokeMeasurementResponse, error)
	// UpdateParams updates the module parameters (governance only)
	UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error)
}

type msgClient struct {
	cc grpc1.ClientConn
}

func NewMsgClient(cc grpc1.ClientConn) MsgClient {
	return &msgClient{cc}
}

func (c *msgClient) RegisterEnclaveIdentity(ctx context.Context, in *MsgRegisterEnclaveIdentity, opts ...grpc.CallOption) (*MsgRegisterEnclaveIdentityResponse, error) {
	out := new(MsgRegisterEnclaveIdentityResponse)
	err := c.cc.Invoke(ctx, "/virtengine.enclave.v1.Msg/RegisterEnclaveIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RotateEnclaveIdentity(ctx context.Context, in *MsgRotateEnclaveIdentity, opts ...grpc.CallOption) (*MsgRotateEnclaveIdentityResponse, error) {
	out := new(MsgRotateEnclaveIdentityResponse)
	err := c.cc.Invoke(ctx, "/virtengine.enclave.v1.Msg/RotateEnclaveIdentity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) ProposeMeasurement(ctx context.Context, in *MsgProposeMeasurement, opts ...grpc.CallOption) (*MsgProposeMeasurementResponse, error) {
	out := new(MsgProposeMeasurementResponse)
	err := c.cc.Invoke(ctx, "/virtengine.enclave.v1.Msg/ProposeMeasurement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) RevokeMeasurement(ctx context.Context, in *MsgRevokeMeasurement, opts ...grpc.CallOption) (*MsgRevokeMeasurementResponse, error) {
	out := new(MsgRevokeMeasurementResponse)
	err := c.cc.Invoke(ctx, "/virtengine.enclave.v1.Msg/RevokeMeasurement", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *msgClient) UpdateParams(ctx context.Context, in *MsgUpdateParams, opts ...grpc.CallOption) (*MsgUpdateParamsResponse, error) {
	out := new(MsgUpdateParamsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.enclave.v1.Msg/UpdateParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MsgServer is the server API for Msg service.
type MsgServer interface {
	// RegisterEnclaveIdentity registers a new enclave identity for a validator
	RegisterEnclaveIdentity(context.Context, *MsgRegisterEnclaveIdentity) (*MsgRegisterEnclaveIdentityResponse, error)
	// RotateEnclaveIdentity initiates a key rotation for a validator's enclave
	RotateEnclaveIdentity(context.Context, *MsgRotateEnclaveIdentity) (*MsgRotateEnclaveIdentityResponse, error)
	// ProposeMeasurement proposes a new enclave measurement for the allowlist
	ProposeMeasurement(context.Context, *MsgProposeMeasurement) (*MsgProposeMeasurementResponse, error)
	// RevokeMeasurement revokes an enclave measurement from the allowlist
	RevokeMeasurement(context.Context, *MsgRevokeMeasurement) (*MsgRevokeMeasurementResponse, error)
	// UpdateParams updates the module parameters (governance only)
	UpdateParams(context.Context, *MsgUpdateParams) (*MsgUpdateParamsResponse, error)
}

// UnimplementedMsgServer can be embedded to have forward compatible implementations.
type UnimplementedMsgServer struct {
}

func (*UnimplementedMsgServer) RegisterEnclaveIdentity(ctx context.Context, req *MsgRegisterEnclaveIdentity) (*MsgRegisterEnclaveIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterEnclaveIdentity not implemented")
}
func (*UnimplementedMsgServer) RotateEnclaveIdentity(ctx context.Context, req *MsgRotateEnclaveIdentity) (*MsgRotateEnclaveIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RotateEnclaveIdentity not implemented")
}
func (*UnimplementedMsgServer) ProposeMeasurement(ctx context.Context, req *MsgProposeMeasurement) (*MsgProposeMeasurementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProposeMeasurement not implemented")
}
func (*UnimplementedMsgServer) RevokeMeasurement(ctx context.Context, req *MsgRevokeMeasurement) (*MsgRevokeMeasurementResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeMeasurement not implemented")
}
func (*UnimplementedMsgServer) UpdateParams(ctx context.Context, req *MsgUpdateParams) (*MsgUpdateParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParams not implemented")
}

func RegisterMsgServer(s grpc1.Server, srv MsgServer) {
	s.RegisterService(&_Msg_serviceDesc, srv)
}

func _Msg_RegisterEnclaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRegisterEnclaveIdentity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RegisterEnclaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.enclave.v1.Msg/RegisterEnclaveIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RegisterEnclaveIdentity(ctx, req.(*MsgRegisterEnclaveIdentity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RotateEnclaveIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRotateEnclaveIdentity)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RotateEnclaveIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.enclave.v1.Msg/RotateEnclaveIdentity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RotateEnclaveIdentity(ctx, req.(*MsgRotateEnclaveIdentity))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_ProposeMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgProposeMeasurement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).ProposeMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.enclave.v1.Msg/ProposeMeasurement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).ProposeMeasurement(ctx, req.(*MsgProposeMeasurement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_RevokeMeasurement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgRevokeMeasurement)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).RevokeMeasurement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.enclave.v1.Msg/RevokeMeasurement",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).RevokeMeasurement(ctx, req.(*MsgRevokeMeasurement))
	}
	return interceptor(ctx, in, info, handler)
}

func _Msg_UpdateParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgUpdateParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MsgServer).UpdateParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.enclave.v1.Msg/UpdateParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MsgServer).UpdateParams(ctx, req.(*MsgUpdateParams))
	}
	return interceptor(ctx, in, info, handler)
}

var Msg_serviceDesc = _Msg_serviceDesc
var _Msg_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.enclave.v1.Msg",
	HandlerType: (*MsgServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterEnclaveIdentity",
			Handler:    _Msg_RegisterEnclaveIdentity_Handler,
		},
		{
			MethodName: "RotateEnclaveIdentity",
			Handler:    _Msg_RotateEnclaveIdentity_Handler,
		},
		{
			MethodName: "ProposeMeasurement",
			Handler:    _Msg_ProposeMeasurement_Handler,
		},
		{
			MethodName: "RevokeMeasurement",
			Handler:    _Msg_RevokeMeasurement_Handler,
		},
		{
			MethodName: "UpdateParams",
			Handler:    _Msg_UpdateParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/enclave/v1/tx.proto",
}

func (m *MsgRegisterEnclaveIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterEnclaveIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterEnclaveIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QuoteVersion != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.QuoteVersion))
		i--
		dAtA[i] = 0x58
	}
	if m.IsvSvn != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.IsvSvn))
		i--
		dAtA[i] = 0x50
	}
	if m.IsvProdId != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.IsvProdId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.AttestationChain) > 0 {
		for iNdEx := len(m.AttestationChain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AttestationChain[iNdEx])
			copy(dAtA[i:], m.AttestationChain[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.AttestationChain[iNdEx])))
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.AttestationQuote) > 0 {
		i -= len(m.AttestationQuote)
		copy(dAtA[i:], m.AttestationQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.AttestationQuote)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.SigningPubKey) > 0 {
		i -= len(m.SigningPubKey)
		copy(dAtA[i:], m.SigningPubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SigningPubKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.EncryptionPubKey) > 0 {
		i -= len(m.EncryptionPubKey)
		copy(dAtA[i:], m.EncryptionPubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.EncryptionPubKey)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.SignerHash) > 0 {
		i -= len(m.SignerHash)
		copy(dAtA[i:], m.SignerHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.SignerHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.TeeType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TeeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterEnclaveIdentityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterEnclaveIdentityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterEnclaveIdentityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpiryHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.KeyFingerprint) > 0 {
		i -= len(m.KeyFingerprint)
		copy(dAtA[i:], m.KeyFingerprint)
		i = encodeVarintTx(dAtA, i, uint64(len(m.KeyFingerprint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRotateEnclaveIdentity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRotateEnclaveIdentity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRotateEnclaveIdentity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapBlocks != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OverlapBlocks))
		i--
		dAtA[i] = 0x40
	}
	if m.NewIsvSvn != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.NewIsvSvn))
		i--
		dAtA[i] = 0x38
	}
	if len(m.NewMeasurementHash) > 0 {
		i -= len(m.NewMeasurementHash)
		copy(dAtA[i:], m.NewMeasurementHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewMeasurementHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NewAttestationChain) > 0 {
		for iNdEx := len(m.NewAttestationChain) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.NewAttestationChain[iNdEx])
			copy(dAtA[i:], m.NewAttestationChain[iNdEx])
			i = encodeVarintTx(dAtA, i, uint64(len(m.NewAttestationChain[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.NewAttestationQuote) > 0 {
		i -= len(m.NewAttestationQuote)
		copy(dAtA[i:], m.NewAttestationQuote)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewAttestationQuote)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewSigningPubKey) > 0 {
		i -= len(m.NewSigningPubKey)
		copy(dAtA[i:], m.NewSigningPubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewSigningPubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NewEncryptionPubKey) > 0 {
		i -= len(m.NewEncryptionPubKey)
		copy(dAtA[i:], m.NewEncryptionPubKey)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewEncryptionPubKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintTx(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRotateEnclaveIdentityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRotateEnclaveIdentityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRotateEnclaveIdentityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OverlapEndHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OverlapEndHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.OverlapStartHeight != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.OverlapStartHeight))
		i--
		dAtA[i] = 0x10
	}
	if len(m.NewKeyFingerprint) > 0 {
		i -= len(m.NewKeyFingerprint)
		copy(dAtA[i:], m.NewKeyFingerprint)
		i = encodeVarintTx(dAtA, i, uint64(len(m.NewKeyFingerprint)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeMeasurement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeMeasurement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeMeasurement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryBlocks != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.ExpiryBlocks))
		i--
		dAtA[i] = 0x30
	}
	if m.MinIsvSvn != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.MinIsvSvn))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.TeeType != 0 {
		i = encodeVarintTx(dAtA, i, uint64(m.TeeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeMeasurementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeMeasurementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeMeasurementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeMeasurement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeMeasurement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeMeasurement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MeasurementHash) > 0 {
		i -= len(m.MeasurementHash)
		copy(dAtA[i:], m.MeasurementHash)
		i = encodeVarintTx(dAtA, i, uint64(len(m.MeasurementHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeMeasurementResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeMeasurementResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeMeasurementResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTx(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintTx(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintTx(dAtA []byte, offset int, v uint64) int {
	offset -= sovTx(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MsgRegisterEnclaveIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TeeType != 0 {
		n += 1 + sovTx(uint64(m.TeeType))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SignerHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.EncryptionPubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.SigningPubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.AttestationQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.AttestationChain) > 0 {
		for _, b := range m.AttestationChain {
			l = len(b)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	if m.IsvProdId != 0 {
		n += 1 + sovTx(uint64(m.IsvProdId))
	}
	if m.IsvSvn != 0 {
		n += 1 + sovTx(uint64(m.IsvSvn))
	}
	if m.QuoteVersion != 0 {
		n += 1 + sovTx(uint64(m.QuoteVersion))
	}
	return n
}

func (m *MsgRegisterEnclaveIdentityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.KeyFingerprint)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.ExpiryHeight != 0 {
		n += 1 + sovTx(uint64(m.ExpiryHeight))
	}
	return n
}

func (m *MsgRotateEnclaveIdentity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewEncryptionPubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewSigningPubKey)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.NewAttestationQuote)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if len(m.NewAttestationChain) > 0 {
		for _, b := range m.NewAttestationChain {
			l = len(b)
			n += 1 + l + sovTx(uint64(l))
		}
	}
	l = len(m.NewMeasurementHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.NewIsvSvn != 0 {
		n += 1 + sovTx(uint64(m.NewIsvSvn))
	}
	if m.OverlapBlocks != 0 {
		n += 1 + sovTx(uint64(m.OverlapBlocks))
	}
	return n
}

func (m *MsgRotateEnclaveIdentityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.NewKeyFingerprint)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.OverlapStartHeight != 0 {
		n += 1 + sovTx(uint64(m.OverlapStartHeight))
	}
	if m.OverlapEndHeight != 0 {
		n += 1 + sovTx(uint64(m.OverlapEndHeight))
	}
	return n
}

func (m *MsgProposeMeasurement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.TeeType != 0 {
		n += 1 + sovTx(uint64(m.TeeType))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	if m.MinIsvSvn != 0 {
		n += 1 + sovTx(uint64(m.MinIsvSvn))
	}
	if m.ExpiryBlocks != 0 {
		n += 1 + sovTx(uint64(m.ExpiryBlocks))
	}
	return n
}

func (m *MsgProposeMeasurementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeMeasurement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.MeasurementHash)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	return n
}

func (m *MsgRevokeMeasurementResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgUpdateParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovTx(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovTx(uint64(l))
	return n
}

func (m *MsgUpdateParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovTx(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTx(x uint64) (n int) {
	return sovTx(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MsgRegisterEnclaveIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterEnclaveIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterEnclaveIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			m.TeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeeType |= TEEType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignerHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignerHash = append(m.SignerHash[:0], dAtA[iNdEx:postIndex]...)
			if m.SignerHash == nil {
				m.SignerHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptionPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptionPubKey = append(m.EncryptionPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptionPubKey == nil {
				m.EncryptionPubKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SigningPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SigningPubKey = append(m.SigningPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SigningPubKey == nil {
				m.SigningPubKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationQuote", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationQuote = append(m.AttestationQuote[:0], dAtA[iNdEx:postIndex]...)
			if m.AttestationQuote == nil {
				m.AttestationQuote = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationChain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationChain = append(m.AttestationChain, make([]byte, postIndex-iNdEx))
			copy(m.AttestationChain[len(m.AttestationChain)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsvProdId", wireType)
			}
			m.IsvProdId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsvProdId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsvSvn", wireType)
			}
			m.IsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuoteVersion", wireType)
			}
			m.QuoteVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.QuoteVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterEnclaveIdentityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterEnclaveIdentityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterEnclaveIdentityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryHeight", wireType)
			}
			m.ExpiryHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRotateEnclaveIdentity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRotateEnclaveIdentity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRotateEnclaveIdentity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewEncryptionPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewEncryptionPubKey = append(m.NewEncryptionPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewEncryptionPubKey == nil {
				m.NewEncryptionPubKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewSigningPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewSigningPubKey = append(m.NewSigningPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.NewSigningPubKey == nil {
				m.NewSigningPubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAttestationQuote", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAttestationQuote = append(m.NewAttestationQuote[:0], dAtA[iNdEx:postIndex]...)
			if m.NewAttestationQuote == nil {
				m.NewAttestationQuote = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewAttestationChain", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewAttestationChain = append(m.NewAttestationChain, make([]byte, postIndex-iNdEx))
			copy(m.NewAttestationChain[len(m.NewAttestationChain)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewMeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewMeasurementHash = append(m.NewMeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NewMeasurementHash == nil {
				m.NewMeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewIsvSvn", wireType)
			}
			m.NewIsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewIsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapBlocks", wireType)
			}
			m.OverlapBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRotateEnclaveIdentityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRotateEnclaveIdentityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRotateEnclaveIdentityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewKeyFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewKeyFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapStartHeight", wireType)
			}
			m.OverlapStartHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapStartHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OverlapEndHeight", wireType)
			}
			m.OverlapEndHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OverlapEndHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeMeasurement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeMeasurement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeMeasurement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TeeType", wireType)
			}
			m.TeeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TeeType |= TEEType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinIsvSvn", wireType)
			}
			m.MinIsvSvn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinIsvSvn |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryBlocks", wireType)
			}
			m.ExpiryBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeMeasurementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeMeasurementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeMeasurementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeMeasurement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeMeasurement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeMeasurement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MeasurementHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MeasurementHash = append(m.MeasurementHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MeasurementHash == nil {
				m.MeasurementHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeMeasurementResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeMeasurementResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeMeasurementResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTx
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTx
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTx
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTx
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTx(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTx
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTx(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTx
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTx
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTx
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTx
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTx
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTx        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTx          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTx = fmt.Errorf("proto: unexpected end of group")
)

