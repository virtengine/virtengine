// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/marketplace/v1/query.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AllocationState represents the lifecycle state of an allocation.
type AllocationState int32

const (
	// ALLOCATION_STATE_UNSPECIFIED represents an unspecified allocation state.
	AllocationState_ALLOCATION_STATE_UNSPECIFIED AllocationState = 0
	// ALLOCATION_STATE_PENDING indicates the allocation is pending provider acknowledgment.
	AllocationState_ALLOCATION_STATE_PENDING AllocationState = 1
	// ALLOCATION_STATE_ACCEPTED indicates the provider accepted the allocation.
	AllocationState_ALLOCATION_STATE_ACCEPTED AllocationState = 2
	// ALLOCATION_STATE_PROVISIONING indicates provisioning is in progress.
	AllocationState_ALLOCATION_STATE_PROVISIONING AllocationState = 3
	// ALLOCATION_STATE_ACTIVE indicates the allocation is active.
	AllocationState_ALLOCATION_STATE_ACTIVE AllocationState = 4
	// ALLOCATION_STATE_SUSPENDED indicates the allocation is suspended.
	AllocationState_ALLOCATION_STATE_SUSPENDED AllocationState = 5
	// ALLOCATION_STATE_TERMINATING indicates the allocation is terminating.
	AllocationState_ALLOCATION_STATE_TERMINATING AllocationState = 6
	// ALLOCATION_STATE_TERMINATED indicates the allocation is terminated.
	AllocationState_ALLOCATION_STATE_TERMINATED AllocationState = 7
	// ALLOCATION_STATE_REJECTED indicates the provider rejected the allocation.
	AllocationState_ALLOCATION_STATE_REJECTED AllocationState = 8
	// ALLOCATION_STATE_FAILED indicates the allocation failed.
	AllocationState_ALLOCATION_STATE_FAILED AllocationState = 9
)

var AllocationState_name = map[int32]string{
	0: "ALLOCATION_STATE_UNSPECIFIED",
	1: "ALLOCATION_STATE_PENDING",
	2: "ALLOCATION_STATE_ACCEPTED",
	3: "ALLOCATION_STATE_PROVISIONING",
	4: "ALLOCATION_STATE_ACTIVE",
	5: "ALLOCATION_STATE_SUSPENDED",
	6: "ALLOCATION_STATE_TERMINATING",
	7: "ALLOCATION_STATE_TERMINATED",
	8: "ALLOCATION_STATE_REJECTED",
	9: "ALLOCATION_STATE_FAILED",
}

var AllocationState_value = map[string]int32{
	"ALLOCATION_STATE_UNSPECIFIED":  0,
	"ALLOCATION_STATE_PENDING":      1,
	"ALLOCATION_STATE_ACCEPTED":     2,
	"ALLOCATION_STATE_PROVISIONING": 3,
	"ALLOCATION_STATE_ACTIVE":       4,
	"ALLOCATION_STATE_SUSPENDED":    5,
	"ALLOCATION_STATE_TERMINATING":  6,
	"ALLOCATION_STATE_TERMINATED":   7,
	"ALLOCATION_STATE_REJECTED":     8,
	"ALLOCATION_STATE_FAILED":       9,
}

func (x AllocationState) String() string {
	return proto.EnumName(AllocationState_name, int32(x))
}

func (AllocationState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{0}
}

// QueryOfferingPriceRequest is request type for the Query/OfferingPrice RPC method.
type QueryOfferingPriceRequest struct {
	// On-chain offering ID string (provider/sequence).
	OfferingId string `protobuf:"bytes,1,opt,name=offering_id,json=offeringId,proto3" json:"offering_id,omitempty"`
	// Resource units keyed by resource type (cpu, ram, storage, gpu, network).
	ResourceUnits map[string]uint64 `protobuf:"bytes,2,rep,name=resource_units,json=resourceUnits,proto3" json:"resource_units,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	// Requested quantity (defaults to 1 if omitted).
	Quantity uint32 `protobuf:"varint,3,opt,name=quantity,proto3" json:"quantity,omitempty"`
}

func (m *QueryOfferingPriceRequest) Reset()         { *m = QueryOfferingPriceRequest{} }
func (m *QueryOfferingPriceRequest) String() string { return proto.CompactTextString(m) }
func (*QueryOfferingPriceRequest) ProtoMessage()    {}
func (*QueryOfferingPriceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{0}
}
func (m *QueryOfferingPriceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOfferingPriceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOfferingPriceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryOfferingPriceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOfferingPriceRequest.Merge(m, src)
}
func (m *QueryOfferingPriceRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryOfferingPriceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOfferingPriceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOfferingPriceRequest proto.InternalMessageInfo

func (m *QueryOfferingPriceRequest) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *QueryOfferingPriceRequest) GetResourceUnits() map[string]uint64 {
	if m != nil {
		return m.ResourceUnits
	}
	return nil
}

func (m *QueryOfferingPriceRequest) GetQuantity() uint32 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

// QueryOfferingPriceResponse is response type for the Query/OfferingPrice RPC method.
type QueryOfferingPriceResponse struct {
	// Total calculated price.
	Total types.Coin `protobuf:"bytes,1,opt,name=total,proto3" json:"total"`
}

func (m *QueryOfferingPriceResponse) Reset()         { *m = QueryOfferingPriceResponse{} }
func (m *QueryOfferingPriceResponse) String() string { return proto.CompactTextString(m) }
func (*QueryOfferingPriceResponse) ProtoMessage()    {}
func (*QueryOfferingPriceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{1}
}
func (m *QueryOfferingPriceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryOfferingPriceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryOfferingPriceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryOfferingPriceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryOfferingPriceResponse.Merge(m, src)
}
func (m *QueryOfferingPriceResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryOfferingPriceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryOfferingPriceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryOfferingPriceResponse proto.InternalMessageInfo

func (m *QueryOfferingPriceResponse) GetTotal() types.Coin {
	if m != nil {
		return m.Total
	}
	return types.Coin{}
}

// Allocation represents a marketplace allocation summary.
type Allocation struct {
	AllocationId    string          `protobuf:"bytes,1,opt,name=allocation_id,json=allocationId,proto3" json:"allocation_id" yaml:"allocation_id"`
	OrderId         string          `protobuf:"bytes,2,opt,name=order_id,json=orderId,proto3" json:"order_id" yaml:"order_id"`
	OfferingId      string          `protobuf:"bytes,3,opt,name=offering_id,json=offeringId,proto3" json:"offering_id" yaml:"offering_id"`
	ProviderAddress string          `protobuf:"bytes,4,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	CustomerAddress string          `protobuf:"bytes,5,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address" yaml:"customer_address"`
	State           AllocationState `protobuf:"varint,6,opt,name=state,proto3,enum=virtengine.marketplace.v1.AllocationState" json:"state" yaml:"state"`
	AcceptedPrice   uint64          `protobuf:"varint,7,opt,name=accepted_price,json=acceptedPrice,proto3" json:"accepted_price" yaml:"accepted_price"`
	CreatedAt       time.Time       `protobuf:"bytes,8,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	UpdatedAt       time.Time       `protobuf:"bytes,9,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	TerminatedAt    *time.Time      `protobuf:"bytes,10,opt,name=terminated_at,json=terminatedAt,proto3,stdtime" json:"terminated_at,omitempty" yaml:"terminated_at"`
	StateReason     string          `protobuf:"bytes,11,opt,name=state_reason,json=stateReason,proto3" json:"state_reason,omitempty" yaml:"state_reason"`
}

func (m *Allocation) Reset()         { *m = Allocation{} }
func (m *Allocation) String() string { return proto.CompactTextString(m) }
func (*Allocation) ProtoMessage()    {}
func (*Allocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{2}
}
func (m *Allocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Allocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Allocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Allocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Allocation.Merge(m, src)
}
func (m *Allocation) XXX_Size() int {
	return m.Size()
}
func (m *Allocation) XXX_DiscardUnknown() {
	xxx_messageInfo_Allocation.DiscardUnknown(m)
}

var xxx_messageInfo_Allocation proto.InternalMessageInfo

func (m *Allocation) GetAllocationId() string {
	if m != nil {
		return m.AllocationId
	}
	return ""
}

func (m *Allocation) GetOrderId() string {
	if m != nil {
		return m.OrderId
	}
	return ""
}

func (m *Allocation) GetOfferingId() string {
	if m != nil {
		return m.OfferingId
	}
	return ""
}

func (m *Allocation) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *Allocation) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *Allocation) GetState() AllocationState {
	if m != nil {
		return m.State
	}
	return AllocationState_ALLOCATION_STATE_UNSPECIFIED
}

func (m *Allocation) GetAcceptedPrice() uint64 {
	if m != nil {
		return m.AcceptedPrice
	}
	return 0
}

func (m *Allocation) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Allocation) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *Allocation) GetTerminatedAt() *time.Time {
	if m != nil {
		return m.TerminatedAt
	}
	return nil
}

func (m *Allocation) GetStateReason() string {
	if m != nil {
		return m.StateReason
	}
	return ""
}

// QueryAllocationsByCustomerRequest is the request for allocations by customer.
type QueryAllocationsByCustomerRequest struct {
	CustomerAddress string             `protobuf:"bytes,1,opt,name=customer_address,json=customerAddress,proto3" json:"customer_address" yaml:"customer_address"`
	Pagination      *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAllocationsByCustomerRequest) Reset()         { *m = QueryAllocationsByCustomerRequest{} }
func (m *QueryAllocationsByCustomerRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAllocationsByCustomerRequest) ProtoMessage()    {}
func (*QueryAllocationsByCustomerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{3}
}
func (m *QueryAllocationsByCustomerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllocationsByCustomerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllocationsByCustomerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllocationsByCustomerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllocationsByCustomerRequest.Merge(m, src)
}
func (m *QueryAllocationsByCustomerRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllocationsByCustomerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllocationsByCustomerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllocationsByCustomerRequest proto.InternalMessageInfo

func (m *QueryAllocationsByCustomerRequest) GetCustomerAddress() string {
	if m != nil {
		return m.CustomerAddress
	}
	return ""
}

func (m *QueryAllocationsByCustomerRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAllocationsByProviderRequest is the request for allocations by provider.
type QueryAllocationsByProviderRequest struct {
	ProviderAddress string             `protobuf:"bytes,1,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Pagination      *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAllocationsByProviderRequest) Reset()         { *m = QueryAllocationsByProviderRequest{} }
func (m *QueryAllocationsByProviderRequest) String() string { return proto.CompactTextString(m) }
func (*QueryAllocationsByProviderRequest) ProtoMessage()    {}
func (*QueryAllocationsByProviderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{4}
}
func (m *QueryAllocationsByProviderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllocationsByProviderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllocationsByProviderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllocationsByProviderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllocationsByProviderRequest.Merge(m, src)
}
func (m *QueryAllocationsByProviderRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllocationsByProviderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllocationsByProviderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllocationsByProviderRequest proto.InternalMessageInfo

func (m *QueryAllocationsByProviderRequest) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *QueryAllocationsByProviderRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryAllocationsResponse is the response for allocations queries.
type QueryAllocationsResponse struct {
	Allocations []Allocation        `protobuf:"bytes,1,rep,name=allocations,proto3" json:"allocations" yaml:"allocations"`
	Pagination  *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty" yaml:"pagination"`
}

func (m *QueryAllocationsResponse) Reset()         { *m = QueryAllocationsResponse{} }
func (m *QueryAllocationsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAllocationsResponse) ProtoMessage()    {}
func (*QueryAllocationsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_707c8d318eaebd6f, []int{5}
}
func (m *QueryAllocationsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllocationsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllocationsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllocationsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllocationsResponse.Merge(m, src)
}
func (m *QueryAllocationsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllocationsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllocationsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllocationsResponse proto.InternalMessageInfo

func (m *QueryAllocationsResponse) GetAllocations() []Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

func (m *QueryAllocationsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

func init() {
	proto.RegisterEnum("virtengine.marketplace.v1.AllocationState", AllocationState_name, AllocationState_value)
	proto.RegisterType((*QueryOfferingPriceRequest)(nil), "virtengine.marketplace.v1.QueryOfferingPriceRequest")
	proto.RegisterMapType((map[string]uint64)(nil), "virtengine.marketplace.v1.QueryOfferingPriceRequest.ResourceUnitsEntry")
	proto.RegisterType((*QueryOfferingPriceResponse)(nil), "virtengine.marketplace.v1.QueryOfferingPriceResponse")
	proto.RegisterType((*Allocation)(nil), "virtengine.marketplace.v1.Allocation")
	proto.RegisterType((*QueryAllocationsByCustomerRequest)(nil), "virtengine.marketplace.v1.QueryAllocationsByCustomerRequest")
	proto.RegisterType((*QueryAllocationsByProviderRequest)(nil), "virtengine.marketplace.v1.QueryAllocationsByProviderRequest")
	proto.RegisterType((*QueryAllocationsResponse)(nil), "virtengine.marketplace.v1.QueryAllocationsResponse")
}

func init() {
	proto.RegisterFile("virtengine/marketplace/v1/query.proto", fileDescriptor_707c8d318eaebd6f)
}

var fileDescriptor_707c8d318eaebd6f = []byte{
	// 1230 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0xcb, 0x6f, 0x1b, 0x45,
	0x18, 0xcf, 0x3a, 0x71, 0x93, 0x8c, 0xe3, 0xc4, 0x0c, 0x29, 0xb1, 0xdd, 0xd4, 0xe3, 0xae, 0x14,
	0x48, 0x53, 0xba, 0xab, 0xa4, 0x54, 0x54, 0x81, 0x43, 0xfd, 0xd8, 0x44, 0x5b, 0x05, 0xc7, 0xac,
	0x9d, 0x1e, 0xe0, 0x60, 0x6d, 0xec, 0x89, 0x59, 0xc5, 0xde, 0x71, 0x76, 0xc7, 0x16, 0x56, 0x94,
	0x0b, 0x07, 0x0e, 0x1c, 0x50, 0x25, 0x4e, 0xfc, 0x1f, 0x9c, 0x39, 0xf7, 0x46, 0x05, 0x12, 0xe2,
	0xb4, 0xa0, 0x84, 0x93, 0x8f, 0x3e, 0x72, 0x42, 0xb3, 0x0f, 0xef, 0xfa, 0x91, 0xa4, 0x01, 0x15,
	0x6e, 0xfb, 0xfd, 0xbe, 0xc7, 0x6f, 0xe6, 0x9b, 0x6f, 0x7f, 0x33, 0x60, 0xad, 0xa3, 0x19, 0x14,
	0xeb, 0x75, 0x4d, 0xc7, 0x62, 0x53, 0x35, 0x8e, 0x31, 0x6d, 0x35, 0xd4, 0x2a, 0x16, 0x3b, 0x9b,
	0xe2, 0x49, 0x1b, 0x1b, 0x5d, 0xa1, 0x65, 0x10, 0x4a, 0x60, 0xc2, 0x0f, 0x13, 0x02, 0x61, 0x42,
	0x67, 0x33, 0x99, 0xaa, 0x12, 0xb3, 0x49, 0x4c, 0xf1, 0x50, 0x35, 0x59, 0xda, 0x21, 0xa6, 0xea,
	0xa6, 0x58, 0x25, 0x9a, 0xee, 0xa4, 0x26, 0x37, 0x82, 0x7e, 0xbb, 0xe6, 0x20, 0xaa, 0xa5, 0xd6,
	0x35, 0x5d, 0xa5, 0x1a, 0xf1, 0x62, 0x13, 0x4e, 0x6c, 0xc5, 0xb6, 0x44, 0xc7, 0x70, 0x5d, 0xab,
	0x75, 0x42, 0xea, 0x0d, 0x2c, 0xaa, 0x2d, 0x4d, 0x54, 0x75, 0x9d, 0x50, 0x3b, 0xcf, 0xf3, 0x2e,
	0xd7, 0x49, 0x9d, 0x38, 0x59, 0xec, 0xcb, 0x45, 0x91, 0x9b, 0x63, 0x5b, 0x87, 0xed, 0x23, 0x91,
	0x6a, 0x4d, 0x6c, 0x52, 0xb5, 0xd9, 0x72, 0x02, 0xf8, 0x6f, 0x42, 0x20, 0xf1, 0x29, 0x5b, 0xd2,
	0xfe, 0xd1, 0x11, 0x36, 0x34, 0xbd, 0x5e, 0x34, 0xb4, 0x2a, 0x56, 0xf0, 0x49, 0x1b, 0x9b, 0x14,
	0x22, 0x10, 0x21, 0x2e, 0x5e, 0xd1, 0x6a, 0x71, 0x2e, 0xcd, 0xad, 0xcf, 0x2b, 0xc0, 0x83, 0xe4,
	0x1a, 0xd4, 0xc1, 0xa2, 0x81, 0x4d, 0xd2, 0x36, 0xaa, 0xb8, 0xd2, 0xd6, 0x35, 0x6a, 0xc6, 0x43,
	0xe9, 0xe9, 0xf5, 0xc8, 0xd6, 0xae, 0x70, 0x69, 0xbb, 0x84, 0x4b, 0xe9, 0x04, 0xc5, 0x2d, 0x75,
	0xc0, 0x2a, 0x49, 0x3a, 0x35, 0xba, 0x4a, 0xd4, 0x08, 0x62, 0x30, 0x09, 0xe6, 0x4e, 0xda, 0xaa,
	0x4e, 0x35, 0xda, 0x8d, 0x4f, 0xa7, 0xb9, 0xf5, 0xa8, 0x32, 0xb0, 0x93, 0x4f, 0x01, 0x1c, 0x2f,
	0x00, 0x63, 0x60, 0xfa, 0x18, 0x77, 0xdd, 0xa5, 0xb3, 0x4f, 0xb8, 0x0c, 0xc2, 0x1d, 0xb5, 0xd1,
	0xc6, 0xf1, 0x50, 0x9a, 0x5b, 0x9f, 0x51, 0x1c, 0x63, 0x3b, 0xf4, 0x84, 0xe3, 0x4b, 0x20, 0x39,
	0x69, 0x71, 0x66, 0x8b, 0xe8, 0x26, 0x86, 0x8f, 0x41, 0x98, 0x12, 0xaa, 0x36, 0xec, 0x5a, 0x91,
	0xad, 0x84, 0xe0, 0x9e, 0x0e, 0x3b, 0x56, 0xc1, 0x3d, 0x50, 0x21, 0x47, 0x34, 0x3d, 0x3b, 0xf3,
	0xd2, 0x42, 0x53, 0x8a, 0x13, 0xcd, 0x7f, 0x3f, 0x07, 0x40, 0xa6, 0xd1, 0x20, 0x55, 0xfb, 0xb8,
	0x60, 0x01, 0x44, 0xd5, 0x81, 0x35, 0x68, 0x6a, 0xf6, 0x7e, 0xcf, 0x42, 0xc3, 0x8e, 0xbe, 0x85,
	0x96, 0xbb, 0x6a, 0xb3, 0xb1, 0xcd, 0x0f, 0xc1, 0xbc, 0xb2, 0xe0, 0xdb, 0x72, 0x0d, 0x6e, 0x83,
	0x39, 0x62, 0xd4, 0xb0, 0xc1, 0x4a, 0x85, 0xec, 0x52, 0xa8, 0x67, 0xa1, 0x01, 0xd6, 0xb7, 0xd0,
	0x92, 0x53, 0xc5, 0x43, 0x78, 0x65, 0xd6, 0xfe, 0x94, 0x6b, 0x70, 0x67, 0xf8, 0x78, 0xa7, 0xed,
	0xf4, 0xb5, 0x9e, 0x85, 0x82, 0x70, 0xdf, 0x42, 0xd0, 0xad, 0xe0, 0x83, 0xfc, 0xd0, 0x14, 0x18,
	0x20, 0xd6, 0x32, 0x48, 0x47, 0x63, 0x04, 0x6a, 0xad, 0x66, 0x60, 0xd3, 0x8c, 0xcf, 0xd8, 0xc5,
	0x76, 0x7b, 0x16, 0x1a, 0xf3, 0xf5, 0x2d, 0xb4, 0xe2, 0x54, 0x1c, 0xf5, 0xf0, 0x3f, 0xff, 0xf0,
	0x70, 0xd9, 0x6d, 0x6b, 0xc6, 0x81, 0x4a, 0x94, 0x91, 0x28, 0x4b, 0x5e, 0xa8, 0x0b, 0x33, 0xce,
	0x6a, 0xdb, 0xa4, 0xa4, 0x19, 0xe0, 0x0c, 0xfb, 0x9c, 0xa3, 0x3e, 0x9f, 0x73, 0xd4, 0x73, 0x05,
	0xa7, 0x17, 0xea, 0x71, 0x7e, 0x0e, 0xc2, 0x26, 0x55, 0x29, 0x8e, 0xdf, 0x4a, 0x73, 0xeb, 0x8b,
	0x5b, 0x1b, 0x57, 0x0c, 0xb9, 0x7f, 0xe2, 0x25, 0x96, 0x91, 0x4d, 0xf4, 0x2c, 0xe4, 0x24, 0xf7,
	0x2d, 0xb4, 0xe0, 0xac, 0xc4, 0x36, 0x79, 0xc5, 0x81, 0xa1, 0x02, 0x16, 0xd5, 0x6a, 0x15, 0xb7,
	0x28, 0xae, 0x55, 0x5a, 0x6c, 0xf0, 0xe2, 0xb3, 0x6c, 0x3e, 0xb3, 0x0f, 0x7a, 0x16, 0x1a, 0xf1,
	0xf4, 0x2d, 0x74, 0xdb, 0x1d, 0x8d, 0x21, 0x9c, 0x57, 0xa2, 0x1e, 0x60, 0x8f, 0x2e, 0x3c, 0x02,
	0xa0, 0x6a, 0x60, 0x95, 0x05, 0xa8, 0x34, 0x3e, 0x67, 0xcf, 0x6d, 0x52, 0x70, 0x34, 0x41, 0xf0,
	0x34, 0x41, 0x28, 0x7b, 0x9a, 0x90, 0x7d, 0xc0, 0x06, 0xb7, 0x67, 0xa1, 0x40, 0x56, 0xdf, 0x42,
	0x6f, 0xb9, 0x8d, 0x1b, 0x60, 0xfc, 0x8b, 0xdf, 0x11, 0xa7, 0xcc, 0xbb, 0x40, 0x86, 0x32, 0x9e,
	0x76, 0xab, 0xe6, 0xf1, 0xcc, 0xbf, 0x3e, 0x8f, 0x9f, 0xe5, 0xf3, 0xf8, 0x98, 0xcb, 0xe3, 0x02,
	0x19, 0x0a, 0xbf, 0x04, 0x51, 0x8a, 0x8d, 0x26, 0x93, 0x4c, 0x87, 0x0a, 0x5c, 0x4b, 0xf5, 0x61,
	0xcf, 0x42, 0x2b, 0x43, 0x49, 0xef, 0x93, 0xa6, 0x46, 0x71, 0xb3, 0x45, 0xbb, 0xfe, 0x2f, 0x36,
	0x14, 0xe0, 0xd0, 0x2e, 0xf8, 0x58, 0x86, 0xc2, 0x32, 0x58, 0xb0, 0x8f, 0xa9, 0x62, 0x60, 0xd5,
	0x24, 0x7a, 0x3c, 0x62, 0x8f, 0xda, 0x66, 0xcf, 0x42, 0xef, 0x04, 0xf1, 0xa1, 0xda, 0x6f, 0x07,
	0x8e, 0xd9, 0xf5, 0xf3, 0x4a, 0xc4, 0x36, 0x15, 0xc7, 0xfa, 0x36, 0x04, 0xee, 0xd9, 0x8a, 0xe3,
	0x8f, 0x8b, 0x99, 0xed, 0xe6, 0xdc, 0xb1, 0xf3, 0x54, 0x78, 0xd2, 0xa8, 0x73, 0x6f, 0x78, 0xd4,
	0xdb, 0x00, 0xf8, 0x77, 0x93, 0x2d, 0x2c, 0x91, 0xad, 0x77, 0x87, 0x14, 0xcf, 0xb9, 0x1c, 0x3d,
	0xdd, 0x2b, 0xaa, 0x75, 0x4f, 0xc6, 0xb3, 0x0f, 0x7b, 0x16, 0x5a, 0xf6, 0xb3, 0x87, 0x7a, 0xe2,
	0x9e, 0xb1, 0xef, 0xe5, 0x95, 0x00, 0xd1, 0x25, 0x0d, 0x29, 0xba, 0xff, 0x7e, 0xa0, 0x21, 0x63,
	0x7a, 0xc3, 0xbd, 0x61, 0xbd, 0xf9, 0x9f, 0x1a, 0xf2, 0x75, 0x08, 0xc4, 0x47, 0x1b, 0x32, 0xb8,
	0x91, 0x0c, 0x10, 0xf1, 0xef, 0x02, 0xd6, 0x02, 0x76, 0xf5, 0xae, 0xbd, 0x96, 0x2a, 0x65, 0xef,
	0xbb, 0xbf, 0x60, 0xb0, 0x82, 0x2f, 0xf5, 0x01, 0x90, 0x57, 0x82, 0x21, 0xb0, 0x33, 0xa1, 0x0f,
	0xef, 0x5d, 0xdb, 0x07, 0x67, 0xc1, 0xff, 0xa2, 0x11, 0x1b, 0x3f, 0x85, 0xc0, 0xd2, 0x88, 0xa8,
	0xc2, 0x34, 0x58, 0xcd, 0xec, 0xed, 0xed, 0xe7, 0x32, 0x65, 0x79, 0xbf, 0x50, 0x29, 0x95, 0x33,
	0x65, 0xa9, 0x72, 0x50, 0x28, 0x15, 0xa5, 0x9c, 0xbc, 0x23, 0x4b, 0xf9, 0xd8, 0x14, 0x5c, 0x05,
	0xf1, 0xb1, 0x88, 0xa2, 0x54, 0xc8, 0xcb, 0x85, 0xdd, 0x18, 0x07, 0xef, 0x82, 0xc4, 0x98, 0x37,
	0x93, 0xcb, 0x49, 0xc5, 0xb2, 0x94, 0x8f, 0x85, 0xe0, 0x3d, 0x70, 0x77, 0x3c, 0x59, 0xd9, 0x7f,
	0x2e, 0x97, 0xe4, 0xfd, 0x02, 0xab, 0x30, 0x0d, 0xef, 0x80, 0x95, 0x09, 0x15, 0xca, 0xf2, 0x73,
	0x29, 0x36, 0x03, 0x53, 0x20, 0x39, 0xe6, 0x2c, 0x1d, 0x94, 0x18, 0xbf, 0x94, 0x8f, 0x85, 0x27,
	0x2e, 0xbf, 0x2c, 0x29, 0x9f, 0xc8, 0x85, 0x4c, 0x99, 0x95, 0xbf, 0x05, 0x11, 0xb8, 0x73, 0x69,
	0x84, 0x94, 0x8f, 0xcd, 0x4e, 0xdc, 0x81, 0x22, 0x3d, 0x93, 0x72, 0xcc, 0x3d, 0x37, 0x71, 0x79,
	0x3b, 0x19, 0x79, 0x4f, 0xca, 0xc7, 0xe6, 0xb7, 0xfe, 0x9a, 0x01, 0x61, 0x7b, 0xb4, 0xe0, 0x8f,
	0x1c, 0x88, 0x0e, 0xbd, 0x79, 0xe0, 0x07, 0xff, 0xe4, 0xfd, 0x96, 0x7c, 0x7c, 0xc3, 0x2c, 0x67,
	0x2a, 0xf8, 0xa7, 0x5f, 0xfd, 0xf2, 0xe7, 0x77, 0xa1, 0x6d, 0xf8, 0x44, 0xbc, 0xfc, 0x29, 0xee,
	0xbd, 0x36, 0x4c, 0xf1, 0x34, 0xf0, 0x0c, 0x39, 0x13, 0xed, 0x7b, 0x0f, 0xfe, 0xca, 0x81, 0xdb,
	0x13, 0x25, 0x14, 0x7e, 0x7c, 0xdd, 0x92, 0xae, 0x52, 0xde, 0xe4, 0xa3, 0x1b, 0x64, 0x0f, 0xb6,
	0xf3, 0xcc, 0xde, 0x4e, 0x1e, 0x66, 0xaf, 0xd8, 0x4e, 0xe0, 0x8f, 0x12, 0x3d, 0xe9, 0x15, 0x4f,
	0x47, 0xf5, 0xfa, 0x6c, 0x7c, 0x63, 0x9e, 0x14, 0xde, 0x70, 0x63, 0x23, 0x0a, 0xfa, 0xdf, 0x6c,
	0xcc, 0x93, 0x50, 0xf1, 0x74, 0x54, 0x77, 0xcf, 0xb2, 0x07, 0x2f, 0xcf, 0x53, 0xdc, 0xab, 0xf3,
	0x14, 0xf7, 0xc7, 0x79, 0x8a, 0x7b, 0x71, 0x91, 0x9a, 0x7a, 0x75, 0x91, 0x9a, 0xfa, 0xed, 0x22,
	0x35, 0xf5, 0xd9, 0x47, 0x75, 0x8d, 0x7e, 0xd1, 0x3e, 0x14, 0xaa, 0xa4, 0x19, 0xe4, 0x09, 0x7c,
	0x9a, 0xb5, 0x63, 0xb1, 0x4e, 0x44, 0x9d, 0xd4, 0x46, 0xe9, 0x0f, 0x6f, 0xd9, 0x2f, 0x80, 0x47,
	0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0x82, 0xd2, 0x9b, 0xf1, 0xd5, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// OfferingPrice calculates pricing for a specific offering.
	OfferingPrice(ctx context.Context, in *QueryOfferingPriceRequest, opts ...grpc.CallOption) (*QueryOfferingPriceResponse, error)
	// AllocationsByCustomer returns allocations for a customer.
	AllocationsByCustomer(ctx context.Context, in *QueryAllocationsByCustomerRequest, opts ...grpc.CallOption) (*QueryAllocationsResponse, error)
	// AllocationsByProvider returns allocations for a provider.
	AllocationsByProvider(ctx context.Context, in *QueryAllocationsByProviderRequest, opts ...grpc.CallOption) (*QueryAllocationsResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) OfferingPrice(ctx context.Context, in *QueryOfferingPriceRequest, opts ...grpc.CallOption) (*QueryOfferingPriceResponse, error) {
	out := new(QueryOfferingPriceResponse)
	err := c.cc.Invoke(ctx, "/virtengine.marketplace.v1.Query/OfferingPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AllocationsByCustomer(ctx context.Context, in *QueryAllocationsByCustomerRequest, opts ...grpc.CallOption) (*QueryAllocationsResponse, error) {
	out := new(QueryAllocationsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.marketplace.v1.Query/AllocationsByCustomer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) AllocationsByProvider(ctx context.Context, in *QueryAllocationsByProviderRequest, opts ...grpc.CallOption) (*QueryAllocationsResponse, error) {
	out := new(QueryAllocationsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.marketplace.v1.Query/AllocationsByProvider", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// OfferingPrice calculates pricing for a specific offering.
	OfferingPrice(context.Context, *QueryOfferingPriceRequest) (*QueryOfferingPriceResponse, error)
	// AllocationsByCustomer returns allocations for a customer.
	AllocationsByCustomer(context.Context, *QueryAllocationsByCustomerRequest) (*QueryAllocationsResponse, error)
	// AllocationsByProvider returns allocations for a provider.
	AllocationsByProvider(context.Context, *QueryAllocationsByProviderRequest) (*QueryAllocationsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) OfferingPrice(ctx context.Context, req *QueryOfferingPriceRequest) (*QueryOfferingPriceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OfferingPrice not implemented")
}
func (*UnimplementedQueryServer) AllocationsByCustomer(ctx context.Context, req *QueryAllocationsByCustomerRequest) (*QueryAllocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocationsByCustomer not implemented")
}
func (*UnimplementedQueryServer) AllocationsByProvider(ctx context.Context, req *QueryAllocationsByProviderRequest) (*QueryAllocationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllocationsByProvider not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_OfferingPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryOfferingPriceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).OfferingPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.marketplace.v1.Query/OfferingPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).OfferingPrice(ctx, req.(*QueryOfferingPriceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AllocationsByCustomer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllocationsByCustomerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AllocationsByCustomer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.marketplace.v1.Query/AllocationsByCustomer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AllocationsByCustomer(ctx, req.(*QueryAllocationsByCustomerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_AllocationsByProvider_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryAllocationsByProviderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).AllocationsByProvider(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.marketplace.v1.Query/AllocationsByProvider",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).AllocationsByProvider(ctx, req.(*QueryAllocationsByProviderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var Query_serviceDesc = _Query_serviceDesc
var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.marketplace.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "OfferingPrice",
			Handler:    _Query_OfferingPrice_Handler,
		},
		{
			MethodName: "AllocationsByCustomer",
			Handler:    _Query_AllocationsByCustomer_Handler,
		},
		{
			MethodName: "AllocationsByProvider",
			Handler:    _Query_AllocationsByProvider_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/marketplace/v1/query.proto",
}

func (m *QueryOfferingPriceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOfferingPriceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryOfferingPriceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Quantity != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Quantity))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ResourceUnits) > 0 {
		for k := range m.ResourceUnits {
			v := m.ResourceUnits[k]
			baseI := i
			i = encodeVarintQuery(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryOfferingPriceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryOfferingPriceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryOfferingPriceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Total.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Allocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Allocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Allocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StateReason) > 0 {
		i -= len(m.StateReason)
		copy(dAtA[i:], m.StateReason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.StateReason)))
		i--
		dAtA[i] = 0x5a
	}
	if m.TerminatedAt != nil {
		n2, err2 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.TerminatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.TerminatedAt):])
		if err2 != nil {
			return 0, err2
		}
		i -= n2
		i = encodeVarintQuery(dAtA, i, uint64(n2))
		i--
		dAtA[i] = 0x52
	}
	n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err3 != nil {
		return 0, err3
	}
	i -= n3
	i = encodeVarintQuery(dAtA, i, uint64(n3))
	i--
	dAtA[i] = 0x4a
	n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err4 != nil {
		return 0, err4
	}
	i -= n4
	i = encodeVarintQuery(dAtA, i, uint64(n4))
	i--
	dAtA[i] = 0x42
	if m.AcceptedPrice != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AcceptedPrice))
		i--
		dAtA[i] = 0x38
	}
	if m.State != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x30
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OfferingId) > 0 {
		i -= len(m.OfferingId)
		copy(dAtA[i:], m.OfferingId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OfferingId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrderId) > 0 {
		i -= len(m.OrderId)
		copy(dAtA[i:], m.OrderId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.OrderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AllocationId) > 0 {
		i -= len(m.AllocationId)
		copy(dAtA[i:], m.AllocationId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AllocationId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAllocationsByCustomerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllocationsByCustomerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllocationsByCustomerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.CustomerAddress) > 0 {
		i -= len(m.CustomerAddress)
		copy(dAtA[i:], m.CustomerAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.CustomerAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAllocationsByProviderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllocationsByProviderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllocationsByProviderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAllocationsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllocationsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllocationsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Allocations) > 0 {
		for iNdEx := len(m.Allocations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Allocations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryOfferingPriceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.ResourceUnits) > 0 {
		for k, v := range m.ResourceUnits {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + 1 + sovQuery(uint64(v))
			n += mapEntrySize + 1 + sovQuery(uint64(mapEntrySize))
		}
	}
	if m.Quantity != 0 {
		n += 1 + sovQuery(uint64(m.Quantity))
	}
	return n
}

func (m *QueryOfferingPriceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Total.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *Allocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AllocationId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OrderId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.OfferingId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovQuery(uint64(m.State))
	}
	if m.AcceptedPrice != 0 {
		n += 1 + sovQuery(uint64(m.AcceptedPrice))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovQuery(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 1 + l + sovQuery(uint64(l))
	if m.TerminatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.TerminatedAt)
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.StateReason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAllocationsByCustomerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CustomerAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAllocationsByProviderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryAllocationsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryOfferingPriceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOfferingPriceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOfferingPriceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceUnits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceUnits == nil {
				m.ResourceUnits = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ResourceUnits[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			m.Quantity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Quantity |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryOfferingPriceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryOfferingPriceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryOfferingPriceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Total.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Allocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Allocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Allocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocationId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OfferingId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OfferingId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AllocationState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedPrice", wireType)
			}
			m.AcceptedPrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptedPrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TerminatedAt == nil {
				m.TerminatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.TerminatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllocationsByCustomerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllocationsByCustomerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllocationsByCustomerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CustomerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllocationsByProviderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllocationsByProviderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllocationsByProviderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllocationsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllocationsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllocationsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, Allocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
