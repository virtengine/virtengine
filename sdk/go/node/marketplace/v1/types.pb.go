// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/marketplace/v1/types.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	types "github.com/cosmos/cosmos-sdk/types"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	v1 "github.com/virtengine/virtengine/sdk/go/node/encryption/v1"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// OfferingState represents the lifecycle state of an offering
type OfferingState int32

const (
	// OFFERING_STATE_UNSPECIFIED represents an unspecified offering state
	OfferingState_OFFERING_STATE_UNSPECIFIED OfferingState = 0
	// OFFERING_STATE_ACTIVE indicates the offering is active and available for orders
	OfferingState_OFFERING_STATE_ACTIVE OfferingState = 1
	// OFFERING_STATE_PAUSED indicates the offering is temporarily paused
	OfferingState_OFFERING_STATE_PAUSED OfferingState = 2
	// OFFERING_STATE_SUSPENDED indicates the offering is suspended by admin/moderator
	OfferingState_OFFERING_STATE_SUSPENDED OfferingState = 3
	// OFFERING_STATE_DEPRECATED indicates the offering is deprecated (no new orders)
	OfferingState_OFFERING_STATE_DEPRECATED OfferingState = 4
	// OFFERING_STATE_TERMINATED indicates the offering is permanently terminated
	OfferingState_OFFERING_STATE_TERMINATED OfferingState = 5
)

var OfferingState_name = map[int32]string{
	0: "OFFERING_STATE_UNSPECIFIED",
	1: "OFFERING_STATE_ACTIVE",
	2: "OFFERING_STATE_PAUSED",
	3: "OFFERING_STATE_SUSPENDED",
	4: "OFFERING_STATE_DEPRECATED",
	5: "OFFERING_STATE_TERMINATED",
}

var OfferingState_value = map[string]int32{
	"OFFERING_STATE_UNSPECIFIED": 0,
	"OFFERING_STATE_ACTIVE":      1,
	"OFFERING_STATE_PAUSED":      2,
	"OFFERING_STATE_SUSPENDED":   3,
	"OFFERING_STATE_DEPRECATED":  4,
	"OFFERING_STATE_TERMINATED":  5,
}

func (x OfferingState) String() string {
	return proto.EnumName(OfferingState_name, int32(x))
}

func (OfferingState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{0}
}

// OfferingCategory represents the category of an offering
type OfferingCategory int32

const (
	// OFFERING_CATEGORY_UNSPECIFIED represents an unspecified category
	OfferingCategory_OFFERING_CATEGORY_UNSPECIFIED OfferingCategory = 0
	// OFFERING_CATEGORY_COMPUTE represents compute/VM offerings
	OfferingCategory_OFFERING_CATEGORY_COMPUTE OfferingCategory = 1
	// OFFERING_CATEGORY_STORAGE represents storage offerings
	OfferingCategory_OFFERING_CATEGORY_STORAGE OfferingCategory = 2
	// OFFERING_CATEGORY_NETWORK represents network offerings
	OfferingCategory_OFFERING_CATEGORY_NETWORK OfferingCategory = 3
	// OFFERING_CATEGORY_HPC represents high-performance computing offerings
	OfferingCategory_OFFERING_CATEGORY_HPC OfferingCategory = 4
	// OFFERING_CATEGORY_GPU represents GPU compute offerings
	OfferingCategory_OFFERING_CATEGORY_GPU OfferingCategory = 5
	// OFFERING_CATEGORY_ML represents machine learning offerings
	OfferingCategory_OFFERING_CATEGORY_ML OfferingCategory = 6
	// OFFERING_CATEGORY_OTHER represents other/custom offerings
	OfferingCategory_OFFERING_CATEGORY_OTHER OfferingCategory = 7
)

var OfferingCategory_name = map[int32]string{
	0: "OFFERING_CATEGORY_UNSPECIFIED",
	1: "OFFERING_CATEGORY_COMPUTE",
	2: "OFFERING_CATEGORY_STORAGE",
	3: "OFFERING_CATEGORY_NETWORK",
	4: "OFFERING_CATEGORY_HPC",
	5: "OFFERING_CATEGORY_GPU",
	6: "OFFERING_CATEGORY_ML",
	7: "OFFERING_CATEGORY_OTHER",
}

var OfferingCategory_value = map[string]int32{
	"OFFERING_CATEGORY_UNSPECIFIED": 0,
	"OFFERING_CATEGORY_COMPUTE":     1,
	"OFFERING_CATEGORY_STORAGE":     2,
	"OFFERING_CATEGORY_NETWORK":     3,
	"OFFERING_CATEGORY_HPC":         4,
	"OFFERING_CATEGORY_GPU":         5,
	"OFFERING_CATEGORY_ML":          6,
	"OFFERING_CATEGORY_OTHER":       7,
}

func (x OfferingCategory) String() string {
	return proto.EnumName(OfferingCategory_name, int32(x))
}

func (OfferingCategory) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{1}
}

// PricingModel represents how an offering is priced
type PricingModel int32

const (
	// PRICING_MODEL_UNSPECIFIED represents an unspecified pricing model
	PricingModel_PRICING_MODEL_UNSPECIFIED PricingModel = 0
	// PRICING_MODEL_HOURLY represents hourly pricing
	PricingModel_PRICING_MODEL_HOURLY PricingModel = 1
	// PRICING_MODEL_DAILY represents daily pricing
	PricingModel_PRICING_MODEL_DAILY PricingModel = 2
	// PRICING_MODEL_MONTHLY represents monthly pricing
	PricingModel_PRICING_MODEL_MONTHLY PricingModel = 3
	// PRICING_MODEL_USAGE_BASED represents usage-based pricing
	PricingModel_PRICING_MODEL_USAGE_BASED PricingModel = 4
	// PRICING_MODEL_FIXED represents fixed/one-time pricing
	PricingModel_PRICING_MODEL_FIXED PricingModel = 5
)

var PricingModel_name = map[int32]string{
	0: "PRICING_MODEL_UNSPECIFIED",
	1: "PRICING_MODEL_HOURLY",
	2: "PRICING_MODEL_DAILY",
	3: "PRICING_MODEL_MONTHLY",
	4: "PRICING_MODEL_USAGE_BASED",
	5: "PRICING_MODEL_FIXED",
}

var PricingModel_value = map[string]int32{
	"PRICING_MODEL_UNSPECIFIED": 0,
	"PRICING_MODEL_HOURLY":      1,
	"PRICING_MODEL_DAILY":       2,
	"PRICING_MODEL_MONTHLY":     3,
	"PRICING_MODEL_USAGE_BASED": 4,
	"PRICING_MODEL_FIXED":       5,
}

func (x PricingModel) String() string {
	return proto.EnumName(PricingModel_name, int32(x))
}

func (PricingModel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{2}
}

// IdentityRequirement defines the identity verification requirements for an offering
type IdentityRequirement struct {
	MinScore              uint32 `protobuf:"varint,1,opt,name=min_score,json=minScore,proto3" json:"min_score" yaml:"min_score"`
	RequiredStatus        string `protobuf:"bytes,2,opt,name=required_status,json=requiredStatus,proto3" json:"required_status" yaml:"required_status"`
	RequireVerifiedEmail  bool   `protobuf:"varint,3,opt,name=require_verified_email,json=requireVerifiedEmail,proto3" json:"require_verified_email" yaml:"require_verified_email"`
	RequireVerifiedDomain bool   `protobuf:"varint,4,opt,name=require_verified_domain,json=requireVerifiedDomain,proto3" json:"require_verified_domain" yaml:"require_verified_domain"`
	RequireMfa            bool   `protobuf:"varint,5,opt,name=require_mfa,json=requireMfa,proto3" json:"require_mfa" yaml:"require_mfa"`
}

func (m *IdentityRequirement) Reset()         { *m = IdentityRequirement{} }
func (m *IdentityRequirement) String() string { return proto.CompactTextString(m) }
func (*IdentityRequirement) ProtoMessage()    {}
func (*IdentityRequirement) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{0}
}
func (m *IdentityRequirement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityRequirement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityRequirement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdentityRequirement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityRequirement.Merge(m, src)
}
func (m *IdentityRequirement) XXX_Size() int {
	return m.Size()
}
func (m *IdentityRequirement) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityRequirement.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityRequirement proto.InternalMessageInfo

func (m *IdentityRequirement) GetMinScore() uint32 {
	if m != nil {
		return m.MinScore
	}
	return 0
}

func (m *IdentityRequirement) GetRequiredStatus() string {
	if m != nil {
		return m.RequiredStatus
	}
	return ""
}

func (m *IdentityRequirement) GetRequireVerifiedEmail() bool {
	if m != nil {
		return m.RequireVerifiedEmail
	}
	return false
}

func (m *IdentityRequirement) GetRequireVerifiedDomain() bool {
	if m != nil {
		return m.RequireVerifiedDomain
	}
	return false
}

func (m *IdentityRequirement) GetRequireMfa() bool {
	if m != nil {
		return m.RequireMfa
	}
	return false
}

// PricingInfo defines the pricing structure for an offering
type PricingInfo struct {
	Model             PricingModel      `protobuf:"varint,1,opt,name=model,proto3,enum=virtengine.marketplace.v1.PricingModel" json:"model" yaml:"model"`
	BasePrice         uint64            `protobuf:"varint,2,opt,name=base_price,json=basePrice,proto3" json:"base_price" yaml:"base_price"`
	Currency          string            `protobuf:"bytes,3,opt,name=currency,proto3" json:"currency" yaml:"currency"`
	UsageRates        map[string]uint64 `protobuf:"bytes,4,rep,name=usage_rates,json=usageRates,proto3" json:"usage_rates,omitempty" yaml:"usage_rates" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	MinimumCommitment int64             `protobuf:"varint,5,opt,name=minimum_commitment,json=minimumCommitment,proto3" json:"minimum_commitment,omitempty" yaml:"minimum_commitment"`
}

func (m *PricingInfo) Reset()         { *m = PricingInfo{} }
func (m *PricingInfo) String() string { return proto.CompactTextString(m) }
func (*PricingInfo) ProtoMessage()    {}
func (*PricingInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{1}
}
func (m *PricingInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PricingInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PricingInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PricingInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PricingInfo.Merge(m, src)
}
func (m *PricingInfo) XXX_Size() int {
	return m.Size()
}
func (m *PricingInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PricingInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PricingInfo proto.InternalMessageInfo

func (m *PricingInfo) GetModel() PricingModel {
	if m != nil {
		return m.Model
	}
	return PricingModel_PRICING_MODEL_UNSPECIFIED
}

func (m *PricingInfo) GetBasePrice() uint64 {
	if m != nil {
		return m.BasePrice
	}
	return 0
}

func (m *PricingInfo) GetCurrency() string {
	if m != nil {
		return m.Currency
	}
	return ""
}

func (m *PricingInfo) GetUsageRates() map[string]uint64 {
	if m != nil {
		return m.UsageRates
	}
	return nil
}

func (m *PricingInfo) GetMinimumCommitment() int64 {
	if m != nil {
		return m.MinimumCommitment
	}
	return 0
}

// PriceComponent represents component-based pricing for an offering.
type PriceComponent struct {
	// Resource type (cpu, ram, storage, gpu, network).
	ResourceType string `protobuf:"bytes,1,opt,name=resource_type,json=resourceType,proto3" json:"resource_type,omitempty" yaml:"resource_type"`
	// Unit of the component (vcpu, gb, hour, month).
	Unit string `protobuf:"bytes,2,opt,name=unit,proto3" json:"unit,omitempty" yaml:"unit"`
	// Price per unit.
	Price types.Coin `protobuf:"bytes,3,opt,name=price,proto3" json:"price" yaml:"price"`
	// USD reference price at time of creation (display only).
	UsdReference string `protobuf:"bytes,4,opt,name=usd_reference,json=usdReference,proto3" json:"usd_reference,omitempty" yaml:"usd_reference"`
}

func (m *PriceComponent) Reset()         { *m = PriceComponent{} }
func (m *PriceComponent) String() string { return proto.CompactTextString(m) }
func (*PriceComponent) ProtoMessage()    {}
func (*PriceComponent) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{2}
}
func (m *PriceComponent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PriceComponent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PriceComponent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PriceComponent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PriceComponent.Merge(m, src)
}
func (m *PriceComponent) XXX_Size() int {
	return m.Size()
}
func (m *PriceComponent) XXX_DiscardUnknown() {
	xxx_messageInfo_PriceComponent.DiscardUnknown(m)
}

var xxx_messageInfo_PriceComponent proto.InternalMessageInfo

func (m *PriceComponent) GetResourceType() string {
	if m != nil {
		return m.ResourceType
	}
	return ""
}

func (m *PriceComponent) GetUnit() string {
	if m != nil {
		return m.Unit
	}
	return ""
}

func (m *PriceComponent) GetPrice() types.Coin {
	if m != nil {
		return m.Price
	}
	return types.Coin{}
}

func (m *PriceComponent) GetUsdReference() string {
	if m != nil {
		return m.UsdReference
	}
	return ""
}

// OfferingID is the unique identifier for an offering
type OfferingID struct {
	ProviderAddress string `protobuf:"bytes,1,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	Sequence        uint64 `protobuf:"varint,2,opt,name=sequence,proto3" json:"sequence" yaml:"sequence"`
}

func (m *OfferingID) Reset()         { *m = OfferingID{} }
func (m *OfferingID) String() string { return proto.CompactTextString(m) }
func (*OfferingID) ProtoMessage()    {}
func (*OfferingID) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{3}
}
func (m *OfferingID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OfferingID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OfferingID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OfferingID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OfferingID.Merge(m, src)
}
func (m *OfferingID) XXX_Size() int {
	return m.Size()
}
func (m *OfferingID) XXX_DiscardUnknown() {
	xxx_messageInfo_OfferingID.DiscardUnknown(m)
}

var xxx_messageInfo_OfferingID proto.InternalMessageInfo

func (m *OfferingID) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *OfferingID) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// EncryptedProviderSecrets holds encrypted provider secrets
type EncryptedProviderSecrets struct {
	Envelope        *v1.EncryptedPayloadEnvelope `protobuf:"bytes,1,opt,name=envelope,proto3" json:"envelope" yaml:"envelope"`
	EnvelopeRef     string                       `protobuf:"bytes,2,opt,name=envelope_ref,json=envelopeRef,proto3" json:"envelope_ref,omitempty" yaml:"envelope_ref"`
	RecipientKeyIds []string                     `protobuf:"bytes,3,rep,name=recipient_key_ids,json=recipientKeyIds,proto3" json:"recipient_key_ids,omitempty" yaml:"recipient_key_ids"`
}

func (m *EncryptedProviderSecrets) Reset()         { *m = EncryptedProviderSecrets{} }
func (m *EncryptedProviderSecrets) String() string { return proto.CompactTextString(m) }
func (*EncryptedProviderSecrets) ProtoMessage()    {}
func (*EncryptedProviderSecrets) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{4}
}
func (m *EncryptedProviderSecrets) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedProviderSecrets) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedProviderSecrets.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedProviderSecrets) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedProviderSecrets.Merge(m, src)
}
func (m *EncryptedProviderSecrets) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedProviderSecrets) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedProviderSecrets.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedProviderSecrets proto.InternalMessageInfo

func (m *EncryptedProviderSecrets) GetEnvelope() *v1.EncryptedPayloadEnvelope {
	if m != nil {
		return m.Envelope
	}
	return nil
}

func (m *EncryptedProviderSecrets) GetEnvelopeRef() string {
	if m != nil {
		return m.EnvelopeRef
	}
	return ""
}

func (m *EncryptedProviderSecrets) GetRecipientKeyIds() []string {
	if m != nil {
		return m.RecipientKeyIds
	}
	return nil
}

// Offering represents a marketplace offering from a provider
type Offering struct {
	Id                  *OfferingID               `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	State               OfferingState             `protobuf:"varint,2,opt,name=state,proto3,enum=virtengine.marketplace.v1.OfferingState" json:"state" yaml:"state"`
	Category            OfferingCategory          `protobuf:"varint,3,opt,name=category,proto3,enum=virtengine.marketplace.v1.OfferingCategory" json:"category" yaml:"category"`
	Name                string                    `protobuf:"bytes,4,opt,name=name,proto3" json:"name" yaml:"name"`
	Description         string                    `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty" yaml:"description"`
	Version             string                    `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" yaml:"version"`
	Pricing             *PricingInfo              `protobuf:"bytes,7,opt,name=pricing,proto3" json:"pricing" yaml:"pricing"`
	IdentityRequirement *IdentityRequirement      `protobuf:"bytes,8,opt,name=identity_requirement,json=identityRequirement,proto3" json:"identity_requirement" yaml:"identity_requirement"`
	RequireMfaForOrders bool                      `protobuf:"varint,9,opt,name=require_mfa_for_orders,json=requireMfaForOrders,proto3" json:"require_mfa_for_orders" yaml:"require_mfa_for_orders"`
	PublicMetadata      map[string]string         `protobuf:"bytes,10,rep,name=public_metadata,json=publicMetadata,proto3" json:"public_metadata,omitempty" yaml:"public_metadata" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	EncryptedSecrets    *EncryptedProviderSecrets `protobuf:"bytes,11,opt,name=encrypted_secrets,json=encryptedSecrets,proto3" json:"encrypted_secrets,omitempty" yaml:"encrypted_secrets"`
	Specifications      map[string]string         `protobuf:"bytes,12,rep,name=specifications,proto3" json:"specifications,omitempty" yaml:"specifications" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Tags                []string                  `protobuf:"bytes,13,rep,name=tags,proto3" json:"tags,omitempty" yaml:"tags"`
	Regions             []string                  `protobuf:"bytes,14,rep,name=regions,proto3" json:"regions,omitempty" yaml:"regions"`
	CreatedAt           time.Time                 `protobuf:"bytes,15,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	UpdatedAt           time.Time                 `protobuf:"bytes,16,opt,name=updated_at,json=updatedAt,proto3,stdtime" json:"updated_at" yaml:"updated_at"`
	ActivatedAt         *time.Time                `protobuf:"bytes,17,opt,name=activated_at,json=activatedAt,proto3,stdtime" json:"activated_at,omitempty" yaml:"activated_at"`
	TerminatedAt        *time.Time                `protobuf:"bytes,18,opt,name=terminated_at,json=terminatedAt,proto3,stdtime" json:"terminated_at,omitempty" yaml:"terminated_at"`
	MaxConcurrentOrders uint32                    `protobuf:"varint,19,opt,name=max_concurrent_orders,json=maxConcurrentOrders,proto3" json:"max_concurrent_orders,omitempty" yaml:"max_concurrent_orders"`
	TotalOrderCount     uint64                    `protobuf:"varint,20,opt,name=total_order_count,json=totalOrderCount,proto3" json:"total_order_count" yaml:"total_order_count"`
	ActiveOrderCount    uint64                    `protobuf:"varint,21,opt,name=active_order_count,json=activeOrderCount,proto3" json:"active_order_count" yaml:"active_order_count"`
	Prices              []PriceComponent          `protobuf:"bytes,22,rep,name=prices,proto3" json:"prices,omitempty" yaml:"prices"`
	AllowBidding        bool                      `protobuf:"varint,23,opt,name=allow_bidding,json=allowBidding,proto3" json:"allow_bidding" yaml:"allow_bidding"`
	MinBid              types.Coin                `protobuf:"bytes,24,opt,name=min_bid,json=minBid,proto3" json:"min_bid,omitempty" yaml:"min_bid"`
}

func (m *Offering) Reset()         { *m = Offering{} }
func (m *Offering) String() string { return proto.CompactTextString(m) }
func (*Offering) ProtoMessage()    {}
func (*Offering) Descriptor() ([]byte, []int) {
	return fileDescriptor_e2d3f824b1680930, []int{5}
}
func (m *Offering) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Offering) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Offering.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Offering) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Offering.Merge(m, src)
}
func (m *Offering) XXX_Size() int {
	return m.Size()
}
func (m *Offering) XXX_DiscardUnknown() {
	xxx_messageInfo_Offering.DiscardUnknown(m)
}

var xxx_messageInfo_Offering proto.InternalMessageInfo

func (m *Offering) GetId() *OfferingID {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *Offering) GetState() OfferingState {
	if m != nil {
		return m.State
	}
	return OfferingState_OFFERING_STATE_UNSPECIFIED
}

func (m *Offering) GetCategory() OfferingCategory {
	if m != nil {
		return m.Category
	}
	return OfferingCategory_OFFERING_CATEGORY_UNSPECIFIED
}

func (m *Offering) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Offering) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Offering) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Offering) GetPricing() *PricingInfo {
	if m != nil {
		return m.Pricing
	}
	return nil
}

func (m *Offering) GetIdentityRequirement() *IdentityRequirement {
	if m != nil {
		return m.IdentityRequirement
	}
	return nil
}

func (m *Offering) GetRequireMfaForOrders() bool {
	if m != nil {
		return m.RequireMfaForOrders
	}
	return false
}

func (m *Offering) GetPublicMetadata() map[string]string {
	if m != nil {
		return m.PublicMetadata
	}
	return nil
}

func (m *Offering) GetEncryptedSecrets() *EncryptedProviderSecrets {
	if m != nil {
		return m.EncryptedSecrets
	}
	return nil
}

func (m *Offering) GetSpecifications() map[string]string {
	if m != nil {
		return m.Specifications
	}
	return nil
}

func (m *Offering) GetTags() []string {
	if m != nil {
		return m.Tags
	}
	return nil
}

func (m *Offering) GetRegions() []string {
	if m != nil {
		return m.Regions
	}
	return nil
}

func (m *Offering) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *Offering) GetUpdatedAt() time.Time {
	if m != nil {
		return m.UpdatedAt
	}
	return time.Time{}
}

func (m *Offering) GetActivatedAt() *time.Time {
	if m != nil {
		return m.ActivatedAt
	}
	return nil
}

func (m *Offering) GetTerminatedAt() *time.Time {
	if m != nil {
		return m.TerminatedAt
	}
	return nil
}

func (m *Offering) GetMaxConcurrentOrders() uint32 {
	if m != nil {
		return m.MaxConcurrentOrders
	}
	return 0
}

func (m *Offering) GetTotalOrderCount() uint64 {
	if m != nil {
		return m.TotalOrderCount
	}
	return 0
}

func (m *Offering) GetActiveOrderCount() uint64 {
	if m != nil {
		return m.ActiveOrderCount
	}
	return 0
}

func (m *Offering) GetPrices() []PriceComponent {
	if m != nil {
		return m.Prices
	}
	return nil
}

func (m *Offering) GetAllowBidding() bool {
	if m != nil {
		return m.AllowBidding
	}
	return false
}

func (m *Offering) GetMinBid() types.Coin {
	if m != nil {
		return m.MinBid
	}
	return types.Coin{}
}

func init() {
	proto.RegisterEnum("virtengine.marketplace.v1.OfferingState", OfferingState_name, OfferingState_value)
	proto.RegisterEnum("virtengine.marketplace.v1.OfferingCategory", OfferingCategory_name, OfferingCategory_value)
	proto.RegisterEnum("virtengine.marketplace.v1.PricingModel", PricingModel_name, PricingModel_value)
	proto.RegisterType((*IdentityRequirement)(nil), "virtengine.marketplace.v1.IdentityRequirement")
	proto.RegisterType((*PricingInfo)(nil), "virtengine.marketplace.v1.PricingInfo")
	proto.RegisterMapType((map[string]uint64)(nil), "virtengine.marketplace.v1.PricingInfo.UsageRatesEntry")
	proto.RegisterType((*PriceComponent)(nil), "virtengine.marketplace.v1.PriceComponent")
	proto.RegisterType((*OfferingID)(nil), "virtengine.marketplace.v1.OfferingID")
	proto.RegisterType((*EncryptedProviderSecrets)(nil), "virtengine.marketplace.v1.EncryptedProviderSecrets")
	proto.RegisterType((*Offering)(nil), "virtengine.marketplace.v1.Offering")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.marketplace.v1.Offering.PublicMetadataEntry")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.marketplace.v1.Offering.SpecificationsEntry")
}

func init() {
	proto.RegisterFile("virtengine/marketplace/v1/types.proto", fileDescriptor_e2d3f824b1680930)
}

var fileDescriptor_e2d3f824b1680930 = []byte{
	// 2099 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcb, 0x6f, 0xdb, 0xc8,
	0x19, 0x8f, 0xfc, 0x48, 0xac, 0x91, 0x1f, 0xf2, 0xd8, 0x8e, 0x69, 0x27, 0x31, 0xb3, 0xd3, 0xa6,
	0xeb, 0x24, 0x5d, 0x09, 0x71, 0xb0, 0xdd, 0x62, 0x83, 0x2d, 0x20, 0xc9, 0xb4, 0xa3, 0x6e, 0x6c,
	0xa9, 0x23, 0x39, 0x4d, 0x0a, 0x14, 0x04, 0x4d, 0x8e, 0xb4, 0x83, 0x88, 0xa4, 0x42, 0x52, 0xde,
	0xe8, 0x3f, 0xe8, 0x71, 0x4f, 0x05, 0x5a, 0xa0, 0x40, 0xff, 0x87, 0xf6, 0xba, 0x87, 0xde, 0x16,
	0xed, 0x65, 0xd1, 0x53, 0x4f, 0xdc, 0x22, 0xb9, 0xe9, 0xa8, 0x7f, 0xa0, 0xc5, 0x3c, 0x28, 0x92,
	0x12, 0x13, 0x7b, 0x6f, 0x9c, 0xdf, 0xef, 0x7b, 0xcc, 0xe3, 0xfb, 0xbe, 0xf9, 0x86, 0xe0, 0xde,
	0x05, 0xf5, 0x02, 0xe2, 0x74, 0xa9, 0x43, 0xca, 0xb6, 0xe1, 0xbd, 0x22, 0x41, 0xbf, 0x67, 0x98,
	0xa4, 0x7c, 0xf1, 0xa8, 0x1c, 0x0c, 0xfb, 0xc4, 0x2f, 0xf5, 0x3d, 0x37, 0x70, 0xe1, 0x4e, 0x2c,
	0x56, 0x4a, 0x88, 0x95, 0x2e, 0x1e, 0xed, 0xee, 0x99, 0xae, 0x6f, 0xbb, 0x7e, 0xf9, 0xdc, 0xf0,
	0x99, 0xda, 0x39, 0x09, 0x8c, 0x47, 0x65, 0xd3, 0xa5, 0x8e, 0x50, 0xdd, 0xdd, 0x11, 0xbc, 0xce,
	0x47, 0x65, 0x31, 0x90, 0xd4, 0x66, 0xd7, 0xed, 0xba, 0x02, 0x67, 0x5f, 0x12, 0x55, 0xbb, 0xae,
	0xdb, 0xed, 0x91, 0x32, 0x1f, 0x9d, 0x0f, 0x3a, 0xe5, 0x80, 0xda, 0xc4, 0x0f, 0x0c, 0xbb, 0x2f,
	0x05, 0x7e, 0x9a, 0x98, 0x33, 0x71, 0x4c, 0x6f, 0xd8, 0x0f, 0xa8, 0xeb, 0x4c, 0x4d, 0x19, 0xfd,
	0x30, 0x0f, 0x36, 0xea, 0x16, 0x71, 0x02, 0x1a, 0x0c, 0x31, 0x79, 0x3d, 0xa0, 0x1e, 0xb1, 0x89,
	0x13, 0xc0, 0x5f, 0x81, 0xbc, 0x4d, 0x1d, 0xdd, 0x37, 0x5d, 0x8f, 0x28, 0xb9, 0xbb, 0xb9, 0xfd,
	0x95, 0xea, 0x47, 0xa3, 0x50, 0x8d, 0xc1, 0x71, 0xa8, 0x16, 0x87, 0x86, 0xdd, 0xfb, 0x1c, 0x4d,
	0x20, 0x84, 0x97, 0x6c, 0xea, 0xb4, 0xd8, 0x27, 0x7c, 0x0e, 0xd6, 0x3c, 0x61, 0xce, 0xd2, 0xfd,
	0xc0, 0x08, 0x06, 0xbe, 0x32, 0x77, 0x37, 0xb7, 0x9f, 0xaf, 0x7e, 0x32, 0x0a, 0xd5, 0x69, 0x6a,
	0x1c, 0xaa, 0x37, 0x85, 0xad, 0x29, 0x02, 0xe1, 0xd5, 0x08, 0x69, 0x71, 0x00, 0xbe, 0x06, 0x37,
	0x25, 0xa2, 0x5f, 0x10, 0x8f, 0x76, 0x28, 0xb1, 0x74, 0x62, 0x1b, 0xb4, 0xa7, 0xcc, 0xdf, 0xcd,
	0xed, 0x2f, 0x55, 0x9f, 0x8c, 0x42, 0xf5, 0x3d, 0x12, 0xe3, 0x50, 0xbd, 0x93, 0xf2, 0x32, 0xc5,
	0x23, 0xbc, 0x29, 0x89, 0xe7, 0x12, 0xd7, 0x18, 0x0c, 0x07, 0x60, 0x7b, 0x46, 0xc1, 0x72, 0x6d,
	0x83, 0x3a, 0xca, 0x02, 0xf7, 0xf9, 0xc5, 0x28, 0x54, 0xdf, 0x27, 0x32, 0x0e, 0xd5, 0xbd, 0xf7,
	0x38, 0x15, 0x02, 0x08, 0x6f, 0x4d, 0x79, 0x3d, 0xe4, 0x38, 0x3c, 0x02, 0x85, 0x48, 0xc5, 0xee,
	0x18, 0xca, 0x22, 0x77, 0x75, 0x6f, 0x14, 0xaa, 0x49, 0x78, 0x1c, 0xaa, 0x30, 0x6d, 0xde, 0xee,
	0x18, 0x08, 0x03, 0x39, 0x3a, 0xe9, 0x18, 0xe8, 0xaf, 0x0b, 0xa0, 0xd0, 0xf4, 0xa8, 0x49, 0x9d,
	0x6e, 0xdd, 0xe9, 0xb8, 0xf0, 0x05, 0x58, 0xb4, 0x5d, 0x8b, 0xf4, 0xf8, 0xa9, 0xae, 0x1e, 0x7c,
	0x5c, 0x7a, 0x6f, 0xd0, 0x96, 0xa4, 0xda, 0x09, 0x13, 0xaf, 0xee, 0x8c, 0x42, 0x55, 0x68, 0x8e,
	0x43, 0x75, 0x59, 0x1e, 0x3d, 0x1b, 0x22, 0x2c, 0x60, 0x58, 0x05, 0x80, 0x85, 0xb7, 0xde, 0xf7,
	0xa8, 0x49, 0xf8, 0x71, 0x2f, 0x54, 0x7f, 0x32, 0x0a, 0xd5, 0x04, 0x3a, 0x0e, 0xd5, 0x75, 0xa1,
	0x1a, 0x63, 0x08, 0xe7, 0xd9, 0x80, 0x39, 0x23, 0xf0, 0x09, 0x58, 0x32, 0x07, 0x9e, 0x47, 0x1c,
	0x73, 0xc8, 0x4f, 0x34, 0x5f, 0x55, 0x47, 0xa1, 0x3a, 0xc1, 0xc6, 0xa1, 0xba, 0x26, 0xf4, 0x23,
	0x04, 0xe1, 0x09, 0x09, 0xff, 0x90, 0x03, 0x85, 0x81, 0x6f, 0x74, 0x89, 0xee, 0x19, 0x01, 0xf1,
	0x95, 0x85, 0xbb, 0xf3, 0xfb, 0x85, 0x83, 0x5f, 0x5c, 0xbe, 0x42, 0xb6, 0x31, 0xa5, 0x33, 0xa6,
	0x89, 0x99, 0xa2, 0xe6, 0x04, 0xde, 0xb0, 0x5a, 0x1e, 0x85, 0xea, 0x56, 0xc2, 0xdc, 0xcf, 0x5d,
	0x9b, 0x06, 0xc4, 0xee, 0x07, 0xc3, 0x78, 0xd7, 0x13, 0x34, 0xc2, 0x60, 0x30, 0xb1, 0x00, 0x7b,
	0x00, 0xda, 0xd4, 0xa1, 0xf6, 0xc0, 0xd6, 0x4d, 0xd7, 0xb6, 0x69, 0xc0, 0xb2, 0x8a, 0x1f, 0xe2,
	0x3c, 0x8f, 0x97, 0xdb, 0xb3, 0x6c, 0xca, 0xfe, 0xce, 0x24, 0xb7, 0xa6, 0xa4, 0x10, 0x5e, 0x97,
	0x60, 0x6d, 0x82, 0xed, 0x7e, 0x01, 0xd6, 0xa6, 0x66, 0x0f, 0x8b, 0x60, 0xfe, 0x15, 0x19, 0xf2,
	0x43, 0xce, 0x63, 0xf6, 0x09, 0x37, 0xc1, 0xe2, 0x85, 0xd1, 0x1b, 0xc8, 0x93, 0xc1, 0x62, 0xf0,
	0xf9, 0xdc, 0x2f, 0x73, 0xe8, 0x5f, 0x73, 0x60, 0x95, 0x6f, 0x7f, 0xcd, 0xb5, 0xfb, 0xae, 0xc3,
	0xf2, 0xff, 0x05, 0x58, 0xf1, 0x88, 0xef, 0x0e, 0x3c, 0x93, 0xe8, 0xac, 0x5e, 0x08, 0x43, 0xd5,
	0xc7, 0x22, 0xd4, 0x13, 0x44, 0x6a, 0xd6, 0x9b, 0x51, 0x2c, 0x26, 0x04, 0x10, 0x5e, 0x8e, 0xc6,
	0xed, 0x61, 0x9f, 0xc0, 0x4f, 0xc1, 0xc2, 0xc0, 0xa1, 0x81, 0x2c, 0x07, 0xac, 0xa8, 0xac, 0xb2,
	0x71, 0xca, 0x4e, 0x41, 0xee, 0xae, 0x43, 0x03, 0x84, 0xb9, 0x38, 0x3c, 0x05, 0x8b, 0x22, 0xae,
	0x58, 0x54, 0x14, 0x0e, 0x76, 0x4a, 0xb2, 0x46, 0xb2, 0xd0, 0x29, 0xc9, 0x82, 0x5a, 0xaa, 0xb9,
	0xd4, 0xa9, 0xde, 0xf9, 0x2e, 0x54, 0xaf, 0xb1, 0x60, 0x8d, 0x22, 0x4e, 0x06, 0xab, 0x0c, 0x36,
	0x01, 0xb3, 0x05, 0x0e, 0x7c, 0x4b, 0xf7, 0x48, 0x87, 0xb0, 0xe0, 0x21, 0x3c, 0x97, 0xe5, 0x02,
	0x53, 0x44, 0xd6, 0x02, 0x53, 0x02, 0x08, 0x2f, 0x0f, 0x7c, 0x0b, 0x4f, 0x86, 0xdf, 0xe6, 0x00,
	0x68, 0x74, 0x3a, 0xc4, 0x63, 0x81, 0x75, 0x08, 0x3d, 0x50, 0xec, 0x7b, 0xee, 0x05, 0xb5, 0x88,
	0xa7, 0x1b, 0x96, 0xe5, 0x11, 0xdf, 0x97, 0x9b, 0x79, 0x3c, 0x0a, 0xd5, 0x19, 0x6e, 0x1c, 0xaa,
	0xdb, 0xd1, 0x7c, 0xd3, 0x0c, 0xfa, 0xf7, 0xdf, 0x3f, 0xd9, 0x94, 0xab, 0xae, 0x08, 0xa8, 0x15,
	0x30, 0x27, 0x78, 0x2d, 0x12, 0x95, 0x30, 0xcb, 0x22, 0x9f, 0xbc, 0x1e, 0xf0, 0x75, 0x89, 0x3c,
	0xe4, 0x59, 0x14, 0x61, 0x71, 0x16, 0x45, 0x08, 0xc2, 0x13, 0x12, 0xfd, 0x73, 0x0e, 0x28, 0x9a,
	0xb8, 0x30, 0x88, 0xd5, 0x94, 0x96, 0x5b, 0xc4, 0xf4, 0x48, 0xe0, 0x43, 0x17, 0x2c, 0x11, 0xe7,
	0x82, 0xf4, 0x5c, 0x19, 0x12, 0x85, 0x83, 0x83, 0x64, 0x7a, 0xc5, 0x17, 0x0d, 0xcb, 0xae, 0xd8,
	0x8a, 0x31, 0xec, 0xb9, 0x86, 0xa5, 0x49, 0x4d, 0x31, 0x9b, 0xc8, 0x4e, 0x3c, 0x9b, 0x08, 0x41,
	0x78, 0x42, 0xc2, 0x36, 0x58, 0x8e, 0xbe, 0xd9, 0x96, 0xcb, 0xb0, 0x79, 0xc4, 0xca, 0x7c, 0x12,
	0x4f, 0x9d, 0xd2, 0x46, 0xda, 0x1c, 0xe3, 0x11, 0x2e, 0x44, 0x43, 0x4c, 0x3a, 0xb0, 0x0b, 0xd6,
	0x3d, 0x62, 0xd2, 0x3e, 0x25, 0x4e, 0xa0, 0xbf, 0x22, 0x43, 0x9d, 0x5a, 0xbe, 0x32, 0x7f, 0x77,
	0x7e, 0x3f, 0xcf, 0x6f, 0x90, 0x5b, 0x33, 0x64, 0xca, 0xbe, 0x12, 0x85, 0xf9, 0x94, 0x10, 0xc2,
	0x6b, 0x13, 0xec, 0x4b, 0x32, 0xac, 0x5b, 0x3e, 0xfa, 0x76, 0x13, 0x2c, 0x45, 0xc1, 0x00, 0x7f,
	0x0d, 0xe6, 0xa8, 0x25, 0xb7, 0xed, 0xde, 0x07, 0xaa, 0x52, 0x1c, 0x3d, 0xd5, 0x8d, 0x51, 0xa8,
	0xce, 0x51, 0x6b, 0x1c, 0xaa, 0x79, 0xe1, 0x94, 0x5a, 0x08, 0xcf, 0x51, 0x0b, 0xbe, 0x04, 0x8b,
	0xec, 0x8e, 0x14, 0xe7, 0xbb, 0x7a, 0xb0, 0x7f, 0x05, 0x73, 0xec, 0x0a, 0x25, 0xa2, 0x8e, 0x73,
	0xd5, 0x38, 0x35, 0xf8, 0x10, 0x61, 0x01, 0xc3, 0xaf, 0xc0, 0x92, 0x69, 0x04, 0xa4, 0xeb, 0x7a,
	0xa2, 0x06, 0xaf, 0x1e, 0x3c, 0xbc, 0x82, 0xf5, 0x9a, 0x54, 0x91, 0x05, 0x5b, 0x8e, 0x12, 0x05,
	0x5b, 0x22, 0xac, 0x60, 0xcb, 0x4f, 0xf8, 0x10, 0x2c, 0x38, 0x86, 0x1d, 0xe5, 0xde, 0xf6, 0x28,
	0x54, 0xf9, 0x38, 0xae, 0x00, 0x6c, 0x84, 0x30, 0x07, 0xe1, 0x6f, 0x40, 0xc1, 0x22, 0xbe, 0xe9,
	0x51, 0x1e, 0x5f, 0xbc, 0x96, 0xe6, 0x45, 0x91, 0x4e, 0xc0, 0x59, 0x45, 0x3a, 0x41, 0x23, 0x9c,
	0xb4, 0x01, 0x2b, 0xe0, 0xc6, 0x05, 0xf1, 0x7c, 0x66, 0xee, 0x3a, 0x37, 0xf7, 0xf1, 0x28, 0x54,
	0xd7, 0x25, 0x94, 0x32, 0xb5, 0x2a, 0x4c, 0x49, 0x0a, 0xe1, 0x48, 0x0f, 0xea, 0xe0, 0x46, 0x5f,
	0x5c, 0x22, 0xca, 0x0d, 0x7e, 0xb0, 0x3f, 0xbb, 0xda, 0x75, 0x53, 0xbd, 0x33, 0x0a, 0xd5, 0x48,
	0x35, 0x76, 0x20, 0x01, 0x84, 0x23, 0x0a, 0xfe, 0x39, 0x07, 0x36, 0xa9, 0xec, 0xd0, 0x74, 0x2f,
	0x6e, 0xd1, 0x94, 0x25, 0xee, 0xae, 0xf4, 0x01, 0x77, 0x19, 0x8d, 0x5d, 0xf5, 0xb3, 0x51, 0xa8,
	0x66, 0xda, 0x1b, 0x87, 0xea, 0xad, 0x28, 0xc4, 0x66, 0x59, 0x84, 0x37, 0x68, 0x46, 0x9b, 0xd8,
	0x8f, 0xdb, 0x31, 0xbb, 0x63, 0xe8, 0x1d, 0xd7, 0xd3, 0x5d, 0xcf, 0x22, 0x9e, 0xaf, 0xe4, 0x67,
	0xdb, 0xb1, 0xb4, 0xc4, 0x6c, 0x3b, 0x96, 0xe6, 0x11, 0xde, 0x88, 0xbb, 0x98, 0x23, 0xd7, 0x6b,
	0x70, 0x14, 0xfe, 0x29, 0x07, 0xd6, 0xfa, 0x83, 0xf3, 0x1e, 0x35, 0x75, 0x9b, 0x04, 0x86, 0x65,
	0x04, 0x86, 0x02, 0xf8, 0x3d, 0xff, 0xd9, 0x15, 0x82, 0xb4, 0xd4, 0xe4, 0xaa, 0x27, 0x52, 0x53,
	0x5c, 0xf4, 0x6c, 0x4b, 0x76, 0xa6, 0x6c, 0xa6, 0x0e, 0x5f, 0x36, 0xa7, 0x53, 0x22, 0x08, 0xaf,
	0xf6, 0x53, 0xd6, 0xe0, 0x5f, 0x72, 0x60, 0x9d, 0x44, 0x35, 0x4f, 0xf7, 0x45, 0xc9, 0x54, 0x0a,
	0xfc, 0x9c, 0x1e, 0x7f, 0x60, 0x76, 0xef, 0xab, 0xb6, 0xa2, 0x16, 0xcd, 0x58, 0xcc, 0xaa, 0x45,
	0x33, 0x42, 0x08, 0x17, 0x27, 0x58, 0x54, 0xbc, 0xff, 0x98, 0x03, 0xab, 0x7e, 0x9f, 0x98, 0xb4,
	0x43, 0x4d, 0x83, 0x25, 0x80, 0xaf, 0x2c, 0x5f, 0x7d, 0xeb, 0x5a, 0x29, 0x4d, 0xb1, 0x75, 0x9f,
	0x8e, 0x42, 0x55, 0x49, 0x9b, 0x4c, 0xcd, 0x6e, 0x4b, 0xd6, 0x97, 0x94, 0x04, 0xc2, 0x53, 0xb3,
	0x60, 0x3d, 0x41, 0x60, 0x74, 0x7d, 0x65, 0x85, 0x57, 0x60, 0xde, 0x13, 0xb0, 0x71, 0x56, 0x4f,
	0xc0, 0x70, 0x84, 0xb9, 0x38, 0x4b, 0x5f, 0x8f, 0x74, 0xf9, 0x3a, 0x56, 0xb9, 0x26, 0x4f, 0x5f,
	0x09, 0x65, 0xa5, 0xaf, 0xa4, 0x10, 0x8e, 0xf4, 0x60, 0x07, 0x00, 0xd3, 0x23, 0x06, 0xdb, 0x38,
	0x23, 0x50, 0xd6, 0xf8, 0x51, 0xed, 0x96, 0xc4, 0xdb, 0xaa, 0x14, 0xbd, 0xad, 0x4a, 0xed, 0xe8,
	0x6d, 0x55, 0x7d, 0x28, 0x9b, 0x8b, 0x84, 0x56, 0xdc, 0xd3, 0xc6, 0x18, 0xfa, 0xe6, 0x07, 0x35,
	0x87, 0xf3, 0x12, 0xa8, 0x04, 0xcc, 0xcf, 0xa0, 0x6f, 0x45, 0x7e, 0x8a, 0x57, 0xf7, 0x13, 0x6b,
	0xc5, 0x7e, 0x62, 0x4c, 0xfa, 0x91, 0x40, 0x25, 0x80, 0x01, 0x58, 0x36, 0xcc, 0x80, 0x5e, 0x44,
	0x9e, 0xd6, 0x2f, 0xf5, 0xc4, 0x8e, 0xf0, 0x66, 0x52, 0x27, 0xeb, 0x2a, 0x4d, 0xf2, 0xc2, 0x67,
	0x61, 0x02, 0x55, 0x02, 0xf8, 0x06, 0xac, 0x04, 0xc4, 0xb3, 0xa9, 0x13, 0xb9, 0x85, 0x97, 0xba,
	0x65, 0x49, 0xb7, 0x9d, 0x52, 0xca, 0x6a, 0xb4, 0x52, 0x02, 0xc2, 0xf1, 0x72, 0x8c, 0x55, 0x02,
	0xf8, 0x35, 0xd8, 0xb2, 0x8d, 0x37, 0xba, 0xe9, 0x3a, 0xe2, 0x15, 0x10, 0x44, 0xf5, 0x67, 0x83,
	0xbf, 0x59, 0x6b, 0xa3, 0x50, 0x55, 0x33, 0x05, 0x52, 0xde, 0x6e, 0xcb, 0x6e, 0x3b, 0x4b, 0x10,
	0xe1, 0x0d, 0xdb, 0x78, 0x53, 0x9b, 0xc0, 0xb2, 0x0e, 0xfd, 0x1e, 0xac, 0x07, 0x6e, 0x60, 0xf4,
	0x84, 0x94, 0x6e, 0xba, 0x03, 0x27, 0x50, 0x36, 0x79, 0xaf, 0xc5, 0x9a, 0x93, 0x59, 0x32, 0xce,
	0xd5, 0x19, 0x0a, 0xe1, 0x35, 0x8e, 0x71, 0xd3, 0x35, 0x86, 0x40, 0x03, 0x40, 0xbe, 0xc1, 0x24,
	0x65, 0x7f, 0x8b, 0xdb, 0x67, 0x3d, 0x6a, 0x06, 0x1b, 0xbf, 0x1a, 0x66, 0x39, 0x84, 0x8b, 0x02,
	0x4c, 0xb8, 0xe8, 0x81, 0xeb, 0xbc, 0x15, 0xf6, 0x95, 0x9b, 0xbc, 0x08, 0xdc, 0xbf, 0xe4, 0xe2,
	0x8a, 0x5f, 0x07, 0xd5, 0xfb, 0x32, 0x3a, 0x8b, 0xc2, 0x40, 0x6a, 0x2f, 0x57, 0x12, 0xdd, 0xb6,
	0x8f, 0xb0, 0xf4, 0x01, 0x4f, 0xc1, 0x8a, 0xd1, 0xeb, 0xb9, 0x5f, 0xeb, 0xe7, 0xd4, 0xb2, 0xd8,
	0x6d, 0xb9, 0xcd, 0x2f, 0x88, 0xfb, 0xa3, 0x50, 0x4d, 0x13, 0xf1, 0xe1, 0xa7, 0x60, 0x84, 0x97,
	0xf9, 0xb8, 0x2a, 0x86, 0xec, 0xde, 0xb5, 0xa9, 0xc3, 0x58, 0x45, 0xb9, 0xec, 0x45, 0x10, 0x25,
	0xd3, 0xba, 0xd4, 0xc8, 0x2a, 0x0d, 0x92, 0x42, 0xf8, 0xba, 0x4d, 0x9d, 0x2a, 0xb5, 0x76, 0x2b,
	0x60, 0x23, 0xe3, 0xb2, 0xb8, 0xec, 0x5d, 0x95, 0x4f, 0xbc, 0xab, 0x98, 0x89, 0x8c, 0xa2, 0xf9,
	0x63, 0x4c, 0x3c, 0xf8, 0x47, 0x0e, 0xac, 0xa4, 0xfa, 0x37, 0xb8, 0x07, 0x76, 0x1b, 0x47, 0x47,
	0x1a, 0xae, 0x9f, 0x1e, 0xeb, 0xad, 0x76, 0xa5, 0xad, 0xe9, 0x67, 0xa7, 0xad, 0xa6, 0x56, 0xab,
	0x1f, 0xd5, 0xb5, 0xc3, 0xe2, 0x35, 0xb8, 0x03, 0xb6, 0xa6, 0xf8, 0x4a, 0xad, 0x5d, 0x7f, 0xae,
	0x15, 0x73, 0x19, 0x54, 0xb3, 0x72, 0xd6, 0xd2, 0x0e, 0x8b, 0x73, 0xf0, 0x36, 0x50, 0xa6, 0xa8,
	0xd6, 0x59, 0xab, 0xa9, 0x9d, 0x1e, 0x6a, 0x87, 0xc5, 0x79, 0x78, 0x07, 0xec, 0x4c, 0xb1, 0x87,
	0x5a, 0x13, 0x6b, 0xb5, 0x4a, 0x5b, 0x3b, 0x2c, 0x2e, 0x64, 0xd0, 0x6d, 0x0d, 0x9f, 0xd4, 0x4f,
	0x39, 0xbd, 0xf8, 0xe0, 0x7f, 0x39, 0x50, 0x9c, 0xee, 0x12, 0xe1, 0x47, 0xe0, 0xce, 0x44, 0x87,
	0xd9, 0x39, 0x6e, 0xe0, 0x97, 0x53, 0x2b, 0x49, 0x9a, 0x9d, 0x88, 0xd4, 0x1a, 0x27, 0xcd, 0xb3,
	0x36, 0x5b, 0x4d, 0x26, 0xdd, 0x6a, 0x37, 0x70, 0xe5, 0x58, 0x2b, 0xce, 0x65, 0xd3, 0xa7, 0x5a,
	0xfb, 0xb7, 0x0d, 0xfc, 0x65, 0x71, 0x3e, 0xb5, 0x17, 0x13, 0xfa, 0x69, 0xb3, 0x56, 0x5c, 0xc8,
	0xa6, 0x8e, 0x9b, 0x67, 0xc5, 0x45, 0xa8, 0x80, 0xcd, 0x59, 0xea, 0xe4, 0x59, 0xf1, 0x3a, 0xbc,
	0x05, 0xb6, 0x67, 0x99, 0x46, 0xfb, 0xa9, 0x86, 0x8b, 0x37, 0x1e, 0xfc, 0x2d, 0x07, 0x96, 0x93,
	0x3f, 0x53, 0xd8, 0xe4, 0x9a, 0xb8, 0x5e, 0x63, 0xc2, 0x27, 0x8d, 0x43, 0xed, 0xd9, 0xd4, 0xca,
	0x15, 0xb0, 0x99, 0xa6, 0x9f, 0x36, 0xce, 0xf0, 0xb3, 0x97, 0xc5, 0x1c, 0xdc, 0x06, 0x1b, 0x69,
	0xe6, 0xb0, 0x52, 0x7f, 0xf6, 0xb2, 0x38, 0xc7, 0x26, 0x9d, 0x26, 0x4e, 0x1a, 0xa7, 0xed, 0xa7,
	0xcf, 0x5e, 0x8a, 0xd3, 0x9b, 0x72, 0xd6, 0xaa, 0x1c, 0x6b, 0x7a, 0xb5, 0xd2, 0xe2, 0xa7, 0x37,
	0x63, 0xf2, 0xa8, 0xfe, 0x82, 0x9d, 0x5b, 0xf5, 0xec, 0xbb, 0xb7, 0x7b, 0xb9, 0xef, 0xdf, 0xee,
	0xe5, 0xfe, 0xfb, 0x76, 0x2f, 0xf7, 0xcd, 0xbb, 0xbd, 0x6b, 0xdf, 0xbf, 0xdb, 0xbb, 0xf6, 0x9f,
	0x77, 0x7b, 0xd7, 0x7e, 0xf7, 0xa4, 0x4b, 0x83, 0xaf, 0x06, 0xe7, 0x25, 0xd3, 0xb5, 0xcb, 0x89,
	0xdf, 0x8c, 0x89, 0x4f, 0xdf, 0x7a, 0x55, 0xee, 0xba, 0x65, 0xc7, 0xb5, 0xa6, 0xff, 0x98, 0x9e,
	0x5f, 0xe7, 0xb7, 0xc1, 0xe3, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0xd6, 0x6b, 0xfc, 0xa5, 0x55,
	0x15, 0x00, 0x00,
}

func (m *IdentityRequirement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityRequirement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityRequirement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireMfa {
		i--
		if m.RequireMfa {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.RequireVerifiedDomain {
		i--
		if m.RequireVerifiedDomain {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.RequireVerifiedEmail {
		i--
		if m.RequireVerifiedEmail {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.RequiredStatus) > 0 {
		i -= len(m.RequiredStatus)
		copy(dAtA[i:], m.RequiredStatus)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RequiredStatus)))
		i--
		dAtA[i] = 0x12
	}
	if m.MinScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinScore))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PricingInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PricingInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PricingInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MinimumCommitment != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MinimumCommitment))
		i--
		dAtA[i] = 0x28
	}
	if len(m.UsageRates) > 0 {
		for k := range m.UsageRates {
			v := m.UsageRates[k]
			baseI := i
			i = encodeVarintTypes(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Currency) > 0 {
		i -= len(m.Currency)
		copy(dAtA[i:], m.Currency)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Currency)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BasePrice != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BasePrice))
		i--
		dAtA[i] = 0x10
	}
	if m.Model != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Model))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PriceComponent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PriceComponent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PriceComponent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UsdReference) > 0 {
		i -= len(m.UsdReference)
		copy(dAtA[i:], m.UsdReference)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UsdReference)))
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.Price.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if len(m.Unit) > 0 {
		i -= len(m.Unit)
		copy(dAtA[i:], m.Unit)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Unit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ResourceType) > 0 {
		i -= len(m.ResourceType)
		copy(dAtA[i:], m.ResourceType)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ResourceType)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OfferingID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OfferingID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OfferingID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Sequence != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Sequence))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EncryptedProviderSecrets) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedProviderSecrets) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedProviderSecrets) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RecipientKeyIds) > 0 {
		for iNdEx := len(m.RecipientKeyIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientKeyIds[iNdEx])
			copy(dAtA[i:], m.RecipientKeyIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RecipientKeyIds[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.EnvelopeRef) > 0 {
		i -= len(m.EnvelopeRef)
		copy(dAtA[i:], m.EnvelopeRef)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.EnvelopeRef)))
		i--
		dAtA[i] = 0x12
	}
	if m.Envelope != nil {
		{
			size, err := m.Envelope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Offering) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Offering) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Offering) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.MinBid.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	if m.AllowBidding {
		i--
		if m.AllowBidding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb8
	}
	if len(m.Prices) > 0 {
		for iNdEx := len(m.Prices) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Prices[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0xb2
		}
	}
	if m.ActiveOrderCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ActiveOrderCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.TotalOrderCount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.TotalOrderCount))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.MaxConcurrentOrders != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxConcurrentOrders))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.TerminatedAt != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.TerminatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.TerminatedAt):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintTypes(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x92
	}
	if m.ActivatedAt != nil {
		n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.ActivatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ActivatedAt):])
		if err5 != nil {
			return 0, err5
		}
		i -= n5
		i = encodeVarintTypes(dAtA, i, uint64(n5))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x8a
	}
	n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.UpdatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt):])
	if err6 != nil {
		return 0, err6
	}
	i -= n6
	i = encodeVarintTypes(dAtA, i, uint64(n6))
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err7 != nil {
		return 0, err7
	}
	i -= n7
	i = encodeVarintTypes(dAtA, i, uint64(n7))
	i--
	dAtA[i] = 0x7a
	if len(m.Regions) > 0 {
		for iNdEx := len(m.Regions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Regions[iNdEx])
			copy(dAtA[i:], m.Regions[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Regions[iNdEx])))
			i--
			dAtA[i] = 0x72
		}
	}
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x6a
		}
	}
	if len(m.Specifications) > 0 {
		for k := range m.Specifications {
			v := m.Specifications[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x62
		}
	}
	if m.EncryptedSecrets != nil {
		{
			size, err := m.EncryptedSecrets.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.PublicMetadata) > 0 {
		for k := range m.PublicMetadata {
			v := m.PublicMetadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x52
		}
	}
	if m.RequireMfaForOrders {
		i--
		if m.RequireMfaForOrders {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.IdentityRequirement != nil {
		{
			size, err := m.IdentityRequirement.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Pricing != nil {
		{
			size, err := m.Pricing.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x22
	}
	if m.Category != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Category))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != nil {
		{
			size, err := m.Id.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *IdentityRequirement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinScore != 0 {
		n += 1 + sovTypes(uint64(m.MinScore))
	}
	l = len(m.RequiredStatus)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireVerifiedEmail {
		n += 2
	}
	if m.RequireVerifiedDomain {
		n += 2
	}
	if m.RequireMfa {
		n += 2
	}
	return n
}

func (m *PricingInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Model != 0 {
		n += 1 + sovTypes(uint64(m.Model))
	}
	if m.BasePrice != 0 {
		n += 1 + sovTypes(uint64(m.BasePrice))
	}
	l = len(m.Currency)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.UsageRates) > 0 {
		for k, v := range m.UsageRates {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + sovTypes(uint64(v))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.MinimumCommitment != 0 {
		n += 1 + sovTypes(uint64(m.MinimumCommitment))
	}
	return n
}

func (m *PriceComponent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ResourceType)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Unit)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = m.Price.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = len(m.UsdReference)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *OfferingID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovTypes(uint64(m.Sequence))
	}
	return n
}

func (m *EncryptedProviderSecrets) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Envelope != nil {
		l = m.Envelope.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.EnvelopeRef)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.RecipientKeyIds) > 0 {
		for _, s := range m.RecipientKeyIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Offering) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != nil {
		l = m.Id.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	if m.Category != 0 {
		n += 1 + sovTypes(uint64(m.Category))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Pricing != nil {
		l = m.Pricing.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.IdentityRequirement != nil {
		l = m.IdentityRequirement.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.RequireMfaForOrders {
		n += 2
	}
	if len(m.PublicMetadata) > 0 {
		for k, v := range m.PublicMetadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if m.EncryptedSecrets != nil {
		l = m.EncryptedSecrets.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Specifications) > 0 {
		for k, v := range m.Specifications {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Regions) > 0 {
		for _, s := range m.Regions {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovTypes(uint64(l))
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.UpdatedAt)
	n += 2 + l + sovTypes(uint64(l))
	if m.ActivatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.ActivatedAt)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.TerminatedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.TerminatedAt)
		n += 2 + l + sovTypes(uint64(l))
	}
	if m.MaxConcurrentOrders != 0 {
		n += 2 + sovTypes(uint64(m.MaxConcurrentOrders))
	}
	if m.TotalOrderCount != 0 {
		n += 2 + sovTypes(uint64(m.TotalOrderCount))
	}
	if m.ActiveOrderCount != 0 {
		n += 2 + sovTypes(uint64(m.ActiveOrderCount))
	}
	if len(m.Prices) > 0 {
		for _, e := range m.Prices {
			l = e.Size()
			n += 2 + l + sovTypes(uint64(l))
		}
	}
	if m.AllowBidding {
		n += 3
	}
	l = m.MinBid.Size()
	n += 2 + l + sovTypes(uint64(l))
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *IdentityRequirement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityRequirement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityRequirement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinScore", wireType)
			}
			m.MinScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireVerifiedEmail", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireVerifiedEmail = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireVerifiedDomain", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireVerifiedDomain = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMfa", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireMfa = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PricingInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PricingInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PricingInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Model", wireType)
			}
			m.Model = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Model |= PricingModel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePrice", wireType)
			}
			m.BasePrice = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BasePrice |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Currency", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Currency = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsageRates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UsageRates == nil {
				m.UsageRates = make(map[string]uint64)
			}
			var mapkey string
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.UsageRates[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinimumCommitment", wireType)
			}
			m.MinimumCommitment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinimumCommitment |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PriceComponent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PriceComponent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PriceComponent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Price.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsdReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UsdReference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OfferingID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OfferingID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OfferingID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EncryptedProviderSecrets) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedProviderSecrets: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedProviderSecrets: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Envelope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Envelope == nil {
				m.Envelope = &v1.EncryptedPayloadEnvelope{}
			}
			if err := m.Envelope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnvelopeRef", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EnvelopeRef = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientKeyIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientKeyIds = append(m.RecipientKeyIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Offering) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Offering: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Offering: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Id == nil {
				m.Id = &OfferingID{}
			}
			if err := m.Id.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= OfferingState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Category", wireType)
			}
			m.Category = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Category |= OfferingCategory(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pricing", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pricing == nil {
				m.Pricing = &PricingInfo{}
			}
			if err := m.Pricing.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdentityRequirement", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdentityRequirement == nil {
				m.IdentityRequirement = &IdentityRequirement{}
			}
			if err := m.IdentityRequirement.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireMfaForOrders", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireMfaForOrders = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PublicMetadata == nil {
				m.PublicMetadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.PublicMetadata[mapkey] = mapvalue
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedSecrets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EncryptedSecrets == nil {
				m.EncryptedSecrets = &EncryptedProviderSecrets{}
			}
			if err := m.EncryptedSecrets.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Specifications", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Specifications == nil {
				m.Specifications = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Specifications[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Regions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Regions = append(m.Regions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.UpdatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ActivatedAt == nil {
				m.ActivatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.ActivatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TerminatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TerminatedAt == nil {
				m.TerminatedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.TerminatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrentOrders", wireType)
			}
			m.MaxConcurrentOrders = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrentOrders |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalOrderCount", wireType)
			}
			m.TotalOrderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalOrderCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveOrderCount", wireType)
			}
			m.ActiveOrderCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveOrderCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prices", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Prices = append(m.Prices, PriceComponent{})
			if err := m.Prices[len(m.Prices)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowBidding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowBidding = bool(v != 0)
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinBid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.MinBid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
