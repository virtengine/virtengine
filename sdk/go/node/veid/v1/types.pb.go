// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/veid/v1/types.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ScopeType represents the type of identity scope
type ScopeType int32

const (
	// SCOPE_TYPE_UNSPECIFIED represents an unspecified scope type
	ScopeTypeUnspecified ScopeType = 0
	// SCOPE_TYPE_ID_DOCUMENT represents government-issued ID documents
	ScopeTypeIDDocument ScopeType = 1
	// SCOPE_TYPE_SELFIE represents a selfie photo for face verification
	ScopeTypeSelfie ScopeType = 2
	// SCOPE_TYPE_FACE_VIDEO represents a video for liveness detection
	ScopeTypeFaceVideo ScopeType = 3
	// SCOPE_TYPE_BIOMETRIC represents biometric data (fingerprint, voice, etc.)
	ScopeTypeBiometric ScopeType = 4
	// SCOPE_TYPE_SSO_METADATA represents SSO provider metadata pointers
	ScopeTypeSSOMetadata ScopeType = 5
	// SCOPE_TYPE_EMAIL_PROOF represents email verification proof
	ScopeTypeEmailProof ScopeType = 6
	// SCOPE_TYPE_SMS_PROOF represents SMS/phone verification proof
	ScopeTypeSMSProof ScopeType = 7
	// SCOPE_TYPE_DOMAIN_VERIFY represents domain ownership verification
	ScopeTypeDomainVerify ScopeType = 8
	// SCOPE_TYPE_AD_SSO represents Active Directory SSO verification
	ScopeTypeADSSO ScopeType = 9
)

var ScopeType_name = map[int32]string{
	0: "SCOPE_TYPE_UNSPECIFIED",
	1: "SCOPE_TYPE_ID_DOCUMENT",
	2: "SCOPE_TYPE_SELFIE",
	3: "SCOPE_TYPE_FACE_VIDEO",
	4: "SCOPE_TYPE_BIOMETRIC",
	5: "SCOPE_TYPE_SSO_METADATA",
	6: "SCOPE_TYPE_EMAIL_PROOF",
	7: "SCOPE_TYPE_SMS_PROOF",
	8: "SCOPE_TYPE_DOMAIN_VERIFY",
	9: "SCOPE_TYPE_AD_SSO",
}

var ScopeType_value = map[string]int32{
	"SCOPE_TYPE_UNSPECIFIED":   0,
	"SCOPE_TYPE_ID_DOCUMENT":   1,
	"SCOPE_TYPE_SELFIE":        2,
	"SCOPE_TYPE_FACE_VIDEO":    3,
	"SCOPE_TYPE_BIOMETRIC":     4,
	"SCOPE_TYPE_SSO_METADATA":  5,
	"SCOPE_TYPE_EMAIL_PROOF":   6,
	"SCOPE_TYPE_SMS_PROOF":     7,
	"SCOPE_TYPE_DOMAIN_VERIFY": 8,
	"SCOPE_TYPE_AD_SSO":        9,
}

func (x ScopeType) String() string {
	return proto.EnumName(ScopeType_name, int32(x))
}

func (ScopeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{0}
}

// VerificationStatus represents the verification state of an identity scope
type VerificationStatus int32

const (
	// VERIFICATION_STATUS_UNKNOWN indicates an uninitialized or unknown status
	VerificationStatusUnknown VerificationStatus = 0
	// VERIFICATION_STATUS_PENDING indicates the scope is awaiting verification
	VerificationStatusPending VerificationStatus = 1
	// VERIFICATION_STATUS_IN_PROGRESS indicates verification is actively being processed
	VerificationStatusInProgress VerificationStatus = 2
	// VERIFICATION_STATUS_VERIFIED indicates the scope has been successfully verified
	VerificationStatusVerified VerificationStatus = 3
	// VERIFICATION_STATUS_REJECTED indicates the scope failed verification
	VerificationStatusRejected VerificationStatus = 4
	// VERIFICATION_STATUS_EXPIRED indicates the verification has expired
	VerificationStatusExpired VerificationStatus = 5
	// VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR indicates borderline score requires MFA
	VerificationStatusNeedsAdditionalFactor VerificationStatus = 6
	// VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING indicates MFA challenge is in progress
	VerificationStatusAdditionalFactorPending VerificationStatus = 7
)

var VerificationStatus_name = map[int32]string{
	0: "VERIFICATION_STATUS_UNKNOWN",
	1: "VERIFICATION_STATUS_PENDING",
	2: "VERIFICATION_STATUS_IN_PROGRESS",
	3: "VERIFICATION_STATUS_VERIFIED",
	4: "VERIFICATION_STATUS_REJECTED",
	5: "VERIFICATION_STATUS_EXPIRED",
	6: "VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR",
	7: "VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING",
}

var VerificationStatus_value = map[string]int32{
	"VERIFICATION_STATUS_UNKNOWN":                   0,
	"VERIFICATION_STATUS_PENDING":                   1,
	"VERIFICATION_STATUS_IN_PROGRESS":               2,
	"VERIFICATION_STATUS_VERIFIED":                  3,
	"VERIFICATION_STATUS_REJECTED":                  4,
	"VERIFICATION_STATUS_EXPIRED":                   5,
	"VERIFICATION_STATUS_NEEDS_ADDITIONAL_FACTOR":   6,
	"VERIFICATION_STATUS_ADDITIONAL_FACTOR_PENDING": 7,
}

func (x VerificationStatus) String() string {
	return proto.EnumName(VerificationStatus_name, int32(x))
}

func (VerificationStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{1}
}

// IdentityTier represents the verification tier of an identity
type IdentityTier int32

const (
	// IDENTITY_TIER_UNVERIFIED is the initial state with no verification
	IdentityTierUnverified IdentityTier = 0
	// IDENTITY_TIER_BASIC is for minimally verified identities (score 50-69)
	IdentityTierBasic IdentityTier = 1
	// IDENTITY_TIER_STANDARD is for standard verified identities (score 70-84)
	IdentityTierStandard IdentityTier = 2
	// IDENTITY_TIER_PREMIUM is for premium verified identities (score 85-100)
	IdentityTierPremium IdentityTier = 3
)

var IdentityTier_name = map[int32]string{
	0: "IDENTITY_TIER_UNVERIFIED",
	1: "IDENTITY_TIER_BASIC",
	2: "IDENTITY_TIER_STANDARD",
	3: "IDENTITY_TIER_PREMIUM",
}

var IdentityTier_value = map[string]int32{
	"IDENTITY_TIER_UNVERIFIED": 0,
	"IDENTITY_TIER_BASIC":      1,
	"IDENTITY_TIER_STANDARD":   2,
	"IDENTITY_TIER_PREMIUM":    3,
}

func (x IdentityTier) String() string {
	return proto.EnumName(IdentityTier_name, int32(x))
}

func (IdentityTier) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{2}
}

// AccountStatus represents the overall account verification status
type AccountStatus int32

const (
	// ACCOUNT_STATUS_UNKNOWN indicates an uninitialized status
	AccountStatusUnknown AccountStatus = 0
	// ACCOUNT_STATUS_PENDING indicates verification is in progress
	AccountStatusPending AccountStatus = 1
	// ACCOUNT_STATUS_IN_PROGRESS indicates active ML scoring
	AccountStatusInProgress AccountStatus = 2
	// ACCOUNT_STATUS_VERIFIED indicates account is verified
	AccountStatusVerified AccountStatus = 3
	// ACCOUNT_STATUS_REJECTED indicates verification was rejected
	AccountStatusRejected AccountStatus = 4
	// ACCOUNT_STATUS_EXPIRED indicates verification has expired
	AccountStatusExpired AccountStatus = 5
	// ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR indicates additional verification needed
	AccountStatusNeedsAdditionalFactor AccountStatus = 6
)

var AccountStatus_name = map[int32]string{
	0: "ACCOUNT_STATUS_UNKNOWN",
	1: "ACCOUNT_STATUS_PENDING",
	2: "ACCOUNT_STATUS_IN_PROGRESS",
	3: "ACCOUNT_STATUS_VERIFIED",
	4: "ACCOUNT_STATUS_REJECTED",
	5: "ACCOUNT_STATUS_EXPIRED",
	6: "ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR",
}

var AccountStatus_value = map[string]int32{
	"ACCOUNT_STATUS_UNKNOWN":                 0,
	"ACCOUNT_STATUS_PENDING":                 1,
	"ACCOUNT_STATUS_IN_PROGRESS":             2,
	"ACCOUNT_STATUS_VERIFIED":                3,
	"ACCOUNT_STATUS_REJECTED":                4,
	"ACCOUNT_STATUS_EXPIRED":                 5,
	"ACCOUNT_STATUS_NEEDS_ADDITIONAL_FACTOR": 6,
}

func (x AccountStatus) String() string {
	return proto.EnumName(AccountStatus_name, int32(x))
}

func (AccountStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{3}
}

// WalletStatus represents the overall status of an identity wallet
type WalletStatus int32

const (
	// WALLET_STATUS_UNSPECIFIED indicates an unspecified status
	WalletStatusUnspecified WalletStatus = 0
	// WALLET_STATUS_ACTIVE indicates the wallet is active and usable
	WalletStatusActive WalletStatus = 1
	// WALLET_STATUS_SUSPENDED indicates the wallet is temporarily suspended
	WalletStatusSuspended WalletStatus = 2
	// WALLET_STATUS_REVOKED indicates the wallet has been revoked
	WalletStatusRevoked WalletStatus = 3
	// WALLET_STATUS_EXPIRED indicates the wallet verification has expired
	WalletStatusExpired WalletStatus = 4
)

var WalletStatus_name = map[int32]string{
	0: "WALLET_STATUS_UNSPECIFIED",
	1: "WALLET_STATUS_ACTIVE",
	2: "WALLET_STATUS_SUSPENDED",
	3: "WALLET_STATUS_REVOKED",
	4: "WALLET_STATUS_EXPIRED",
}

var WalletStatus_value = map[string]int32{
	"WALLET_STATUS_UNSPECIFIED": 0,
	"WALLET_STATUS_ACTIVE":      1,
	"WALLET_STATUS_SUSPENDED":   2,
	"WALLET_STATUS_REVOKED":     3,
	"WALLET_STATUS_EXPIRED":     4,
}

func (x WalletStatus) String() string {
	return proto.EnumName(WalletStatus_name, int32(x))
}

func (WalletStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{4}
}

// EncryptedPayloadEnvelope is the canonical encrypted payload structure
// for all sensitive fields stored on-chain.
type EncryptedPayloadEnvelope struct {
	// Version is the envelope format version for future compatibility
	Version uint32 `protobuf:"varint,1,opt,name=version,proto3" json:"version" yaml:"version"`
	// AlgorithmID identifies the encryption algorithm used
	AlgorithmId string `protobuf:"bytes,2,opt,name=algorithm_id,json=algorithmId,proto3" json:"algorithm_id" yaml:"algorithm_id"`
	// AlgorithmVersion is the version of the algorithm used
	AlgorithmVersion uint32 `protobuf:"varint,3,opt,name=algorithm_version,json=algorithmVersion,proto3" json:"algorithm_version" yaml:"algorithm_version"`
	// RecipientKeyIDs are the fingerprints of intended recipients' public keys
	RecipientKeyIds []string `protobuf:"bytes,4,rep,name=recipient_key_ids,json=recipientKeyIds,proto3" json:"recipient_key_ids" yaml:"recipient_key_ids"`
	// RecipientPublicKeys are the public keys for intended recipients
	RecipientPublicKeys [][]byte `protobuf:"bytes,5,rep,name=recipient_public_keys,json=recipientPublicKeys,proto3" json:"recipient_public_keys" yaml:"recipient_public_keys"`
	// EncryptedKeys contains the data encryption key encrypted for each recipient
	EncryptedKeys [][]byte `protobuf:"bytes,6,rep,name=encrypted_keys,json=encryptedKeys,proto3" json:"encrypted_keys" yaml:"encrypted_keys"`
	// Nonce is the initialization vector / nonce for encryption
	Nonce []byte `protobuf:"bytes,7,opt,name=nonce,proto3" json:"nonce" yaml:"nonce"`
	// Ciphertext is the encrypted payload data
	Ciphertext []byte `protobuf:"bytes,8,opt,name=ciphertext,proto3" json:"ciphertext" yaml:"ciphertext"`
	// SenderSignature is the signature over the envelope contents
	SenderSignature []byte `protobuf:"bytes,9,opt,name=sender_signature,json=senderSignature,proto3" json:"sender_signature" yaml:"sender_signature"`
	// SenderPubKey is the sender's public key for signature verification
	SenderPubKey []byte `protobuf:"bytes,10,opt,name=sender_pub_key,json=senderPubKey,proto3" json:"sender_pub_key" yaml:"sender_pub_key"`
	// Metadata contains optional public or encrypted metadata
	Metadata map[string]string `protobuf:"bytes,11,rep,name=metadata,proto3" json:"metadata" yaml:"metadata" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *EncryptedPayloadEnvelope) Reset()         { *m = EncryptedPayloadEnvelope{} }
func (m *EncryptedPayloadEnvelope) String() string { return proto.CompactTextString(m) }
func (*EncryptedPayloadEnvelope) ProtoMessage()    {}
func (*EncryptedPayloadEnvelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{0}
}
func (m *EncryptedPayloadEnvelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EncryptedPayloadEnvelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EncryptedPayloadEnvelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EncryptedPayloadEnvelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptedPayloadEnvelope.Merge(m, src)
}
func (m *EncryptedPayloadEnvelope) XXX_Size() int {
	return m.Size()
}
func (m *EncryptedPayloadEnvelope) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptedPayloadEnvelope.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptedPayloadEnvelope proto.InternalMessageInfo

func (m *EncryptedPayloadEnvelope) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *EncryptedPayloadEnvelope) GetAlgorithmId() string {
	if m != nil {
		return m.AlgorithmId
	}
	return ""
}

func (m *EncryptedPayloadEnvelope) GetAlgorithmVersion() uint32 {
	if m != nil {
		return m.AlgorithmVersion
	}
	return 0
}

func (m *EncryptedPayloadEnvelope) GetRecipientKeyIds() []string {
	if m != nil {
		return m.RecipientKeyIds
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetRecipientPublicKeys() [][]byte {
	if m != nil {
		return m.RecipientPublicKeys
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetEncryptedKeys() [][]byte {
	if m != nil {
		return m.EncryptedKeys
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetCiphertext() []byte {
	if m != nil {
		return m.Ciphertext
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetSenderSignature() []byte {
	if m != nil {
		return m.SenderSignature
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetSenderPubKey() []byte {
	if m != nil {
		return m.SenderPubKey
	}
	return nil
}

func (m *EncryptedPayloadEnvelope) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// UploadMetadata contains metadata about an identity scope upload
type UploadMetadata struct {
	// Salt is a per-upload unique salt for cryptographic binding
	Salt []byte `protobuf:"bytes,1,opt,name=salt,proto3" json:"salt" yaml:"salt"`
	// SaltHash is the SHA256 hash of the salt
	SaltHash []byte `protobuf:"bytes,2,opt,name=salt_hash,json=saltHash,proto3" json:"salt_hash" yaml:"salt_hash"`
	// DeviceFingerprint is a hash/identifier of the device used for upload
	DeviceFingerprint string `protobuf:"bytes,3,opt,name=device_fingerprint,json=deviceFingerprint,proto3" json:"device_fingerprint" yaml:"device_fingerprint"`
	// ClientID is the identifier of the approved client
	ClientId string `protobuf:"bytes,4,opt,name=client_id,json=clientId,proto3" json:"client_id" yaml:"client_id"`
	// ClientSignature is the cryptographic signature from the approved client
	ClientSignature []byte `protobuf:"bytes,5,opt,name=client_signature,json=clientSignature,proto3" json:"client_signature" yaml:"client_signature"`
	// UserSignature is the cryptographic signature from the user's account
	UserSignature []byte `protobuf:"bytes,6,opt,name=user_signature,json=userSignature,proto3" json:"user_signature" yaml:"user_signature"`
	// PayloadHash is the SHA256 hash of the encrypted payload
	PayloadHash []byte `protobuf:"bytes,7,opt,name=payload_hash,json=payloadHash,proto3" json:"payload_hash" yaml:"payload_hash"`
	// UploadNonce is a unique nonce for this upload session
	UploadNonce []byte `protobuf:"bytes,8,opt,name=upload_nonce,json=uploadNonce,proto3" json:"upload_nonce" yaml:"upload_nonce"`
	// CaptureTimestamp is when the data was captured (Unix timestamp)
	CaptureTimestamp int64 `protobuf:"varint,9,opt,name=capture_timestamp,json=captureTimestamp,proto3" json:"capture_timestamp" yaml:"capture_timestamp"`
	// GeoHint is an optional geographic hint (coarse location)
	GeoHint string `protobuf:"bytes,10,opt,name=geo_hint,json=geoHint,proto3" json:"geo_hint" yaml:"geo_hint"`
}

func (m *UploadMetadata) Reset()         { *m = UploadMetadata{} }
func (m *UploadMetadata) String() string { return proto.CompactTextString(m) }
func (*UploadMetadata) ProtoMessage()    {}
func (*UploadMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{1}
}
func (m *UploadMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadMetadata.Merge(m, src)
}
func (m *UploadMetadata) XXX_Size() int {
	return m.Size()
}
func (m *UploadMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_UploadMetadata proto.InternalMessageInfo

func (m *UploadMetadata) GetSalt() []byte {
	if m != nil {
		return m.Salt
	}
	return nil
}

func (m *UploadMetadata) GetSaltHash() []byte {
	if m != nil {
		return m.SaltHash
	}
	return nil
}

func (m *UploadMetadata) GetDeviceFingerprint() string {
	if m != nil {
		return m.DeviceFingerprint
	}
	return ""
}

func (m *UploadMetadata) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *UploadMetadata) GetClientSignature() []byte {
	if m != nil {
		return m.ClientSignature
	}
	return nil
}

func (m *UploadMetadata) GetUserSignature() []byte {
	if m != nil {
		return m.UserSignature
	}
	return nil
}

func (m *UploadMetadata) GetPayloadHash() []byte {
	if m != nil {
		return m.PayloadHash
	}
	return nil
}

func (m *UploadMetadata) GetUploadNonce() []byte {
	if m != nil {
		return m.UploadNonce
	}
	return nil
}

func (m *UploadMetadata) GetCaptureTimestamp() int64 {
	if m != nil {
		return m.CaptureTimestamp
	}
	return 0
}

func (m *UploadMetadata) GetGeoHint() string {
	if m != nil {
		return m.GeoHint
	}
	return ""
}

// ScopeRef is a lightweight reference to an identity scope
type ScopeRef struct {
	// ScopeID is the unique identifier for the scope
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// ScopeType indicates what kind of identity data this scope contains
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
	// Status is the current verification status
	Status VerificationStatus `protobuf:"varint,3,opt,name=status,proto3,enum=virtengine.veid.v1.VerificationStatus" json:"status" yaml:"status"`
	// UploadedAt is when the scope was uploaded (Unix timestamp)
	UploadedAt int64 `protobuf:"varint,4,opt,name=uploaded_at,json=uploadedAt,proto3" json:"uploaded_at" yaml:"uploaded_at"`
	// VerifiedAt is when the scope was verified (Unix timestamp)
	VerifiedAt int64 `protobuf:"varint,5,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at" yaml:"verified_at"`
	// ExpiresAt is when the verification expires (Unix timestamp)
	ExpiresAt int64 `protobuf:"varint,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
}

func (m *ScopeRef) Reset()         { *m = ScopeRef{} }
func (m *ScopeRef) String() string { return proto.CompactTextString(m) }
func (*ScopeRef) ProtoMessage()    {}
func (*ScopeRef) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{2}
}
func (m *ScopeRef) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScopeRef) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScopeRef.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScopeRef) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScopeRef.Merge(m, src)
}
func (m *ScopeRef) XXX_Size() int {
	return m.Size()
}
func (m *ScopeRef) XXX_DiscardUnknown() {
	xxx_messageInfo_ScopeRef.DiscardUnknown(m)
}

var xxx_messageInfo_ScopeRef proto.InternalMessageInfo

func (m *ScopeRef) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *ScopeRef) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

func (m *ScopeRef) GetStatus() VerificationStatus {
	if m != nil {
		return m.Status
	}
	return VerificationStatusUnknown
}

func (m *ScopeRef) GetUploadedAt() int64 {
	if m != nil {
		return m.UploadedAt
	}
	return 0
}

func (m *ScopeRef) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *ScopeRef) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// IdentityScope represents a single piece of identity information
type IdentityScope struct {
	// ScopeID is the unique identifier for this scope
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// ScopeType indicates what kind of identity data this scope contains
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
	// Version is the schema version for this scope
	Version uint32 `protobuf:"varint,3,opt,name=version,proto3" json:"version" yaml:"version"`
	// EncryptedPayload contains the encrypted identity data
	EncryptedPayload EncryptedPayloadEnvelope `protobuf:"bytes,4,opt,name=encrypted_payload,json=encryptedPayload,proto3" json:"encrypted_payload" yaml:"encrypted_payload"`
	// UploadMetadata contains metadata about the upload
	UploadMetadata UploadMetadata `protobuf:"bytes,5,opt,name=upload_metadata,json=uploadMetadata,proto3" json:"upload_metadata" yaml:"upload_metadata"`
	// Status is the current verification status
	Status VerificationStatus `protobuf:"varint,6,opt,name=status,proto3,enum=virtengine.veid.v1.VerificationStatus" json:"status" yaml:"status"`
	// UploadedAt is when this scope was uploaded (Unix timestamp)
	UploadedAt int64 `protobuf:"varint,7,opt,name=uploaded_at,json=uploadedAt,proto3" json:"uploaded_at" yaml:"uploaded_at"`
	// VerifiedAt is when this scope was verified (Unix timestamp)
	VerifiedAt int64 `protobuf:"varint,8,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at" yaml:"verified_at"`
	// ExpiresAt is when the verification expires (Unix timestamp)
	ExpiresAt int64 `protobuf:"varint,9,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// OwnerAddress is the blockchain address that owns this scope
	OwnerAddress string `protobuf:"bytes,10,opt,name=owner_address,json=ownerAddress,proto3" json:"owner_address" yaml:"owner_address"`
}

func (m *IdentityScope) Reset()         { *m = IdentityScope{} }
func (m *IdentityScope) String() string { return proto.CompactTextString(m) }
func (*IdentityScope) ProtoMessage()    {}
func (*IdentityScope) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{3}
}
func (m *IdentityScope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityScope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityScope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdentityScope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityScope.Merge(m, src)
}
func (m *IdentityScope) XXX_Size() int {
	return m.Size()
}
func (m *IdentityScope) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityScope.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityScope proto.InternalMessageInfo

func (m *IdentityScope) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *IdentityScope) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

func (m *IdentityScope) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *IdentityScope) GetEncryptedPayload() EncryptedPayloadEnvelope {
	if m != nil {
		return m.EncryptedPayload
	}
	return EncryptedPayloadEnvelope{}
}

func (m *IdentityScope) GetUploadMetadata() UploadMetadata {
	if m != nil {
		return m.UploadMetadata
	}
	return UploadMetadata{}
}

func (m *IdentityScope) GetStatus() VerificationStatus {
	if m != nil {
		return m.Status
	}
	return VerificationStatusUnknown
}

func (m *IdentityScope) GetUploadedAt() int64 {
	if m != nil {
		return m.UploadedAt
	}
	return 0
}

func (m *IdentityScope) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *IdentityScope) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *IdentityScope) GetOwnerAddress() string {
	if m != nil {
		return m.OwnerAddress
	}
	return ""
}

// IdentityRecord represents a user's complete identity record on-chain
type IdentityRecord struct {
	// AccountAddress is the blockchain address that owns this identity
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeRefs are lightweight references to the scopes owned by this identity
	ScopeRefs []ScopeRef `protobuf:"bytes,2,rep,name=scope_refs,json=scopeRefs,proto3" json:"scope_refs" yaml:"scope_refs"`
	// CurrentScore is the current identity score (0-100)
	CurrentScore uint32 `protobuf:"varint,3,opt,name=current_score,json=currentScore,proto3" json:"current_score" yaml:"current_score"`
	// ScoreVersion is the ML model version used to compute the current score
	ScoreVersion string `protobuf:"bytes,4,opt,name=score_version,json=scoreVersion,proto3" json:"score_version" yaml:"score_version"`
	// LastVerifiedAt is when the identity was last verified (Unix timestamp)
	LastVerifiedAt int64 `protobuf:"varint,5,opt,name=last_verified_at,json=lastVerifiedAt,proto3" json:"last_verified_at" yaml:"last_verified_at"`
	// CreatedAt is when this identity record was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,6,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// UpdatedAt is when this identity record was last updated (Unix timestamp)
	UpdatedAt int64 `protobuf:"varint,7,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at" yaml:"updated_at"`
	// Tier is the current identity tier based on score
	Tier IdentityTier `protobuf:"varint,8,opt,name=tier,proto3,enum=virtengine.veid.v1.IdentityTier" json:"tier" yaml:"tier"`
	// Flags contains any flags on this identity
	Flags []string `protobuf:"bytes,9,rep,name=flags,proto3" json:"flags" yaml:"flags"`
	// Locked indicates if the identity is locked
	Locked bool `protobuf:"varint,10,opt,name=locked,proto3" json:"locked" yaml:"locked"`
	// LockedReason is the reason for locking
	LockedReason string `protobuf:"bytes,11,opt,name=locked_reason,json=lockedReason,proto3" json:"locked_reason" yaml:"locked_reason"`
}

func (m *IdentityRecord) Reset()         { *m = IdentityRecord{} }
func (m *IdentityRecord) String() string { return proto.CompactTextString(m) }
func (*IdentityRecord) ProtoMessage()    {}
func (*IdentityRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{4}
}
func (m *IdentityRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdentityRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityRecord.Merge(m, src)
}
func (m *IdentityRecord) XXX_Size() int {
	return m.Size()
}
func (m *IdentityRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityRecord.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityRecord proto.InternalMessageInfo

func (m *IdentityRecord) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *IdentityRecord) GetScopeRefs() []ScopeRef {
	if m != nil {
		return m.ScopeRefs
	}
	return nil
}

func (m *IdentityRecord) GetCurrentScore() uint32 {
	if m != nil {
		return m.CurrentScore
	}
	return 0
}

func (m *IdentityRecord) GetScoreVersion() string {
	if m != nil {
		return m.ScoreVersion
	}
	return ""
}

func (m *IdentityRecord) GetLastVerifiedAt() int64 {
	if m != nil {
		return m.LastVerifiedAt
	}
	return 0
}

func (m *IdentityRecord) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *IdentityRecord) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *IdentityRecord) GetTier() IdentityTier {
	if m != nil {
		return m.Tier
	}
	return IdentityTierUnverified
}

func (m *IdentityRecord) GetFlags() []string {
	if m != nil {
		return m.Flags
	}
	return nil
}

func (m *IdentityRecord) GetLocked() bool {
	if m != nil {
		return m.Locked
	}
	return false
}

func (m *IdentityRecord) GetLockedReason() string {
	if m != nil {
		return m.LockedReason
	}
	return ""
}

// IdentityScore represents the current identity score for an account
type IdentityScore struct {
	// AccountAddress is the blockchain address this score belongs to
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Score is the current identity score (0-100)
	Score uint32 `protobuf:"varint,2,opt,name=score,proto3" json:"score" yaml:"score"`
	// Status is the current account verification status
	Status AccountStatus `protobuf:"varint,3,opt,name=status,proto3,enum=virtengine.veid.v1.AccountStatus" json:"status" yaml:"status"`
	// Tier is the identity tier based on score
	Tier IdentityTier `protobuf:"varint,4,opt,name=tier,proto3,enum=virtengine.veid.v1.IdentityTier" json:"tier" yaml:"tier"`
	// ModelVersion is the ML model version used
	ModelVersion string `protobuf:"bytes,5,opt,name=model_version,json=modelVersion,proto3" json:"model_version" yaml:"model_version"`
	// LastUpdatedAt is when the score was last updated (Unix timestamp)
	LastUpdatedAt int64 `protobuf:"varint,6,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at" yaml:"last_updated_at"`
	// BlockHeight is the block height when score was computed
	BlockHeight int64 `protobuf:"varint,7,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
}

func (m *IdentityScore) Reset()         { *m = IdentityScore{} }
func (m *IdentityScore) String() string { return proto.CompactTextString(m) }
func (*IdentityScore) ProtoMessage()    {}
func (*IdentityScore) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{5}
}
func (m *IdentityScore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IdentityScore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IdentityScore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IdentityScore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IdentityScore.Merge(m, src)
}
func (m *IdentityScore) XXX_Size() int {
	return m.Size()
}
func (m *IdentityScore) XXX_DiscardUnknown() {
	xxx_messageInfo_IdentityScore.DiscardUnknown(m)
}

var xxx_messageInfo_IdentityScore proto.InternalMessageInfo

func (m *IdentityScore) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *IdentityScore) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *IdentityScore) GetStatus() AccountStatus {
	if m != nil {
		return m.Status
	}
	return AccountStatusUnknown
}

func (m *IdentityScore) GetTier() IdentityTier {
	if m != nil {
		return m.Tier
	}
	return IdentityTierUnverified
}

func (m *IdentityScore) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *IdentityScore) GetLastUpdatedAt() int64 {
	if m != nil {
		return m.LastUpdatedAt
	}
	return 0
}

func (m *IdentityScore) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

// ConsentSettings represents consent configuration for an identity wallet
type ConsentSettings struct {
	// ShareWithProviders allows providers to access non-sensitive identity metadata
	ShareWithProviders bool `protobuf:"varint,1,opt,name=share_with_providers,json=shareWithProviders,proto3" json:"share_with_providers" yaml:"share_with_providers"`
	// ShareForVerification allows the identity to be used for verification requests
	ShareForVerification bool `protobuf:"varint,2,opt,name=share_for_verification,json=shareForVerification,proto3" json:"share_for_verification" yaml:"share_for_verification"`
	// AllowReVerification allows the identity to be re-verified without explicit request
	AllowReVerification bool `protobuf:"varint,3,opt,name=allow_re_verification,json=allowReVerification,proto3" json:"allow_re_verification" yaml:"allow_re_verification"`
	// AllowDerivedFeatureSharing allows sharing of derived feature hashes
	AllowDerivedFeatureSharing bool `protobuf:"varint,4,opt,name=allow_derived_feature_sharing,json=allowDerivedFeatureSharing,proto3" json:"allow_derived_feature_sharing" yaml:"allow_derived_feature_sharing"`
	// ConsentVersion tracks consent settings version for audit
	ConsentVersion uint32 `protobuf:"varint,5,opt,name=consent_version,json=consentVersion,proto3" json:"consent_version" yaml:"consent_version"`
	// LastUpdatedAt is when consent was last updated (Unix timestamp)
	LastUpdatedAt int64 `protobuf:"varint,6,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at" yaml:"last_updated_at"`
}

func (m *ConsentSettings) Reset()         { *m = ConsentSettings{} }
func (m *ConsentSettings) String() string { return proto.CompactTextString(m) }
func (*ConsentSettings) ProtoMessage()    {}
func (*ConsentSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{6}
}
func (m *ConsentSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsentSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsentSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsentSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsentSettings.Merge(m, src)
}
func (m *ConsentSettings) XXX_Size() int {
	return m.Size()
}
func (m *ConsentSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsentSettings.DiscardUnknown(m)
}

var xxx_messageInfo_ConsentSettings proto.InternalMessageInfo

func (m *ConsentSettings) GetShareWithProviders() bool {
	if m != nil {
		return m.ShareWithProviders
	}
	return false
}

func (m *ConsentSettings) GetShareForVerification() bool {
	if m != nil {
		return m.ShareForVerification
	}
	return false
}

func (m *ConsentSettings) GetAllowReVerification() bool {
	if m != nil {
		return m.AllowReVerification
	}
	return false
}

func (m *ConsentSettings) GetAllowDerivedFeatureSharing() bool {
	if m != nil {
		return m.AllowDerivedFeatureSharing
	}
	return false
}

func (m *ConsentSettings) GetConsentVersion() uint32 {
	if m != nil {
		return m.ConsentVersion
	}
	return 0
}

func (m *ConsentSettings) GetLastUpdatedAt() int64 {
	if m != nil {
		return m.LastUpdatedAt
	}
	return 0
}

// GlobalConsentUpdate represents an update to global consent settings
type GlobalConsentUpdate struct {
	// ShareWithProviders update
	ShareWithProviders bool `protobuf:"varint,1,opt,name=share_with_providers,json=shareWithProviders,proto3" json:"share_with_providers,omitempty"`
	// ShareForVerification update
	ShareForVerification bool `protobuf:"varint,2,opt,name=share_for_verification,json=shareForVerification,proto3" json:"share_for_verification,omitempty"`
	// AllowReVerification update
	AllowReVerification bool `protobuf:"varint,3,opt,name=allow_re_verification,json=allowReVerification,proto3" json:"allow_re_verification,omitempty"`
	// AllowDerivedFeatureSharing update
	AllowDerivedFeatureSharing bool `protobuf:"varint,4,opt,name=allow_derived_feature_sharing,json=allowDerivedFeatureSharing,proto3" json:"allow_derived_feature_sharing,omitempty"`
}

func (m *GlobalConsentUpdate) Reset()         { *m = GlobalConsentUpdate{} }
func (m *GlobalConsentUpdate) String() string { return proto.CompactTextString(m) }
func (*GlobalConsentUpdate) ProtoMessage()    {}
func (*GlobalConsentUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{7}
}
func (m *GlobalConsentUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GlobalConsentUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GlobalConsentUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GlobalConsentUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GlobalConsentUpdate.Merge(m, src)
}
func (m *GlobalConsentUpdate) XXX_Size() int {
	return m.Size()
}
func (m *GlobalConsentUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_GlobalConsentUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_GlobalConsentUpdate proto.InternalMessageInfo

func (m *GlobalConsentUpdate) GetShareWithProviders() bool {
	if m != nil {
		return m.ShareWithProviders
	}
	return false
}

func (m *GlobalConsentUpdate) GetShareForVerification() bool {
	if m != nil {
		return m.ShareForVerification
	}
	return false
}

func (m *GlobalConsentUpdate) GetAllowReVerification() bool {
	if m != nil {
		return m.AllowReVerification
	}
	return false
}

func (m *GlobalConsentUpdate) GetAllowDerivedFeatureSharing() bool {
	if m != nil {
		return m.AllowDerivedFeatureSharing
	}
	return false
}

// BorderlineParams contains parameters for borderline score handling
type BorderlineParams struct {
	// LowerThreshold is the lower threshold for borderline scores
	LowerThreshold uint32 `protobuf:"varint,1,opt,name=lower_threshold,json=lowerThreshold,proto3" json:"lower_threshold" yaml:"lower_threshold"`
	// UpperThreshold is the upper threshold for borderline scores
	UpperThreshold uint32 `protobuf:"varint,2,opt,name=upper_threshold,json=upperThreshold,proto3" json:"upper_threshold" yaml:"upper_threshold"`
	// MfaTimeoutBlocks is how long MFA challenge is valid
	MfaTimeoutBlocks int64 `protobuf:"varint,3,opt,name=mfa_timeout_blocks,json=mfaTimeoutBlocks,proto3" json:"mfa_timeout_blocks" yaml:"mfa_timeout_blocks"`
	// RequiredFactors is the number of MFA factors required
	RequiredFactors uint32 `protobuf:"varint,4,opt,name=required_factors,json=requiredFactors,proto3" json:"required_factors" yaml:"required_factors"`
}

func (m *BorderlineParams) Reset()         { *m = BorderlineParams{} }
func (m *BorderlineParams) String() string { return proto.CompactTextString(m) }
func (*BorderlineParams) ProtoMessage()    {}
func (*BorderlineParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{8}
}
func (m *BorderlineParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BorderlineParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BorderlineParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BorderlineParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BorderlineParams.Merge(m, src)
}
func (m *BorderlineParams) XXX_Size() int {
	return m.Size()
}
func (m *BorderlineParams) XXX_DiscardUnknown() {
	xxx_messageInfo_BorderlineParams.DiscardUnknown(m)
}

var xxx_messageInfo_BorderlineParams proto.InternalMessageInfo

func (m *BorderlineParams) GetLowerThreshold() uint32 {
	if m != nil {
		return m.LowerThreshold
	}
	return 0
}

func (m *BorderlineParams) GetUpperThreshold() uint32 {
	if m != nil {
		return m.UpperThreshold
	}
	return 0
}

func (m *BorderlineParams) GetMfaTimeoutBlocks() int64 {
	if m != nil {
		return m.MfaTimeoutBlocks
	}
	return 0
}

func (m *BorderlineParams) GetRequiredFactors() uint32 {
	if m != nil {
		return m.RequiredFactors
	}
	return 0
}

// ApprovedClient represents an approved client application
type ApprovedClient struct {
	// ClientID is the unique identifier for the client
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id" yaml:"client_id"`
	// Name is the human-readable name of the client
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name" yaml:"name"`
	// PublicKey is the client's public key for signature verification
	PublicKey []byte `protobuf:"bytes,3,opt,name=public_key,json=publicKey,proto3" json:"public_key" yaml:"public_key"`
	// Active indicates if the client is currently active
	Active bool `protobuf:"varint,4,opt,name=active,proto3" json:"active" yaml:"active"`
	// CreatedAt is when the client was registered (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,5,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// DeactivatedAt is when the client was deactivated (Unix timestamp)
	DeactivatedAt int64 `protobuf:"varint,6,opt,name=deactivated_at,json=deactivatedAt,proto3" json:"deactivated_at" yaml:"deactivated_at"`
}

func (m *ApprovedClient) Reset()         { *m = ApprovedClient{} }
func (m *ApprovedClient) String() string { return proto.CompactTextString(m) }
func (*ApprovedClient) ProtoMessage()    {}
func (*ApprovedClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{9}
}
func (m *ApprovedClient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ApprovedClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ApprovedClient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ApprovedClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ApprovedClient.Merge(m, src)
}
func (m *ApprovedClient) XXX_Size() int {
	return m.Size()
}
func (m *ApprovedClient) XXX_DiscardUnknown() {
	xxx_messageInfo_ApprovedClient.DiscardUnknown(m)
}

var xxx_messageInfo_ApprovedClient proto.InternalMessageInfo

func (m *ApprovedClient) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ApprovedClient) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ApprovedClient) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *ApprovedClient) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *ApprovedClient) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *ApprovedClient) GetDeactivatedAt() int64 {
	if m != nil {
		return m.DeactivatedAt
	}
	return 0
}

// Params defines the parameters for the veid module
type Params struct {
	// MaxScopesPerAccount is the maximum number of scopes per account
	MaxScopesPerAccount uint32 `protobuf:"varint,1,opt,name=max_scopes_per_account,json=maxScopesPerAccount,proto3" json:"max_scopes_per_account" yaml:"max_scopes_per_account"`
	// MaxScopesPerType is the maximum number of scopes per type per account
	MaxScopesPerType uint32 `protobuf:"varint,2,opt,name=max_scopes_per_type,json=maxScopesPerType,proto3" json:"max_scopes_per_type" yaml:"max_scopes_per_type"`
	// SaltMinBytes is the minimum salt size in bytes
	SaltMinBytes uint32 `protobuf:"varint,3,opt,name=salt_min_bytes,json=saltMinBytes,proto3" json:"salt_min_bytes" yaml:"salt_min_bytes"`
	// SaltMaxBytes is the maximum salt size in bytes
	SaltMaxBytes uint32 `protobuf:"varint,4,opt,name=salt_max_bytes,json=saltMaxBytes,proto3" json:"salt_max_bytes" yaml:"salt_max_bytes"`
	// RequireClientSignature determines if client signatures are mandatory
	RequireClientSignature bool `protobuf:"varint,5,opt,name=require_client_signature,json=requireClientSignature,proto3" json:"require_client_signature" yaml:"require_client_signature"`
	// RequireUserSignature determines if user signatures are mandatory
	RequireUserSignature bool `protobuf:"varint,6,opt,name=require_user_signature,json=requireUserSignature,proto3" json:"require_user_signature" yaml:"require_user_signature"`
	// VerificationExpiryDays is how long a verification is valid (in days)
	VerificationExpiryDays uint32 `protobuf:"varint,7,opt,name=verification_expiry_days,json=verificationExpiryDays,proto3" json:"verification_expiry_days" yaml:"verification_expiry_days"`
}

func (m *Params) Reset()      { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage() {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_7c30559501e7c7cb, []int{10}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxScopesPerAccount() uint32 {
	if m != nil {
		return m.MaxScopesPerAccount
	}
	return 0
}

func (m *Params) GetMaxScopesPerType() uint32 {
	if m != nil {
		return m.MaxScopesPerType
	}
	return 0
}

func (m *Params) GetSaltMinBytes() uint32 {
	if m != nil {
		return m.SaltMinBytes
	}
	return 0
}

func (m *Params) GetSaltMaxBytes() uint32 {
	if m != nil {
		return m.SaltMaxBytes
	}
	return 0
}

func (m *Params) GetRequireClientSignature() bool {
	if m != nil {
		return m.RequireClientSignature
	}
	return false
}

func (m *Params) GetRequireUserSignature() bool {
	if m != nil {
		return m.RequireUserSignature
	}
	return false
}

func (m *Params) GetVerificationExpiryDays() uint32 {
	if m != nil {
		return m.VerificationExpiryDays
	}
	return 0
}

func init() {
	proto.RegisterEnum("virtengine.veid.v1.ScopeType", ScopeType_name, ScopeType_value)
	proto.RegisterEnum("virtengine.veid.v1.VerificationStatus", VerificationStatus_name, VerificationStatus_value)
	proto.RegisterEnum("virtengine.veid.v1.IdentityTier", IdentityTier_name, IdentityTier_value)
	proto.RegisterEnum("virtengine.veid.v1.AccountStatus", AccountStatus_name, AccountStatus_value)
	proto.RegisterEnum("virtengine.veid.v1.WalletStatus", WalletStatus_name, WalletStatus_value)
	proto.RegisterType((*EncryptedPayloadEnvelope)(nil), "virtengine.veid.v1.EncryptedPayloadEnvelope")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.veid.v1.EncryptedPayloadEnvelope.MetadataEntry")
	proto.RegisterType((*UploadMetadata)(nil), "virtengine.veid.v1.UploadMetadata")
	proto.RegisterType((*ScopeRef)(nil), "virtengine.veid.v1.ScopeRef")
	proto.RegisterType((*IdentityScope)(nil), "virtengine.veid.v1.IdentityScope")
	proto.RegisterType((*IdentityRecord)(nil), "virtengine.veid.v1.IdentityRecord")
	proto.RegisterType((*IdentityScore)(nil), "virtengine.veid.v1.IdentityScore")
	proto.RegisterType((*ConsentSettings)(nil), "virtengine.veid.v1.ConsentSettings")
	proto.RegisterType((*GlobalConsentUpdate)(nil), "virtengine.veid.v1.GlobalConsentUpdate")
	proto.RegisterType((*BorderlineParams)(nil), "virtengine.veid.v1.BorderlineParams")
	proto.RegisterType((*ApprovedClient)(nil), "virtengine.veid.v1.ApprovedClient")
	proto.RegisterType((*Params)(nil), "virtengine.veid.v1.Params")
}

func init() { proto.RegisterFile("virtengine/veid/v1/types.proto", fileDescriptor_7c30559501e7c7cb) }

var fileDescriptor_7c30559501e7c7cb = []byte{
	// 3274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x5a, 0xcd, 0x73, 0x1b, 0xc7,
	0x95, 0x27, 0x08, 0x7e, 0x36, 0x01, 0x70, 0x38, 0xa4, 0x24, 0x08, 0x92, 0x38, 0xf0, 0xec, 0xda,
	0x96, 0xa5, 0x15, 0x69, 0x49, 0xfe, 0x5a, 0xb9, 0xca, 0xbb, 0x00, 0x31, 0xb4, 0x47, 0x12, 0x41,
	0xb8, 0x01, 0x52, 0x2b, 0xef, 0xae, 0x67, 0x87, 0x98, 0x26, 0x38, 0x2b, 0x60, 0x06, 0x9e, 0x19,
	0x50, 0xc2, 0x65, 0x0f, 0x7b, 0x49, 0x0a, 0x49, 0xa5, 0x7c, 0x48, 0xa5, 0x92, 0x03, 0xaa, 0x5c,
	0xce, 0x3f, 0x90, 0x43, 0x0e, 0xf9, 0x13, 0x7c, 0x74, 0xe5, 0x94, 0xd3, 0x94, 0xcb, 0xae, 0x54,
	0x5c, 0x38, 0xa2, 0x72, 0xca, 0x29, 0xd5, 0x1f, 0x33, 0x3d, 0x33, 0x00, 0x54, 0x91, 0xcb, 0x4e,
	0xe5, 0x62, 0xa3, 0x7f, 0xbf, 0x7e, 0xaf, 0x7b, 0xfa, 0xbd, 0x5f, 0x7f, 0x3c, 0x11, 0x6c, 0x9f,
	0x9b, 0x8e, 0x87, 0xac, 0x96, 0x69, 0xa1, 0xdd, 0x73, 0x64, 0x1a, 0xbb, 0xe7, 0xb7, 0x77, 0xbd,
	0x7e, 0x17, 0xb9, 0x3b, 0x5d, 0xc7, 0xf6, 0x6c, 0x51, 0xe4, 0xfc, 0x0e, 0xe6, 0x77, 0xce, 0x6f,
	0x17, 0xb6, 0x5a, 0x76, 0xcb, 0x26, 0xf4, 0x2e, 0xfe, 0x45, 0x7b, 0x16, 0x2e, 0x37, 0x6d, 0xb7,
	0x63, 0xbb, 0x1a, 0x25, 0x68, 0x83, 0x51, 0x1b, 0x7a, 0xc7, 0xb4, 0xec, 0x5d, 0xf2, 0x5f, 0x0a,
	0xc9, 0xff, 0xbf, 0x02, 0xf2, 0x8a, 0xd5, 0x74, 0xfa, 0x5d, 0x0f, 0x19, 0x35, 0xbd, 0xdf, 0xb6,
	0x75, 0x43, 0xb1, 0xce, 0x51, 0xdb, 0xee, 0x22, 0xf1, 0x6d, 0xb0, 0x7c, 0x8e, 0x1c, 0xd7, 0xb4,
	0xad, 0x7c, 0xaa, 0x98, 0xba, 0x9e, 0x2d, 0x5f, 0x1b, 0xf9, 0x52, 0x00, 0x8d, 0x7d, 0x29, 0xd7,
	0xd7, 0x3b, 0xed, 0x7b, 0x32, 0x03, 0x64, 0x18, 0x50, 0xe2, 0x7d, 0x90, 0xd1, 0xdb, 0x2d, 0xdb,
	0x31, 0xbd, 0xb3, 0x8e, 0x66, 0x1a, 0xf9, 0xf9, 0x62, 0xea, 0xfa, 0x6a, 0xf9, 0xd5, 0x91, 0x2f,
	0xc5, 0xf0, 0xb1, 0x2f, 0x6d, 0x52, 0x17, 0x51, 0x54, 0x86, 0x6b, 0x61, 0x53, 0x35, 0xc4, 0x8f,
	0xc1, 0x06, 0x67, 0x83, 0xe9, 0xa4, 0xc9, 0x74, 0x6e, 0x8f, 0x7c, 0x69, 0x92, 0x1c, 0xfb, 0x52,
	0x3e, 0xe9, 0x35, 0x9c, 0xa2, 0x10, 0x62, 0xc7, 0x6c, 0xae, 0xff, 0x0d, 0x36, 0x1c, 0xd4, 0x34,
	0xbb, 0x26, 0xb2, 0x3c, 0xed, 0x09, 0xea, 0x6b, 0xa6, 0xe1, 0xe6, 0x17, 0x8a, 0xe9, 0xeb, 0xab,
	0xd4, 0xff, 0x04, 0xc9, 0xfd, 0x4f, 0x50, 0x32, 0x5c, 0x0f, 0xb1, 0x07, 0xa8, 0xaf, 0x1a, 0xae,
	0xd8, 0x01, 0x17, 0x78, 0xb7, 0x6e, 0xef, 0xa4, 0x6d, 0x36, 0x71, 0x6f, 0x37, 0xbf, 0x58, 0x4c,
	0x5f, 0xcf, 0x94, 0xff, 0x75, 0xe4, 0x4b, 0xd3, 0x3b, 0x8c, 0x7d, 0xe9, 0x6a, 0x72, 0x98, 0x08,
	0x2d, 0xc3, 0xcd, 0x10, 0xaf, 0x11, 0xf8, 0x01, 0xea, 0xbb, 0x22, 0x04, 0x39, 0x14, 0x84, 0x93,
	0x8e, 0xb3, 0x44, 0xc6, 0xb9, 0x39, 0xf2, 0xa5, 0x04, 0x33, 0xf6, 0xa5, 0x0b, 0x74, 0x80, 0x38,
	0x2e, 0xc3, 0x6c, 0x08, 0x10, 0x9f, 0xbb, 0x60, 0xd1, 0xb2, 0xad, 0x26, 0xca, 0x2f, 0x17, 0x53,
	0xd7, 0x33, 0xe5, 0xcb, 0x23, 0x5f, 0xa2, 0xc0, 0xd8, 0x97, 0x32, 0xd4, 0x03, 0x69, 0xca, 0x90,
	0xc2, 0xe2, 0x1e, 0x00, 0x4d, 0xb3, 0x7b, 0x86, 0x1c, 0x0f, 0x3d, 0xf3, 0xf2, 0x2b, 0xc4, 0xea,
	0x9f, 0x46, 0xbe, 0x14, 0x41, 0xc7, 0xbe, 0xb4, 0x41, 0x4d, 0x39, 0x26, 0xc3, 0x48, 0x07, 0xf1,
	0x23, 0x20, 0xb8, 0xc8, 0x32, 0x90, 0xa3, 0xb9, 0x66, 0xcb, 0xd2, 0xbd, 0x9e, 0x83, 0xf2, 0xab,
	0xc4, 0xd5, 0xee, 0xc8, 0x97, 0x26, 0xb8, 0xb1, 0x2f, 0x5d, 0xa2, 0x0e, 0x93, 0x8c, 0x0c, 0xd7,
	0x29, 0x54, 0x0f, 0x10, 0xf1, 0x43, 0x90, 0x63, 0xbd, 0xba, 0xbd, 0x13, 0xfc, 0xd1, 0x79, 0x40,
	0x3c, 0x93, 0x55, 0x8a, 0x33, 0x7c, 0x95, 0xe2, 0xb8, 0x0c, 0x33, 0x14, 0xa8, 0xf5, 0x4e, 0x1e,
	0xa0, 0xbe, 0xf8, 0x14, 0xac, 0x74, 0x90, 0xa7, 0x1b, 0xba, 0xa7, 0xe7, 0xd7, 0x8a, 0xe9, 0xeb,
	0x6b, 0x77, 0xee, 0xed, 0x4c, 0x6a, 0x76, 0x67, 0x96, 0xd6, 0x76, 0x0e, 0x98, 0xb1, 0x62, 0x79,
	0x4e, 0xbf, 0x2c, 0x8d, 0x7c, 0x29, 0xf4, 0x37, 0xf6, 0xa5, 0x75, 0x3a, 0x85, 0x00, 0x91, 0x61,
	0x48, 0x16, 0xde, 0x05, 0xd9, 0x98, 0xad, 0x28, 0x80, 0x34, 0xfe, 0x22, 0xac, 0xd8, 0x55, 0x88,
	0x7f, 0x8a, 0x5b, 0x60, 0xf1, 0x5c, 0x6f, 0xf7, 0x10, 0xd5, 0x21, 0xa4, 0x8d, 0x7b, 0xf3, 0xef,
	0xa4, 0xee, 0x2d, 0x7c, 0xfb, 0x99, 0x94, 0x92, 0x7f, 0xb2, 0x04, 0x72, 0x47, 0x5d, 0x3c, 0x9d,
	0xc0, 0x93, 0x78, 0x13, 0x2c, 0xb8, 0x7a, 0xdb, 0x23, 0x5e, 0x32, 0xe5, 0x4b, 0x23, 0x5f, 0x22,
	0xed, 0xb1, 0x2f, 0xad, 0xb1, 0xd5, 0xd0, 0xdb, 0x9e, 0x0c, 0x09, 0x28, 0xbe, 0x07, 0x56, 0xf1,
	0xff, 0xb5, 0x33, 0xdd, 0x3d, 0x23, 0x63, 0x64, 0xca, 0x2f, 0x8d, 0x7c, 0x89, 0x83, 0x63, 0x5f,
	0x12, 0xb8, 0x19, 0x81, 0x64, 0xb8, 0x82, 0x7f, 0x7f, 0xa0, 0xbb, 0x67, 0xe2, 0x09, 0x10, 0x0d,
	0x74, 0x6e, 0x36, 0x91, 0x76, 0x6a, 0x5a, 0x2d, 0xe4, 0x74, 0x1d, 0xd3, 0xf2, 0x88, 0xc6, 0x57,
	0xcb, 0x77, 0x47, 0xbe, 0x34, 0x85, 0x1d, 0xfb, 0xd2, 0x65, 0xea, 0x71, 0x92, 0x93, 0xe1, 0x06,
	0x05, 0xf7, 0x39, 0x86, 0xe7, 0xd8, 0x6c, 0x13, 0x11, 0x99, 0x46, 0x7e, 0x81, 0xb8, 0x26, 0x73,
	0x0c, 0x41, 0x3e, 0xc7, 0x10, 0x92, 0xe1, 0x0a, 0xfd, 0xad, 0x1a, 0x38, 0x1d, 0x19, 0xce, 0xd3,
	0x71, 0x91, 0xa7, 0x63, 0x92, 0xe3, 0xe9, 0x98, 0x64, 0x64, 0xb8, 0x4e, 0x21, 0x9e, 0x8e, 0x10,
	0xe4, 0x7a, 0x6e, 0x2c, 0xd1, 0x97, 0x78, 0x3a, 0xc6, 0x19, 0x9e, 0x8e, 0x71, 0x5c, 0x86, 0x59,
	0x0c, 0x70, 0x9f, 0xf7, 0x41, 0xa6, 0x4b, 0x53, 0x8c, 0x86, 0x85, 0x6a, 0x97, 0x6c, 0xc1, 0x51,
	0x9c, 0x6f, 0xc1, 0x51, 0x54, 0x86, 0x6b, 0xac, 0x49, 0xe2, 0x73, 0x1f, 0x64, 0x7a, 0x24, 0x3d,
	0x34, 0xba, 0x0f, 0xac, 0x70, 0x5f, 0x51, 0x9c, 0xfb, 0x8a, 0xa2, 0x32, 0x5c, 0xa3, 0xcd, 0x2a,
	0xd9, 0x1b, 0x3e, 0x06, 0x1b, 0x4d, 0xbd, 0x8b, 0xa7, 0xa8, 0x79, 0x66, 0x07, 0xb9, 0x9e, 0xde,
	0xe9, 0x12, 0x5d, 0xa7, 0xe9, 0x76, 0x3b, 0x41, 0xf2, 0xed, 0x76, 0x82, 0x92, 0xa1, 0xc0, 0xb0,
	0x46, 0x00, 0x89, 0xf7, 0xc0, 0x4a, 0x0b, 0xd9, 0xda, 0x19, 0xce, 0x20, 0x40, 0xc2, 0x4c, 0xb4,
	0x14, 0x60, 0x5c, 0x4b, 0x01, 0x22, 0xc3, 0xe5, 0x16, 0xb2, 0x3f, 0x30, 0x2d, 0x8f, 0xa9, 0xe1,
	0xab, 0x34, 0x58, 0xa9, 0x37, 0xed, 0x2e, 0x82, 0xe8, 0x14, 0xbb, 0x73, 0xf1, 0x6f, 0x9c, 0x35,
	0x29, 0xee, 0x2e, 0xc0, 0xb8, 0xbb, 0x00, 0x91, 0xe1, 0x32, 0xf9, 0xa9, 0x1a, 0xa2, 0x0e, 0x00,
	0x45, 0xf1, 0x41, 0x4e, 0x74, 0x91, 0xbb, 0x73, 0x6d, 0xda, 0xa6, 0x40, 0x46, 0x6b, 0xf4, 0xbb,
	0x88, 0xee, 0x92, 0xdc, 0x88, 0xef, 0x92, 0x1c, 0x93, 0xe1, 0xaa, 0x1b, 0xf4, 0x17, 0xff, 0x13,
	0x2c, 0xb9, 0x9e, 0xee, 0xf5, 0x5c, 0xa2, 0x96, 0xdc, 0x9d, 0x57, 0xa6, 0xb9, 0x3f, 0x46, 0x8e,
	0x79, 0x6a, 0x36, 0x75, 0xcf, 0xb4, 0xad, 0x3a, 0xe9, 0x5d, 0xbe, 0x32, 0xf2, 0x25, 0x66, 0x39,
	0xf6, 0xa5, 0x2c, 0x1b, 0x83, 0xb4, 0x65, 0xc8, 0x08, 0x71, 0x1f, 0xb0, 0xc8, 0x21, 0x43, 0xd3,
	0x3d, 0x22, 0x9a, 0x74, 0xf9, 0xe5, 0x91, 0x2f, 0x45, 0xe1, 0xb1, 0x2f, 0x89, 0xd1, 0xa0, 0x13,
	0x50, 0x86, 0x20, 0x68, 0x95, 0x3c, 0xec, 0xe7, 0x9c, 0x4c, 0x81, 0xfa, 0x59, 0xe4, 0x7e, 0x22,
	0x30, 0xf7, 0x13, 0x01, 0x65, 0x08, 0x82, 0x56, 0xc9, 0x13, 0xcb, 0x00, 0xa0, 0x67, 0x5d, 0xd3,
	0x41, 0x2e, 0x76, 0xb3, 0x44, 0xdc, 0x90, 0x05, 0xe3, 0x28, 0x5f, 0x30, 0x8e, 0xc9, 0x70, 0x95,
	0x35, 0x4a, 0x41, 0x88, 0x7f, 0xb5, 0x0c, 0xb2, 0xaa, 0x81, 0x2c, 0xcf, 0xf4, 0xfa, 0x64, 0xf1,
	0xff, 0xd1, 0xe3, 0x1c, 0xb9, 0x89, 0xa5, 0x5f, 0xe8, 0x26, 0xf6, 0x69, 0x0a, 0x6c, 0xf0, 0xe3,
	0x9d, 0x89, 0x9a, 0x84, 0x72, 0xed, 0xce, 0xbf, 0xbc, 0xc8, 0x01, 0x55, 0x7e, 0xf3, 0x0b, 0x5f,
	0x9a, 0xc3, 0x0a, 0x9d, 0x70, 0xc7, 0x15, 0x3a, 0x41, 0xc9, 0x50, 0x40, 0x09, 0x87, 0xe2, 0xff,
	0x81, 0x75, 0xb6, 0x3f, 0x84, 0x07, 0xe6, 0x22, 0x99, 0x8f, 0x3c, 0x6d, 0x3e, 0xf1, 0x73, 0xa9,
	0x7c, 0x9b, 0xcd, 0x22, 0xe9, 0x62, 0xec, 0x4b, 0x17, 0x63, 0x7b, 0x0f, 0x3f, 0x2a, 0x73, 0xbd,
	0xf8, 0xd1, 0xc6, 0x35, 0xb3, 0xf4, 0x83, 0x6b, 0x66, 0xf9, 0x7b, 0xd2, 0xcc, 0xca, 0xf7, 0xa3,
	0x99, 0xd5, 0xef, 0xa2, 0x19, 0xf1, 0x14, 0x64, 0xed, 0xa7, 0x16, 0x72, 0x34, 0xdd, 0x30, 0x1c,
	0xe4, 0xba, 0x6c, 0x5f, 0x2d, 0x8d, 0x7c, 0x29, 0x4e, 0x8c, 0x7d, 0x69, 0x8b, 0x7a, 0x8a, 0xc1,
	0xf2, 0xef, 0x7f, 0x7b, 0x6b, 0x8b, 0x3d, 0x44, 0x4a, 0x14, 0xaa, 0x7b, 0x8e, 0x69, 0xb5, 0x60,
	0x86, 0xf4, 0x63, 0x18, 0xd3, 0xe6, 0x9f, 0x97, 0x40, 0x2e, 0xd0, 0x26, 0x44, 0x4d, 0xdb, 0x31,
	0x44, 0x0b, 0xac, 0xeb, 0xcd, 0xa6, 0xdd, 0xb3, 0xbc, 0x70, 0x0a, 0x54, 0xa3, 0x0a, 0xce, 0x84,
	0x04, 0xc5, 0x33, 0x21, 0x41, 0xcc, 0x9e, 0x46, 0x8e, 0xf5, 0x64, 0xa8, 0x68, 0x04, 0x82, 0x76,
	0xd0, 0xa9, 0x9b, 0x9f, 0x27, 0xb7, 0xb9, 0xab, 0x33, 0x05, 0x0d, 0xd1, 0x69, 0xf9, 0x55, 0x96,
	0x96, 0x11, 0xbb, 0xa4, 0xa6, 0x31, 0x16, 0x68, 0x1a, 0xa2, 0x53, 0x57, 0xac, 0x82, 0x6c, 0xb3,
	0xe7, 0x38, 0xe4, 0x72, 0xd0, 0xb4, 0x1d, 0xc4, 0x94, 0xfd, 0x1a, 0x5e, 0xd6, 0x18, 0xc1, 0x97,
	0x35, 0x06, 0xcb, 0x30, 0xc3, 0xda, 0x75, 0xdc, 0xc4, 0xfe, 0x08, 0x1e, 0x3e, 0x92, 0xe8, 0x2d,
	0x87, 0xf8, 0x8b, 0x11, 0xdc, 0x5f, 0x0c, 0xc6, 0x37, 0x5a, 0xdc, 0x0e, 0x1e, 0x46, 0x8f, 0x81,
	0xd0, 0xd6, 0x5d, 0x4f, 0x9b, 0xdc, 0xbb, 0xc9, 0x8d, 0x27, 0xc9, 0xf1, 0x1b, 0x4f, 0x92, 0x91,
	0x61, 0x0e, 0x43, 0xc7, 0xb1, 0xac, 0x6c, 0x3a, 0x48, 0xf7, 0xa8, 0xd3, 0xc8, 0x4e, 0xce, 0xd1,
	0xc8, 0x03, 0x21, 0xc4, 0x64, 0xb8, 0xca, 0x1a, 0xd4, 0x47, 0xaf, 0x6b, 0x04, 0x3e, 0x96, 0xb9,
	0x0f, 0x8e, 0x72, 0x1f, 0x1c, 0x93, 0xe1, 0x2a, 0x6b, 0x94, 0x3c, 0xf1, 0x00, 0x2c, 0x78, 0x26,
	0x72, 0x88, 0xbc, 0x72, 0x77, 0x8a, 0xd3, 0x42, 0x1c, 0xa4, 0x62, 0xc3, 0x44, 0x0e, 0xbd, 0x07,
	0x63, 0x0b, 0x7e, 0x0f, 0xc6, 0x2d, 0x19, 0x12, 0x10, 0x3f, 0x94, 0x4e, 0xdb, 0x7a, 0xcb, 0xcd,
	0xaf, 0x92, 0xe7, 0x23, 0x79, 0x28, 0x11, 0x80, 0x3f, 0x94, 0x48, 0x53, 0x86, 0x14, 0x16, 0xef,
	0x82, 0xa5, 0xb6, 0xdd, 0x7c, 0x82, 0x0c, 0x22, 0xa9, 0x15, 0xba, 0xc5, 0x50, 0x84, 0x6f, 0x31,
	0xb4, 0x2d, 0x43, 0x46, 0xe0, 0x38, 0xd3, 0x5f, 0x9a, 0x83, 0x74, 0xd7, 0xb6, 0xf2, 0x6b, 0x3c,
	0xce, 0x31, 0x82, 0xc7, 0x39, 0x06, 0xcb, 0x30, 0x43, 0xdb, 0x90, 0x34, 0x99, 0xec, 0xbe, 0x5c,
	0x88, 0x1d, 0x89, 0x0e, 0xfa, 0xbb, 0xab, 0x6e, 0x17, 0x2c, 0x52, 0x1d, 0xcc, 0x13, 0x1d, 0x90,
	0xd5, 0x0b, 0xf2, 0x3f, 0x13, 0xc9, 0x57, 0x19, 0x52, 0x58, 0x3c, 0x4e, 0x5c, 0x7e, 0x5e, 0x9a,
	0x16, 0xbf, 0x12, 0x1d, 0xe4, 0x45, 0xf6, 0xf0, 0x20, 0x2b, 0x16, 0xbe, 0x9f, 0xac, 0xa8, 0x82,
	0x6c, 0xc7, 0x36, 0x50, 0x3b, 0xd4, 0xe5, 0x22, 0x8f, 0x57, 0x8c, 0xe0, 0xf1, 0x8a, 0xc1, 0x32,
	0xcc, 0x90, 0x76, 0xa0, 0xcb, 0x23, 0xb0, 0x4e, 0x14, 0x16, 0xc9, 0x7e, 0xaa, 0xa0, 0x5b, 0x38,
	0x2e, 0x09, 0x8a, 0xc7, 0x25, 0x41, 0xc8, 0x30, 0x8b, 0x91, 0xa3, 0x50, 0x0b, 0xf7, 0x41, 0xe6,
	0x04, 0xe7, 0x85, 0x76, 0x86, 0xcc, 0xd6, 0x59, 0xa0, 0x28, 0x72, 0xc9, 0x8f, 0xe2, 0xfc, 0x92,
	0x1f, 0x45, 0x65, 0xb8, 0x46, 0x9a, 0x1f, 0x90, 0x16, 0x4b, 0xa9, 0xcf, 0x17, 0xc1, 0xfa, 0x9e,
	0x6d, 0xb9, 0x78, 0x87, 0x42, 0x9e, 0x67, 0x5a, 0x2d, 0x57, 0x34, 0xc1, 0x96, 0x7b, 0xa6, 0x3b,
	0x48, 0x7b, 0x6a, 0x7a, 0x67, 0x5a, 0xd7, 0xb1, 0xcf, 0x4d, 0x03, 0x39, 0x34, 0xb3, 0x56, 0xca,
	0x6f, 0x8f, 0x7c, 0x69, 0x2a, 0x3f, 0xf6, 0xa5, 0x2b, 0x2c, 0x58, 0x53, 0x58, 0x19, 0x8a, 0x04,
	0x7e, 0x64, 0x7a, 0x67, 0xb5, 0x00, 0x14, 0x3f, 0x01, 0x17, 0x69, 0xe7, 0x53, 0xdb, 0x61, 0xdb,
	0x11, 0x3d, 0xcf, 0x49, 0x82, 0xad, 0x94, 0xdf, 0x1d, 0xf9, 0xd2, 0x8c, 0x1e, 0x63, 0x5f, 0xba,
	0x16, 0x1d, 0x2e, 0xc9, 0xcb, 0x90, 0xce, 0x72, 0xdf, 0x76, 0xa2, 0x17, 0x05, 0xb1, 0x03, 0x2e,
	0xe8, 0xed, 0xb6, 0xfd, 0x54, 0xa3, 0xbb, 0x2a, 0x1f, 0x31, 0x4d, 0x46, 0x24, 0xc5, 0x9e, 0xa9,
	0x1d, 0x78, 0xb1, 0x67, 0x2a, 0x2d, 0xc3, 0x4d, 0x82, 0x43, 0x14, 0x1b, 0xee, 0xa7, 0x29, 0x70,
	0x8d, 0xf6, 0x37, 0x90, 0x63, 0x9e, 0x23, 0x43, 0x3b, 0x45, 0xe4, 0xf5, 0xa7, 0xe1, 0xd9, 0x99,
	0x56, 0x8b, 0xa4, 0xf0, 0x4a, 0x59, 0x1d, 0xf9, 0xd2, 0xf3, 0x3b, 0x8e, 0x7d, 0xe9, 0x9f, 0xa3,
	0xe3, 0xcf, 0xe8, 0x26, 0xc3, 0x02, 0xe1, 0x2b, 0x94, 0xde, 0xa7, 0x6c, 0x9d, 0x92, 0xe2, 0x31,
	0x58, 0x6f, 0xd2, 0x70, 0xc7, 0x52, 0x3d, 0x4b, 0x13, 0x33, 0x41, 0xf1, 0xc4, 0x4c, 0x10, 0x32,
	0xcc, 0x31, 0xe4, 0x87, 0x4d, 0x78, 0x96, 0xa4, 0x7f, 0x49, 0x81, 0xcd, 0xf7, 0xdb, 0xf6, 0x89,
	0xde, 0x66, 0xa9, 0x4a, 0x3b, 0x88, 0xaf, 0x3f, 0x2f, 0x51, 0xa7, 0xe6, 0xdb, 0x1b, 0xcf, 0xcf,
	0xb7, 0x19, 0x29, 0x73, 0xe7, 0xb9, 0x29, 0x33, 0x3d, 0xee, 0xa5, 0xbf, 0x29, 0xec, 0xcf, 0x8b,
	0x15, 0xfb, 0xf8, 0x1f, 0xa5, 0x81, 0x50, 0xb6, 0x1d, 0x03, 0x39, 0x6d, 0xd3, 0x42, 0x35, 0xdd,
	0xd1, 0x3b, 0x2e, 0x0e, 0x63, 0xdb, 0x7e, 0x8a, 0x1c, 0xcd, 0x3b, 0x73, 0x90, 0x7b, 0x66, 0xb7,
	0x0d, 0x56, 0xfd, 0xa5, 0xcb, 0x1d, 0xa7, 0x22, 0xcb, 0x1d, 0x27, 0xf0, 0xa1, 0x8f, 0x91, 0x46,
	0x00, 0x60, 0xbf, 0xbd, 0x6e, 0x37, 0xe6, 0x77, 0x9e, 0xfb, 0x4d, 0x50, 0xd1, 0xfb, 0x7c, 0x37,
	0xe1, 0x97, 0x20, 0xdc, 0xaf, 0x0e, 0xc4, 0xce, 0xa9, 0x4e, 0xaa, 0x02, 0x76, 0xcf, 0xd3, 0xc8,
	0x3e, 0x44, 0x8f, 0x84, 0x34, 0xad, 0x1e, 0x4d, 0xb2, 0xbc, 0x7a, 0x34, 0xc9, 0xc9, 0x50, 0xe8,
	0x9c, 0xea, 0x0d, 0x8a, 0x95, 0x09, 0x24, 0x7e, 0x04, 0x04, 0x07, 0x7d, 0xd2, 0x33, 0x1d, 0xbc,
	0xd6, 0x7a, 0xd3, 0xb3, 0x1d, 0x97, 0xac, 0x71, 0x96, 0x5e, 0x85, 0x92, 0x1c, 0xbf, 0x0a, 0x25,
	0x19, 0x52, 0x20, 0xa6, 0xd0, 0x3e, 0x45, 0x58, 0x24, 0x7e, 0x9e, 0x06, 0xb9, 0x52, 0x17, 0xa7,
	0x19, 0x32, 0xf6, 0x48, 0x79, 0x28, 0x5e, 0xb1, 0x4a, 0xbd, 0x78, 0xc5, 0xea, 0x26, 0x58, 0xb0,
	0xf4, 0x0e, 0x2b, 0xfa, 0xd1, 0x43, 0x0a, 0xb7, 0xf9, 0x21, 0x85, 0x5b, 0x32, 0x24, 0x20, 0xbe,
	0x4d, 0xf1, 0xe2, 0x32, 0x59, 0x3c, 0x56, 0xb2, 0xe5, 0x28, 0xbf, 0x4d, 0x71, 0x4c, 0x86, 0xab,
	0xdd, 0xa0, 0xf8, 0x8c, 0x6f, 0x33, 0x7a, 0xd3, 0x33, 0xcf, 0x11, 0xdb, 0x76, 0xc8, 0x61, 0x4b,
	0x11, 0x7e, 0xd8, 0xd2, 0xb6, 0x0c, 0x19, 0x91, 0xb8, 0x0a, 0x2e, 0x7e, 0xa7, 0xab, 0x20, 0x04,
	0x39, 0x03, 0x11, 0x7f, 0xf1, 0xfd, 0x81, 0xd4, 0xcf, 0xe2, 0x0c, 0xaf, 0x9f, 0xc5, 0x71, 0x19,
	0x66, 0x23, 0x40, 0xb8, 0x3b, 0xfc, 0x62, 0x09, 0x2c, 0x31, 0x59, 0x74, 0xc1, 0xc5, 0x8e, 0xfe,
	0x4c, 0x23, 0xf7, 0x77, 0x57, 0xc3, 0x39, 0xc9, 0xee, 0x2f, 0x4c, 0x1d, 0xe4, 0x38, 0x99, 0xde,
	0x83, 0x1f, 0x27, 0xd3, 0x79, 0x19, 0x6e, 0x76, 0xf4, 0x67, 0xe4, 0x31, 0xe1, 0xd6, 0x90, 0xc3,
	0xae, 0x2c, 0xa2, 0x01, 0x36, 0x13, 0xfd, 0xc3, 0x02, 0x43, 0xb6, 0xfc, 0xe6, 0xc8, 0x97, 0xa6,
	0xd1, 0x63, 0x5f, 0x2a, 0x4c, 0x1d, 0x8b, 0xd6, 0x14, 0x84, 0xe8, 0x40, 0xa4, 0xb4, 0xf0, 0x21,
	0xc8, 0x91, 0xa2, 0x6c, 0xc7, 0xb4, 0xb4, 0x93, 0xbe, 0x87, 0x5c, 0xf6, 0x0e, 0xa1, 0xb5, 0xf0,
	0x18, 0x13, 0xa9, 0x85, 0xc7, 0x70, 0xfc, 0x72, 0xd0, 0xdb, 0xde, 0x81, 0x69, 0x95, 0x71, 0x93,
	0xbb, 0xd4, 0x9f, 0x31, 0x97, 0x0b, 0x49, 0x97, 0x01, 0x93, 0x74, 0x19, 0xe0, 0x81, 0x4b, 0xfd,
	0x19, 0x75, 0xd9, 0x07, 0x79, 0x26, 0x1c, 0x6d, 0x6a, 0x19, 0x76, 0xa5, 0xfc, 0x6f, 0x23, 0x5f,
	0x9a, 0xd9, 0x67, 0xec, 0x4b, 0x52, 0x4c, 0x91, 0xda, 0x64, 0x59, 0xf6, 0x22, 0xa3, 0xf6, 0x12,
	0xd5, 0xd9, 0x4f, 0x40, 0xc0, 0x68, 0x53, 0xaa, 0xb4, 0xec, 0x1e, 0x31, 0xbd, 0x07, 0x0f, 0xfc,
	0x74, 0x5e, 0x86, 0x5b, 0x8c, 0x38, 0x8a, 0x15, 0x6f, 0xfb, 0x20, 0x1f, 0x3d, 0x0b, 0x34, 0xf2,
	0x16, 0xef, 0x6b, 0x86, 0xde, 0x77, 0xc9, 0xbd, 0x2c, 0x4b, 0xbf, 0x76, 0x56, 0x1f, 0xfe, 0xb5,
	0xb3, 0x7a, 0xc8, 0xf0, 0x62, 0x94, 0x52, 0x08, 0x53, 0xd1, 0xfb, 0xee, 0xbd, 0x97, 0x7f, 0xf9,
	0x99, 0x34, 0x87, 0x73, 0x7f, 0xf0, 0xa7, 0xdf, 0xdc, 0xc8, 0x47, 0xfe, 0x55, 0xf2, 0x19, 0xfd,
	0x77, 0x49, 0xaa, 0x86, 0x1b, 0x3f, 0x5b, 0x00, 0xab, 0x61, 0x39, 0x0b, 0x1f, 0x7d, 0xf5, 0xbd,
	0xc3, 0x9a, 0xa2, 0x35, 0x1e, 0xd7, 0x14, 0xed, 0xa8, 0x5a, 0xaf, 0x29, 0x7b, 0xea, 0xbe, 0xaa,
	0x54, 0x84, 0xb9, 0x42, 0x7e, 0x30, 0x2c, 0x6e, 0x85, 0x5d, 0x8f, 0x2c, 0xb7, 0x8b, 0x9a, 0xe4,
	0x1d, 0x28, 0xde, 0x8d, 0x59, 0xa9, 0x15, 0xad, 0x72, 0xb8, 0x77, 0x74, 0xa0, 0x54, 0x1b, 0x42,
	0xaa, 0x70, 0x69, 0x30, 0x2c, 0x6e, 0x86, 0x56, 0x6a, 0xa5, 0x62, 0x37, 0x7b, 0x1d, 0xbc, 0x2b,
	0xde, 0x00, 0x1b, 0x11, 0xa3, 0xba, 0xf2, 0x70, 0x5f, 0x55, 0x84, 0xf9, 0xc2, 0xe6, 0x60, 0x58,
	0x5c, 0x0f, 0xfb, 0xd7, 0x51, 0xfb, 0xd4, 0x44, 0xe2, 0x6d, 0x70, 0x21, 0xd2, 0x77, 0xbf, 0xb4,
	0xa7, 0x68, 0xc7, 0x6a, 0x45, 0x39, 0x14, 0xd2, 0x85, 0x8b, 0x83, 0x61, 0x51, 0x0c, 0xfb, 0xef,
	0xeb, 0x4d, 0x74, 0x6c, 0x1a, 0xc8, 0xc6, 0xc7, 0x7e, 0xc4, 0xa4, 0xac, 0x1e, 0x1e, 0x28, 0x0d,
	0xa8, 0xee, 0x09, 0x0b, 0x09, 0x8b, 0xb2, 0x69, 0x77, 0x90, 0xe7, 0x98, 0x4d, 0xf1, 0x4d, 0x70,
	0x29, 0x3a, 0xa1, 0xfa, 0xa1, 0x76, 0xa0, 0x34, 0x4a, 0x95, 0x52, 0xa3, 0x24, 0x2c, 0x26, 0x3e,
	0xbe, 0x5e, 0x3f, 0x0c, 0xab, 0x50, 0xf1, 0x8f, 0x57, 0x0e, 0x4a, 0xea, 0x43, 0xad, 0x06, 0x0f,
	0x0f, 0xf7, 0x85, 0xa5, 0xc4, 0xc7, 0x2b, 0x1d, 0xdd, 0x6c, 0xd7, 0x1c, 0xdb, 0x3e, 0x15, 0x77,
	0x63, 0xb3, 0xab, 0x1f, 0xd4, 0x99, 0xc9, 0x72, 0xe1, 0xc2, 0x60, 0x58, 0xdc, 0xe0, 0x03, 0x1d,
	0xd4, 0xa9, 0xc1, 0xdb, 0x20, 0x1f, 0x31, 0xa8, 0x1c, 0x1e, 0x94, 0xd4, 0xaa, 0x76, 0xac, 0x40,
	0x75, 0xff, 0xb1, 0xb0, 0x52, 0xb8, 0x3c, 0x18, 0x16, 0x2f, 0x84, 0x46, 0x15, 0xbb, 0xa3, 0x9b,
	0x16, 0xb9, 0x68, 0xf4, 0xc5, 0xd7, 0x62, 0xcb, 0x5c, 0xaa, 0xe0, 0x0f, 0x13, 0x56, 0x0b, 0xe2,
	0x60, 0x58, 0xcc, 0x85, 0x16, 0xa5, 0x4a, 0xbd, 0x7e, 0x58, 0x58, 0xf8, 0xf1, 0xaf, 0xb7, 0xe7,
	0x6e, 0xfc, 0x71, 0x01, 0x88, 0x93, 0x45, 0x33, 0xf1, 0x3d, 0x70, 0x85, 0x0c, 0xa7, 0xee, 0x95,
	0x1a, 0xea, 0x61, 0x55, 0xab, 0x37, 0x4a, 0x8d, 0xa3, 0xba, 0x76, 0x54, 0x7d, 0x50, 0x3d, 0x7c,
	0x54, 0x15, 0xe6, 0x0a, 0xd7, 0x06, 0xc3, 0xe2, 0xe5, 0x49, 0xc3, 0x23, 0xeb, 0x89, 0x65, 0x3f,
	0xb5, 0x66, 0xd9, 0xd7, 0x94, 0x6a, 0x45, 0xad, 0xbe, 0x2f, 0xa4, 0x66, 0xd9, 0xd7, 0x90, 0x65,
	0xe0, 0x3b, 0xa9, 0x02, 0xa4, 0x69, 0xf6, 0x6a, 0x15, 0xaf, 0xdc, 0xfb, 0x50, 0xa9, 0xd7, 0x85,
	0xf9, 0x42, 0x71, 0x30, 0x2c, 0x5e, 0x9d, 0xf4, 0xa1, 0x5a, 0x35, 0xc7, 0x6e, 0x91, 0xb7, 0xe9,
	0xbf, 0x83, 0xab, 0xd3, 0xdc, 0x50, 0x4c, 0xa9, 0x08, 0xe9, 0xc2, 0xf6, 0x60, 0x58, 0x2c, 0x4c,
	0xfa, 0x08, 0x8a, 0x1e, 0xb3, 0x3c, 0x40, 0xe5, 0xbe, 0xb2, 0xd7, 0x50, 0x2a, 0xc2, 0xc2, 0x2c,
	0x0f, 0x10, 0xfd, 0x2f, 0x6a, 0x7a, 0xc8, 0x98, 0xb5, 0x14, 0xca, 0x7f, 0xd4, 0x54, 0xa8, 0x54,
	0x84, 0xc5, 0x59, 0x4b, 0x41, 0xc4, 0x8d, 0x0c, 0xf1, 0xbf, 0xc0, 0xcd, 0x69, 0xf6, 0x55, 0x45,
	0xa9, 0xd4, 0xb5, 0x52, 0xa5, 0xa2, 0x62, 0xb4, 0xf4, 0x10, 0xeb, 0xa4, 0x71, 0x08, 0x85, 0xa5,
	0xc2, 0xcd, 0xc1, 0xb0, 0xf8, 0xea, 0xa4, 0xbf, 0x2a, 0x42, 0x86, 0x5b, 0x32, 0x0c, 0x13, 0x43,
	0x7a, 0x9b, 0xde, 0x63, 0xc4, 0xff, 0x01, 0xb7, 0xa6, 0x79, 0x9f, 0xf0, 0x1b, 0x86, 0x6e, 0xb9,
	0x70, 0x6b, 0x30, 0x2c, 0xbe, 0x36, 0xe9, 0x3f, 0xe9, 0x9a, 0x85, 0x92, 0xe5, 0xd9, 0xb7, 0x29,
	0x90, 0x89, 0xbe, 0xbe, 0xc5, 0x77, 0x40, 0x5e, 0xad, 0x28, 0xd5, 0x86, 0xda, 0x78, 0xac, 0x35,
	0x54, 0x05, 0x6a, 0x47, 0xd5, 0x30, 0x2c, 0x73, 0x85, 0xc2, 0x60, 0x58, 0xbc, 0x18, 0xed, 0x7f,
	0x64, 0x05, 0x95, 0x29, 0x71, 0x07, 0x6c, 0xc6, 0x2d, 0xcb, 0xa5, 0xba, 0xba, 0x27, 0xa4, 0xa8,
	0x98, 0x62, 0x4f, 0x7c, 0xdd, 0x35, 0x9b, 0x78, 0x97, 0x8b, 0xf7, 0xaf, 0x37, 0x4a, 0xd5, 0x4a,
	0x09, 0x56, 0x84, 0x79, 0x2a, 0xf4, 0xa8, 0x49, 0xdd, 0xd3, 0x2d, 0x43, 0x77, 0x0c, 0x7c, 0xc1,
	0x8f, 0x5b, 0xd5, 0xa0, 0x72, 0xa0, 0x1e, 0x1d, 0x08, 0x69, 0xaa, 0xf3, 0xa8, 0x51, 0xcd, 0x41,
	0x1d, 0xb3, 0xd7, 0x61, 0x9f, 0xfa, 0xbb, 0x34, 0xc8, 0xc6, 0xca, 0x17, 0x78, 0x06, 0xa5, 0xbd,
	0xbd, 0xc3, 0xa3, 0x6a, 0x63, 0x52, 0x48, 0x64, 0x06, 0xb1, 0xee, 0x81, 0x86, 0x26, 0xad, 0xb8,
	0x7c, 0x26, 0xad, 0x02, 0xe5, 0xbc, 0x0b, 0x0a, 0x09, 0xab, 0xb8, 0x68, 0xae, 0x0c, 0x86, 0xc5,
	0x4b, 0x31, 0xcb, 0x88, 0x5e, 0xde, 0x02, 0x97, 0x12, 0xc6, 0x11, 0xa9, 0x90, 0x6d, 0x27, 0x66,
	0x19, 0xaa, 0x64, 0xd2, 0x2e, 0x22, 0x90, 0x49, 0xbb, 0x50, 0x1b, 0x93, 0x9f, 0xc8, 0x65, 0x31,
	0xf9, 0x89, 0x81, 0x22, 0x20, 0x78, 0x25, 0x61, 0x35, 0x5b, 0x0c, 0xaf, 0x0c, 0x86, 0x45, 0x39,
	0xe6, 0x65, 0xaa, 0x0e, 0x58, 0xe8, 0x3e, 0x9f, 0x07, 0x99, 0x47, 0x7a, 0xbb, 0x8d, 0x82, 0xc8,
	0xdd, 0x03, 0x97, 0x1f, 0x95, 0x1e, 0x3e, 0x54, 0x22, 0x81, 0x8b, 0x1e, 0x92, 0x64, 0x31, 0xa3,
	0x06, 0xd1, 0x73, 0xf2, 0x75, 0xb0, 0x15, 0xb7, 0x2d, 0xed, 0x35, 0xd4, 0x63, 0x45, 0x48, 0xd1,
	0x33, 0x29, 0x6a, 0x56, 0xa2, 0x97, 0xea, 0xb7, 0xc0, 0xa5, 0xb8, 0x45, 0xfd, 0xa8, 0x8e, 0x63,
	0xae, 0xe0, 0x54, 0x25, 0xcb, 0x18, 0x35, 0xaa, 0xf7, 0xdc, 0x2e, 0xb2, 0x0c, 0x44, 0x72, 0x35,
	0x6e, 0x07, 0x95, 0xe3, 0xc3, 0x07, 0x24, 0x68, 0x24, 0x57, 0xa3, 0x56, 0x10, 0x9d, 0xdb, 0x4f,
	0xa6, 0xd9, 0x04, 0x2b, 0xbf, 0x30, 0x69, 0xc3, 0x16, 0x9e, 0x2e, 0x52, 0xb9, 0xfa, 0xc5, 0xd7,
	0xdb, 0xa9, 0x2f, 0xbf, 0xde, 0x4e, 0x7d, 0xf5, 0xf5, 0x76, 0xea, 0xd3, 0x6f, 0xb6, 0xe7, 0xbe,
	0xfc, 0x66, 0x7b, 0xee, 0x0f, 0xdf, 0x6c, 0xcf, 0x7d, 0xf4, 0x46, 0xcb, 0xf4, 0xce, 0x7a, 0x27,
	0x3b, 0x4d, 0xbb, 0xb3, 0x1b, 0xfd, 0xc3, 0x28, 0xfe, 0xd3, 0x35, 0x9e, 0xec, 0xb6, 0xec, 0x5d,
	0xcb, 0x36, 0xc2, 0xbf, 0x97, 0x3a, 0x59, 0x22, 0x7f, 0xd2, 0x74, 0xf7, 0xaf, 0x01, 0x00, 0x00,
	0xff, 0xff, 0xe5, 0x17, 0x49, 0x30, 0x4c, 0x25, 0x00, 0x00,
}

func (this *EncryptedPayloadEnvelope) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EncryptedPayloadEnvelope)
	if !ok {
		that2, ok := that.(EncryptedPayloadEnvelope)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.AlgorithmId != that1.AlgorithmId {
		return false
	}
	if this.AlgorithmVersion != that1.AlgorithmVersion {
		return false
	}
	if len(this.RecipientKeyIds) != len(that1.RecipientKeyIds) {
		return false
	}
	for i := range this.RecipientKeyIds {
		if this.RecipientKeyIds[i] != that1.RecipientKeyIds[i] {
			return false
		}
	}
	if len(this.RecipientPublicKeys) != len(that1.RecipientPublicKeys) {
		return false
	}
	for i := range this.RecipientPublicKeys {
		if !bytes.Equal(this.RecipientPublicKeys[i], that1.RecipientPublicKeys[i]) {
			return false
		}
	}
	if len(this.EncryptedKeys) != len(that1.EncryptedKeys) {
		return false
	}
	for i := range this.EncryptedKeys {
		if !bytes.Equal(this.EncryptedKeys[i], that1.EncryptedKeys[i]) {
			return false
		}
	}
	if !bytes.Equal(this.Nonce, that1.Nonce) {
		return false
	}
	if !bytes.Equal(this.Ciphertext, that1.Ciphertext) {
		return false
	}
	if !bytes.Equal(this.SenderSignature, that1.SenderSignature) {
		return false
	}
	if !bytes.Equal(this.SenderPubKey, that1.SenderPubKey) {
		return false
	}
	if len(this.Metadata) != len(that1.Metadata) {
		return false
	}
	for i := range this.Metadata {
		if this.Metadata[i] != that1.Metadata[i] {
			return false
		}
	}
	return true
}
func (this *UploadMetadata) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UploadMetadata)
	if !ok {
		that2, ok := that.(UploadMetadata)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.Salt, that1.Salt) {
		return false
	}
	if !bytes.Equal(this.SaltHash, that1.SaltHash) {
		return false
	}
	if this.DeviceFingerprint != that1.DeviceFingerprint {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if !bytes.Equal(this.ClientSignature, that1.ClientSignature) {
		return false
	}
	if !bytes.Equal(this.UserSignature, that1.UserSignature) {
		return false
	}
	if !bytes.Equal(this.PayloadHash, that1.PayloadHash) {
		return false
	}
	if !bytes.Equal(this.UploadNonce, that1.UploadNonce) {
		return false
	}
	if this.CaptureTimestamp != that1.CaptureTimestamp {
		return false
	}
	if this.GeoHint != that1.GeoHint {
		return false
	}
	return true
}
func (this *ScopeRef) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ScopeRef)
	if !ok {
		that2, ok := that.(ScopeRef)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.ScopeType != that1.ScopeType {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.UploadedAt != that1.UploadedAt {
		return false
	}
	if this.VerifiedAt != that1.VerifiedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	return true
}
func (this *IdentityScope) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityScope)
	if !ok {
		that2, ok := that.(IdentityScope)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.ScopeType != that1.ScopeType {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if !this.EncryptedPayload.Equal(&that1.EncryptedPayload) {
		return false
	}
	if !this.UploadMetadata.Equal(&that1.UploadMetadata) {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.UploadedAt != that1.UploadedAt {
		return false
	}
	if this.VerifiedAt != that1.VerifiedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	if this.OwnerAddress != that1.OwnerAddress {
		return false
	}
	return true
}
func (this *IdentityRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityRecord)
	if !ok {
		that2, ok := that.(IdentityRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if len(this.ScopeRefs) != len(that1.ScopeRefs) {
		return false
	}
	for i := range this.ScopeRefs {
		if !this.ScopeRefs[i].Equal(&that1.ScopeRefs[i]) {
			return false
		}
	}
	if this.CurrentScore != that1.CurrentScore {
		return false
	}
	if this.ScoreVersion != that1.ScoreVersion {
		return false
	}
	if this.LastVerifiedAt != that1.LastVerifiedAt {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.UpdatedAt != that1.UpdatedAt {
		return false
	}
	if this.Tier != that1.Tier {
		return false
	}
	if len(this.Flags) != len(that1.Flags) {
		return false
	}
	for i := range this.Flags {
		if this.Flags[i] != that1.Flags[i] {
			return false
		}
	}
	if this.Locked != that1.Locked {
		return false
	}
	if this.LockedReason != that1.LockedReason {
		return false
	}
	return true
}
func (this *IdentityScore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*IdentityScore)
	if !ok {
		that2, ok := that.(IdentityScore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.Score != that1.Score {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.Tier != that1.Tier {
		return false
	}
	if this.ModelVersion != that1.ModelVersion {
		return false
	}
	if this.LastUpdatedAt != that1.LastUpdatedAt {
		return false
	}
	if this.BlockHeight != that1.BlockHeight {
		return false
	}
	return true
}
func (this *ConsentSettings) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ConsentSettings)
	if !ok {
		that2, ok := that.(ConsentSettings)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShareWithProviders != that1.ShareWithProviders {
		return false
	}
	if this.ShareForVerification != that1.ShareForVerification {
		return false
	}
	if this.AllowReVerification != that1.AllowReVerification {
		return false
	}
	if this.AllowDerivedFeatureSharing != that1.AllowDerivedFeatureSharing {
		return false
	}
	if this.ConsentVersion != that1.ConsentVersion {
		return false
	}
	if this.LastUpdatedAt != that1.LastUpdatedAt {
		return false
	}
	return true
}
func (this *GlobalConsentUpdate) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GlobalConsentUpdate)
	if !ok {
		that2, ok := that.(GlobalConsentUpdate)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ShareWithProviders != that1.ShareWithProviders {
		return false
	}
	if this.ShareForVerification != that1.ShareForVerification {
		return false
	}
	if this.AllowReVerification != that1.AllowReVerification {
		return false
	}
	if this.AllowDerivedFeatureSharing != that1.AllowDerivedFeatureSharing {
		return false
	}
	return true
}
func (this *BorderlineParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BorderlineParams)
	if !ok {
		that2, ok := that.(BorderlineParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.LowerThreshold != that1.LowerThreshold {
		return false
	}
	if this.UpperThreshold != that1.UpperThreshold {
		return false
	}
	if this.MfaTimeoutBlocks != that1.MfaTimeoutBlocks {
		return false
	}
	if this.RequiredFactors != that1.RequiredFactors {
		return false
	}
	return true
}
func (this *ApprovedClient) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ApprovedClient)
	if !ok {
		that2, ok := that.(ApprovedClient)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ClientId != that1.ClientId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if !bytes.Equal(this.PublicKey, that1.PublicKey) {
		return false
	}
	if this.Active != that1.Active {
		return false
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.DeactivatedAt != that1.DeactivatedAt {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxScopesPerAccount != that1.MaxScopesPerAccount {
		return false
	}
	if this.MaxScopesPerType != that1.MaxScopesPerType {
		return false
	}
	if this.SaltMinBytes != that1.SaltMinBytes {
		return false
	}
	if this.SaltMaxBytes != that1.SaltMaxBytes {
		return false
	}
	if this.RequireClientSignature != that1.RequireClientSignature {
		return false
	}
	if this.RequireUserSignature != that1.RequireUserSignature {
		return false
	}
	if this.VerificationExpiryDays != that1.VerificationExpiryDays {
		return false
	}
	return true
}
func (m *EncryptedPayloadEnvelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EncryptedPayloadEnvelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EncryptedPayloadEnvelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Metadata) > 0 {
		for k := range m.Metadata {
			v := m.Metadata[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintTypes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTypes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.SenderPubKey) > 0 {
		i -= len(m.SenderPubKey)
		copy(dAtA[i:], m.SenderPubKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SenderPubKey)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.SenderSignature) > 0 {
		i -= len(m.SenderSignature)
		copy(dAtA[i:], m.SenderSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SenderSignature)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.Ciphertext) > 0 {
		i -= len(m.Ciphertext)
		copy(dAtA[i:], m.Ciphertext)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Ciphertext)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.EncryptedKeys) > 0 {
		for iNdEx := len(m.EncryptedKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EncryptedKeys[iNdEx])
			copy(dAtA[i:], m.EncryptedKeys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.EncryptedKeys[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.RecipientPublicKeys) > 0 {
		for iNdEx := len(m.RecipientPublicKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientPublicKeys[iNdEx])
			copy(dAtA[i:], m.RecipientPublicKeys[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RecipientPublicKeys[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.RecipientKeyIds) > 0 {
		for iNdEx := len(m.RecipientKeyIds) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RecipientKeyIds[iNdEx])
			copy(dAtA[i:], m.RecipientKeyIds[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.RecipientKeyIds[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AlgorithmVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AlgorithmVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AlgorithmId) > 0 {
		i -= len(m.AlgorithmId)
		copy(dAtA[i:], m.AlgorithmId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AlgorithmId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UploadMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GeoHint) > 0 {
		i -= len(m.GeoHint)
		copy(dAtA[i:], m.GeoHint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.GeoHint)))
		i--
		dAtA[i] = 0x52
	}
	if m.CaptureTimestamp != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CaptureTimestamp))
		i--
		dAtA[i] = 0x48
	}
	if len(m.UploadNonce) > 0 {
		i -= len(m.UploadNonce)
		copy(dAtA[i:], m.UploadNonce)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UploadNonce)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.PayloadHash) > 0 {
		i -= len(m.PayloadHash)
		copy(dAtA[i:], m.PayloadHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PayloadHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UserSignature) > 0 {
		i -= len(m.UserSignature)
		copy(dAtA[i:], m.UserSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.UserSignature)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ClientSignature) > 0 {
		i -= len(m.ClientSignature)
		copy(dAtA[i:], m.ClientSignature)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientSignature)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.DeviceFingerprint) > 0 {
		i -= len(m.DeviceFingerprint)
		copy(dAtA[i:], m.DeviceFingerprint)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.DeviceFingerprint)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SaltHash) > 0 {
		i -= len(m.SaltHash)
		copy(dAtA[i:], m.SaltHash)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.SaltHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Salt) > 0 {
		i -= len(m.Salt)
		copy(dAtA[i:], m.Salt)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Salt)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ScopeRef) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScopeRef) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ScopeRef) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.UploadedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UploadedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.ScopeType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdentityScope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityScope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityScope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OwnerAddress) > 0 {
		i -= len(m.OwnerAddress)
		copy(dAtA[i:], m.OwnerAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.OwnerAddress)))
		i--
		dAtA[i] = 0x52
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x48
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.UploadedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UploadedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.UploadMetadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.EncryptedPayload.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Version != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.ScopeType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdentityRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LockedReason) > 0 {
		i -= len(m.LockedReason)
		copy(dAtA[i:], m.LockedReason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.LockedReason)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Locked {
		i--
		if m.Locked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if len(m.Flags) > 0 {
		for iNdEx := len(m.Flags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Flags[iNdEx])
			copy(dAtA[i:], m.Flags[iNdEx])
			i = encodeVarintTypes(dAtA, i, uint64(len(m.Flags[iNdEx])))
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Tier != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x40
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.LastVerifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastVerifiedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ScoreVersion) > 0 {
		i -= len(m.ScoreVersion)
		copy(dAtA[i:], m.ScoreVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ScoreVersion)))
		i--
		dAtA[i] = 0x22
	}
	if m.CurrentScore != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CurrentScore))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ScopeRefs) > 0 {
		for iNdEx := len(m.ScopeRefs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScopeRefs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTypes(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IdentityScore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IdentityScore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IdentityScore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x38
	}
	if m.LastUpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Tier != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Score != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsentSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsentSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsentSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LastUpdatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.ConsentVersion != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ConsentVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.AllowDerivedFeatureSharing {
		i--
		if m.AllowDerivedFeatureSharing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AllowReVerification {
		i--
		if m.AllowReVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ShareForVerification {
		i--
		if m.ShareForVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ShareWithProviders {
		i--
		if m.ShareWithProviders {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GlobalConsentUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GlobalConsentUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GlobalConsentUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowDerivedFeatureSharing {
		i--
		if m.AllowDerivedFeatureSharing {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AllowReVerification {
		i--
		if m.AllowReVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ShareForVerification {
		i--
		if m.ShareForVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.ShareWithProviders {
		i--
		if m.ShareWithProviders {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BorderlineParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BorderlineParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BorderlineParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequiredFactors != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.RequiredFactors))
		i--
		dAtA[i] = 0x20
	}
	if m.MfaTimeoutBlocks != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MfaTimeoutBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.UpperThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.UpperThreshold))
		i--
		dAtA[i] = 0x10
	}
	if m.LowerThreshold != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.LowerThreshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ApprovedClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ApprovedClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ApprovedClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeactivatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.DeactivatedAt))
		i--
		dAtA[i] = 0x30
	}
	if m.CreatedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Active {
		i--
		if m.Active {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ClientId) > 0 {
		i -= len(m.ClientId)
		copy(dAtA[i:], m.ClientId)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ClientId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.VerificationExpiryDays != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.VerificationExpiryDays))
		i--
		dAtA[i] = 0x38
	}
	if m.RequireUserSignature {
		i--
		if m.RequireUserSignature {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.RequireClientSignature {
		i--
		if m.RequireClientSignature {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.SaltMaxBytes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SaltMaxBytes))
		i--
		dAtA[i] = 0x20
	}
	if m.SaltMinBytes != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.SaltMinBytes))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxScopesPerType != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxScopesPerType))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxScopesPerAccount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxScopesPerAccount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EncryptedPayloadEnvelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = len(m.AlgorithmId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AlgorithmVersion != 0 {
		n += 1 + sovTypes(uint64(m.AlgorithmVersion))
	}
	if len(m.RecipientKeyIds) > 0 {
		for _, s := range m.RecipientKeyIds {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.RecipientPublicKeys) > 0 {
		for _, b := range m.RecipientPublicKeys {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.EncryptedKeys) > 0 {
		for _, b := range m.EncryptedKeys {
			l = len(b)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Ciphertext)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SenderSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SenderPubKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Metadata) > 0 {
		for k, v := range m.Metadata {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + 1 + len(v) + sovTypes(uint64(len(v)))
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *UploadMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Salt)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.SaltHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.DeviceFingerprint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ClientSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UserSignature)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PayloadHash)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.UploadNonce)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.CaptureTimestamp != 0 {
		n += 1 + sovTypes(uint64(m.CaptureTimestamp))
	}
	l = len(m.GeoHint)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *ScopeRef) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovTypes(uint64(m.ScopeType))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.UploadedAt != 0 {
		n += 1 + sovTypes(uint64(m.UploadedAt))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.VerifiedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovTypes(uint64(m.ExpiresAt))
	}
	return n
}

func (m *IdentityScope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovTypes(uint64(m.ScopeType))
	}
	if m.Version != 0 {
		n += 1 + sovTypes(uint64(m.Version))
	}
	l = m.EncryptedPayload.Size()
	n += 1 + l + sovTypes(uint64(l))
	l = m.UploadMetadata.Size()
	n += 1 + l + sovTypes(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.UploadedAt != 0 {
		n += 1 + sovTypes(uint64(m.UploadedAt))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.VerifiedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovTypes(uint64(m.ExpiresAt))
	}
	l = len(m.OwnerAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IdentityRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.ScopeRefs) > 0 {
		for _, e := range m.ScopeRefs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.CurrentScore != 0 {
		n += 1 + sovTypes(uint64(m.CurrentScore))
	}
	l = len(m.ScoreVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastVerifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.LastVerifiedAt))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.UpdatedAt))
	}
	if m.Tier != 0 {
		n += 1 + sovTypes(uint64(m.Tier))
	}
	if len(m.Flags) > 0 {
		for _, s := range m.Flags {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if m.Locked {
		n += 2
	}
	l = len(m.LockedReason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *IdentityScore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Score != 0 {
		n += 1 + sovTypes(uint64(m.Score))
	}
	if m.Status != 0 {
		n += 1 + sovTypes(uint64(m.Status))
	}
	if m.Tier != 0 {
		n += 1 + sovTypes(uint64(m.Tier))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LastUpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdatedAt))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovTypes(uint64(m.BlockHeight))
	}
	return n
}

func (m *ConsentSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShareWithProviders {
		n += 2
	}
	if m.ShareForVerification {
		n += 2
	}
	if m.AllowReVerification {
		n += 2
	}
	if m.AllowDerivedFeatureSharing {
		n += 2
	}
	if m.ConsentVersion != 0 {
		n += 1 + sovTypes(uint64(m.ConsentVersion))
	}
	if m.LastUpdatedAt != 0 {
		n += 1 + sovTypes(uint64(m.LastUpdatedAt))
	}
	return n
}

func (m *GlobalConsentUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShareWithProviders {
		n += 2
	}
	if m.ShareForVerification {
		n += 2
	}
	if m.AllowReVerification {
		n += 2
	}
	if m.AllowDerivedFeatureSharing {
		n += 2
	}
	return n
}

func (m *BorderlineParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LowerThreshold != 0 {
		n += 1 + sovTypes(uint64(m.LowerThreshold))
	}
	if m.UpperThreshold != 0 {
		n += 1 + sovTypes(uint64(m.UpperThreshold))
	}
	if m.MfaTimeoutBlocks != 0 {
		n += 1 + sovTypes(uint64(m.MfaTimeoutBlocks))
	}
	if m.RequiredFactors != 0 {
		n += 1 + sovTypes(uint64(m.RequiredFactors))
	}
	return n
}

func (m *ApprovedClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ClientId)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Active {
		n += 2
	}
	if m.CreatedAt != 0 {
		n += 1 + sovTypes(uint64(m.CreatedAt))
	}
	if m.DeactivatedAt != 0 {
		n += 1 + sovTypes(uint64(m.DeactivatedAt))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxScopesPerAccount != 0 {
		n += 1 + sovTypes(uint64(m.MaxScopesPerAccount))
	}
	if m.MaxScopesPerType != 0 {
		n += 1 + sovTypes(uint64(m.MaxScopesPerType))
	}
	if m.SaltMinBytes != 0 {
		n += 1 + sovTypes(uint64(m.SaltMinBytes))
	}
	if m.SaltMaxBytes != 0 {
		n += 1 + sovTypes(uint64(m.SaltMaxBytes))
	}
	if m.RequireClientSignature {
		n += 2
	}
	if m.RequireUserSignature {
		n += 2
	}
	if m.VerificationExpiryDays != 0 {
		n += 1 + sovTypes(uint64(m.VerificationExpiryDays))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EncryptedPayloadEnvelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EncryptedPayloadEnvelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EncryptedPayloadEnvelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AlgorithmId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlgorithmVersion", wireType)
			}
			m.AlgorithmVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AlgorithmVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientKeyIds", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientKeyIds = append(m.RecipientKeyIds, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecipientPublicKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RecipientPublicKeys = append(m.RecipientPublicKeys, make([]byte, postIndex-iNdEx))
			copy(m.RecipientPublicKeys[len(m.RecipientPublicKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKeys = append(m.EncryptedKeys, make([]byte, postIndex-iNdEx))
			copy(m.EncryptedKeys[len(m.EncryptedKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ciphertext", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ciphertext = append(m.Ciphertext[:0], dAtA[iNdEx:postIndex]...)
			if m.Ciphertext == nil {
				m.Ciphertext = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderSignature = append(m.SenderSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderSignature == nil {
				m.SenderSignature = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SenderPubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SenderPubKey = append(m.SenderPubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SenderPubKey == nil {
				m.SenderPubKey = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthTypes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Metadata[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UploadMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salt = append(m.Salt[:0], dAtA[iNdEx:postIndex]...)
			if m.Salt == nil {
				m.Salt = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaltHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SaltHash = append(m.SaltHash[:0], dAtA[iNdEx:postIndex]...)
			if m.SaltHash == nil {
				m.SaltHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceFingerprint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceFingerprint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientSignature = append(m.ClientSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.ClientSignature == nil {
				m.ClientSignature = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserSignature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserSignature = append(m.UserSignature[:0], dAtA[iNdEx:postIndex]...)
			if m.UserSignature == nil {
				m.UserSignature = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadHash = append(m.PayloadHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadHash == nil {
				m.PayloadHash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadNonce = append(m.UploadNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadNonce == nil {
				m.UploadNonce = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaptureTimestamp", wireType)
			}
			m.CaptureTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CaptureTimestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GeoHint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GeoHint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScopeRef) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScopeRef: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScopeRef: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= VerificationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedAt", wireType)
			}
			m.UploadedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentityScope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityScope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityScope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedPayload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.EncryptedPayload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadMetadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UploadMetadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= VerificationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedAt", wireType)
			}
			m.UploadedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UploadedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentityRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeRefs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeRefs = append(m.ScopeRefs, ScopeRef{})
			if err := m.ScopeRefs[len(m.ScopeRefs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentScore", wireType)
			}
			m.CurrentScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScoreVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVerifiedAt", wireType)
			}
			m.LastVerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastVerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= IdentityTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Flags = append(m.Flags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Locked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Locked = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockedReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IdentityScore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IdentityScore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IdentityScore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= IdentityTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			m.LastUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsentSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsentSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsentSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareWithProviders", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareWithProviders = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareForVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareForVerification = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowReVerification = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDerivedFeatureSharing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDerivedFeatureSharing = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsentVersion", wireType)
			}
			m.ConsentVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsentVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			m.LastUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GlobalConsentUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GlobalConsentUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GlobalConsentUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareWithProviders", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareWithProviders = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareForVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ShareForVerification = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowReVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowReVerification = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowDerivedFeatureSharing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowDerivedFeatureSharing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BorderlineParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BorderlineParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BorderlineParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LowerThreshold", wireType)
			}
			m.LowerThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LowerThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpperThreshold", wireType)
			}
			m.UpperThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpperThreshold |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MfaTimeoutBlocks", wireType)
			}
			m.MfaTimeoutBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MfaTimeoutBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredFactors", wireType)
			}
			m.RequiredFactors = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RequiredFactors |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ApprovedClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ApprovedClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ApprovedClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Active", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Active = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeactivatedAt", wireType)
			}
			m.DeactivatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeactivatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScopesPerAccount", wireType)
			}
			m.MaxScopesPerAccount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScopesPerAccount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxScopesPerType", wireType)
			}
			m.MaxScopesPerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxScopesPerType |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaltMinBytes", wireType)
			}
			m.SaltMinBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaltMinBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SaltMaxBytes", wireType)
			}
			m.SaltMaxBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SaltMaxBytes |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireClientSignature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireClientSignature = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireUserSignature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireUserSignature = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerificationExpiryDays", wireType)
			}
			m.VerificationExpiryDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerificationExpiryDays |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)
