// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/veid/v1/compliance.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ComplianceStatus represents the compliance state of an identity
type ComplianceStatus int32

const (
	// COMPLIANCE_STATUS_UNKNOWN indicates no compliance check has been performed
	ComplianceStatusUnknown ComplianceStatus = 0
	// COMPLIANCE_STATUS_PENDING indicates compliance check is in progress
	ComplianceStatusPending ComplianceStatus = 1
	// COMPLIANCE_STATUS_CLEARED indicates identity passed all compliance checks
	ComplianceStatusCleared ComplianceStatus = 2
	// COMPLIANCE_STATUS_FLAGGED indicates identity has been flagged for review
	ComplianceStatusFlagged ComplianceStatus = 3
	// COMPLIANCE_STATUS_BLOCKED indicates identity is blocked from transactions
	ComplianceStatusBlocked ComplianceStatus = 4
	// COMPLIANCE_STATUS_EXPIRED indicates compliance check has expired
	ComplianceStatusExpired ComplianceStatus = 5
)

var ComplianceStatus_name = map[int32]string{
	0: "COMPLIANCE_STATUS_UNKNOWN",
	1: "COMPLIANCE_STATUS_PENDING",
	2: "COMPLIANCE_STATUS_CLEARED",
	3: "COMPLIANCE_STATUS_FLAGGED",
	4: "COMPLIANCE_STATUS_BLOCKED",
	5: "COMPLIANCE_STATUS_EXPIRED",
}

var ComplianceStatus_value = map[string]int32{
	"COMPLIANCE_STATUS_UNKNOWN": 0,
	"COMPLIANCE_STATUS_PENDING": 1,
	"COMPLIANCE_STATUS_CLEARED": 2,
	"COMPLIANCE_STATUS_FLAGGED": 3,
	"COMPLIANCE_STATUS_BLOCKED": 4,
	"COMPLIANCE_STATUS_EXPIRED": 5,
}

func (x ComplianceStatus) String() string {
	return proto.EnumName(ComplianceStatus_name, int32(x))
}

func (ComplianceStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{0}
}

// ComplianceCheckType defines what type of compliance check
type ComplianceCheckType int32

const (
	// COMPLIANCE_CHECK_SANCTION_LIST checks against global sanction lists
	ComplianceCheckSanctionList ComplianceCheckType = 0
	// COMPLIANCE_CHECK_PEP checks for Politically Exposed Person status
	ComplianceCheckPEP ComplianceCheckType = 1
	// COMPLIANCE_CHECK_ADVERSE_MEDIA checks for negative news coverage
	ComplianceCheckAdverseMedia ComplianceCheckType = 2
	// COMPLIANCE_CHECK_GEOGRAPHIC checks geographic restrictions
	ComplianceCheckGeographic ComplianceCheckType = 3
	// COMPLIANCE_CHECK_WATCHLIST checks against custom watchlists
	ComplianceCheckWatchlist ComplianceCheckType = 4
	// COMPLIANCE_CHECK_DOCUMENT_VERIFICATION verifies identity documents
	ComplianceCheckDocumentVerification ComplianceCheckType = 5
	// COMPLIANCE_CHECK_AML_RISK assesses anti-money laundering risk
	ComplianceCheckAMLRisk ComplianceCheckType = 6
)

var ComplianceCheckType_name = map[int32]string{
	0: "COMPLIANCE_CHECK_SANCTION_LIST",
	1: "COMPLIANCE_CHECK_PEP",
	2: "COMPLIANCE_CHECK_ADVERSE_MEDIA",
	3: "COMPLIANCE_CHECK_GEOGRAPHIC",
	4: "COMPLIANCE_CHECK_WATCHLIST",
	5: "COMPLIANCE_CHECK_DOCUMENT_VERIFICATION",
	6: "COMPLIANCE_CHECK_AML_RISK",
}

var ComplianceCheckType_value = map[string]int32{
	"COMPLIANCE_CHECK_SANCTION_LIST":         0,
	"COMPLIANCE_CHECK_PEP":                   1,
	"COMPLIANCE_CHECK_ADVERSE_MEDIA":         2,
	"COMPLIANCE_CHECK_GEOGRAPHIC":            3,
	"COMPLIANCE_CHECK_WATCHLIST":             4,
	"COMPLIANCE_CHECK_DOCUMENT_VERIFICATION": 5,
	"COMPLIANCE_CHECK_AML_RISK":              6,
}

func (x ComplianceCheckType) String() string {
	return proto.EnumName(ComplianceCheckType_name, int32(x))
}

func (ComplianceCheckType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{1}
}

// ComplianceCheckResult stores result of a single compliance check
type ComplianceCheckResult struct {
	// CheckType indicates what kind of check was performed
	CheckType ComplianceCheckType `protobuf:"varint,1,opt,name=check_type,json=checkType,proto3,enum=virtengine.veid.v1.ComplianceCheckType" json:"check_type" yaml:"check_type"`
	// Passed indicates whether the check passed
	Passed bool `protobuf:"varint,2,opt,name=passed,proto3" json:"passed" yaml:"passed"`
	// Details provides additional context about the check result
	Details string `protobuf:"bytes,3,opt,name=details,proto3" json:"details" yaml:"details"`
	// MatchScore indicates confidence of any matches found (0-100)
	MatchScore int32 `protobuf:"varint,4,opt,name=match_score,json=matchScore,proto3" json:"match_score" yaml:"match_score"`
	// CheckedAt is the Unix timestamp when the check was performed
	CheckedAt int64 `protobuf:"varint,5,opt,name=checked_at,json=checkedAt,proto3" json:"checked_at" yaml:"checked_at"`
	// ProviderID identifies the compliance provider that performed the check
	ProviderId string `protobuf:"bytes,6,opt,name=provider_id,json=providerId,proto3" json:"provider_id" yaml:"provider_id"`
	// ReferenceID is the provider's reference for this check
	ReferenceId string `protobuf:"bytes,7,opt,name=reference_id,json=referenceId,proto3" json:"reference_id" yaml:"reference_id"`
}

func (m *ComplianceCheckResult) Reset()         { *m = ComplianceCheckResult{} }
func (m *ComplianceCheckResult) String() string { return proto.CompactTextString(m) }
func (*ComplianceCheckResult) ProtoMessage()    {}
func (*ComplianceCheckResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{0}
}
func (m *ComplianceCheckResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceCheckResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceCheckResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceCheckResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceCheckResult.Merge(m, src)
}
func (m *ComplianceCheckResult) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceCheckResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceCheckResult.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceCheckResult proto.InternalMessageInfo

func (m *ComplianceCheckResult) GetCheckType() ComplianceCheckType {
	if m != nil {
		return m.CheckType
	}
	return ComplianceCheckSanctionList
}

func (m *ComplianceCheckResult) GetPassed() bool {
	if m != nil {
		return m.Passed
	}
	return false
}

func (m *ComplianceCheckResult) GetDetails() string {
	if m != nil {
		return m.Details
	}
	return ""
}

func (m *ComplianceCheckResult) GetMatchScore() int32 {
	if m != nil {
		return m.MatchScore
	}
	return 0
}

func (m *ComplianceCheckResult) GetCheckedAt() int64 {
	if m != nil {
		return m.CheckedAt
	}
	return 0
}

func (m *ComplianceCheckResult) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *ComplianceCheckResult) GetReferenceId() string {
	if m != nil {
		return m.ReferenceId
	}
	return ""
}

// ComplianceAttestation is a validator attestation of compliance status
type ComplianceAttestation struct {
	// ValidatorAddress is the address of the attesting validator
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// AttestedAt is the Unix timestamp when attestation was made
	AttestedAt int64 `protobuf:"varint,2,opt,name=attested_at,json=attestedAt,proto3" json:"attested_at" yaml:"attested_at"`
	// ExpiresAt is the Unix timestamp when this attestation expires
	ExpiresAt int64 `protobuf:"varint,3,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// AttestationType describes what is being attested
	AttestationType string `protobuf:"bytes,4,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type" yaml:"attestation_type"`
	// AttestationHash is a hash of the attestation data for verification
	AttestationHash string `protobuf:"bytes,5,opt,name=attestation_hash,json=attestationHash,proto3" json:"attestation_hash" yaml:"attestation_hash"`
}

func (m *ComplianceAttestation) Reset()         { *m = ComplianceAttestation{} }
func (m *ComplianceAttestation) String() string { return proto.CompactTextString(m) }
func (*ComplianceAttestation) ProtoMessage()    {}
func (*ComplianceAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{1}
}
func (m *ComplianceAttestation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceAttestation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceAttestation.Merge(m, src)
}
func (m *ComplianceAttestation) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceAttestation proto.InternalMessageInfo

func (m *ComplianceAttestation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ComplianceAttestation) GetAttestedAt() int64 {
	if m != nil {
		return m.AttestedAt
	}
	return 0
}

func (m *ComplianceAttestation) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *ComplianceAttestation) GetAttestationType() string {
	if m != nil {
		return m.AttestationType
	}
	return ""
}

func (m *ComplianceAttestation) GetAttestationHash() string {
	if m != nil {
		return m.AttestationHash
	}
	return ""
}

// ComplianceRecord stores the complete compliance status for an identity
type ComplianceRecord struct {
	// AccountAddress is the blockchain address of the identity
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Status is the overall compliance status
	Status ComplianceStatus `protobuf:"varint,2,opt,name=status,proto3,enum=virtengine.veid.v1.ComplianceStatus" json:"status" yaml:"status"`
	// CheckResults contains results of individual compliance checks
	CheckResults []ComplianceCheckResult `protobuf:"bytes,3,rep,name=check_results,json=checkResults,proto3" json:"check_results" yaml:"check_results"`
	// LastCheckedAt is the Unix timestamp of the last compliance check
	LastCheckedAt int64 `protobuf:"varint,4,opt,name=last_checked_at,json=lastCheckedAt,proto3" json:"last_checked_at" yaml:"last_checked_at"`
	// ExpiresAt is the Unix timestamp when the compliance record expires
	ExpiresAt int64 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// RiskScore is the overall risk score (0-100, lower is better)
	RiskScore int32 `protobuf:"varint,6,opt,name=risk_score,json=riskScore,proto3" json:"risk_score" yaml:"risk_score"`
	// RestrictedRegions lists regions where this identity is restricted
	RestrictedRegions []string `protobuf:"bytes,7,rep,name=restricted_regions,json=restrictedRegions,proto3" json:"restricted_regions" yaml:"restricted_regions"`
	// Attestations contains validator attestations of compliance
	Attestations []ComplianceAttestation `protobuf:"bytes,8,rep,name=attestations,proto3" json:"attestations" yaml:"attestations"`
	// CreatedAt is when this record was first created
	CreatedAt int64 `protobuf:"varint,9,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// UpdatedAt is when this record was last updated
	UpdatedAt int64 `protobuf:"varint,10,opt,name=updated_at,json=updatedAt,proto3" json:"updated_at" yaml:"updated_at"`
	// Notes contains any additional notes about the compliance status
	Notes string `protobuf:"bytes,11,opt,name=notes,proto3" json:"notes" yaml:"notes"`
}

func (m *ComplianceRecord) Reset()         { *m = ComplianceRecord{} }
func (m *ComplianceRecord) String() string { return proto.CompactTextString(m) }
func (*ComplianceRecord) ProtoMessage()    {}
func (*ComplianceRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{2}
}
func (m *ComplianceRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceRecord.Merge(m, src)
}
func (m *ComplianceRecord) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceRecord proto.InternalMessageInfo

func (m *ComplianceRecord) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *ComplianceRecord) GetStatus() ComplianceStatus {
	if m != nil {
		return m.Status
	}
	return ComplianceStatusUnknown
}

func (m *ComplianceRecord) GetCheckResults() []ComplianceCheckResult {
	if m != nil {
		return m.CheckResults
	}
	return nil
}

func (m *ComplianceRecord) GetLastCheckedAt() int64 {
	if m != nil {
		return m.LastCheckedAt
	}
	return 0
}

func (m *ComplianceRecord) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *ComplianceRecord) GetRiskScore() int32 {
	if m != nil {
		return m.RiskScore
	}
	return 0
}

func (m *ComplianceRecord) GetRestrictedRegions() []string {
	if m != nil {
		return m.RestrictedRegions
	}
	return nil
}

func (m *ComplianceRecord) GetAttestations() []ComplianceAttestation {
	if m != nil {
		return m.Attestations
	}
	return nil
}

func (m *ComplianceRecord) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *ComplianceRecord) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *ComplianceRecord) GetNotes() string {
	if m != nil {
		return m.Notes
	}
	return ""
}

// ComplianceParams configures the compliance module behavior
type ComplianceParams struct {
	// RequireSanctionCheck indicates if sanction list check is mandatory
	RequireSanctionCheck bool `protobuf:"varint,1,opt,name=require_sanction_check,json=requireSanctionCheck,proto3" json:"require_sanction_check" yaml:"require_sanction_check"`
	// RequirePEPCheck indicates if PEP check is mandatory
	RequirePepCheck bool `protobuf:"varint,2,opt,name=require_pep_check,json=requirePepCheck,proto3" json:"require_pep_check" yaml:"require_pep_check"`
	// CheckExpiryBlocks is how long compliance checks remain valid
	CheckExpiryBlocks int64 `protobuf:"varint,3,opt,name=check_expiry_blocks,json=checkExpiryBlocks,proto3" json:"check_expiry_blocks" yaml:"check_expiry_blocks"`
	// RiskScoreThreshold is the maximum allowed risk score (0-100)
	RiskScoreThreshold int32 `protobuf:"varint,4,opt,name=risk_score_threshold,json=riskScoreThreshold,proto3" json:"risk_score_threshold" yaml:"risk_score_threshold"`
	// RestrictedCountries is list of ISO country codes that are restricted
	RestrictedCountries []string `protobuf:"bytes,5,rep,name=restricted_countries,json=restrictedCountries,proto3" json:"restricted_countries" yaml:"restricted_countries"`
	// MinAttestationsRequired is minimum validator attestations needed
	MinAttestationsRequired int32 `protobuf:"varint,6,opt,name=min_attestations_required,json=minAttestationsRequired,proto3" json:"min_attestations_required" yaml:"min_attestations_required"`
	// EnableAutoExpiry enables automatic expiration of compliance records
	EnableAutoExpiry bool `protobuf:"varint,7,opt,name=enable_auto_expiry,json=enableAutoExpiry,proto3" json:"enable_auto_expiry" yaml:"enable_auto_expiry"`
	// RequireDocumentVerification indicates if document verification is mandatory
	RequireDocumentVerification bool `protobuf:"varint,8,opt,name=require_document_verification,json=requireDocumentVerification,proto3" json:"require_document_verification" yaml:"require_document_verification"`
}

func (m *ComplianceParams) Reset()         { *m = ComplianceParams{} }
func (m *ComplianceParams) String() string { return proto.CompactTextString(m) }
func (*ComplianceParams) ProtoMessage()    {}
func (*ComplianceParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{3}
}
func (m *ComplianceParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceParams.Merge(m, src)
}
func (m *ComplianceParams) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceParams.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceParams proto.InternalMessageInfo

func (m *ComplianceParams) GetRequireSanctionCheck() bool {
	if m != nil {
		return m.RequireSanctionCheck
	}
	return false
}

func (m *ComplianceParams) GetRequirePepCheck() bool {
	if m != nil {
		return m.RequirePepCheck
	}
	return false
}

func (m *ComplianceParams) GetCheckExpiryBlocks() int64 {
	if m != nil {
		return m.CheckExpiryBlocks
	}
	return 0
}

func (m *ComplianceParams) GetRiskScoreThreshold() int32 {
	if m != nil {
		return m.RiskScoreThreshold
	}
	return 0
}

func (m *ComplianceParams) GetRestrictedCountries() []string {
	if m != nil {
		return m.RestrictedCountries
	}
	return nil
}

func (m *ComplianceParams) GetMinAttestationsRequired() int32 {
	if m != nil {
		return m.MinAttestationsRequired
	}
	return 0
}

func (m *ComplianceParams) GetEnableAutoExpiry() bool {
	if m != nil {
		return m.EnableAutoExpiry
	}
	return false
}

func (m *ComplianceParams) GetRequireDocumentVerification() bool {
	if m != nil {
		return m.RequireDocumentVerification
	}
	return false
}

// ComplianceProvider represents an authorized external compliance provider
type ComplianceProvider struct {
	// ProviderID is the unique identifier for this provider
	ProviderId string `protobuf:"bytes,1,opt,name=provider_id,json=providerId,proto3" json:"provider_id" yaml:"provider_id"`
	// Name is the human-readable name of the provider
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name" yaml:"name"`
	// ProviderAddress is the blockchain address authorized to submit checks
	ProviderAddress string `protobuf:"bytes,3,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	// SupportedCheckTypes lists which check types this provider can perform
	SupportedCheckTypes []ComplianceCheckType `protobuf:"varint,4,rep,packed,name=supported_check_types,json=supportedCheckTypes,proto3,enum=virtengine.veid.v1.ComplianceCheckType" json:"supported_check_types" yaml:"supported_check_types"`
	// IsActive indicates if this provider is currently active
	IsActive bool `protobuf:"varint,5,opt,name=is_active,json=isActive,proto3" json:"is_active" yaml:"is_active"`
	// RegisteredAt is when this provider was registered
	RegisteredAt int64 `protobuf:"varint,6,opt,name=registered_at,json=registeredAt,proto3" json:"registered_at" yaml:"registered_at"`
	// LastActiveAt is when this provider last submitted a check
	LastActiveAt int64 `protobuf:"varint,7,opt,name=last_active_at,json=lastActiveAt,proto3" json:"last_active_at" yaml:"last_active_at"`
}

func (m *ComplianceProvider) Reset()         { *m = ComplianceProvider{} }
func (m *ComplianceProvider) String() string { return proto.CompactTextString(m) }
func (*ComplianceProvider) ProtoMessage()    {}
func (*ComplianceProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{4}
}
func (m *ComplianceProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ComplianceProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ComplianceProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ComplianceProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ComplianceProvider.Merge(m, src)
}
func (m *ComplianceProvider) XXX_Size() int {
	return m.Size()
}
func (m *ComplianceProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_ComplianceProvider.DiscardUnknown(m)
}

var xxx_messageInfo_ComplianceProvider proto.InternalMessageInfo

func (m *ComplianceProvider) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *ComplianceProvider) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ComplianceProvider) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *ComplianceProvider) GetSupportedCheckTypes() []ComplianceCheckType {
	if m != nil {
		return m.SupportedCheckTypes
	}
	return nil
}

func (m *ComplianceProvider) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *ComplianceProvider) GetRegisteredAt() int64 {
	if m != nil {
		return m.RegisteredAt
	}
	return 0
}

func (m *ComplianceProvider) GetLastActiveAt() int64 {
	if m != nil {
		return m.LastActiveAt
	}
	return 0
}

// MsgSubmitComplianceCheck submits external compliance check results
type MsgSubmitComplianceCheck struct {
	// ProviderAddress is the address of the compliance provider
	ProviderAddress string `protobuf:"bytes,1,opt,name=provider_address,json=providerAddress,proto3" json:"provider_address" yaml:"provider_address"`
	// TargetAddress is the address being checked
	TargetAddress string `protobuf:"bytes,2,opt,name=target_address,json=targetAddress,proto3" json:"target_address" yaml:"target_address"`
	// CheckResults contains the compliance check results
	CheckResults []ComplianceCheckResult `protobuf:"bytes,3,rep,name=check_results,json=checkResults,proto3" json:"check_results" yaml:"check_results"`
	// ProviderID is the ID of the compliance provider
	ProviderId string `protobuf:"bytes,4,opt,name=provider_id,json=providerId,proto3" json:"provider_id" yaml:"provider_id"`
}

func (m *MsgSubmitComplianceCheck) Reset()         { *m = MsgSubmitComplianceCheck{} }
func (m *MsgSubmitComplianceCheck) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitComplianceCheck) ProtoMessage()    {}
func (*MsgSubmitComplianceCheck) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{5}
}
func (m *MsgSubmitComplianceCheck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitComplianceCheck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitComplianceCheck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitComplianceCheck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitComplianceCheck.Merge(m, src)
}
func (m *MsgSubmitComplianceCheck) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitComplianceCheck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitComplianceCheck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitComplianceCheck proto.InternalMessageInfo

func (m *MsgSubmitComplianceCheck) GetProviderAddress() string {
	if m != nil {
		return m.ProviderAddress
	}
	return ""
}

func (m *MsgSubmitComplianceCheck) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *MsgSubmitComplianceCheck) GetCheckResults() []ComplianceCheckResult {
	if m != nil {
		return m.CheckResults
	}
	return nil
}

func (m *MsgSubmitComplianceCheck) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

// MsgSubmitComplianceCheckResponse is the response for MsgSubmitComplianceCheck
type MsgSubmitComplianceCheckResponse struct {
	// Status is the updated compliance status
	Status ComplianceStatus `protobuf:"varint,1,opt,name=status,proto3,enum=virtengine.veid.v1.ComplianceStatus" json:"status" yaml:"status"`
	// RiskScore is the updated risk score
	RiskScore int32 `protobuf:"varint,2,opt,name=risk_score,json=riskScore,proto3" json:"risk_score" yaml:"risk_score"`
}

func (m *MsgSubmitComplianceCheckResponse) Reset()         { *m = MsgSubmitComplianceCheckResponse{} }
func (m *MsgSubmitComplianceCheckResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitComplianceCheckResponse) ProtoMessage()    {}
func (*MsgSubmitComplianceCheckResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{6}
}
func (m *MsgSubmitComplianceCheckResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitComplianceCheckResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitComplianceCheckResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitComplianceCheckResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitComplianceCheckResponse.Merge(m, src)
}
func (m *MsgSubmitComplianceCheckResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitComplianceCheckResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitComplianceCheckResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitComplianceCheckResponse proto.InternalMessageInfo

func (m *MsgSubmitComplianceCheckResponse) GetStatus() ComplianceStatus {
	if m != nil {
		return m.Status
	}
	return ComplianceStatusUnknown
}

func (m *MsgSubmitComplianceCheckResponse) GetRiskScore() int32 {
	if m != nil {
		return m.RiskScore
	}
	return 0
}

// MsgAttestCompliance allows validators to attest compliance status
type MsgAttestCompliance struct {
	// ValidatorAddress is the address of the attesting validator
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// TargetAddress is the address being attested
	TargetAddress string `protobuf:"bytes,2,opt,name=target_address,json=targetAddress,proto3" json:"target_address" yaml:"target_address"`
	// AttestationType describes what is being attested
	AttestationType string `protobuf:"bytes,3,opt,name=attestation_type,json=attestationType,proto3" json:"attestation_type" yaml:"attestation_type"`
	// ExpiryBlocks is how long until this attestation expires (in blocks)
	ExpiryBlocks int64 `protobuf:"varint,4,opt,name=expiry_blocks,json=expiryBlocks,proto3" json:"expiry_blocks" yaml:"expiry_blocks"`
}

func (m *MsgAttestCompliance) Reset()         { *m = MsgAttestCompliance{} }
func (m *MsgAttestCompliance) String() string { return proto.CompactTextString(m) }
func (*MsgAttestCompliance) ProtoMessage()    {}
func (*MsgAttestCompliance) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{7}
}
func (m *MsgAttestCompliance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttestCompliance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttestCompliance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttestCompliance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttestCompliance.Merge(m, src)
}
func (m *MsgAttestCompliance) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttestCompliance) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttestCompliance.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttestCompliance proto.InternalMessageInfo

func (m *MsgAttestCompliance) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgAttestCompliance) GetTargetAddress() string {
	if m != nil {
		return m.TargetAddress
	}
	return ""
}

func (m *MsgAttestCompliance) GetAttestationType() string {
	if m != nil {
		return m.AttestationType
	}
	return ""
}

func (m *MsgAttestCompliance) GetExpiryBlocks() int64 {
	if m != nil {
		return m.ExpiryBlocks
	}
	return 0
}

// MsgAttestComplianceResponse is the response for MsgAttestCompliance
type MsgAttestComplianceResponse struct {
	// AttestedAt is the block height when attested
	AttestedAt int64 `protobuf:"varint,1,opt,name=attested_at,json=attestedAt,proto3" json:"attested_at" yaml:"attested_at"`
	// ExpiresAt is when the attestation expires
	ExpiresAt int64 `protobuf:"varint,2,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
}

func (m *MsgAttestComplianceResponse) Reset()         { *m = MsgAttestComplianceResponse{} }
func (m *MsgAttestComplianceResponse) String() string { return proto.CompactTextString(m) }
func (*MsgAttestComplianceResponse) ProtoMessage()    {}
func (*MsgAttestComplianceResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{8}
}
func (m *MsgAttestComplianceResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgAttestComplianceResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgAttestComplianceResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgAttestComplianceResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgAttestComplianceResponse.Merge(m, src)
}
func (m *MsgAttestComplianceResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgAttestComplianceResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgAttestComplianceResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgAttestComplianceResponse proto.InternalMessageInfo

func (m *MsgAttestComplianceResponse) GetAttestedAt() int64 {
	if m != nil {
		return m.AttestedAt
	}
	return 0
}

func (m *MsgAttestComplianceResponse) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// MsgUpdateComplianceParams updates compliance configuration (gov only)
type MsgUpdateComplianceParams struct {
	// Authority is the address that is authorized to update params (x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// Params are the new compliance parameters
	Params ComplianceParams `protobuf:"bytes,2,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *MsgUpdateComplianceParams) Reset()         { *m = MsgUpdateComplianceParams{} }
func (m *MsgUpdateComplianceParams) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateComplianceParams) ProtoMessage()    {}
func (*MsgUpdateComplianceParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{9}
}
func (m *MsgUpdateComplianceParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateComplianceParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateComplianceParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateComplianceParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateComplianceParams.Merge(m, src)
}
func (m *MsgUpdateComplianceParams) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateComplianceParams) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateComplianceParams.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateComplianceParams proto.InternalMessageInfo

func (m *MsgUpdateComplianceParams) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgUpdateComplianceParams) GetParams() ComplianceParams {
	if m != nil {
		return m.Params
	}
	return ComplianceParams{}
}

// MsgUpdateComplianceParamsResponse is the response for MsgUpdateComplianceParams
type MsgUpdateComplianceParamsResponse struct {
}

func (m *MsgUpdateComplianceParamsResponse) Reset()         { *m = MsgUpdateComplianceParamsResponse{} }
func (m *MsgUpdateComplianceParamsResponse) String() string { return proto.CompactTextString(m) }
func (*MsgUpdateComplianceParamsResponse) ProtoMessage()    {}
func (*MsgUpdateComplianceParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{10}
}
func (m *MsgUpdateComplianceParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgUpdateComplianceParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgUpdateComplianceParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgUpdateComplianceParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgUpdateComplianceParamsResponse.Merge(m, src)
}
func (m *MsgUpdateComplianceParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgUpdateComplianceParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgUpdateComplianceParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgUpdateComplianceParamsResponse proto.InternalMessageInfo

// MsgRegisterComplianceProvider registers a new compliance provider
type MsgRegisterComplianceProvider struct {
	// Authority is the address that is authorized to register providers (x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// Provider is the compliance provider to register
	Provider ComplianceProvider `protobuf:"bytes,2,opt,name=provider,proto3" json:"provider" yaml:"provider"`
}

func (m *MsgRegisterComplianceProvider) Reset()         { *m = MsgRegisterComplianceProvider{} }
func (m *MsgRegisterComplianceProvider) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterComplianceProvider) ProtoMessage()    {}
func (*MsgRegisterComplianceProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{11}
}
func (m *MsgRegisterComplianceProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterComplianceProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterComplianceProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterComplianceProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterComplianceProvider.Merge(m, src)
}
func (m *MsgRegisterComplianceProvider) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterComplianceProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterComplianceProvider.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterComplianceProvider proto.InternalMessageInfo

func (m *MsgRegisterComplianceProvider) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRegisterComplianceProvider) GetProvider() ComplianceProvider {
	if m != nil {
		return m.Provider
	}
	return ComplianceProvider{}
}

// MsgRegisterComplianceProviderResponse is the response for MsgRegisterComplianceProvider
type MsgRegisterComplianceProviderResponse struct {
	// ProviderID is the registered provider's ID
	ProviderId string `protobuf:"bytes,1,opt,name=provider_id,json=providerId,proto3" json:"provider_id" yaml:"provider_id"`
}

func (m *MsgRegisterComplianceProviderResponse) Reset()         { *m = MsgRegisterComplianceProviderResponse{} }
func (m *MsgRegisterComplianceProviderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterComplianceProviderResponse) ProtoMessage()    {}
func (*MsgRegisterComplianceProviderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{12}
}
func (m *MsgRegisterComplianceProviderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterComplianceProviderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterComplianceProviderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterComplianceProviderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterComplianceProviderResponse.Merge(m, src)
}
func (m *MsgRegisterComplianceProviderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterComplianceProviderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterComplianceProviderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterComplianceProviderResponse proto.InternalMessageInfo

func (m *MsgRegisterComplianceProviderResponse) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

// MsgDeactivateComplianceProvider deactivates a compliance provider
type MsgDeactivateComplianceProvider struct {
	// Authority is the address that is authorized to deactivate providers (x/gov)
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// ProviderID is the ID of the provider to deactivate
	ProviderId string `protobuf:"bytes,2,opt,name=provider_id,json=providerId,proto3" json:"provider_id" yaml:"provider_id"`
	// Reason is the reason for deactivation
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *MsgDeactivateComplianceProvider) Reset()         { *m = MsgDeactivateComplianceProvider{} }
func (m *MsgDeactivateComplianceProvider) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateComplianceProvider) ProtoMessage()    {}
func (*MsgDeactivateComplianceProvider) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{13}
}
func (m *MsgDeactivateComplianceProvider) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateComplianceProvider) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateComplianceProvider.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateComplianceProvider) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateComplianceProvider.Merge(m, src)
}
func (m *MsgDeactivateComplianceProvider) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateComplianceProvider) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateComplianceProvider.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateComplianceProvider proto.InternalMessageInfo

func (m *MsgDeactivateComplianceProvider) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgDeactivateComplianceProvider) GetProviderId() string {
	if m != nil {
		return m.ProviderId
	}
	return ""
}

func (m *MsgDeactivateComplianceProvider) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgDeactivateComplianceProviderResponse is the response for MsgDeactivateComplianceProvider
type MsgDeactivateComplianceProviderResponse struct {
}

func (m *MsgDeactivateComplianceProviderResponse) Reset() {
	*m = MsgDeactivateComplianceProviderResponse{}
}
func (m *MsgDeactivateComplianceProviderResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeactivateComplianceProviderResponse) ProtoMessage()    {}
func (*MsgDeactivateComplianceProviderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_efc9d803464b624a, []int{14}
}
func (m *MsgDeactivateComplianceProviderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeactivateComplianceProviderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeactivateComplianceProviderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeactivateComplianceProviderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeactivateComplianceProviderResponse.Merge(m, src)
}
func (m *MsgDeactivateComplianceProviderResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeactivateComplianceProviderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeactivateComplianceProviderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeactivateComplianceProviderResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("virtengine.veid.v1.ComplianceStatus", ComplianceStatus_name, ComplianceStatus_value)
	proto.RegisterEnum("virtengine.veid.v1.ComplianceCheckType", ComplianceCheckType_name, ComplianceCheckType_value)
	proto.RegisterType((*ComplianceCheckResult)(nil), "virtengine.veid.v1.ComplianceCheckResult")
	proto.RegisterType((*ComplianceAttestation)(nil), "virtengine.veid.v1.ComplianceAttestation")
	proto.RegisterType((*ComplianceRecord)(nil), "virtengine.veid.v1.ComplianceRecord")
	proto.RegisterType((*ComplianceParams)(nil), "virtengine.veid.v1.ComplianceParams")
	proto.RegisterType((*ComplianceProvider)(nil), "virtengine.veid.v1.ComplianceProvider")
	proto.RegisterType((*MsgSubmitComplianceCheck)(nil), "virtengine.veid.v1.MsgSubmitComplianceCheck")
	proto.RegisterType((*MsgSubmitComplianceCheckResponse)(nil), "virtengine.veid.v1.MsgSubmitComplianceCheckResponse")
	proto.RegisterType((*MsgAttestCompliance)(nil), "virtengine.veid.v1.MsgAttestCompliance")
	proto.RegisterType((*MsgAttestComplianceResponse)(nil), "virtengine.veid.v1.MsgAttestComplianceResponse")
	proto.RegisterType((*MsgUpdateComplianceParams)(nil), "virtengine.veid.v1.MsgUpdateComplianceParams")
	proto.RegisterType((*MsgUpdateComplianceParamsResponse)(nil), "virtengine.veid.v1.MsgUpdateComplianceParamsResponse")
	proto.RegisterType((*MsgRegisterComplianceProvider)(nil), "virtengine.veid.v1.MsgRegisterComplianceProvider")
	proto.RegisterType((*MsgRegisterComplianceProviderResponse)(nil), "virtengine.veid.v1.MsgRegisterComplianceProviderResponse")
	proto.RegisterType((*MsgDeactivateComplianceProvider)(nil), "virtengine.veid.v1.MsgDeactivateComplianceProvider")
	proto.RegisterType((*MsgDeactivateComplianceProviderResponse)(nil), "virtengine.veid.v1.MsgDeactivateComplianceProviderResponse")
}

func init() {
	proto.RegisterFile("virtengine/veid/v1/compliance.proto", fileDescriptor_efc9d803464b624a)
}

var fileDescriptor_efc9d803464b624a = []byte{
	// 2255 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcf, 0x6f, 0x1b, 0xc7,
	0xf5, 0x17, 0x45, 0x4a, 0x96, 0x46, 0xbf, 0xa8, 0x95, 0x62, 0x53, 0x54, 0xa4, 0x61, 0xc6, 0x49,
	0x2c, 0xdb, 0xb0, 0xf4, 0xb5, 0xfd, 0x0d, 0x0c, 0x2b, 0x45, 0x80, 0x25, 0x45, 0xcb, 0xac, 0x25,
	0x4a, 0x1d, 0x4a, 0x76, 0x1b, 0x20, 0x58, 0xac, 0x76, 0x27, 0xd4, 0x46, 0xe4, 0x2e, 0xb3, 0xb3,
	0x54, 0xeb, 0x02, 0x01, 0x8a, 0x9e, 0x0a, 0x01, 0x05, 0x7a, 0x2a, 0x8a, 0xa2, 0x02, 0x02, 0xf4,
	0xd4, 0x5b, 0x0e, 0xf9, 0x07, 0x7a, 0xcb, 0x31, 0xe8, 0xa9, 0xed, 0x61, 0x51, 0xd8, 0x28, 0x12,
	0xf0, 0xc8, 0x3f, 0xa0, 0x2d, 0x76, 0x66, 0x96, 0xb3, 0x5c, 0x2e, 0xed, 0x54, 0xb0, 0x9b, 0x8b,
	0xc0, 0xf9, 0x7c, 0xe6, 0xbd, 0x99, 0x79, 0xbf, 0xe6, 0xcd, 0x0a, 0x5c, 0x3d, 0xb5, 0x5c, 0x8f,
	0xd8, 0x75, 0xcb, 0x26, 0x1b, 0xa7, 0xc4, 0x32, 0x37, 0x4e, 0x6f, 0x6f, 0x18, 0x4e, 0xb3, 0xd5,
	0xb0, 0x74, 0xdb, 0x20, 0xeb, 0x2d, 0xd7, 0xf1, 0x1c, 0x45, 0x91, 0x93, 0xd6, 0x83, 0x49, 0xeb,
	0xa7, 0xb7, 0xf3, 0x8b, 0x75, 0xa7, 0xee, 0x30, 0x7a, 0x23, 0xf8, 0xc5, 0x67, 0xe6, 0x97, 0x0c,
	0x87, 0x36, 0x1d, 0xaa, 0x71, 0x82, 0x0f, 0x04, 0x75, 0x85, 0x8f, 0x36, 0x9a, 0xb4, 0x1e, 0x2c,
	0xd2, 0xa4, 0x75, 0x41, 0xcc, 0xeb, 0x4d, 0xcb, 0x76, 0x36, 0xd8, 0x5f, 0x0e, 0xa1, 0xdf, 0x65,
	0xc0, 0x1b, 0xa5, 0xde, 0x2e, 0x4a, 0xc7, 0xc4, 0x38, 0xc1, 0x84, 0xb6, 0x1b, 0x9e, 0x72, 0x02,
	0x80, 0x11, 0x0c, 0x35, 0xef, 0x69, 0x8b, 0xe4, 0x52, 0x85, 0xd4, 0xda, 0xec, 0x9d, 0x6b, 0xeb,
	0x83, 0xfb, 0x5b, 0x8f, 0x89, 0x1f, 0x3c, 0x6d, 0x91, 0xe2, 0xd5, 0x8e, 0x0f, 0x23, 0xe2, 0x5d,
	0x1f, 0xce, 0x3f, 0xd5, 0x9b, 0x8d, 0x4d, 0x24, 0x31, 0x84, 0x27, 0x8d, 0x70, 0xbe, 0x72, 0x17,
	0x8c, 0xb7, 0x74, 0x4a, 0x89, 0x99, 0x1b, 0x2d, 0xa4, 0xd6, 0x26, 0x8a, 0xcb, 0x1d, 0x1f, 0x0a,
	0xa4, 0xeb, 0xc3, 0x19, 0x2e, 0xcb, 0xc7, 0x08, 0x0b, 0x42, 0xb9, 0x07, 0x2e, 0x99, 0xc4, 0xd3,
	0xad, 0x06, 0xcd, 0xa5, 0x0b, 0xa9, 0xb5, 0xc9, 0xe2, 0x4a, 0xc7, 0x87, 0x21, 0xd4, 0xf5, 0xe1,
	0x2c, 0x17, 0x13, 0x00, 0xc2, 0x21, 0xa5, 0x3c, 0x00, 0x53, 0x4d, 0xdd, 0x33, 0x8e, 0x35, 0x6a,
	0x38, 0x2e, 0xc9, 0x65, 0x0a, 0xa9, 0xb5, 0xb1, 0xe2, 0x3b, 0x1d, 0x1f, 0x46, 0xe1, 0xae, 0x0f,
	0x15, 0xae, 0x20, 0x02, 0x22, 0x0c, 0xd8, 0xa8, 0x16, 0x0c, 0x94, 0xa2, 0x30, 0x11, 0x31, 0x35,
	0xdd, 0xcb, 0x8d, 0x15, 0x52, 0x6b, 0xe9, 0xc8, 0xc9, 0x19, 0x1a, 0x3b, 0x39, 0xc3, 0xc2, 0x93,
	0x13, 0x53, 0xf5, 0x82, 0xbd, 0xb4, 0x5c, 0xe7, 0xd4, 0x32, 0x89, 0xab, 0x59, 0x66, 0x6e, 0x9c,
	0x1d, 0x84, 0xed, 0x25, 0x02, 0xcb, 0xbd, 0x44, 0x40, 0x84, 0x41, 0x38, 0xaa, 0x98, 0xca, 0x0f,
	0xc1, 0xb4, 0x4b, 0x3e, 0x26, 0x2e, 0xb1, 0x0d, 0x12, 0x28, 0xba, 0xc4, 0x14, 0x5d, 0xeb, 0xf8,
	0xb0, 0x0f, 0xef, 0xfa, 0x70, 0x81, 0x6b, 0x8a, 0xa2, 0x08, 0x4f, 0xf5, 0x86, 0x15, 0x73, 0x33,
	0xf3, 0xed, 0xe7, 0x30, 0x85, 0xfe, 0x96, 0x8e, 0x86, 0x86, 0xea, 0x79, 0x84, 0x7a, 0xba, 0x67,
	0x39, 0xb6, 0x72, 0x0a, 0xe6, 0x4f, 0xf5, 0x86, 0x65, 0xea, 0x9e, 0xe3, 0x6a, 0xba, 0x69, 0xba,
	0x84, 0x52, 0x16, 0x21, 0x93, 0xc5, 0x4a, 0xc7, 0x87, 0x83, 0x64, 0xd7, 0x87, 0x39, 0xbe, 0xea,
	0x00, 0x85, 0xfe, 0xf2, 0xe5, 0xad, 0x45, 0x11, 0xbe, 0x2a, 0x87, 0x6a, 0x9e, 0x6b, 0xd9, 0x75,
	0x9c, 0xed, 0xcd, 0x15, 0x78, 0x60, 0x2b, 0x9d, 0x6d, 0x83, 0x1b, 0x7c, 0x94, 0x19, 0x9c, 0xd9,
	0x2a, 0x02, 0x4b, 0x5b, 0x45, 0x40, 0x84, 0x41, 0x38, 0x52, 0xbd, 0xc0, 0x6f, 0xe4, 0x67, 0x2d,
	0xcb, 0x25, 0x34, 0x50, 0x93, 0x96, 0x7e, 0x93, 0xa8, 0xf4, 0x9b, 0xc4, 0x10, 0x9e, 0x14, 0x03,
	0xd5, 0x53, 0x3e, 0x04, 0x59, 0x5d, 0x9a, 0x84, 0x27, 0x49, 0x86, 0x99, 0x60, 0xa3, 0xe3, 0xc3,
	0x01, 0xae, 0xeb, 0xc3, 0x2b, 0xd1, 0x5d, 0x49, 0x06, 0xe1, 0xb9, 0x08, 0xc4, 0xb2, 0x21, 0xa6,
	0xfb, 0x58, 0xa7, 0xc7, 0x2c, 0xba, 0x12, 0x74, 0x07, 0x5c, 0xb2, 0xee, 0x80, 0xe9, 0xd7, 0xfd,
	0x50, 0xa7, 0xc7, 0xc2, 0xb7, 0x7f, 0xbf, 0x04, 0xb2, 0xd2, 0xb7, 0x98, 0x18, 0x8e, 0x6b, 0x2a,
	0x36, 0x98, 0xd3, 0x0d, 0xc3, 0x69, 0xdb, 0x5e, 0xcc, 0xa9, 0xe5, 0x8e, 0x0f, 0xe3, 0x54, 0xd7,
	0x87, 0x97, 0xc5, 0xa2, 0xfd, 0xc4, 0x70, 0x87, 0xce, 0x8a, 0x99, 0xa1, 0x3b, 0x7f, 0x02, 0xc6,
	0x83, 0x9d, 0xb5, 0x29, 0xf3, 0xe4, 0xec, 0x9d, 0xb7, 0x5f, 0x5c, 0x5d, 0x6a, 0x6c, 0x2e, 0x2f,
	0x0d, 0x5c, 0x4e, 0x96, 0x06, 0x3e, 0x46, 0x58, 0x10, 0xca, 0x67, 0x60, 0x86, 0x57, 0x1a, 0x97,
	0x15, 0xb3, 0xa0, 0x40, 0xa4, 0xd7, 0xa6, 0xee, 0x5c, 0xff, 0x0e, 0xf5, 0x8b, 0x97, 0xbf, 0xe2,
	0xad, 0xaf, 0x7c, 0x38, 0xd2, 0xf1, 0x61, 0xbf, 0x9e, 0xae, 0x0f, 0x17, 0xa3, 0x85, 0x4c, 0xc0,
	0x08, 0x4f, 0x1b, 0x52, 0x96, 0x2a, 0x87, 0x60, 0xae, 0xa1, 0x53, 0x4f, 0x8b, 0x54, 0x87, 0x0c,
	0x8b, 0xb2, 0x5b, 0x81, 0x25, 0x63, 0x94, 0xb4, 0x64, 0x8c, 0x40, 0x78, 0x26, 0x40, 0x4a, 0xbd,
	0x5a, 0xd1, 0x1f, 0xb7, 0x63, 0x17, 0x8a, 0xdb, 0x22, 0x00, 0xae, 0x45, 0x4f, 0x44, 0xe9, 0x1b,
	0x67, 0xa5, 0x8f, 0xe9, 0x90, 0xa8, 0xd4, 0x21, 0x31, 0x84, 0x27, 0x83, 0x01, 0xaf, 0x7b, 0x47,
	0x40, 0x71, 0x09, 0xf5, 0x5c, 0xcb, 0x08, 0xb2, 0xcb, 0x25, 0x75, 0xcb, 0xb1, 0x69, 0xee, 0x52,
	0x21, 0xbd, 0x36, 0x59, 0xbc, 0xdb, 0xf1, 0x61, 0x02, 0xdb, 0xf5, 0xe1, 0x52, 0x58, 0x77, 0xe2,
	0x1c, 0xc2, 0xf3, 0x12, 0xc4, 0x1c, 0x53, 0x7e, 0x0e, 0xa6, 0x23, 0xa1, 0x4b, 0x73, 0x13, 0xdf,
	0xc5, 0x81, 0x91, 0x22, 0x55, 0xbc, 0x29, 0x1c, 0xd8, 0xa7, 0x46, 0x96, 0xbf, 0x28, 0x8a, 0x70,
	0xdf, 0x24, 0x56, 0xd7, 0x5d, 0xa2, 0x8b, 0x32, 0x33, 0x19, 0xa9, 0xeb, 0x3d, 0x34, 0x52, 0xd7,
	0x7b, 0x58, 0x50, 0xd7, 0xf9, 0x80, 0xdb, 0xb9, 0xdd, 0x32, 0x43, 0x1d, 0x40, 0xea, 0x90, 0xa8,
	0xd4, 0x21, 0x31, 0x84, 0x27, 0xc5, 0x40, 0xf5, 0x94, 0x0d, 0x30, 0x66, 0x3b, 0x1e, 0xa1, 0xb9,
	0x29, 0x96, 0x86, 0x4b, 0x1d, 0x1f, 0x72, 0xa0, 0xeb, 0xc3, 0x69, 0x2e, 0xc9, 0x86, 0x08, 0x73,
	0x58, 0x24, 0xf7, 0xef, 0xfb, 0x92, 0x7b, 0x5f, 0x77, 0xf5, 0x26, 0x55, 0x3e, 0x05, 0x97, 0x5d,
	0xf2, 0x69, 0xdb, 0x72, 0x89, 0x46, 0x75, 0xdb, 0x60, 0x25, 0x82, 0x85, 0x1a, 0xcb, 0xf1, 0x89,
	0xe2, 0xfb, 0x1d, 0x1f, 0x0e, 0x99, 0xd1, 0xf5, 0xe1, 0x4a, 0xe8, 0xbb, 0x24, 0x1e, 0xe1, 0x45,
	0x41, 0xd4, 0x04, 0xce, 0x42, 0x56, 0xf9, 0x08, 0xcc, 0x87, 0x02, 0x2d, 0xd2, 0x12, 0xab, 0xf1,
	0xfb, 0xfd, 0x76, 0x70, 0x4d, 0x0c, 0x90, 0xf2, 0x9a, 0x18, 0xa0, 0x10, 0x9e, 0x13, 0xd8, 0x3e,
	0x69, 0x71, 0xf5, 0x04, 0x2c, 0xf0, 0x24, 0x64, 0xc1, 0xfd, 0x54, 0x3b, 0x6a, 0x38, 0xc6, 0x09,
	0x15, 0xe5, 0xfc, 0xbd, 0x8e, 0x0f, 0x93, 0xe8, 0xae, 0x0f, 0xf3, 0xd1, 0x04, 0xee, 0x23, 0x11,
	0x9e, 0x67, 0x68, 0x99, 0x81, 0x45, 0x86, 0x29, 0x16, 0x58, 0x94, 0x69, 0xa0, 0x79, 0xc7, 0x2e,
	0xa1, 0xc7, 0x4e, 0xc3, 0x14, 0x5d, 0xc3, 0xbd, 0x8e, 0x0f, 0x13, 0xf9, 0xae, 0x0f, 0x97, 0xe3,
	0x49, 0x24, 0x59, 0x84, 0x95, 0x5e, 0x3a, 0x1d, 0x84, 0xa0, 0xf2, 0x09, 0x58, 0x8c, 0x64, 0x07,
	0xab, 0x95, 0xae, 0x45, 0x68, 0x6e, 0x8c, 0x65, 0x16, 0x5f, 0x2a, 0x81, 0x8f, 0x2c, 0x95, 0xc0,
	0x22, 0xbc, 0x20, 0xe1, 0x52, 0x88, 0x2a, 0x9f, 0x81, 0xa5, 0xa6, 0x65, 0x6b, 0xd1, 0xb8, 0xd7,
	0x84, 0x85, 0x4d, 0x51, 0x16, 0xd4, 0x8e, 0x0f, 0x87, 0x4f, 0xea, 0xfa, 0xb0, 0x20, 0xfa, 0xa3,
	0x61, 0x53, 0x10, 0xbe, 0xd2, 0xb4, 0xec, 0x48, 0x52, 0x52, 0x2c, 0x18, 0x45, 0x07, 0x0a, 0xb1,
	0xf5, 0xa3, 0x06, 0xd1, 0xf4, 0xb6, 0xe7, 0x08, 0x37, 0xb0, 0xa6, 0x65, 0x82, 0x97, 0x90, 0x41,
	0x56, 0x96, 0x90, 0x41, 0x0e, 0xe1, 0x2c, 0x07, 0xd5, 0xb6, 0xe7, 0x70, 0xf7, 0x29, 0xbf, 0x4e,
	0x81, 0x95, 0x30, 0x8e, 0x4c, 0xc7, 0x68, 0x37, 0x89, 0xed, 0x69, 0xa7, 0xc4, 0xb5, 0x3e, 0xb6,
	0x0c, 0xb6, 0x9b, 0xdc, 0x04, 0x5b, 0x2e, 0x68, 0x59, 0x5e, 0x3c, 0xb1, 0xeb, 0xc3, 0xb7, 0xfb,
	0xe3, 0x32, 0x71, 0x1a, 0xc2, 0xcb, 0x82, 0xdf, 0x12, 0xf4, 0xe3, 0x08, 0x2b, 0x92, 0xf3, 0xdf,
	0x19, 0xa0, 0x44, 0x92, 0x53, 0x34, 0x70, 0xf1, 0x36, 0x30, 0x75, 0xd1, 0x36, 0xf0, 0x26, 0xc8,
	0xd8, 0x7a, 0x93, 0xb0, 0x34, 0x9b, 0x2c, 0x5e, 0xe9, 0xf8, 0x90, 0x8d, 0xbb, 0x3e, 0x9c, 0x12,
	0x05, 0x43, 0x6f, 0x12, 0x84, 0x19, 0xa8, 0xb8, 0x20, 0xdb, 0x53, 0x14, 0xde, 0xf8, 0xbc, 0x93,
	0xde, 0x0e, 0xfa, 0x8c, 0x38, 0x27, 0xfb, 0x8c, 0x38, 0x33, 0xfc, 0xce, 0x9f, 0x0b, 0xa7, 0x86,
	0x97, 0xfe, 0x6f, 0x53, 0xe0, 0x0d, 0xda, 0x6e, 0xb5, 0x1c, 0x97, 0x45, 0x69, 0xef, 0x39, 0x40,
	0x73, 0x99, 0x42, 0xfa, 0xbf, 0x79, 0x62, 0xdc, 0xef, 0xf8, 0x30, 0x59, 0x53, 0xd7, 0x87, 0x6f,
	0x8a, 0xb6, 0x20, 0x89, 0x46, 0x78, 0xa1, 0x87, 0xf7, 0xd4, 0x51, 0xe5, 0x03, 0x30, 0x69, 0x51,
	0x4d, 0x37, 0x3c, 0xeb, 0x94, 0xb0, 0xbb, 0x75, 0xa2, 0xf8, 0x56, 0xc7, 0x87, 0x12, 0xec, 0xfa,
	0x30, 0xcb, 0xd5, 0xf6, 0x20, 0x84, 0x27, 0x2c, 0xaa, 0xb2, 0x9f, 0x4a, 0x15, 0xcc, 0x04, 0xf7,
	0x19, 0xf5, 0x88, 0xcb, 0x6b, 0xfe, 0x38, 0x2b, 0x44, 0xd7, 0x83, 0x1e, 0xa2, 0x8f, 0x90, 0x3d,
	0x44, 0x1f, 0x8c, 0xf0, 0xb4, 0x1c, 0xab, 0x9e, 0xf2, 0x23, 0x30, 0xcb, 0xfa, 0x01, 0xbe, 0x52,
	0xa0, 0xf0, 0x12, 0x53, 0x78, 0xb3, 0xe3, 0xc3, 0x18, 0xd3, 0xf5, 0xe1, 0x1b, 0x91, 0x0e, 0xa2,
	0x87, 0x23, 0x3c, 0x1d, 0x00, 0x7c, 0x83, 0xaa, 0x27, 0x22, 0xf0, 0x5f, 0x69, 0x90, 0xdb, 0xa5,
	0xf5, 0x5a, 0xfb, 0xa8, 0x69, 0x79, 0x31, 0xcb, 0x26, 0x86, 0x44, 0xea, 0x35, 0x87, 0xc4, 0x27,
	0x60, 0xd6, 0xd3, 0xdd, 0x3a, 0x91, 0x6d, 0x27, 0x8f, 0xde, 0x52, 0x70, 0xd2, 0x7e, 0x46, 0x9e,
	0xb4, 0x1f, 0x1f, 0xbe, 0xda, 0x0c, 0x9f, 0x18, 0xae, 0xf5, 0x3d, 0x37, 0x86, 0xb1, 0x34, 0xcf,
	0x5c, 0x30, 0xcd, 0x37, 0xdf, 0xff, 0xf6, 0x73, 0x38, 0xf2, 0xcb, 0x6f, 0xbe, 0xb8, 0x31, 0xe0,
	0x91, 0xb3, 0x6f, 0xbe, 0xb8, 0xb1, 0xc2, 0xbe, 0x2f, 0x0c, 0xf3, 0x31, 0xfa, 0x73, 0x0a, 0x14,
	0x86, 0x91, 0x98, 0xd0, 0x96, 0x63, 0x53, 0x12, 0x69, 0xce, 0x53, 0xaf, 0xba, 0x39, 0xef, 0x6f,
	0x41, 0x47, 0x2f, 0xd2, 0x82, 0x22, 0x3f, 0x0d, 0x16, 0x76, 0x69, 0x9d, 0xdf, 0x2d, 0x72, 0x1b,
	0xdf, 0xdb, 0xd3, 0xf4, 0x7f, 0x19, 0xc3, 0x49, 0x4f, 0xcf, 0xf4, 0x2b, 0x7a, 0x7a, 0x56, 0xc1,
	0x4c, 0x7f, 0x3b, 0x95, 0x91, 0x55, 0x2c, 0xde, 0x48, 0x2d, 0x46, 0x1e, 0x1a, 0xb2, 0x85, 0x9a,
	0x26, 0x91, 0xee, 0x69, 0xf3, 0x5e, 0x18, 0xa8, 0x83, 0x96, 0x0f, 0x22, 0x35, 0x17, 0x46, 0x6a,
	0xdc, 0x91, 0xe8, 0x4f, 0x29, 0xb0, 0x9c, 0x80, 0xf7, 0xe2, 0x33, 0xf6, 0x2d, 0x20, 0xf5, 0x6a,
	0xbe, 0x05, 0x8c, 0x5e, 0xe4, 0x4d, 0x85, 0xce, 0x46, 0xc1, 0xd2, 0x2e, 0xad, 0x1f, 0xb2, 0xc6,
	0x7d, 0xa0, 0xf3, 0x7e, 0x02, 0x26, 0xf5, 0xb6, 0x77, 0xec, 0xb8, 0x96, 0xf7, 0x54, 0x84, 0x62,
	0x70, 0x77, 0x49, 0x50, 0x5e, 0x2c, 0x3d, 0x68, 0x78, 0x2c, 0x48, 0x31, 0xe5, 0x23, 0x30, 0xde,
	0x62, 0x4b, 0xb0, 0x6d, 0x4f, 0xbd, 0x2c, 0x45, 0xf9, 0x76, 0x8a, 0x50, 0xd4, 0x2f, 0x21, 0x1b,
	0xfd, 0xbc, 0x16, 0x8c, 0xd9, 0xe7, 0xb5, 0xe0, 0xc7, 0xe6, 0x7b, 0xa1, 0xeb, 0xe4, 0x92, 0x81,
	0xcb, 0x56, 0x43, 0x97, 0x25, 0x1f, 0x17, 0x5d, 0x05, 0x6f, 0x0d, 0x25, 0x43, 0xef, 0xa1, 0x3f,
	0x8c, 0x82, 0x95, 0x5d, 0x5a, 0xc7, 0xe2, 0xc2, 0x4b, 0x68, 0x88, 0x5e, 0x9b, 0xd5, 0xea, 0x60,
	0x22, 0xac, 0x99, 0xc2, 0x6e, 0xef, 0xbe, 0xc4, 0x6e, 0x62, 0x76, 0xf1, 0xaa, 0xb0, 0x5c, 0x4f,
	0xbe, 0xeb, 0xc3, 0xb9, 0xfe, 0x42, 0x8d, 0x70, 0x8f, 0xdc, 0xbc, 0x9f, 0x6c, 0x3f, 0x14, 0xda,
	0x6f, 0xf8, 0xe1, 0x91, 0x03, 0xde, 0x79, 0xe1, 0x84, 0x68, 0x16, 0xbc, 0x8a, 0xb6, 0x11, 0x7d,
	0x39, 0x0a, 0xe0, 0x2e, 0xad, 0x6f, 0x11, 0xd6, 0x3b, 0xf4, 0x7b, 0xee, 0xb5, 0x7b, 0x24, 0x76,
	0x88, 0xd1, 0x8b, 0xf6, 0xbe, 0x77, 0xc1, 0xb8, 0x4b, 0x74, 0xea, 0xd8, 0xa2, 0x1a, 0xb2, 0xcb,
	0x88, 0x23, 0x32, 0xca, 0xf9, 0x18, 0x61, 0x41, 0xc8, 0x9b, 0xb4, 0xdf, 0x4b, 0x6f, 0x87, 0x5e,
	0x7a, 0x91, 0x49, 0xd0, 0x75, 0x70, 0xed, 0x25, 0x53, 0x42, 0x4f, 0xdd, 0xf8, 0x45, 0x3a, 0xfa,
	0x28, 0xe7, 0xd7, 0xa5, 0xb2, 0x09, 0x96, 0x4a, 0x7b, 0xbb, 0xfb, 0x3b, 0x15, 0xb5, 0x5a, 0x2a,
	0x6b, 0xb5, 0x03, 0xf5, 0xe0, 0xb0, 0xa6, 0x1d, 0x56, 0x1f, 0x55, 0xf7, 0x9e, 0x54, 0xb3, 0x23,
	0xf9, 0xe5, 0xb3, 0xf3, 0xc2, 0x95, 0xb8, 0xd0, 0xa1, 0x7d, 0x62, 0x3b, 0x3f, 0xb5, 0x93, 0x65,
	0xf7, 0xcb, 0xd5, 0xad, 0x4a, 0x75, 0x3b, 0x9b, 0x4a, 0x96, 0xdd, 0x27, 0xb6, 0x69, 0xd9, 0xf5,
	0x64, 0xd9, 0xd2, 0x4e, 0x59, 0xc5, 0xe5, 0xad, 0xec, 0x68, 0xb2, 0x6c, 0xa9, 0x41, 0xf4, 0xe0,
	0xe5, 0x96, 0x28, 0xfb, 0x60, 0x47, 0xdd, 0xde, 0x2e, 0x6f, 0x65, 0xd3, 0xc9, 0xb2, 0x0f, 0x1a,
	0x7a, 0xbd, 0x3e, 0x4c, 0xb6, 0xb8, 0xb3, 0x57, 0x7a, 0x54, 0xde, 0xca, 0x66, 0x92, 0x65, 0xd9,
	0x45, 0x32, 0x4c, 0xb6, 0xfc, 0xe3, 0xfd, 0x4a, 0xb0, 0xe7, 0xb1, 0x64, 0x59, 0xf6, 0x12, 0x24,
	0x66, 0x3e, 0xf3, 0xab, 0x3f, 0xae, 0x8e, 0xdc, 0xf8, 0x67, 0x1a, 0x2c, 0x24, 0xbc, 0x24, 0x94,
	0x12, 0x58, 0x8d, 0x68, 0x2e, 0x3d, 0x2c, 0x97, 0x1e, 0x69, 0x35, 0xb5, 0x5a, 0x3a, 0xa8, 0xec,
	0x55, 0xb5, 0x9d, 0x4a, 0xed, 0x20, 0x3b, 0x92, 0x87, 0x67, 0xe7, 0x85, 0xe5, 0x98, 0x70, 0xf8,
	0xb5, 0x63, 0xc7, 0xa2, 0x9e, 0xf2, 0x7f, 0x60, 0x71, 0x40, 0xc9, 0x7e, 0x79, 0x3f, 0x9b, 0xca,
	0x5f, 0x3e, 0x3b, 0x2f, 0x28, 0x31, 0xd1, 0xfd, 0xf2, 0x7e, 0xe2, 0xb2, 0xea, 0xd6, 0xe3, 0x32,
	0xae, 0x95, 0xb5, 0xdd, 0xf2, 0x56, 0x45, 0xcd, 0x8e, 0x26, 0x2e, 0xab, 0x9a, 0xa7, 0xc4, 0xa5,
	0x64, 0x97, 0x98, 0x96, 0xae, 0x7c, 0x00, 0x96, 0x07, 0x94, 0x6c, 0x97, 0xf7, 0xb6, 0xb1, 0xba,
	0xff, 0xb0, 0x52, 0xca, 0xa6, 0xf3, 0x2b, 0x67, 0xe7, 0x85, 0xa5, 0x98, 0x86, 0x6d, 0xe2, 0xd4,
	0x5d, 0xbd, 0x75, 0x6c, 0x19, 0xca, 0x0f, 0x40, 0x7e, 0x40, 0xfe, 0x89, 0x7a, 0x50, 0x7a, 0xc8,
	0xce, 0x9d, 0xc9, 0xbf, 0x79, 0x76, 0x5e, 0xc8, 0xc5, 0xc4, 0x9f, 0xe8, 0x9e, 0x71, 0xdc, 0x08,
	0x0e, 0x5d, 0x03, 0xef, 0x0e, 0x48, 0x6f, 0xed, 0x95, 0x0e, 0x77, 0xcb, 0xd5, 0x03, 0xed, 0x71,
	0x19, 0x57, 0x1e, 0x54, 0x4a, 0x6a, 0x60, 0xc6, 0xec, 0x58, 0xfe, 0xda, 0xd9, 0x79, 0xe1, 0x6a,
	0x4c, 0x53, 0xd2, 0x3b, 0x59, 0xb9, 0xdf, 0xe7, 0x68, 0x61, 0x97, 0xdd, 0x1d, 0x0d, 0x57, 0x6a,
	0x8f, 0xb2, 0xe3, 0xf9, 0xfc, 0xd9, 0x79, 0xe1, 0x72, 0xdc, 0x24, 0xbb, 0x3b, 0xd8, 0xa2, 0x27,
	0xdc, 0xcf, 0xc5, 0xea, 0x57, 0xcf, 0x56, 0x53, 0x5f, 0x3f, 0x5b, 0x4d, 0xfd, 0xe3, 0xd9, 0x6a,
	0xea, 0x37, 0xcf, 0x57, 0x47, 0xbe, 0x7e, 0xbe, 0x3a, 0xf2, 0xd7, 0xe7, 0xab, 0x23, 0x1f, 0xfe,
	0x7f, 0xdd, 0xf2, 0x8e, 0xdb, 0x47, 0xeb, 0x86, 0xd3, 0xdc, 0x88, 0xfe, 0x3b, 0x4e, 0xfe, 0xa4,
	0xe6, 0xc9, 0x46, 0xdd, 0xd9, 0xb0, 0x1d, 0xb3, 0xf7, 0x5f, 0xba, 0xa3, 0x71, 0xf6, 0xaf, 0xb2,
	0xbb, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0x1f, 0x27, 0x97, 0xb9, 0xc2, 0x1b, 0x00, 0x00,
}

func (this *ComplianceCheckResult) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplianceCheckResult)
	if !ok {
		that2, ok := that.(ComplianceCheckResult)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.CheckType != that1.CheckType {
		return false
	}
	if this.Passed != that1.Passed {
		return false
	}
	if this.Details != that1.Details {
		return false
	}
	if this.MatchScore != that1.MatchScore {
		return false
	}
	if this.CheckedAt != that1.CheckedAt {
		return false
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.ReferenceId != that1.ReferenceId {
		return false
	}
	return true
}
func (this *ComplianceAttestation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplianceAttestation)
	if !ok {
		that2, ok := that.(ComplianceAttestation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if this.AttestedAt != that1.AttestedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	if this.AttestationType != that1.AttestationType {
		return false
	}
	if this.AttestationHash != that1.AttestationHash {
		return false
	}
	return true
}
func (this *ComplianceRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplianceRecord)
	if !ok {
		that2, ok := that.(ComplianceRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if len(this.CheckResults) != len(that1.CheckResults) {
		return false
	}
	for i := range this.CheckResults {
		if !this.CheckResults[i].Equal(&that1.CheckResults[i]) {
			return false
		}
	}
	if this.LastCheckedAt != that1.LastCheckedAt {
		return false
	}
	if this.ExpiresAt != that1.ExpiresAt {
		return false
	}
	if this.RiskScore != that1.RiskScore {
		return false
	}
	if len(this.RestrictedRegions) != len(that1.RestrictedRegions) {
		return false
	}
	for i := range this.RestrictedRegions {
		if this.RestrictedRegions[i] != that1.RestrictedRegions[i] {
			return false
		}
	}
	if len(this.Attestations) != len(that1.Attestations) {
		return false
	}
	for i := range this.Attestations {
		if !this.Attestations[i].Equal(&that1.Attestations[i]) {
			return false
		}
	}
	if this.CreatedAt != that1.CreatedAt {
		return false
	}
	if this.UpdatedAt != that1.UpdatedAt {
		return false
	}
	if this.Notes != that1.Notes {
		return false
	}
	return true
}
func (this *ComplianceParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplianceParams)
	if !ok {
		that2, ok := that.(ComplianceParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.RequireSanctionCheck != that1.RequireSanctionCheck {
		return false
	}
	if this.RequirePepCheck != that1.RequirePepCheck {
		return false
	}
	if this.CheckExpiryBlocks != that1.CheckExpiryBlocks {
		return false
	}
	if this.RiskScoreThreshold != that1.RiskScoreThreshold {
		return false
	}
	if len(this.RestrictedCountries) != len(that1.RestrictedCountries) {
		return false
	}
	for i := range this.RestrictedCountries {
		if this.RestrictedCountries[i] != that1.RestrictedCountries[i] {
			return false
		}
	}
	if this.MinAttestationsRequired != that1.MinAttestationsRequired {
		return false
	}
	if this.EnableAutoExpiry != that1.EnableAutoExpiry {
		return false
	}
	if this.RequireDocumentVerification != that1.RequireDocumentVerification {
		return false
	}
	return true
}
func (this *ComplianceProvider) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ComplianceProvider)
	if !ok {
		that2, ok := that.(ComplianceProvider)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ProviderId != that1.ProviderId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.ProviderAddress != that1.ProviderAddress {
		return false
	}
	if len(this.SupportedCheckTypes) != len(that1.SupportedCheckTypes) {
		return false
	}
	for i := range this.SupportedCheckTypes {
		if this.SupportedCheckTypes[i] != that1.SupportedCheckTypes[i] {
			return false
		}
	}
	if this.IsActive != that1.IsActive {
		return false
	}
	if this.RegisteredAt != that1.RegisteredAt {
		return false
	}
	if this.LastActiveAt != that1.LastActiveAt {
		return false
	}
	return true
}
func (m *ComplianceCheckResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceCheckResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceCheckResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReferenceId) > 0 {
		i -= len(m.ReferenceId)
		copy(dAtA[i:], m.ReferenceId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ReferenceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x32
	}
	if m.CheckedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.CheckedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.MatchScore != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.MatchScore))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Details) > 0 {
		i -= len(m.Details)
		copy(dAtA[i:], m.Details)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Details)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Passed {
		i--
		if m.Passed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.CheckType != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.CheckType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceAttestation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceAttestation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceAttestation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AttestationHash) > 0 {
		i -= len(m.AttestationHash)
		copy(dAtA[i:], m.AttestationHash)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.AttestationHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x22
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x18
	}
	if m.AttestedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.AttestedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Notes) > 0 {
		i -= len(m.Notes)
		copy(dAtA[i:], m.Notes)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Notes)))
		i--
		dAtA[i] = 0x5a
	}
	if m.UpdatedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.UpdatedAt))
		i--
		dAtA[i] = 0x50
	}
	if m.CreatedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Attestations) > 0 {
		for iNdEx := len(m.Attestations) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attestations[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.RestrictedRegions) > 0 {
		for iNdEx := len(m.RestrictedRegions) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RestrictedRegions[iNdEx])
			copy(dAtA[i:], m.RestrictedRegions[iNdEx])
			i = encodeVarintCompliance(dAtA, i, uint64(len(m.RestrictedRegions[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.RiskScore != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.RiskScore))
		i--
		dAtA[i] = 0x30
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.LastCheckedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.LastCheckedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.CheckResults) > 0 {
		for iNdEx := len(m.CheckResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CheckResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RequireDocumentVerification {
		i--
		if m.RequireDocumentVerification {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.EnableAutoExpiry {
		i--
		if m.EnableAutoExpiry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.MinAttestationsRequired != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.MinAttestationsRequired))
		i--
		dAtA[i] = 0x30
	}
	if len(m.RestrictedCountries) > 0 {
		for iNdEx := len(m.RestrictedCountries) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RestrictedCountries[iNdEx])
			copy(dAtA[i:], m.RestrictedCountries[iNdEx])
			i = encodeVarintCompliance(dAtA, i, uint64(len(m.RestrictedCountries[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.RiskScoreThreshold != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.RiskScoreThreshold))
		i--
		dAtA[i] = 0x20
	}
	if m.CheckExpiryBlocks != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.CheckExpiryBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.RequirePepCheck {
		i--
		if m.RequirePepCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.RequireSanctionCheck {
		i--
		if m.RequireSanctionCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ComplianceProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ComplianceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ComplianceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastActiveAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.LastActiveAt))
		i--
		dAtA[i] = 0x38
	}
	if m.RegisteredAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.RegisteredAt))
		i--
		dAtA[i] = 0x30
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.SupportedCheckTypes) > 0 {
		dAtA2 := make([]byte, len(m.SupportedCheckTypes)*10)
		var j1 int
		for _, num := range m.SupportedCheckTypes {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCompliance(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitComplianceCheck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitComplianceCheck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitComplianceCheck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CheckResults) > 0 {
		for iNdEx := len(m.CheckResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CheckResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCompliance(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.TargetAddress) > 0 {
		i -= len(m.TargetAddress)
		copy(dAtA[i:], m.TargetAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.TargetAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ProviderAddress) > 0 {
		i -= len(m.ProviderAddress)
		copy(dAtA[i:], m.ProviderAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitComplianceCheckResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitComplianceCheckResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitComplianceCheckResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RiskScore != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.RiskScore))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgAttestCompliance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttestCompliance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttestCompliance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiryBlocks != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.ExpiryBlocks))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AttestationType) > 0 {
		i -= len(m.AttestationType)
		copy(dAtA[i:], m.AttestationType)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.AttestationType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TargetAddress) > 0 {
		i -= len(m.TargetAddress)
		copy(dAtA[i:], m.TargetAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.TargetAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgAttestComplianceResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgAttestComplianceResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgAttestComplianceResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x10
	}
	if m.AttestedAt != 0 {
		i = encodeVarintCompliance(dAtA, i, uint64(m.AttestedAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateComplianceParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateComplianceParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateComplianceParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCompliance(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgUpdateComplianceParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgUpdateComplianceParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgUpdateComplianceParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRegisterComplianceProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterComplianceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterComplianceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Provider.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintCompliance(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterComplianceProviderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterComplianceProviderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterComplianceProviderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateComplianceProvider) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateComplianceProvider) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateComplianceProvider) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ProviderId) > 0 {
		i -= len(m.ProviderId)
		copy(dAtA[i:], m.ProviderId)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.ProviderId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintCompliance(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeactivateComplianceProviderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeactivateComplianceProviderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeactivateComplianceProviderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintCompliance(dAtA []byte, offset int, v uint64) int {
	offset -= sovCompliance(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ComplianceCheckResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CheckType != 0 {
		n += 1 + sovCompliance(uint64(m.CheckType))
	}
	if m.Passed {
		n += 2
	}
	l = len(m.Details)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.MatchScore != 0 {
		n += 1 + sovCompliance(uint64(m.MatchScore))
	}
	if m.CheckedAt != 0 {
		n += 1 + sovCompliance(uint64(m.CheckedAt))
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.ReferenceId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *ComplianceAttestation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.AttestedAt != 0 {
		n += 1 + sovCompliance(uint64(m.AttestedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovCompliance(uint64(m.ExpiresAt))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.AttestationHash)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *ComplianceRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovCompliance(uint64(m.Status))
	}
	if len(m.CheckResults) > 0 {
		for _, e := range m.CheckResults {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.LastCheckedAt != 0 {
		n += 1 + sovCompliance(uint64(m.LastCheckedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovCompliance(uint64(m.ExpiresAt))
	}
	if m.RiskScore != 0 {
		n += 1 + sovCompliance(uint64(m.RiskScore))
	}
	if len(m.RestrictedRegions) > 0 {
		for _, s := range m.RestrictedRegions {
			l = len(s)
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if len(m.Attestations) > 0 {
		for _, e := range m.Attestations {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.CreatedAt != 0 {
		n += 1 + sovCompliance(uint64(m.CreatedAt))
	}
	if m.UpdatedAt != 0 {
		n += 1 + sovCompliance(uint64(m.UpdatedAt))
	}
	l = len(m.Notes)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *ComplianceParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RequireSanctionCheck {
		n += 2
	}
	if m.RequirePepCheck {
		n += 2
	}
	if m.CheckExpiryBlocks != 0 {
		n += 1 + sovCompliance(uint64(m.CheckExpiryBlocks))
	}
	if m.RiskScoreThreshold != 0 {
		n += 1 + sovCompliance(uint64(m.RiskScoreThreshold))
	}
	if len(m.RestrictedCountries) > 0 {
		for _, s := range m.RestrictedCountries {
			l = len(s)
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	if m.MinAttestationsRequired != 0 {
		n += 1 + sovCompliance(uint64(m.MinAttestationsRequired))
	}
	if m.EnableAutoExpiry {
		n += 2
	}
	if m.RequireDocumentVerification {
		n += 2
	}
	return n
}

func (m *ComplianceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if len(m.SupportedCheckTypes) > 0 {
		l = 0
		for _, e := range m.SupportedCheckTypes {
			l += sovCompliance(uint64(e))
		}
		n += 1 + sovCompliance(uint64(l)) + l
	}
	if m.IsActive {
		n += 2
	}
	if m.RegisteredAt != 0 {
		n += 1 + sovCompliance(uint64(m.RegisteredAt))
	}
	if m.LastActiveAt != 0 {
		n += 1 + sovCompliance(uint64(m.LastActiveAt))
	}
	return n
}

func (m *MsgSubmitComplianceCheck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if len(m.CheckResults) > 0 {
		for _, e := range m.CheckResults {
			l = e.Size()
			n += 1 + l + sovCompliance(uint64(l))
		}
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *MsgSubmitComplianceCheckResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovCompliance(uint64(m.Status))
	}
	if m.RiskScore != 0 {
		n += 1 + sovCompliance(uint64(m.RiskScore))
	}
	return n
}

func (m *MsgAttestCompliance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.TargetAddress)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.AttestationType)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	if m.ExpiryBlocks != 0 {
		n += 1 + sovCompliance(uint64(m.ExpiryBlocks))
	}
	return n
}

func (m *MsgAttestComplianceResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AttestedAt != 0 {
		n += 1 + sovCompliance(uint64(m.AttestedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovCompliance(uint64(m.ExpiresAt))
	}
	return n
}

func (m *MsgUpdateComplianceParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = m.Params.Size()
	n += 1 + l + sovCompliance(uint64(l))
	return n
}

func (m *MsgUpdateComplianceParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRegisterComplianceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = m.Provider.Size()
	n += 1 + l + sovCompliance(uint64(l))
	return n
}

func (m *MsgRegisterComplianceProviderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *MsgDeactivateComplianceProvider) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.ProviderId)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovCompliance(uint64(l))
	}
	return n
}

func (m *MsgDeactivateComplianceProviderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovCompliance(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCompliance(x uint64) (n int) {
	return sovCompliance(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ComplianceCheckResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceCheckResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceCheckResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckType", wireType)
			}
			m.CheckType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckType |= ComplianceCheckType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Passed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Passed = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchScore", wireType)
			}
			m.MatchScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckedAt", wireType)
			}
			m.CheckedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReferenceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceAttestation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceAttestation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceAttestation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestedAt", wireType)
			}
			m.AttestedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttestedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ComplianceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckResults = append(m.CheckResults, ComplianceCheckResult{})
			if err := m.CheckResults[len(m.CheckResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastCheckedAt", wireType)
			}
			m.LastCheckedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastCheckedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScore", wireType)
			}
			m.RiskScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RiskScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictedRegions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestrictedRegions = append(m.RestrictedRegions, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attestations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attestations = append(m.Attestations, ComplianceAttestation{})
			if err := m.Attestations[len(m.Attestations)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatedAt", wireType)
			}
			m.UpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Notes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Notes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireSanctionCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireSanctionCheck = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequirePepCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequirePepCheck = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckExpiryBlocks", wireType)
			}
			m.CheckExpiryBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CheckExpiryBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScoreThreshold", wireType)
			}
			m.RiskScoreThreshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RiskScoreThreshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestrictedCountries", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RestrictedCountries = append(m.RestrictedCountries, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAttestationsRequired", wireType)
			}
			m.MinAttestationsRequired = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAttestationsRequired |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableAutoExpiry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableAutoExpiry = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireDocumentVerification", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireDocumentVerification = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ComplianceProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ComplianceProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ComplianceProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v ComplianceCheckType
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= ComplianceCheckType(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.SupportedCheckTypes = append(m.SupportedCheckTypes, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCompliance
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCompliance
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCompliance
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.SupportedCheckTypes) == 0 {
					m.SupportedCheckTypes = make([]ComplianceCheckType, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v ComplianceCheckType
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCompliance
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= ComplianceCheckType(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.SupportedCheckTypes = append(m.SupportedCheckTypes, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedCheckTypes", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			m.RegisteredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastActiveAt", wireType)
			}
			m.LastActiveAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastActiveAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitComplianceCheck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitComplianceCheck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitComplianceCheck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CheckResults = append(m.CheckResults, ComplianceCheckResult{})
			if err := m.CheckResults[len(m.CheckResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitComplianceCheckResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitComplianceCheckResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitComplianceCheckResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ComplianceStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RiskScore", wireType)
			}
			m.RiskScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RiskScore |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttestCompliance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttestCompliance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttestCompliance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestationType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AttestationType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiryBlocks", wireType)
			}
			m.ExpiryBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiryBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgAttestComplianceResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgAttestComplianceResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgAttestComplianceResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AttestedAt", wireType)
			}
			m.AttestedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AttestedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateComplianceParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateComplianceParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateComplianceParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgUpdateComplianceParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgUpdateComplianceParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgUpdateComplianceParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterComplianceProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterComplianceProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterComplianceProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Provider", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Provider.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterComplianceProviderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterComplianceProviderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterComplianceProviderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateComplianceProvider) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateComplianceProvider: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateComplianceProvider: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProviderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProviderId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCompliance
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCompliance
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeactivateComplianceProviderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeactivateComplianceProviderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeactivateComplianceProviderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipCompliance(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCompliance
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCompliance(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCompliance
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCompliance
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCompliance
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCompliance
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCompliance
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCompliance        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCompliance          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCompliance = fmt.Errorf("proto: unexpected end of group")
)

