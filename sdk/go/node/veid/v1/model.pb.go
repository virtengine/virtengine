// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/veid/v1/model.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ModelType represents the type of ML model
type ModelType int32

const (
	// MODEL_TYPE_UNSPECIFIED is the default unspecified type
	ModelTypeUnspecified ModelType = 0
	// MODEL_TYPE_TRUST_SCORE is the trust score calculation model
	ModelTypeTrustScore ModelType = 1
	// MODEL_TYPE_FACE_VERIFICATION is the facial verification model
	ModelTypeFaceVerification ModelType = 2
	// MODEL_TYPE_LIVENESS is the liveness detection model
	ModelTypeLiveness ModelType = 3
	// MODEL_TYPE_GAN_DETECTION is the GAN-generated image detection model
	ModelTypeGANDetection ModelType = 4
	// MODEL_TYPE_OCR is the OCR extraction model
	ModelTypeOCR ModelType = 5
)

var ModelType_name = map[int32]string{
	0: "MODEL_TYPE_UNSPECIFIED",
	1: "MODEL_TYPE_TRUST_SCORE",
	2: "MODEL_TYPE_FACE_VERIFICATION",
	3: "MODEL_TYPE_LIVENESS",
	4: "MODEL_TYPE_GAN_DETECTION",
	5: "MODEL_TYPE_OCR",
}

var ModelType_value = map[string]int32{
	"MODEL_TYPE_UNSPECIFIED":       0,
	"MODEL_TYPE_TRUST_SCORE":       1,
	"MODEL_TYPE_FACE_VERIFICATION": 2,
	"MODEL_TYPE_LIVENESS":          3,
	"MODEL_TYPE_GAN_DETECTION":     4,
	"MODEL_TYPE_OCR":               5,
}

func (x ModelType) String() string {
	return proto.EnumName(ModelType_name, int32(x))
}

func (ModelType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{0}
}

// ModelStatus represents the lifecycle status of a model
type ModelStatus int32

const (
	// MODEL_STATUS_UNSPECIFIED is the default unspecified status
	ModelStatusUnspecified ModelStatus = 0
	// MODEL_STATUS_PENDING indicates the model is pending activation
	ModelStatusPending ModelStatus = 1
	// MODEL_STATUS_ACTIVE indicates the model is currently active
	ModelStatusActive ModelStatus = 2
	// MODEL_STATUS_DEPRECATED indicates the model has been deprecated
	ModelStatusDeprecated ModelStatus = 3
	// MODEL_STATUS_REVOKED indicates the model has been revoked
	ModelStatusRevoked ModelStatus = 4
)

var ModelStatus_name = map[int32]string{
	0: "MODEL_STATUS_UNSPECIFIED",
	1: "MODEL_STATUS_PENDING",
	2: "MODEL_STATUS_ACTIVE",
	3: "MODEL_STATUS_DEPRECATED",
	4: "MODEL_STATUS_REVOKED",
}

var ModelStatus_value = map[string]int32{
	"MODEL_STATUS_UNSPECIFIED": 0,
	"MODEL_STATUS_PENDING":     1,
	"MODEL_STATUS_ACTIVE":      2,
	"MODEL_STATUS_DEPRECATED":  3,
	"MODEL_STATUS_REVOKED":     4,
}

func (x ModelStatus) String() string {
	return proto.EnumName(ModelStatus_name, int32(x))
}

func (ModelStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{1}
}

// ModelProposalStatus represents the status of a model update proposal
type ModelProposalStatus int32

const (
	// MODEL_PROPOSAL_STATUS_UNSPECIFIED is the default unspecified status
	ModelProposalStatusUnspecified ModelProposalStatus = 0
	// MODEL_PROPOSAL_STATUS_PENDING indicates the proposal is pending
	ModelProposalStatusPending ModelProposalStatus = 1
	// MODEL_PROPOSAL_STATUS_APPROVED indicates the proposal was approved
	ModelProposalStatusApproved ModelProposalStatus = 2
	// MODEL_PROPOSAL_STATUS_REJECTED indicates the proposal was rejected
	ModelProposalStatusRejected ModelProposalStatus = 3
	// MODEL_PROPOSAL_STATUS_ACTIVATED indicates the model has been activated
	ModelProposalStatusActivated ModelProposalStatus = 4
	// MODEL_PROPOSAL_STATUS_EXPIRED indicates the proposal has expired
	ModelProposalStatusExpired ModelProposalStatus = 5
)

var ModelProposalStatus_name = map[int32]string{
	0: "MODEL_PROPOSAL_STATUS_UNSPECIFIED",
	1: "MODEL_PROPOSAL_STATUS_PENDING",
	2: "MODEL_PROPOSAL_STATUS_APPROVED",
	3: "MODEL_PROPOSAL_STATUS_REJECTED",
	4: "MODEL_PROPOSAL_STATUS_ACTIVATED",
	5: "MODEL_PROPOSAL_STATUS_EXPIRED",
}

var ModelProposalStatus_value = map[string]int32{
	"MODEL_PROPOSAL_STATUS_UNSPECIFIED": 0,
	"MODEL_PROPOSAL_STATUS_PENDING":     1,
	"MODEL_PROPOSAL_STATUS_APPROVED":    2,
	"MODEL_PROPOSAL_STATUS_REJECTED":    3,
	"MODEL_PROPOSAL_STATUS_ACTIVATED":   4,
	"MODEL_PROPOSAL_STATUS_EXPIRED":     5,
}

func (x ModelProposalStatus) String() string {
	return proto.EnumName(ModelProposalStatus_name, int32(x))
}

func (ModelProposalStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{2}
}

// MLModelInfo describes a registered ML model for version tracking
type MLModelInfo struct {
	// ModelID is the unique identifier for this model
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id" yaml:"model_id"`
	// Name is the human-readable name of the model
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name" yaml:"name"`
	// Version is the semantic version of the model (e.g., "1.0.0")
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version" yaml:"version"`
	// ModelType is the type of model (e.g., "face_verification")
	ModelType string `protobuf:"bytes,4,opt,name=model_type,json=modelType,proto3" json:"model_type" yaml:"model_type"`
	// SHA256Hash is the SHA256 hash of the model binary
	Sha256Hash string `protobuf:"bytes,5,opt,name=sha256_hash,json=sha256Hash,proto3" json:"sha256_hash" yaml:"sha256_hash"`
	// Description is a human-readable description of the model
	Description string `protobuf:"bytes,6,opt,name=description,proto3" json:"description" yaml:"description"`
	// ActivatedAt is the block height when this model was activated
	ActivatedAt int64 `protobuf:"varint,7,opt,name=activated_at,json=activatedAt,proto3" json:"activated_at" yaml:"activated_at"`
	// RegisteredAt is the block height when this model was registered
	RegisteredAt int64 `protobuf:"varint,8,opt,name=registered_at,json=registeredAt,proto3" json:"registered_at" yaml:"registered_at"`
	// RegisteredBy is the address that registered this model
	RegisteredBy string `protobuf:"bytes,9,opt,name=registered_by,json=registeredBy,proto3" json:"registered_by" yaml:"registered_by"`
	// GovernanceID is the governance proposal ID that approved this model
	GovernanceId uint64 `protobuf:"varint,10,opt,name=governance_id,json=governanceId,proto3" json:"governance_id" yaml:"governance_id"`
	// Status is the current status of the model
	Status ModelStatus `protobuf:"varint,11,opt,name=status,proto3,enum=virtengine.veid.v1.ModelStatus" json:"status" yaml:"status"`
}

func (m *MLModelInfo) Reset()         { *m = MLModelInfo{} }
func (m *MLModelInfo) String() string { return proto.CompactTextString(m) }
func (*MLModelInfo) ProtoMessage()    {}
func (*MLModelInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{0}
}
func (m *MLModelInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MLModelInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MLModelInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MLModelInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MLModelInfo.Merge(m, src)
}
func (m *MLModelInfo) XXX_Size() int {
	return m.Size()
}
func (m *MLModelInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MLModelInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MLModelInfo proto.InternalMessageInfo

func (m *MLModelInfo) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *MLModelInfo) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MLModelInfo) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *MLModelInfo) GetModelType() string {
	if m != nil {
		return m.ModelType
	}
	return ""
}

func (m *MLModelInfo) GetSha256Hash() string {
	if m != nil {
		return m.Sha256Hash
	}
	return ""
}

func (m *MLModelInfo) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *MLModelInfo) GetActivatedAt() int64 {
	if m != nil {
		return m.ActivatedAt
	}
	return 0
}

func (m *MLModelInfo) GetRegisteredAt() int64 {
	if m != nil {
		return m.RegisteredAt
	}
	return 0
}

func (m *MLModelInfo) GetRegisteredBy() string {
	if m != nil {
		return m.RegisteredBy
	}
	return ""
}

func (m *MLModelInfo) GetGovernanceId() uint64 {
	if m != nil {
		return m.GovernanceId
	}
	return 0
}

func (m *MLModelInfo) GetStatus() ModelStatus {
	if m != nil {
		return m.Status
	}
	return ModelStatusUnspecified
}

// ModelVersionState tracks the current active model versions for consensus
type ModelVersionState struct {
	// TrustScoreModel is the active model ID for trust scoring
	TrustScoreModel string `protobuf:"bytes,1,opt,name=trust_score_model,json=trustScoreModel,proto3" json:"trust_score_model" yaml:"trust_score_model"`
	// FaceVerificationModel is the active model ID for face verification
	FaceVerificationModel string `protobuf:"bytes,2,opt,name=face_verification_model,json=faceVerificationModel,proto3" json:"face_verification_model" yaml:"face_verification_model"`
	// LivenessModel is the active model ID for liveness detection
	LivenessModel string `protobuf:"bytes,3,opt,name=liveness_model,json=livenessModel,proto3" json:"liveness_model" yaml:"liveness_model"`
	// GANDetectionModel is the active model ID for GAN detection
	GanDetectionModel string `protobuf:"bytes,4,opt,name=gan_detection_model,json=ganDetectionModel,proto3" json:"gan_detection_model" yaml:"gan_detection_model"`
	// OCRModel is the active model ID for OCR extraction
	OcrModel string `protobuf:"bytes,5,opt,name=ocr_model,json=ocrModel,proto3" json:"ocr_model" yaml:"ocr_model"`
	// LastUpdated is the block height when state was last updated
	LastUpdated int64 `protobuf:"varint,6,opt,name=last_updated,json=lastUpdated,proto3" json:"last_updated" yaml:"last_updated"`
}

func (m *ModelVersionState) Reset()         { *m = ModelVersionState{} }
func (m *ModelVersionState) String() string { return proto.CompactTextString(m) }
func (*ModelVersionState) ProtoMessage()    {}
func (*ModelVersionState) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{1}
}
func (m *ModelVersionState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelVersionState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelVersionState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelVersionState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelVersionState.Merge(m, src)
}
func (m *ModelVersionState) XXX_Size() int {
	return m.Size()
}
func (m *ModelVersionState) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelVersionState.DiscardUnknown(m)
}

var xxx_messageInfo_ModelVersionState proto.InternalMessageInfo

func (m *ModelVersionState) GetTrustScoreModel() string {
	if m != nil {
		return m.TrustScoreModel
	}
	return ""
}

func (m *ModelVersionState) GetFaceVerificationModel() string {
	if m != nil {
		return m.FaceVerificationModel
	}
	return ""
}

func (m *ModelVersionState) GetLivenessModel() string {
	if m != nil {
		return m.LivenessModel
	}
	return ""
}

func (m *ModelVersionState) GetGanDetectionModel() string {
	if m != nil {
		return m.GanDetectionModel
	}
	return ""
}

func (m *ModelVersionState) GetOcrModel() string {
	if m != nil {
		return m.OcrModel
	}
	return ""
}

func (m *ModelVersionState) GetLastUpdated() int64 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

// ModelUpdateProposal for governance-controlled model updates
type ModelUpdateProposal struct {
	// Title is the proposal title
	Title string `protobuf:"bytes,1,opt,name=title,proto3" json:"title" yaml:"title"`
	// Description is the detailed proposal description
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description" yaml:"description"`
	// ModelType is the type of model being updated
	ModelType string `protobuf:"bytes,3,opt,name=model_type,json=modelType,proto3" json:"model_type" yaml:"model_type"`
	// NewModelID is the ID of the new model to activate
	NewModelId string `protobuf:"bytes,4,opt,name=new_model_id,json=newModelId,proto3" json:"new_model_id" yaml:"new_model_id"`
	// NewModelHash is the SHA256 hash of the new model
	NewModelHash string `protobuf:"bytes,5,opt,name=new_model_hash,json=newModelHash,proto3" json:"new_model_hash" yaml:"new_model_hash"`
	// ActivationDelay is the number of blocks to wait after approval
	ActivationDelay int64 `protobuf:"varint,6,opt,name=activation_delay,json=activationDelay,proto3" json:"activation_delay" yaml:"activation_delay"`
	// ProposedAt is the block height when proposal was submitted
	ProposedAt int64 `protobuf:"varint,7,opt,name=proposed_at,json=proposedAt,proto3" json:"proposed_at" yaml:"proposed_at"`
	// ProposerAddress is the address that submitted the proposal
	ProposerAddress string `protobuf:"bytes,8,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address" yaml:"proposer_address"`
	// Status is the current status of the proposal
	Status ModelProposalStatus `protobuf:"varint,9,opt,name=status,proto3,enum=virtengine.veid.v1.ModelProposalStatus" json:"status" yaml:"status"`
	// GovernanceID is the governance proposal ID (set when submitted to gov)
	GovernanceId uint64 `protobuf:"varint,10,opt,name=governance_id,json=governanceId,proto3" json:"governance_id" yaml:"governance_id"`
	// ActivationHeight is the block height when activation should occur
	ActivationHeight int64 `protobuf:"varint,11,opt,name=activation_height,json=activationHeight,proto3" json:"activation_height" yaml:"activation_height"`
}

func (m *ModelUpdateProposal) Reset()         { *m = ModelUpdateProposal{} }
func (m *ModelUpdateProposal) String() string { return proto.CompactTextString(m) }
func (*ModelUpdateProposal) ProtoMessage()    {}
func (*ModelUpdateProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{2}
}
func (m *ModelUpdateProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelUpdateProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelUpdateProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelUpdateProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelUpdateProposal.Merge(m, src)
}
func (m *ModelUpdateProposal) XXX_Size() int {
	return m.Size()
}
func (m *ModelUpdateProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelUpdateProposal.DiscardUnknown(m)
}

var xxx_messageInfo_ModelUpdateProposal proto.InternalMessageInfo

func (m *ModelUpdateProposal) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ModelUpdateProposal) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *ModelUpdateProposal) GetModelType() string {
	if m != nil {
		return m.ModelType
	}
	return ""
}

func (m *ModelUpdateProposal) GetNewModelId() string {
	if m != nil {
		return m.NewModelId
	}
	return ""
}

func (m *ModelUpdateProposal) GetNewModelHash() string {
	if m != nil {
		return m.NewModelHash
	}
	return ""
}

func (m *ModelUpdateProposal) GetActivationDelay() int64 {
	if m != nil {
		return m.ActivationDelay
	}
	return 0
}

func (m *ModelUpdateProposal) GetProposedAt() int64 {
	if m != nil {
		return m.ProposedAt
	}
	return 0
}

func (m *ModelUpdateProposal) GetProposerAddress() string {
	if m != nil {
		return m.ProposerAddress
	}
	return ""
}

func (m *ModelUpdateProposal) GetStatus() ModelProposalStatus {
	if m != nil {
		return m.Status
	}
	return ModelProposalStatusUnspecified
}

func (m *ModelUpdateProposal) GetGovernanceId() uint64 {
	if m != nil {
		return m.GovernanceId
	}
	return 0
}

func (m *ModelUpdateProposal) GetActivationHeight() int64 {
	if m != nil {
		return m.ActivationHeight
	}
	return 0
}

// ModelVersionHistory tracks model version changes
type ModelVersionHistory struct {
	// HistoryID is the unique identifier for this history entry
	HistoryId string `protobuf:"bytes,1,opt,name=history_id,json=historyId,proto3" json:"history_id" yaml:"history_id"`
	// ModelType is the type of model that was changed
	ModelType string `protobuf:"bytes,2,opt,name=model_type,json=modelType,proto3" json:"model_type" yaml:"model_type"`
	// OldModelID is the previous model ID (empty if first model)
	OldModelId string `protobuf:"bytes,3,opt,name=old_model_id,json=oldModelId,proto3" json:"old_model_id" yaml:"old_model_id"`
	// NewModelID is the new model ID
	NewModelId string `protobuf:"bytes,4,opt,name=new_model_id,json=newModelId,proto3" json:"new_model_id" yaml:"new_model_id"`
	// OldModelHash is the previous model hash
	OldModelHash string `protobuf:"bytes,5,opt,name=old_model_hash,json=oldModelHash,proto3" json:"old_model_hash" yaml:"old_model_hash"`
	// NewModelHash is the new model hash
	NewModelHash string `protobuf:"bytes,6,opt,name=new_model_hash,json=newModelHash,proto3" json:"new_model_hash" yaml:"new_model_hash"`
	// ChangedAt is the block height when the change occurred
	ChangedAt int64 `protobuf:"varint,7,opt,name=changed_at,json=changedAt,proto3" json:"changed_at" yaml:"changed_at"`
	// GovernanceID is the governance proposal ID that approved this change
	GovernanceId uint64 `protobuf:"varint,8,opt,name=governance_id,json=governanceId,proto3" json:"governance_id" yaml:"governance_id"`
	// ProposerAddress is the address that proposed this change
	ProposerAddress string `protobuf:"bytes,9,opt,name=proposer_address,json=proposerAddress,proto3" json:"proposer_address" yaml:"proposer_address"`
	// Reason is the reason for the change
	Reason string `protobuf:"bytes,10,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *ModelVersionHistory) Reset()         { *m = ModelVersionHistory{} }
func (m *ModelVersionHistory) String() string { return proto.CompactTextString(m) }
func (*ModelVersionHistory) ProtoMessage()    {}
func (*ModelVersionHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{3}
}
func (m *ModelVersionHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelVersionHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelVersionHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelVersionHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelVersionHistory.Merge(m, src)
}
func (m *ModelVersionHistory) XXX_Size() int {
	return m.Size()
}
func (m *ModelVersionHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelVersionHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ModelVersionHistory proto.InternalMessageInfo

func (m *ModelVersionHistory) GetHistoryId() string {
	if m != nil {
		return m.HistoryId
	}
	return ""
}

func (m *ModelVersionHistory) GetModelType() string {
	if m != nil {
		return m.ModelType
	}
	return ""
}

func (m *ModelVersionHistory) GetOldModelId() string {
	if m != nil {
		return m.OldModelId
	}
	return ""
}

func (m *ModelVersionHistory) GetNewModelId() string {
	if m != nil {
		return m.NewModelId
	}
	return ""
}

func (m *ModelVersionHistory) GetOldModelHash() string {
	if m != nil {
		return m.OldModelHash
	}
	return ""
}

func (m *ModelVersionHistory) GetNewModelHash() string {
	if m != nil {
		return m.NewModelHash
	}
	return ""
}

func (m *ModelVersionHistory) GetChangedAt() int64 {
	if m != nil {
		return m.ChangedAt
	}
	return 0
}

func (m *ModelVersionHistory) GetGovernanceId() uint64 {
	if m != nil {
		return m.GovernanceId
	}
	return 0
}

func (m *ModelVersionHistory) GetProposerAddress() string {
	if m != nil {
		return m.ProposerAddress
	}
	return ""
}

func (m *ModelVersionHistory) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// ValidatorModelReport represents a validator's reported model versions
type ValidatorModelReport struct {
	// ValidatorAddress is the validator's operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// ModelVersions maps model type to SHA256 hash
	ModelVersions map[string]string `protobuf:"bytes,2,rep,name=model_versions,json=modelVersions,proto3" json:"model_versions" yaml:"model_versions" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// ReportedAt is the block height when this report was submitted
	ReportedAt int64 `protobuf:"varint,3,opt,name=reported_at,json=reportedAt,proto3" json:"reported_at" yaml:"reported_at"`
	// LastVerified is the block height when versions were last verified
	LastVerified int64 `protobuf:"varint,4,opt,name=last_verified,json=lastVerified,proto3" json:"last_verified" yaml:"last_verified"`
	// IsSynced indicates if all model versions match consensus
	IsSynced bool `protobuf:"varint,5,opt,name=is_synced,json=isSynced,proto3" json:"is_synced" yaml:"is_synced"`
	// MismatchedModels lists model types with version mismatches
	MismatchedModels []string `protobuf:"bytes,6,rep,name=mismatched_models,json=mismatchedModels,proto3" json:"mismatched_models" yaml:"mismatched_models"`
}

func (m *ValidatorModelReport) Reset()         { *m = ValidatorModelReport{} }
func (m *ValidatorModelReport) String() string { return proto.CompactTextString(m) }
func (*ValidatorModelReport) ProtoMessage()    {}
func (*ValidatorModelReport) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{4}
}
func (m *ValidatorModelReport) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorModelReport) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorModelReport.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorModelReport) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorModelReport.Merge(m, src)
}
func (m *ValidatorModelReport) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorModelReport) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorModelReport.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorModelReport proto.InternalMessageInfo

func (m *ValidatorModelReport) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *ValidatorModelReport) GetModelVersions() map[string]string {
	if m != nil {
		return m.ModelVersions
	}
	return nil
}

func (m *ValidatorModelReport) GetReportedAt() int64 {
	if m != nil {
		return m.ReportedAt
	}
	return 0
}

func (m *ValidatorModelReport) GetLastVerified() int64 {
	if m != nil {
		return m.LastVerified
	}
	return 0
}

func (m *ValidatorModelReport) GetIsSynced() bool {
	if m != nil {
		return m.IsSynced
	}
	return false
}

func (m *ValidatorModelReport) GetMismatchedModels() []string {
	if m != nil {
		return m.MismatchedModels
	}
	return nil
}

// ModelParams contains parameters for model management
type ModelParams struct {
	// RequiredModelTypes lists model types that must be registered
	RequiredModelTypes []string `protobuf:"bytes,1,rep,name=required_model_types,json=requiredModelTypes,proto3" json:"required_model_types" yaml:"required_model_types"`
	// ActivationDelayBlocks is the default delay for model activation
	ActivationDelayBlocks int64 `protobuf:"varint,2,opt,name=activation_delay_blocks,json=activationDelayBlocks,proto3" json:"activation_delay_blocks" yaml:"activation_delay_blocks"`
	// MaxModelAgeDays is the maximum age of a model before requiring update
	MaxModelAgeDays int32 `protobuf:"varint,3,opt,name=max_model_age_days,json=maxModelAgeDays,proto3" json:"max_model_age_days" yaml:"max_model_age_days"`
	// AllowedRegistrars lists addresses allowed to register models
	AllowedRegistrars []string `protobuf:"bytes,4,rep,name=allowed_registrars,json=allowedRegistrars,proto3" json:"allowed_registrars" yaml:"allowed_registrars"`
	// ValidatorSyncGracePeriod is blocks allowed for validators to sync
	ValidatorSyncGracePeriod int64 `protobuf:"varint,5,opt,name=validator_sync_grace_period,json=validatorSyncGracePeriod,proto3" json:"validator_sync_grace_period" yaml:"validator_sync_grace_period"`
	// ModelUpdateQuorum is the minimum voting power for model updates
	ModelUpdateQuorum uint32 `protobuf:"varint,6,opt,name=model_update_quorum,json=modelUpdateQuorum,proto3" json:"model_update_quorum" yaml:"model_update_quorum"`
	// EnableGovernanceUpdates enables governance-controlled updates
	EnableGovernanceUpdates bool `protobuf:"varint,7,opt,name=enable_governance_updates,json=enableGovernanceUpdates,proto3" json:"enable_governance_updates" yaml:"enable_governance_updates"`
}

func (m *ModelParams) Reset()         { *m = ModelParams{} }
func (m *ModelParams) String() string { return proto.CompactTextString(m) }
func (*ModelParams) ProtoMessage()    {}
func (*ModelParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{5}
}
func (m *ModelParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ModelParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ModelParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ModelParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelParams.Merge(m, src)
}
func (m *ModelParams) XXX_Size() int {
	return m.Size()
}
func (m *ModelParams) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelParams.DiscardUnknown(m)
}

var xxx_messageInfo_ModelParams proto.InternalMessageInfo

func (m *ModelParams) GetRequiredModelTypes() []string {
	if m != nil {
		return m.RequiredModelTypes
	}
	return nil
}

func (m *ModelParams) GetActivationDelayBlocks() int64 {
	if m != nil {
		return m.ActivationDelayBlocks
	}
	return 0
}

func (m *ModelParams) GetMaxModelAgeDays() int32 {
	if m != nil {
		return m.MaxModelAgeDays
	}
	return 0
}

func (m *ModelParams) GetAllowedRegistrars() []string {
	if m != nil {
		return m.AllowedRegistrars
	}
	return nil
}

func (m *ModelParams) GetValidatorSyncGracePeriod() int64 {
	if m != nil {
		return m.ValidatorSyncGracePeriod
	}
	return 0
}

func (m *ModelParams) GetModelUpdateQuorum() uint32 {
	if m != nil {
		return m.ModelUpdateQuorum
	}
	return 0
}

func (m *ModelParams) GetEnableGovernanceUpdates() bool {
	if m != nil {
		return m.EnableGovernanceUpdates
	}
	return false
}

// MsgRegisterModel registers a new ML model
type MsgRegisterModel struct {
	// Authority is the address authorized to register models
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// ModelInfo contains the model information
	ModelInfo MLModelInfo `protobuf:"bytes,2,opt,name=model_info,json=modelInfo,proto3" json:"model_info" yaml:"model_info"`
}

func (m *MsgRegisterModel) Reset()         { *m = MsgRegisterModel{} }
func (m *MsgRegisterModel) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterModel) ProtoMessage()    {}
func (*MsgRegisterModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{6}
}
func (m *MsgRegisterModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterModel.Merge(m, src)
}
func (m *MsgRegisterModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterModel proto.InternalMessageInfo

func (m *MsgRegisterModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRegisterModel) GetModelInfo() MLModelInfo {
	if m != nil {
		return m.ModelInfo
	}
	return MLModelInfo{}
}

// MsgRegisterModelResponse is the response for MsgRegisterModel
type MsgRegisterModelResponse struct {
	// ModelID is the registered model's ID
	ModelId string `protobuf:"bytes,1,opt,name=model_id,json=modelId,proto3" json:"model_id" yaml:"model_id"`
	// Status is the initial model status
	Status ModelStatus `protobuf:"varint,2,opt,name=status,proto3,enum=virtengine.veid.v1.ModelStatus" json:"status" yaml:"status"`
}

func (m *MsgRegisterModelResponse) Reset()         { *m = MsgRegisterModelResponse{} }
func (m *MsgRegisterModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRegisterModelResponse) ProtoMessage()    {}
func (*MsgRegisterModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{7}
}
func (m *MsgRegisterModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRegisterModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRegisterModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRegisterModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRegisterModelResponse.Merge(m, src)
}
func (m *MsgRegisterModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRegisterModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRegisterModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRegisterModelResponse proto.InternalMessageInfo

func (m *MsgRegisterModelResponse) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *MsgRegisterModelResponse) GetStatus() ModelStatus {
	if m != nil {
		return m.Status
	}
	return ModelStatusUnspecified
}

// MsgProposeModelUpdate proposes updating active model via governance
type MsgProposeModelUpdate struct {
	// Proposer is the address proposing the update
	Proposer string `protobuf:"bytes,1,opt,name=proposer,proto3" json:"proposer" yaml:"proposer"`
	// Proposal contains the update proposal details
	Proposal ModelUpdateProposal `protobuf:"bytes,2,opt,name=proposal,proto3" json:"proposal" yaml:"proposal"`
}

func (m *MsgProposeModelUpdate) Reset()         { *m = MsgProposeModelUpdate{} }
func (m *MsgProposeModelUpdate) String() string { return proto.CompactTextString(m) }
func (*MsgProposeModelUpdate) ProtoMessage()    {}
func (*MsgProposeModelUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{8}
}
func (m *MsgProposeModelUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeModelUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeModelUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeModelUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeModelUpdate.Merge(m, src)
}
func (m *MsgProposeModelUpdate) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeModelUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeModelUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeModelUpdate proto.InternalMessageInfo

func (m *MsgProposeModelUpdate) GetProposer() string {
	if m != nil {
		return m.Proposer
	}
	return ""
}

func (m *MsgProposeModelUpdate) GetProposal() ModelUpdateProposal {
	if m != nil {
		return m.Proposal
	}
	return ModelUpdateProposal{}
}

// MsgProposeModelUpdateResponse is the response for MsgProposeModelUpdate
type MsgProposeModelUpdateResponse struct {
	// ProposalID is the governance proposal ID
	ProposalId uint64 `protobuf:"varint,1,opt,name=proposal_id,json=proposalId,proto3" json:"proposal_id" yaml:"proposal_id"`
}

func (m *MsgProposeModelUpdateResponse) Reset()         { *m = MsgProposeModelUpdateResponse{} }
func (m *MsgProposeModelUpdateResponse) String() string { return proto.CompactTextString(m) }
func (*MsgProposeModelUpdateResponse) ProtoMessage()    {}
func (*MsgProposeModelUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{9}
}
func (m *MsgProposeModelUpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgProposeModelUpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgProposeModelUpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgProposeModelUpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgProposeModelUpdateResponse.Merge(m, src)
}
func (m *MsgProposeModelUpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgProposeModelUpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgProposeModelUpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgProposeModelUpdateResponse proto.InternalMessageInfo

func (m *MsgProposeModelUpdateResponse) GetProposalId() uint64 {
	if m != nil {
		return m.ProposalId
	}
	return 0
}

// MsgReportModelVersion reports validator's model versions
type MsgReportModelVersion struct {
	// ValidatorAddress is the validator's operator address
	ValidatorAddress string `protobuf:"bytes,1,opt,name=validator_address,json=validatorAddress,proto3" json:"validator_address" yaml:"validator_address"`
	// ModelVersions maps model type to SHA256 hash
	ModelVersions map[string]string `protobuf:"bytes,2,rep,name=model_versions,json=modelVersions,proto3" json:"model_versions" yaml:"model_versions" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MsgReportModelVersion) Reset()         { *m = MsgReportModelVersion{} }
func (m *MsgReportModelVersion) String() string { return proto.CompactTextString(m) }
func (*MsgReportModelVersion) ProtoMessage()    {}
func (*MsgReportModelVersion) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{10}
}
func (m *MsgReportModelVersion) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportModelVersion) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportModelVersion.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportModelVersion) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportModelVersion.Merge(m, src)
}
func (m *MsgReportModelVersion) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportModelVersion) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportModelVersion.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportModelVersion proto.InternalMessageInfo

func (m *MsgReportModelVersion) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *MsgReportModelVersion) GetModelVersions() map[string]string {
	if m != nil {
		return m.ModelVersions
	}
	return nil
}

// MsgReportModelVersionResponse is the response for MsgReportModelVersion
type MsgReportModelVersionResponse struct {
	// IsSynced indicates if all models match consensus
	IsSynced bool `protobuf:"varint,1,opt,name=is_synced,json=isSynced,proto3" json:"is_synced" yaml:"is_synced"`
	// MismatchedModels lists any models that don't match
	MismatchedModels []string `protobuf:"bytes,2,rep,name=mismatched_models,json=mismatchedModels,proto3" json:"mismatched_models" yaml:"mismatched_models"`
}

func (m *MsgReportModelVersionResponse) Reset()         { *m = MsgReportModelVersionResponse{} }
func (m *MsgReportModelVersionResponse) String() string { return proto.CompactTextString(m) }
func (*MsgReportModelVersionResponse) ProtoMessage()    {}
func (*MsgReportModelVersionResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{11}
}
func (m *MsgReportModelVersionResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReportModelVersionResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReportModelVersionResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReportModelVersionResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReportModelVersionResponse.Merge(m, src)
}
func (m *MsgReportModelVersionResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgReportModelVersionResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReportModelVersionResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReportModelVersionResponse proto.InternalMessageInfo

func (m *MsgReportModelVersionResponse) GetIsSynced() bool {
	if m != nil {
		return m.IsSynced
	}
	return false
}

func (m *MsgReportModelVersionResponse) GetMismatchedModels() []string {
	if m != nil {
		return m.MismatchedModels
	}
	return nil
}

// MsgActivateModel activates a pending model after governance approval
type MsgActivateModel struct {
	// Authority is the address authorized to activate models
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// ModelType is the type of model to activate
	ModelType string `protobuf:"bytes,2,opt,name=model_type,json=modelType,proto3" json:"model_type" yaml:"model_type"`
	// ModelID is the ID of the model to activate
	ModelId string `protobuf:"bytes,3,opt,name=model_id,json=modelId,proto3" json:"model_id" yaml:"model_id"`
	// GovernanceID is the governance proposal ID
	GovernanceId uint64 `protobuf:"varint,4,opt,name=governance_id,json=governanceId,proto3" json:"governance_id" yaml:"governance_id"`
}

func (m *MsgActivateModel) Reset()         { *m = MsgActivateModel{} }
func (m *MsgActivateModel) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModel) ProtoMessage()    {}
func (*MsgActivateModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{12}
}
func (m *MsgActivateModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModel.Merge(m, src)
}
func (m *MsgActivateModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModel proto.InternalMessageInfo

func (m *MsgActivateModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgActivateModel) GetModelType() string {
	if m != nil {
		return m.ModelType
	}
	return ""
}

func (m *MsgActivateModel) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *MsgActivateModel) GetGovernanceId() uint64 {
	if m != nil {
		return m.GovernanceId
	}
	return 0
}

// MsgActivateModelResponse is the response for MsgActivateModel
type MsgActivateModelResponse struct {
	// ActivatedAt is the block height when activated
	ActivatedAt int64 `protobuf:"varint,1,opt,name=activated_at,json=activatedAt,proto3" json:"activated_at" yaml:"activated_at"`
}

func (m *MsgActivateModelResponse) Reset()         { *m = MsgActivateModelResponse{} }
func (m *MsgActivateModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgActivateModelResponse) ProtoMessage()    {}
func (*MsgActivateModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{13}
}
func (m *MsgActivateModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgActivateModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgActivateModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgActivateModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgActivateModelResponse.Merge(m, src)
}
func (m *MsgActivateModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgActivateModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgActivateModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgActivateModelResponse proto.InternalMessageInfo

func (m *MsgActivateModelResponse) GetActivatedAt() int64 {
	if m != nil {
		return m.ActivatedAt
	}
	return 0
}

// MsgDeprecateModel deprecates a model
type MsgDeprecateModel struct {
	// Authority is the address authorized to deprecate models
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// ModelID is the ID of the model to deprecate
	ModelId string `protobuf:"bytes,2,opt,name=model_id,json=modelId,proto3" json:"model_id" yaml:"model_id"`
	// Reason is the reason for deprecation
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *MsgDeprecateModel) Reset()         { *m = MsgDeprecateModel{} }
func (m *MsgDeprecateModel) String() string { return proto.CompactTextString(m) }
func (*MsgDeprecateModel) ProtoMessage()    {}
func (*MsgDeprecateModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{14}
}
func (m *MsgDeprecateModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeprecateModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeprecateModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeprecateModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeprecateModel.Merge(m, src)
}
func (m *MsgDeprecateModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeprecateModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeprecateModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeprecateModel proto.InternalMessageInfo

func (m *MsgDeprecateModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgDeprecateModel) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *MsgDeprecateModel) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgDeprecateModelResponse is the response for MsgDeprecateModel
type MsgDeprecateModelResponse struct {
}

func (m *MsgDeprecateModelResponse) Reset()         { *m = MsgDeprecateModelResponse{} }
func (m *MsgDeprecateModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgDeprecateModelResponse) ProtoMessage()    {}
func (*MsgDeprecateModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{15}
}
func (m *MsgDeprecateModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDeprecateModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDeprecateModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDeprecateModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDeprecateModelResponse.Merge(m, src)
}
func (m *MsgDeprecateModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgDeprecateModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDeprecateModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDeprecateModelResponse proto.InternalMessageInfo

// MsgRevokeModel revokes a model
type MsgRevokeModel struct {
	// Authority is the address authorized to revoke models
	Authority string `protobuf:"bytes,1,opt,name=authority,proto3" json:"authority" yaml:"authority"`
	// ModelID is the ID of the model to revoke
	ModelId string `protobuf:"bytes,2,opt,name=model_id,json=modelId,proto3" json:"model_id" yaml:"model_id"`
	// Reason is the reason for revocation
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *MsgRevokeModel) Reset()         { *m = MsgRevokeModel{} }
func (m *MsgRevokeModel) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeModel) ProtoMessage()    {}
func (*MsgRevokeModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{16}
}
func (m *MsgRevokeModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeModel.Merge(m, src)
}
func (m *MsgRevokeModel) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeModel) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeModel.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeModel proto.InternalMessageInfo

func (m *MsgRevokeModel) GetAuthority() string {
	if m != nil {
		return m.Authority
	}
	return ""
}

func (m *MsgRevokeModel) GetModelId() string {
	if m != nil {
		return m.ModelId
	}
	return ""
}

func (m *MsgRevokeModel) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// MsgRevokeModelResponse is the response for MsgRevokeModel
type MsgRevokeModelResponse struct {
}

func (m *MsgRevokeModelResponse) Reset()         { *m = MsgRevokeModelResponse{} }
func (m *MsgRevokeModelResponse) String() string { return proto.CompactTextString(m) }
func (*MsgRevokeModelResponse) ProtoMessage()    {}
func (*MsgRevokeModelResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c0e2a865c4075769, []int{17}
}
func (m *MsgRevokeModelResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgRevokeModelResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgRevokeModelResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgRevokeModelResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgRevokeModelResponse.Merge(m, src)
}
func (m *MsgRevokeModelResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgRevokeModelResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgRevokeModelResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgRevokeModelResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("virtengine.veid.v1.ModelType", ModelType_name, ModelType_value)
	proto.RegisterEnum("virtengine.veid.v1.ModelStatus", ModelStatus_name, ModelStatus_value)
	proto.RegisterEnum("virtengine.veid.v1.ModelProposalStatus", ModelProposalStatus_name, ModelProposalStatus_value)
	proto.RegisterType((*MLModelInfo)(nil), "virtengine.veid.v1.MLModelInfo")
	proto.RegisterType((*ModelVersionState)(nil), "virtengine.veid.v1.ModelVersionState")
	proto.RegisterType((*ModelUpdateProposal)(nil), "virtengine.veid.v1.ModelUpdateProposal")
	proto.RegisterType((*ModelVersionHistory)(nil), "virtengine.veid.v1.ModelVersionHistory")
	proto.RegisterType((*ValidatorModelReport)(nil), "virtengine.veid.v1.ValidatorModelReport")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.veid.v1.ValidatorModelReport.ModelVersionsEntry")
	proto.RegisterType((*ModelParams)(nil), "virtengine.veid.v1.ModelParams")
	proto.RegisterType((*MsgRegisterModel)(nil), "virtengine.veid.v1.MsgRegisterModel")
	proto.RegisterType((*MsgRegisterModelResponse)(nil), "virtengine.veid.v1.MsgRegisterModelResponse")
	proto.RegisterType((*MsgProposeModelUpdate)(nil), "virtengine.veid.v1.MsgProposeModelUpdate")
	proto.RegisterType((*MsgProposeModelUpdateResponse)(nil), "virtengine.veid.v1.MsgProposeModelUpdateResponse")
	proto.RegisterType((*MsgReportModelVersion)(nil), "virtengine.veid.v1.MsgReportModelVersion")
	proto.RegisterMapType((map[string]string)(nil), "virtengine.veid.v1.MsgReportModelVersion.ModelVersionsEntry")
	proto.RegisterType((*MsgReportModelVersionResponse)(nil), "virtengine.veid.v1.MsgReportModelVersionResponse")
	proto.RegisterType((*MsgActivateModel)(nil), "virtengine.veid.v1.MsgActivateModel")
	proto.RegisterType((*MsgActivateModelResponse)(nil), "virtengine.veid.v1.MsgActivateModelResponse")
	proto.RegisterType((*MsgDeprecateModel)(nil), "virtengine.veid.v1.MsgDeprecateModel")
	proto.RegisterType((*MsgDeprecateModelResponse)(nil), "virtengine.veid.v1.MsgDeprecateModelResponse")
	proto.RegisterType((*MsgRevokeModel)(nil), "virtengine.veid.v1.MsgRevokeModel")
	proto.RegisterType((*MsgRevokeModelResponse)(nil), "virtengine.veid.v1.MsgRevokeModelResponse")
}

func init() { proto.RegisterFile("virtengine/veid/v1/model.proto", fileDescriptor_c0e2a865c4075769) }

var fileDescriptor_c0e2a865c4075769 = []byte{
	// 2546 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x5a, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0x17, 0x3f, 0x24, 0x8b, 0x23, 0x59, 0xa6, 0x56, 0x92, 0x45, 0xd1, 0x31, 0x97, 0x99, 0xb4,
	0x88, 0xeb, 0x34, 0x52, 0x12, 0xe7, 0x53, 0xfd, 0x24, 0xc5, 0xb5, 0x42, 0xd7, 0x92, 0x98, 0x21,
	0xad, 0xb6, 0x41, 0xdb, 0xed, 0x8a, 0x3b, 0x5a, 0x6e, 0x4d, 0xee, 0x32, 0xbb, 0x2b, 0xda, 0x3c,
	0xf4, 0x12, 0x14, 0x45, 0x40, 0x14, 0x68, 0xae, 0x05, 0x4a, 0xd4, 0x40, 0x2f, 0x3d, 0xf4, 0x90,
	0x43, 0xd0, 0x5b, 0xd1, 0x6b, 0x0e, 0x3d, 0x04, 0x3d, 0xf5, 0xb4, 0x28, 0xec, 0x43, 0x52, 0x1e,
	0xf9, 0x17, 0x14, 0x3b, 0x33, 0xbb, 0xb3, 0xcb, 0x25, 0xdb, 0xda, 0x96, 0x51, 0xa0, 0x17, 0x61,
	0xe7, 0xf7, 0xe6, 0xbd, 0x99, 0x79, 0x5f, 0xf3, 0xde, 0x88, 0xa0, 0xd0, 0xd3, 0x2d, 0x07, 0x1b,
	0x9a, 0x6e, 0xe0, 0x9d, 0x1e, 0xd6, 0xd5, 0x9d, 0xde, 0xab, 0x3b, 0x1d, 0x53, 0xc5, 0xed, 0xed,
	0xae, 0x65, 0x3a, 0xa6, 0x20, 0x70, 0xfa, 0xb6, 0x47, 0xdf, 0xee, 0xbd, 0x9a, 0x5f, 0xd7, 0x4c,
	0xcd, 0x24, 0xe4, 0x1d, 0xef, 0x8b, 0xce, 0xcc, 0x6f, 0x35, 0x4d, 0xbb, 0x63, 0xda, 0x32, 0x25,
	0xd0, 0x01, 0x23, 0x6d, 0xd2, 0xd1, 0x4e, 0xc7, 0xd6, 0x88, 0x7c, 0x5b, 0x63, 0x84, 0x55, 0xa5,
	0xa3, 0x1b, 0xe6, 0x0e, 0xf9, 0x4b, 0x21, 0xf8, 0xe9, 0x02, 0x58, 0x3a, 0xb8, 0x7d, 0xe0, 0x6d,
	0xa1, 0x6a, 0x9c, 0x9a, 0xc2, 0x2e, 0x58, 0x24, 0xfb, 0x91, 0x75, 0x35, 0x97, 0x28, 0x26, 0xae,
	0x65, 0xca, 0xe2, 0xc8, 0x15, 0x03, 0x6c, 0xec, 0x8a, 0x97, 0xfa, 0x4a, 0xa7, 0xbd, 0x0b, 0x7d,
	0x04, 0xa2, 0x0b, 0xe4, 0xb3, 0xaa, 0x0a, 0x2f, 0x81, 0xb4, 0xa1, 0x74, 0x70, 0x2e, 0x49, 0xf8,
	0x36, 0x47, 0xae, 0x48, 0xc6, 0x63, 0x57, 0x5c, 0xa2, 0x3c, 0xde, 0x08, 0x22, 0x02, 0x0a, 0x6f,
	0x81, 0x0b, 0x3d, 0x6c, 0xd9, 0xba, 0x69, 0xe4, 0x52, 0x64, 0xfe, 0xd5, 0x91, 0x2b, 0xfa, 0xd0,
	0xd8, 0x15, 0x57, 0x28, 0x0b, 0x03, 0x20, 0xf2, 0x49, 0x42, 0x19, 0x00, 0xba, 0xb6, 0xd3, 0xef,
	0xe2, 0x5c, 0x9a, 0xf0, 0xbe, 0x30, 0x72, 0xc5, 0x10, 0x3a, 0x76, 0xc5, 0xd5, 0xf0, 0x2e, 0x3d,
	0x0c, 0xa2, 0x0c, 0x19, 0x34, 0xfa, 0x5d, 0x2c, 0xdc, 0x04, 0x4b, 0x76, 0x4b, 0x79, 0xed, 0x8d,
	0x37, 0xe5, 0x96, 0x62, 0xb7, 0x72, 0xf3, 0x44, 0xc8, 0x57, 0x47, 0xae, 0x18, 0x86, 0xc7, 0xae,
	0x28, 0x50, 0x29, 0x21, 0x10, 0x22, 0x40, 0x47, 0xef, 0x2a, 0x76, 0x4b, 0xd8, 0x07, 0x4b, 0x2a,
	0xb6, 0x9b, 0x96, 0xde, 0x75, 0xbc, 0x83, 0x2c, 0x70, 0x39, 0x21, 0x98, 0xcb, 0x09, 0x81, 0x10,
	0x85, 0xa7, 0x08, 0xb7, 0xc0, 0xb2, 0xd2, 0x74, 0xf4, 0x9e, 0xe2, 0x60, 0x55, 0x56, 0x9c, 0xdc,
	0x85, 0x62, 0xe2, 0x5a, 0xaa, 0xfc, 0xe2, 0xc8, 0x15, 0x23, 0xf8, 0xd8, 0x15, 0xd7, 0xa8, 0xa8,
	0x30, 0x0a, 0xd1, 0x52, 0x30, 0x2c, 0x39, 0xc2, 0x21, 0xb8, 0x68, 0x61, 0x4d, 0xb7, 0x1d, 0x6c,
	0x51, 0x61, 0x8b, 0x44, 0xd8, 0xd7, 0x46, 0xae, 0x18, 0x25, 0x8c, 0x5d, 0x71, 0x9d, 0x4a, 0x8b,
	0xc0, 0x10, 0x2d, 0xf3, 0x71, 0xc9, 0x11, 0x4e, 0x23, 0xf2, 0x4e, 0xfa, 0xb9, 0x0c, 0x39, 0x66,
	0x69, 0x42, 0xde, 0x49, 0x7f, 0xaa, 0xbc, 0x93, 0x3e, 0xfc, 0xdb, 0xa7, 0x2f, 0xaf, 0x33, 0x07,
	0x2d, 0xa9, 0xaa, 0x85, 0x6d, 0xbb, 0xee, 0x58, 0xba, 0xa1, 0x85, 0xd7, 0x29, 0xf7, 0xbd, 0x7d,
	0x6b, 0x66, 0x0f, 0x5b, 0x86, 0x62, 0x34, 0xb1, 0xe7, 0x7f, 0xa0, 0x98, 0xb8, 0x96, 0xa6, 0xfb,
	0x8e, 0x10, 0xf8, 0x3a, 0x11, 0x18, 0xa2, 0x65, 0x3e, 0xae, 0xaa, 0x42, 0x03, 0x2c, 0xd8, 0x8e,
	0xe2, 0x9c, 0xd9, 0xb9, 0xa5, 0x62, 0xe2, 0xda, 0xca, 0x6b, 0xe2, 0x76, 0x3c, 0xb8, 0xb6, 0x89,
	0xe7, 0xd7, 0xc9, 0xb4, 0xf2, 0x95, 0x91, 0x2b, 0x32, 0x96, 0xb1, 0x2b, 0x5e, 0x64, 0xb6, 0x27,
	0x63, 0x88, 0x18, 0x61, 0x37, 0xfd, 0xe5, 0x03, 0x31, 0x01, 0xff, 0x94, 0x06, 0xab, 0x84, 0xf5,
	0x98, 0x7a, 0xa5, 0x27, 0x01, 0x0b, 0x3f, 0x06, 0xab, 0x8e, 0x75, 0x66, 0x3b, 0xb2, 0xdd, 0x34,
	0x2d, 0x2c, 0x13, 0x7f, 0x63, 0x51, 0xf4, 0xea, 0xc8, 0x15, 0xe3, 0xc4, 0xb1, 0x2b, 0xe6, 0xe8,
	0x32, 0x31, 0x12, 0x44, 0x97, 0x08, 0x56, 0xf7, 0x20, 0xb2, 0x94, 0x70, 0x06, 0x36, 0x4f, 0x95,
	0x26, 0x96, 0x7b, 0xd8, 0xd2, 0x4f, 0xf5, 0xa6, 0xe2, 0x79, 0x0e, 0x5b, 0x84, 0x86, 0xdc, 0xb7,
	0x46, 0xae, 0x38, 0x6b, 0xca, 0xd8, 0x15, 0x0b, 0x74, 0xa9, 0x19, 0x13, 0x20, 0xda, 0xf0, 0x28,
	0xc7, 0x21, 0x02, 0x5d, 0x16, 0x81, 0x95, 0xb6, 0xde, 0xc3, 0x06, 0xb6, 0x6d, 0xb6, 0x1a, 0x0d,
	0xd8, 0x97, 0x46, 0xae, 0x38, 0x41, 0x19, 0xbb, 0xe2, 0x06, 0x5d, 0x24, 0x8a, 0x43, 0x74, 0xd1,
	0x07, 0xa8, 0x4c, 0x0c, 0xd6, 0x34, 0xc5, 0x90, 0x55, 0xec, 0xe0, 0x66, 0xe8, 0x18, 0x34, 0x9a,
	0xdf, 0x18, 0xb9, 0xe2, 0x34, 0xf2, 0xd8, 0x15, 0xf3, 0xcc, 0xee, 0x71, 0x22, 0x44, 0xab, 0x9a,
	0x62, 0x54, 0x7c, 0x90, 0x2e, 0xf3, 0x6d, 0x90, 0x31, 0x9b, 0x16, 0x13, 0x4e, 0xa3, 0xfc, 0xf9,
	0x91, 0x2b, 0x72, 0x70, 0xec, 0x8a, 0x59, 0x2a, 0x32, 0x80, 0x20, 0x5a, 0x34, 0x9b, 0x16, 0xe5,
	0xbf, 0x05, 0x96, 0xdb, 0x8a, 0xed, 0xc8, 0x67, 0x5d, 0xd5, 0x0b, 0x2e, 0x12, 0xe0, 0x2c, 0x2c,
	0xc3, 0x38, 0x0f, 0xcb, 0x30, 0x0a, 0xd1, 0x92, 0x37, 0xbc, 0x43, 0x47, 0xcc, 0x71, 0x86, 0x17,
	0xc0, 0x1a, 0x91, 0x4d, 0xe1, 0x9a, 0x65, 0x76, 0x4d, 0x5b, 0x69, 0x0b, 0x3b, 0x60, 0xde, 0xd1,
	0x9d, 0x36, 0x66, 0xee, 0xb2, 0x35, 0x72, 0x45, 0x0a, 0x8c, 0x5d, 0x71, 0x99, 0xb9, 0x88, 0x37,
	0x84, 0x88, 0xc2, 0x93, 0xa9, 0x27, 0xf9, 0xc4, 0xa9, 0x27, 0x9a, 0x4f, 0x53, 0x4f, 0x94, 0x4f,
	0xab, 0x60, 0xd9, 0xc0, 0xf7, 0xe4, 0xe0, 0xe6, 0xa0, 0x76, 0x24, 0x7a, 0x0a, 0xe3, 0x5c, 0x4f,
	0x61, 0x14, 0x22, 0x60, 0xe0, 0x7b, 0x07, 0xec, 0x12, 0x79, 0x0f, 0xac, 0x70, 0x62, 0x28, 0x3b,
	0x13, 0x6f, 0x8b, 0x52, 0xb8, 0xb7, 0x45, 0x71, 0x88, 0x96, 0x7d, 0x81, 0x24, 0x4b, 0xbf, 0x0f,
	0xb2, 0x2c, 0x3f, 0x7a, 0xde, 0xa2, 0xe2, 0xb6, 0xd2, 0x67, 0x96, 0xdc, 0x19, 0xb9, 0x62, 0x8c,
	0x36, 0x76, 0xc5, 0xcd, 0x48, 0x92, 0x0d, 0x28, 0x10, 0x5d, 0xe2, 0x50, 0xc5, 0x43, 0xbc, 0x9b,
	0xa4, 0x4b, 0x6c, 0x18, 0xce, 0xdb, 0xc4, 0x0c, 0x21, 0x98, 0x9b, 0x21, 0x04, 0x42, 0x04, 0xfc,
	0x51, 0xc9, 0x11, 0x2c, 0x90, 0x65, 0x23, 0x4b, 0x56, 0x68, 0x92, 0x24, 0x79, 0x3b, 0x53, 0xde,
	0xf7, 0xf6, 0x38, 0x49, 0xe3, 0x7b, 0x9c, 0xa4, 0xcc, 0xce, 0xb6, 0x97, 0xfc, 0xa9, 0x0c, 0x16,
	0x7e, 0x14, 0x24, 0xc8, 0x0c, 0x49, 0x90, 0x2f, 0xce, 0x4c, 0x90, 0xbe, 0x9b, 0x3e, 0x46, 0xa2,
	0x3c, 0xf7, 0x74, 0xfe, 0x13, 0xb0, 0x1a, 0xb2, 0x47, 0x0b, 0xeb, 0x5a, 0xcb, 0x21, 0x99, 0x3d,
	0x45, 0x93, 0x6b, 0x8c, 0xc8, 0x93, 0x6b, 0x8c, 0x04, 0x51, 0xc8, 0xea, 0xef, 0x12, 0x88, 0xc5,
	0xe7, 0x6f, 0x17, 0x58, 0x7c, 0xb2, 0xc4, 0xfe, 0xae, 0x6e, 0x3b, 0xa6, 0xd5, 0xf7, 0xa2, 0xa4,
	0x45, 0x3f, 0x79, 0x65, 0x44, 0xa2, 0x84, 0xa3, 0x3c, 0x4a, 0x38, 0x06, 0x51, 0x86, 0x0d, 0xaa,
	0xea, 0x44, 0xa4, 0x25, 0x9f, 0x34, 0xd2, 0xcc, 0xb6, 0xca, 0x23, 0x2d, 0xc5, 0x23, 0x2d, 0x8c,
	0xf3, 0x48, 0x0b, 0xa3, 0x10, 0x01, 0xb3, 0xad, 0xfa, 0x91, 0x76, 0xbe, 0x41, 0xcb, 0xd7, 0x99,
	0x0c, 0xda, 0x28, 0x85, 0x07, 0x6d, 0x14, 0x87, 0x68, 0xd9, 0xdf, 0x1b, 0x09, 0xda, 0x78, 0x1e,
	0x58, 0x78, 0xda, 0x3c, 0x50, 0x06, 0xa0, 0xd9, 0x52, 0x0c, 0x2d, 0x1c, 0xaa, 0x44, 0xff, 0x1c,
	0xe5, 0xfa, 0xe7, 0x18, 0x44, 0x19, 0x36, 0xa0, 0xc5, 0x55, 0xd4, 0xab, 0x17, 0x9f, 0xce, 0xab,
	0xa7, 0xc5, 0x7d, 0xe6, 0x19, 0xc7, 0xfd, 0x0d, 0xb0, 0x60, 0x61, 0xc5, 0x36, 0x0d, 0x12, 0x92,
	0x19, 0x1a, 0xce, 0x14, 0xe1, 0xe1, 0x4c, 0xc7, 0x10, 0x31, 0x02, 0x0b, 0x8f, 0x07, 0xf3, 0x60,
	0xfd, 0x58, 0x69, 0xeb, 0xaa, 0xe2, 0x98, 0xf4, 0x8e, 0x44, 0xb8, 0x6b, 0x5a, 0x8e, 0xd0, 0x03,
	0xab, 0x3d, 0x1f, 0x0f, 0x0e, 0x42, 0xc3, 0xa4, 0xea, 0x45, 0x67, 0x8c, 0xc8, 0xa3, 0x33, 0x46,
	0x9a, 0x7d, 0x94, 0x6c, 0x30, 0xd7, 0x3f, 0xcb, 0xaf, 0x13, 0x60, 0x85, 0x5a, 0x9c, 0xf5, 0x07,
	0x76, 0x2e, 0x59, 0x4c, 0x5d, 0x5b, 0x7a, 0xed, 0x1b, 0xd3, 0x92, 0xd9, 0xb4, 0xad, 0x6f, 0x87,
	0xc3, 0xdd, 0x96, 0x0c, 0xc7, 0xea, 0x53, 0x27, 0x8b, 0x8a, 0xe5, 0x4e, 0x16, 0xc5, 0x21, 0xba,
	0xd8, 0x09, 0x0b, 0xf0, 0x6e, 0x04, 0x8b, 0x08, 0xa6, 0x6e, 0x96, 0xe2, 0x37, 0x42, 0x08, 0xe6,
	0x37, 0x42, 0x08, 0x84, 0x08, 0xf8, 0x23, 0xea, 0x69, 0xa4, 0x9a, 0xa0, 0x95, 0x1a, 0xa6, 0xf1,
	0xc9, 0xca, 0xf8, 0x08, 0x81, 0x7b, 0x5a, 0x04, 0x86, 0x88, 0xd4, 0x28, 0xc7, 0x6c, 0xe8, 0xd5,
	0x42, 0xba, 0x2d, 0xdb, 0x7d, 0xa3, 0x89, 0x55, 0x12, 0x9e, 0x8b, 0xb4, 0x16, 0x0a, 0x40, 0x5e,
	0x0b, 0x05, 0x10, 0x44, 0x8b, 0xba, 0x5d, 0x27, 0x9f, 0x5e, 0xfe, 0xed, 0xe8, 0x76, 0x47, 0x71,
	0x9a, 0x2d, 0xcc, 0x02, 0xd7, 0xce, 0x2d, 0x14, 0x53, 0x7e, 0x71, 0x1b, 0x23, 0x72, 0x0b, 0xc7,
	0x48, 0x10, 0x65, 0x39, 0x46, 0xf4, 0x6f, 0xe7, 0xbf, 0x0b, 0x84, 0xb8, 0x25, 0x84, 0x2c, 0x48,
	0xdd, 0xc5, 0x7d, 0xea, 0x49, 0xc8, 0xfb, 0x14, 0xd6, 0xc1, 0x7c, 0x4f, 0x69, 0x9f, 0xb1, 0x04,
	0x8a, 0xe8, 0x60, 0x37, 0xf9, 0x76, 0x82, 0xb9, 0xe8, 0x1f, 0xbc, 0x8e, 0x96, 0x5c, 0x5a, 0x8a,
	0xa5, 0x74, 0x6c, 0x41, 0x07, 0xeb, 0x16, 0xfe, 0xe0, 0x4c, 0xb7, 0xfc, 0xd5, 0x49, 0x52, 0xf5,
	0x9c, 0xd3, 0xdb, 0xfa, 0x5b, 0x23, 0x57, 0x9c, 0x4a, 0x1f, 0xbb, 0xe2, 0x15, 0xdf, 0x42, 0x71,
	0x2a, 0x44, 0x82, 0x0f, 0x1f, 0xf8, 0xb9, 0xd9, 0xf6, 0x0a, 0xf4, 0xc9, 0x92, 0x41, 0x3e, 0x69,
	0x9b, 0xcd, 0xbb, 0x36, 0xd9, 0x6c, 0x8a, 0x16, 0xe8, 0x33, 0xa6, 0xf0, 0x02, 0x7d, 0xc6, 0x04,
	0x88, 0x36, 0x26, 0xaa, 0x8f, 0x32, 0xc1, 0x85, 0x9f, 0x02, 0xa1, 0xa3, 0xdc, 0x67, 0xdb, 0x53,
	0x34, 0x2c, 0xab, 0x4a, 0xdf, 0x26, 0x8e, 0x37, 0x5f, 0xbe, 0x31, 0x72, 0xc5, 0x29, 0xd4, 0xb1,
	0x2b, 0x6e, 0x31, 0xdb, 0xc4, 0x68, 0x10, 0x5d, 0xea, 0x28, 0xf7, 0xc9, 0xb1, 0x4a, 0x1a, 0xae,
	0x28, 0x7d, 0x5b, 0x38, 0x01, 0x82, 0xd2, 0x6e, 0x9b, 0xf7, 0xb0, 0x2a, 0xd3, 0x96, 0xcd, 0x52,
	0x2c, 0x3b, 0x97, 0x26, 0x1a, 0x24, 0x2b, 0xc4, 0xa9, 0x7c, 0x85, 0x38, 0x0d, 0xa2, 0x55, 0x06,
	0xa2, 0x00, 0x13, 0x7e, 0x91, 0x00, 0x57, 0x78, 0x2a, 0xf0, 0xfc, 0x4f, 0xd6, 0x2c, 0xaf, 0x55,
	0xe9, 0x62, 0x4b, 0x37, 0xa9, 0xcb, 0xa6, 0xca, 0xd2, 0xc8, 0x15, 0xff, 0xdd, 0xb4, 0xb1, 0x2b,
	0xc2, 0xc9, 0xb4, 0x12, 0x9b, 0x04, 0x51, 0x2e, 0xa0, 0x7a, 0xde, 0xbd, 0xef, 0xd1, 0x6a, 0x84,
	0xe4, 0x75, 0x26, 0x54, 0x1d, 0xb4, 0x8a, 0x97, 0x3f, 0x38, 0x33, 0xad, 0xb3, 0x0e, 0xb9, 0x7c,
	0x2e, 0xd2, 0xce, 0x64, 0x0a, 0x99, 0x77, 0x26, 0x53, 0x88, 0x10, 0xad, 0x76, 0x78, 0xc5, 0xff,
	0x1e, 0xc1, 0x84, 0x9f, 0x83, 0x2d, 0x6c, 0x28, 0x27, 0x6d, 0x2c, 0x87, 0xae, 0x07, 0xca, 0x66,
	0x93, 0xab, 0x69, 0x91, 0x34, 0xd8, 0xb3, 0x27, 0x8d, 0x5d, 0xb1, 0x48, 0x97, 0x9c, 0x39, 0x05,
	0xa2, 0x4d, 0x4a, 0xdb, 0x0f, 0x48, 0x74, 0x0f, 0x7e, 0x17, 0xfb, 0x61, 0x12, 0x64, 0x0f, 0x6c,
	0x0d, 0xb1, 0x2e, 0x9c, 0xf6, 0x3c, 0xdf, 0x07, 0x19, 0xe5, 0xcc, 0x69, 0x99, 0x96, 0xee, 0xb0,
	0xb8, 0x2b, 0xbf, 0xe3, 0xe5, 0x89, 0x00, 0xe4, 0x79, 0x22, 0x80, 0x66, 0x67, 0x6c, 0xce, 0x26,
	0x68, 0x7e, 0xf9, 0xa3, 0x1b, 0xa7, 0x26, 0x09, 0x88, 0xa5, 0x19, 0x3d, 0x39, 0x7f, 0x8f, 0x2a,
	0xbf, 0xf8, 0x99, 0x2b, 0xce, 0xf1, 0x1a, 0xc9, 0x63, 0x9d, 0xac, 0x91, 0x3c, 0xcc, 0xaf, 0x91,
	0x3c, 0x9e, 0xdd, 0xaf, 0x7f, 0xf9, 0x40, 0x9c, 0xfb, 0xf0, 0x8b, 0x4f, 0xae, 0xf3, 0xc5, 0x07,
	0x5f, 0x7c, 0x72, 0x7d, 0x83, 0x3c, 0xb8, 0x4d, 0x9e, 0x17, 0xfe, 0x31, 0x01, 0x72, 0x93, 0x20,
	0xc2, 0x76, 0xd7, 0x34, 0x6c, 0xfc, 0x54, 0xcf, 0x61, 0xfc, 0xfd, 0x21, 0x79, 0x7e, 0xef, 0x0f,
	0xf0, 0xa3, 0x24, 0xd8, 0x38, 0xb0, 0x35, 0x5a, 0x91, 0xe3, 0x50, 0x2b, 0x29, 0xd4, 0xc1, 0xa2,
	0x7f, 0xd3, 0xb3, 0xbd, 0x7a, 0xc9, 0x2d, 0xc0, 0xf8, 0x5e, 0x7d, 0x64, 0xb6, 0xd5, 0x02, 0x26,
	0xa1, 0xe5, 0x0b, 0x55, 0xda, 0xcc, 0x64, 0xb3, 0xbb, 0x84, 0x68, 0x4b, 0x5b, 0x7e, 0x81, 0x99,
	0x2e, 0x10, 0x30, 0xb9, 0x03, 0xc5, 0xeb, 0xb5, 0xfd, 0xcf, 0xdd, 0x57, 0x7c, 0xab, 0x05, 0x8b,
	0x7b, 0x46, 0xcb, 0xfb, 0x46, 0x8b, 0x1f, 0x18, 0x6a, 0xe0, 0xea, 0x54, 0x42, 0x60, 0xbd, 0xa0,
	0x39, 0x53, 0x02, 0x03, 0xa6, 0xc3, 0xcd, 0x99, 0xc2, 0x6c, 0x28, 0x44, 0x77, 0x45, 0xcb, 0x5b,
	0x7f, 0x54, 0x55, 0xe1, 0xef, 0x52, 0x44, 0xe7, 0xb4, 0x5e, 0x08, 0x5f, 0x52, 0xff, 0xb3, 0xb2,
	0xe7, 0xe3, 0x59, 0x65, 0xcf, 0x37, 0xa7, 0x5a, 0x67, 0xda, 0xde, 0xcf, 0xb9, 0xee, 0x39, 0x87,
	0xfb, 0xfb, 0x1d, 0xdf, 0x03, 0xe2, 0x6a, 0x8b, 0xb8, 0x42, 0xfc, 0x2c, 0xf0, 0x2f, 0x09, 0xe2,
	0x0b, 0x71, 0x4a, 0xe0, 0x0b, 0x91, 0xf2, 0x27, 0x71, 0x4e, 0xe5, 0x4f, 0xf2, 0xdc, 0xca, 0x1f,
	0xf8, 0x4f, 0x9a, 0x8b, 0x4b, 0xec, 0x21, 0xf7, 0x19, 0xe7, 0xe2, 0xf3, 0x68, 0x45, 0xc3, 0xb9,
	0x31, 0xf5, 0x98, 0xb9, 0x31, 0xd6, 0x46, 0xa5, 0x9f, 0xaa, 0x8d, 0xfa, 0x8f, 0x29, 0x3f, 0xa2,
	0x56, 0x78, 0x4a, 0x32, 0x7e, 0x04, 0x0b, 0xfc, 0x64, 0xf2, 0x25, 0x3e, 0xf1, 0xe4, 0x2f, 0xf1,
	0xf0, 0x57, 0x49, 0xb0, 0x7a, 0x60, 0x6b, 0x15, 0xdc, 0xb5, 0x70, 0xf3, 0xd9, 0x1b, 0x35, 0x6c,
	0x90, 0xe4, 0x63, 0x1a, 0x84, 0xf7, 0x84, 0xa9, 0xff, 0xbe, 0x27, 0x7c, 0x79, 0xba, 0xd6, 0x2f,
	0xfb, 0x5a, 0x8f, 0x1e, 0x1c, 0x5e, 0x01, 0x5b, 0x31, 0xd0, 0xd7, 0x3b, 0xfc, 0x65, 0x12, 0xac,
	0x90, 0x08, 0xee, 0x99, 0x77, 0xff, 0xef, 0x14, 0x75, 0x7d, 0xba, 0xa2, 0xd6, 0x78, 0x46, 0x0b,
	0x4e, 0x0d, 0x73, 0xe0, 0x72, 0x14, 0xf1, 0x55, 0x74, 0xfd, 0xaf, 0x49, 0x90, 0x09, 0xba, 0x0d,
	0xe1, 0x75, 0x70, 0xf9, 0xe0, 0xa8, 0x22, 0xdd, 0x96, 0x1b, 0x3f, 0xac, 0x49, 0xf2, 0x9d, 0xc3,
	0x7a, 0x4d, 0xda, 0xab, 0xde, 0xac, 0x4a, 0x95, 0xec, 0x5c, 0x3e, 0x37, 0x18, 0x16, 0xd7, 0x83,
	0xa9, 0x77, 0x0c, 0xbb, 0x8b, 0x9b, 0xb4, 0x0b, 0xbc, 0x11, 0xe1, 0x6a, 0xa0, 0x3b, 0xf5, 0x86,
	0x5c, 0xdf, 0x3b, 0x42, 0x52, 0x36, 0x91, 0xdf, 0x1c, 0x0c, 0x8b, 0x6b, 0x01, 0x57, 0x23, 0xf8,
	0xef, 0x83, 0xf0, 0x1d, 0xf0, 0x5c, 0x88, 0xe9, 0x66, 0x69, 0x4f, 0x92, 0x8f, 0x25, 0x54, 0xbd,
	0x59, 0xdd, 0x2b, 0x35, 0xaa, 0x47, 0x87, 0xd9, 0x64, 0xfe, 0xea, 0x60, 0x58, 0xdc, 0x0a, 0x58,
	0x6f, 0x4e, 0xfc, 0x1f, 0x41, 0xd8, 0x06, 0x6b, 0x21, 0x01, 0xb7, 0xab, 0xc7, 0xd2, 0xa1, 0x54,
	0xaf, 0x67, 0x53, 0xf9, 0x8d, 0xc1, 0xb0, 0xb8, 0x1a, 0xf0, 0xdd, 0x66, 0xff, 0x23, 0x10, 0xde,
	0x02, 0xb9, 0xd0, 0xfc, 0xfd, 0xd2, 0xa1, 0x5c, 0x91, 0x1a, 0xd2, 0x1e, 0x59, 0x2c, 0x9d, 0xdf,
	0x1a, 0x0c, 0x8b, 0x1b, 0x01, 0xd3, 0x7e, 0xe9, 0x30, 0x78, 0xf5, 0x17, 0xbe, 0x02, 0x56, 0x42,
	0x8c, 0x47, 0x7b, 0x28, 0x3b, 0x9f, 0xcf, 0x0e, 0x86, 0xc5, 0xe5, 0x60, 0xfa, 0xd1, 0x1e, 0xca,
	0xa7, 0x3f, 0xfa, 0x7d, 0x61, 0xee, 0xfa, 0x6f, 0x92, 0xac, 0x51, 0xa4, 0xe5, 0x97, 0xf0, 0xb6,
	0xbf, 0x68, 0xbd, 0x51, 0x6a, 0xdc, 0xa9, 0x4f, 0xa8, 0x34, 0x3f, 0x18, 0x16, 0x2f, 0x87, 0xa6,
	0x87, 0x95, 0xfa, 0x0a, 0x58, 0x8f, 0x70, 0xd6, 0xa4, 0xc3, 0x4a, 0xf5, 0x70, 0x3f, 0x9b, 0xc8,
	0x5f, 0x1e, 0x0c, 0x8b, 0x42, 0x88, 0xab, 0x86, 0x0d, 0x55, 0x37, 0x34, 0xae, 0x10, 0xc6, 0x51,
	0xda, 0x6b, 0x54, 0x8f, 0xa5, 0x6c, 0x32, 0xa4, 0x10, 0xca, 0x40, 0x92, 0x14, 0x16, 0xde, 0x04,
	0x9b, 0x91, 0xf9, 0x15, 0xa9, 0x86, 0xa4, 0xbd, 0x52, 0x43, 0xaa, 0x64, 0x53, 0x21, 0x7d, 0x50,
	0x9e, 0x20, 0xc2, 0xe2, 0x3b, 0x43, 0xd2, 0xf1, 0xd1, 0xf7, 0xa4, 0x4a, 0x36, 0x1d, 0xdb, 0x19,
	0x75, 0x38, 0x95, 0xe9, 0xe6, 0xcf, 0x29, 0xf6, 0x0c, 0x1a, 0x7d, 0xf9, 0x15, 0xaa, 0xe0, 0x79,
	0x2a, 0xaf, 0x86, 0x8e, 0x6a, 0x47, 0xf5, 0xd2, 0x0c, 0x65, 0xc1, 0xc1, 0xb0, 0x58, 0x98, 0xc2,
	0x1f, 0x56, 0x5a, 0x09, 0x5c, 0x9d, 0x2e, 0x8a, 0x6b, 0xaf, 0x30, 0x18, 0x16, 0xf3, 0x53, 0xc4,
	0xf8, 0x5a, 0xdc, 0x03, 0x85, 0xe9, 0x22, 0x4a, 0xb5, 0x1a, 0x3a, 0x3a, 0x96, 0x2a, 0xd9, 0x64,
	0x5e, 0x1c, 0x0c, 0x8b, 0x57, 0xa6, 0xc8, 0x28, 0x75, 0xbb, 0x96, 0xd9, 0xc3, 0xea, 0x6c, 0x21,
	0x48, 0xba, 0x25, 0xed, 0x51, 0x0d, 0xcf, 0x12, 0x82, 0xf0, 0xcf, 0x70, 0xd3, 0xd3, 0xb3, 0x04,
	0xc4, 0x19, 0x3b, 0xf1, 0x0c, 0x4b, 0xec, 0x94, 0xce, 0x17, 0x07, 0xc3, 0xe2, 0x73, 0xd3, 0xb6,
	0xe2, 0x5f, 0x19, 0xb3, 0x75, 0x22, 0xfd, 0xa0, 0x56, 0x45, 0x52, 0x25, 0x3b, 0x3f, 0x53, 0x27,
	0xd2, 0xfd, 0xae, 0x6e, 0xf9, 0xf6, 0x2b, 0x1f, 0x7e, 0xf6, 0xb0, 0x90, 0xf8, 0xfc, 0x61, 0x21,
	0xf1, 0x8f, 0x87, 0x85, 0xc4, 0xc7, 0x8f, 0x0a, 0x73, 0x9f, 0x3f, 0x2a, 0xcc, 0xfd, 0xfd, 0x51,
	0x61, 0xee, 0xfd, 0xd7, 0x35, 0xdd, 0x69, 0x9d, 0x9d, 0x6c, 0x37, 0xcd, 0xce, 0x4e, 0xf8, 0xc7,
	0x08, 0xfc, 0xd3, 0x56, 0xef, 0xee, 0x68, 0xe6, 0x8e, 0x61, 0xaa, 0xc1, 0x6f, 0x14, 0x4e, 0x16,
	0xc8, 0xaf, 0x05, 0x6e, 0xfc, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x8c, 0x2f, 0x1c, 0x40, 0xc0, 0x20,
	0x00, 0x00,
}

func (this *MLModelInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*MLModelInfo)
	if !ok {
		that2, ok := that.(MLModelInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ModelId != that1.ModelId {
		return false
	}
	if this.Name != that1.Name {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.ModelType != that1.ModelType {
		return false
	}
	if this.Sha256Hash != that1.Sha256Hash {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.ActivatedAt != that1.ActivatedAt {
		return false
	}
	if this.RegisteredAt != that1.RegisteredAt {
		return false
	}
	if this.RegisteredBy != that1.RegisteredBy {
		return false
	}
	if this.GovernanceId != that1.GovernanceId {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	return true
}
func (this *ModelVersionState) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelVersionState)
	if !ok {
		that2, ok := that.(ModelVersionState)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TrustScoreModel != that1.TrustScoreModel {
		return false
	}
	if this.FaceVerificationModel != that1.FaceVerificationModel {
		return false
	}
	if this.LivenessModel != that1.LivenessModel {
		return false
	}
	if this.GanDetectionModel != that1.GanDetectionModel {
		return false
	}
	if this.OcrModel != that1.OcrModel {
		return false
	}
	if this.LastUpdated != that1.LastUpdated {
		return false
	}
	return true
}
func (this *ModelUpdateProposal) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelUpdateProposal)
	if !ok {
		that2, ok := that.(ModelUpdateProposal)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.ModelType != that1.ModelType {
		return false
	}
	if this.NewModelId != that1.NewModelId {
		return false
	}
	if this.NewModelHash != that1.NewModelHash {
		return false
	}
	if this.ActivationDelay != that1.ActivationDelay {
		return false
	}
	if this.ProposedAt != that1.ProposedAt {
		return false
	}
	if this.ProposerAddress != that1.ProposerAddress {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.GovernanceId != that1.GovernanceId {
		return false
	}
	if this.ActivationHeight != that1.ActivationHeight {
		return false
	}
	return true
}
func (this *ModelVersionHistory) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelVersionHistory)
	if !ok {
		that2, ok := that.(ModelVersionHistory)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.HistoryId != that1.HistoryId {
		return false
	}
	if this.ModelType != that1.ModelType {
		return false
	}
	if this.OldModelId != that1.OldModelId {
		return false
	}
	if this.NewModelId != that1.NewModelId {
		return false
	}
	if this.OldModelHash != that1.OldModelHash {
		return false
	}
	if this.NewModelHash != that1.NewModelHash {
		return false
	}
	if this.ChangedAt != that1.ChangedAt {
		return false
	}
	if this.GovernanceId != that1.GovernanceId {
		return false
	}
	if this.ProposerAddress != that1.ProposerAddress {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *ValidatorModelReport) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ValidatorModelReport)
	if !ok {
		that2, ok := that.(ValidatorModelReport)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ValidatorAddress != that1.ValidatorAddress {
		return false
	}
	if len(this.ModelVersions) != len(that1.ModelVersions) {
		return false
	}
	for i := range this.ModelVersions {
		if this.ModelVersions[i] != that1.ModelVersions[i] {
			return false
		}
	}
	if this.ReportedAt != that1.ReportedAt {
		return false
	}
	if this.LastVerified != that1.LastVerified {
		return false
	}
	if this.IsSynced != that1.IsSynced {
		return false
	}
	if len(this.MismatchedModels) != len(that1.MismatchedModels) {
		return false
	}
	for i := range this.MismatchedModels {
		if this.MismatchedModels[i] != that1.MismatchedModels[i] {
			return false
		}
	}
	return true
}
func (this *ModelParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ModelParams)
	if !ok {
		that2, ok := that.(ModelParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RequiredModelTypes) != len(that1.RequiredModelTypes) {
		return false
	}
	for i := range this.RequiredModelTypes {
		if this.RequiredModelTypes[i] != that1.RequiredModelTypes[i] {
			return false
		}
	}
	if this.ActivationDelayBlocks != that1.ActivationDelayBlocks {
		return false
	}
	if this.MaxModelAgeDays != that1.MaxModelAgeDays {
		return false
	}
	if len(this.AllowedRegistrars) != len(that1.AllowedRegistrars) {
		return false
	}
	for i := range this.AllowedRegistrars {
		if this.AllowedRegistrars[i] != that1.AllowedRegistrars[i] {
			return false
		}
	}
	if this.ValidatorSyncGracePeriod != that1.ValidatorSyncGracePeriod {
		return false
	}
	if this.ModelUpdateQuorum != that1.ModelUpdateQuorum {
		return false
	}
	if this.EnableGovernanceUpdates != that1.EnableGovernanceUpdates {
		return false
	}
	return true
}
func (m *MLModelInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MLModelInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MLModelInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x58
	}
	if m.GovernanceId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.GovernanceId))
		i--
		dAtA[i] = 0x50
	}
	if len(m.RegisteredBy) > 0 {
		i -= len(m.RegisteredBy)
		copy(dAtA[i:], m.RegisteredBy)
		i = encodeVarintModel(dAtA, i, uint64(len(m.RegisteredBy)))
		i--
		dAtA[i] = 0x4a
	}
	if m.RegisteredAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.RegisteredAt))
		i--
		dAtA[i] = 0x40
	}
	if m.ActivatedAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ActivatedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Sha256Hash) > 0 {
		i -= len(m.Sha256Hash)
		copy(dAtA[i:], m.Sha256Hash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Sha256Hash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ModelType) > 0 {
		i -= len(m.ModelType)
		copy(dAtA[i:], m.ModelType)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelType)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelVersionState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelVersionState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelVersionState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdated != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.LastUpdated))
		i--
		dAtA[i] = 0x30
	}
	if len(m.OcrModel) > 0 {
		i -= len(m.OcrModel)
		copy(dAtA[i:], m.OcrModel)
		i = encodeVarintModel(dAtA, i, uint64(len(m.OcrModel)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GanDetectionModel) > 0 {
		i -= len(m.GanDetectionModel)
		copy(dAtA[i:], m.GanDetectionModel)
		i = encodeVarintModel(dAtA, i, uint64(len(m.GanDetectionModel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.LivenessModel) > 0 {
		i -= len(m.LivenessModel)
		copy(dAtA[i:], m.LivenessModel)
		i = encodeVarintModel(dAtA, i, uint64(len(m.LivenessModel)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.FaceVerificationModel) > 0 {
		i -= len(m.FaceVerificationModel)
		copy(dAtA[i:], m.FaceVerificationModel)
		i = encodeVarintModel(dAtA, i, uint64(len(m.FaceVerificationModel)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TrustScoreModel) > 0 {
		i -= len(m.TrustScoreModel)
		copy(dAtA[i:], m.TrustScoreModel)
		i = encodeVarintModel(dAtA, i, uint64(len(m.TrustScoreModel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelUpdateProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelUpdateProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelUpdateProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivationHeight != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ActivationHeight))
		i--
		dAtA[i] = 0x58
	}
	if m.GovernanceId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.GovernanceId))
		i--
		dAtA[i] = 0x50
	}
	if m.Status != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x48
	}
	if len(m.ProposerAddress) > 0 {
		i -= len(m.ProposerAddress)
		copy(dAtA[i:], m.ProposerAddress)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ProposerAddress)))
		i--
		dAtA[i] = 0x42
	}
	if m.ProposedAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ProposedAt))
		i--
		dAtA[i] = 0x38
	}
	if m.ActivationDelay != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ActivationDelay))
		i--
		dAtA[i] = 0x30
	}
	if len(m.NewModelHash) > 0 {
		i -= len(m.NewModelHash)
		copy(dAtA[i:], m.NewModelHash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewModelHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewModelId) > 0 {
		i -= len(m.NewModelId)
		copy(dAtA[i:], m.NewModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewModelId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ModelType) > 0 {
		i -= len(m.ModelType)
		copy(dAtA[i:], m.ModelType)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelType)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelVersionHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelVersionHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelVersionHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ProposerAddress) > 0 {
		i -= len(m.ProposerAddress)
		copy(dAtA[i:], m.ProposerAddress)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ProposerAddress)))
		i--
		dAtA[i] = 0x4a
	}
	if m.GovernanceId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.GovernanceId))
		i--
		dAtA[i] = 0x40
	}
	if m.ChangedAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ChangedAt))
		i--
		dAtA[i] = 0x38
	}
	if len(m.NewModelHash) > 0 {
		i -= len(m.NewModelHash)
		copy(dAtA[i:], m.NewModelHash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewModelHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.OldModelHash) > 0 {
		i -= len(m.OldModelHash)
		copy(dAtA[i:], m.OldModelHash)
		i = encodeVarintModel(dAtA, i, uint64(len(m.OldModelHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewModelId) > 0 {
		i -= len(m.NewModelId)
		copy(dAtA[i:], m.NewModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.NewModelId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OldModelId) > 0 {
		i -= len(m.OldModelId)
		copy(dAtA[i:], m.OldModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.OldModelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelType) > 0 {
		i -= len(m.ModelType)
		copy(dAtA[i:], m.ModelType)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HistoryId) > 0 {
		i -= len(m.HistoryId)
		copy(dAtA[i:], m.HistoryId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.HistoryId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorModelReport) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorModelReport) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorModelReport) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MismatchedModels) > 0 {
		for iNdEx := len(m.MismatchedModels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MismatchedModels[iNdEx])
			copy(dAtA[i:], m.MismatchedModels[iNdEx])
			i = encodeVarintModel(dAtA, i, uint64(len(m.MismatchedModels[iNdEx])))
			i--
			dAtA[i] = 0x32
		}
	}
	if m.IsSynced {
		i--
		if m.IsSynced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LastVerified != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.LastVerified))
		i--
		dAtA[i] = 0x20
	}
	if m.ReportedAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ReportedAt))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ModelVersions) > 0 {
		for k := range m.ModelVersions {
			v := m.ModelVersions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintModel(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModel(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModel(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ModelParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ModelParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ModelParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EnableGovernanceUpdates {
		i--
		if m.EnableGovernanceUpdates {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ModelUpdateQuorum != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ModelUpdateQuorum))
		i--
		dAtA[i] = 0x30
	}
	if m.ValidatorSyncGracePeriod != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ValidatorSyncGracePeriod))
		i--
		dAtA[i] = 0x28
	}
	if len(m.AllowedRegistrars) > 0 {
		for iNdEx := len(m.AllowedRegistrars) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.AllowedRegistrars[iNdEx])
			copy(dAtA[i:], m.AllowedRegistrars[iNdEx])
			i = encodeVarintModel(dAtA, i, uint64(len(m.AllowedRegistrars[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.MaxModelAgeDays != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.MaxModelAgeDays))
		i--
		dAtA[i] = 0x18
	}
	if m.ActivationDelayBlocks != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ActivationDelayBlocks))
		i--
		dAtA[i] = 0x10
	}
	if len(m.RequiredModelTypes) > 0 {
		for iNdEx := len(m.RequiredModelTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.RequiredModelTypes[iNdEx])
			copy(dAtA[i:], m.RequiredModelTypes[iNdEx])
			i = encodeVarintModel(dAtA, i, uint64(len(m.RequiredModelTypes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.ModelInfo.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModel(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRegisterModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRegisterModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRegisterModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeModelUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeModelUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeModelUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Proposal.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintModel(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgProposeModelUpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgProposeModelUpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgProposeModelUpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ProposalId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ProposalId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportModelVersion) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportModelVersion) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportModelVersion) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelVersions) > 0 {
		for k := range m.ModelVersions {
			v := m.ModelVersions[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintModel(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintModel(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintModel(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReportModelVersionResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReportModelVersionResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReportModelVersionResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MismatchedModels) > 0 {
		for iNdEx := len(m.MismatchedModels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.MismatchedModels[iNdEx])
			copy(dAtA[i:], m.MismatchedModels[iNdEx])
			i = encodeVarintModel(dAtA, i, uint64(len(m.MismatchedModels[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.IsSynced {
		i--
		if m.IsSynced {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GovernanceId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.GovernanceId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelType) > 0 {
		i -= len(m.ModelType)
		copy(dAtA[i:], m.ModelType)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelType)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgActivateModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgActivateModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgActivateModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActivatedAt != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ActivatedAt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeprecateModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeprecateModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeprecateModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgDeprecateModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDeprecateModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDeprecateModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *MsgRevokeModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ModelId) > 0 {
		i -= len(m.ModelId)
		copy(dAtA[i:], m.ModelId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ModelId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Authority) > 0 {
		i -= len(m.Authority)
		copy(dAtA[i:], m.Authority)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Authority)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgRevokeModelResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgRevokeModelResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgRevokeModelResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	offset -= sovModel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *MLModelInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelType)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Sha256Hash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ActivatedAt != 0 {
		n += 1 + sovModel(uint64(m.ActivatedAt))
	}
	if m.RegisteredAt != 0 {
		n += 1 + sovModel(uint64(m.RegisteredAt))
	}
	l = len(m.RegisteredBy)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.GovernanceId != 0 {
		n += 1 + sovModel(uint64(m.GovernanceId))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	return n
}

func (m *ModelVersionState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TrustScoreModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.FaceVerificationModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.LivenessModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.GanDetectionModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.OcrModel)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.LastUpdated != 0 {
		n += 1 + sovModel(uint64(m.LastUpdated))
	}
	return n
}

func (m *ModelUpdateProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelType)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.NewModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.NewModelHash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ActivationDelay != 0 {
		n += 1 + sovModel(uint64(m.ActivationDelay))
	}
	if m.ProposedAt != 0 {
		n += 1 + sovModel(uint64(m.ProposedAt))
	}
	l = len(m.ProposerAddress)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	if m.GovernanceId != 0 {
		n += 1 + sovModel(uint64(m.GovernanceId))
	}
	if m.ActivationHeight != 0 {
		n += 1 + sovModel(uint64(m.ActivationHeight))
	}
	return n
}

func (m *ModelVersionHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.HistoryId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelType)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.OldModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.NewModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.OldModelHash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.NewModelHash)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.ChangedAt != 0 {
		n += 1 + sovModel(uint64(m.ChangedAt))
	}
	if m.GovernanceId != 0 {
		n += 1 + sovModel(uint64(m.GovernanceId))
	}
	l = len(m.ProposerAddress)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *ValidatorModelReport) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.ModelVersions) > 0 {
		for k, v := range m.ModelVersions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	if m.ReportedAt != 0 {
		n += 1 + sovModel(uint64(m.ReportedAt))
	}
	if m.LastVerified != 0 {
		n += 1 + sovModel(uint64(m.LastVerified))
	}
	if m.IsSynced {
		n += 2
	}
	if len(m.MismatchedModels) > 0 {
		for _, s := range m.MismatchedModels {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *ModelParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RequiredModelTypes) > 0 {
		for _, s := range m.RequiredModelTypes {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.ActivationDelayBlocks != 0 {
		n += 1 + sovModel(uint64(m.ActivationDelayBlocks))
	}
	if m.MaxModelAgeDays != 0 {
		n += 1 + sovModel(uint64(m.MaxModelAgeDays))
	}
	if len(m.AllowedRegistrars) > 0 {
		for _, s := range m.AllowedRegistrars {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.ValidatorSyncGracePeriod != 0 {
		n += 1 + sovModel(uint64(m.ValidatorSyncGracePeriod))
	}
	if m.ModelUpdateQuorum != 0 {
		n += 1 + sovModel(uint64(m.ModelUpdateQuorum))
	}
	if m.EnableGovernanceUpdates {
		n += 2
	}
	return n
}

func (m *MsgRegisterModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = m.ModelInfo.Size()
	n += 1 + l + sovModel(uint64(l))
	return n
}

func (m *MsgRegisterModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovModel(uint64(m.Status))
	}
	return n
}

func (m *MsgProposeModelUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = m.Proposal.Size()
	n += 1 + l + sovModel(uint64(l))
	return n
}

func (m *MsgProposeModelUpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalId != 0 {
		n += 1 + sovModel(uint64(m.ProposalId))
	}
	return n
}

func (m *MsgReportModelVersion) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.ModelVersions) > 0 {
		for k, v := range m.ModelVersions {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovModel(uint64(len(k))) + 1 + len(v) + sovModel(uint64(len(v)))
			n += mapEntrySize + 1 + sovModel(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MsgReportModelVersionResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSynced {
		n += 2
	}
	if len(m.MismatchedModels) > 0 {
		for _, s := range m.MismatchedModels {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	return n
}

func (m *MsgActivateModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelType)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.GovernanceId != 0 {
		n += 1 + sovModel(uint64(m.GovernanceId))
	}
	return n
}

func (m *MsgActivateModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActivatedAt != 0 {
		n += 1 + sovModel(uint64(m.ActivatedAt))
	}
	return n
}

func (m *MsgDeprecateModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *MsgDeprecateModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MsgRevokeModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Authority)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ModelId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *MsgRevokeModelResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovModel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *MLModelInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MLModelInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MLModelInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Hash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Hash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			m.ActivatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredAt", wireType)
			}
			m.RegisteredAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RegisteredAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisteredBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceId", wireType)
			}
			m.GovernanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GovernanceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ModelStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelVersionState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelVersionState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelVersionState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrustScoreModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TrustScoreModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceVerificationModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceVerificationModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LivenessModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LivenessModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GanDetectionModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GanDetectionModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OcrModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OcrModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdated", wireType)
			}
			m.LastUpdated = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdated |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelUpdateProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelUpdateProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelUpdateProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationDelay", wireType)
			}
			m.ActivationDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivationDelay |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedAt", wireType)
			}
			m.ProposedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ModelProposalStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceId", wireType)
			}
			m.GovernanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GovernanceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationHeight", wireType)
			}
			m.ActivationHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivationHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelVersionHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelVersionHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelVersionHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OldModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewModelHash", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewModelHash = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangedAt", wireType)
			}
			m.ChangedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceId", wireType)
			}
			m.GovernanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GovernanceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorModelReport) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorModelReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorModelReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelVersions == nil {
				m.ModelVersions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModel
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModel
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModel
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModel
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModel(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthModel
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModelVersions[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportedAt", wireType)
			}
			m.ReportedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReportedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastVerified", wireType)
			}
			m.LastVerified = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastVerified |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSynced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSynced = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MismatchedModels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MismatchedModels = append(m.MismatchedModels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ModelParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ModelParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ModelParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredModelTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredModelTypes = append(m.RequiredModelTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivationDelayBlocks", wireType)
			}
			m.ActivationDelayBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivationDelayBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxModelAgeDays", wireType)
			}
			m.MaxModelAgeDays = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxModelAgeDays |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowedRegistrars", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllowedRegistrars = append(m.AllowedRegistrars, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorSyncGracePeriod", wireType)
			}
			m.ValidatorSyncGracePeriod = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidatorSyncGracePeriod |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelUpdateQuorum", wireType)
			}
			m.ModelUpdateQuorum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModelUpdateQuorum |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EnableGovernanceUpdates", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.EnableGovernanceUpdates = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ModelInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRegisterModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRegisterModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRegisterModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ModelStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeModelUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeModelUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeModelUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Proposal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgProposeModelUpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgProposeModelUpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgProposeModelUpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalId", wireType)
			}
			m.ProposalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposalId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportModelVersion) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportModelVersion: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportModelVersion: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ModelVersions == nil {
				m.ModelVersions = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowModel
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthModel
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthModel
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowModel
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthModel
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthModel
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipModel(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthModel
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ModelVersions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReportModelVersionResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReportModelVersionResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReportModelVersionResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSynced", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSynced = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MismatchedModels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MismatchedModels = append(m.MismatchedModels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovernanceId", wireType)
			}
			m.GovernanceId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GovernanceId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgActivateModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgActivateModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgActivateModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActivatedAt", wireType)
			}
			m.ActivatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActivatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeprecateModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeprecateModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeprecateModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDeprecateModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDeprecateModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDeprecateModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Authority", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Authority = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgRevokeModelResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgRevokeModelResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgRevokeModelResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModel = fmt.Errorf("proto: unexpected end of group")
)
