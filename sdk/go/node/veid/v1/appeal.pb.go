// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/veid/v1/appeal.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/msgservice"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// AppealStatus represents the current state of an appeal
type AppealStatus int32

const (
	// APPEAL_STATUS_UNSPECIFIED is the default unspecified status
	AppealStatusUnspecified AppealStatus = 0
	// APPEAL_STATUS_PENDING indicates the appeal has been submitted and awaits review
	AppealStatusPending AppealStatus = 1
	// APPEAL_STATUS_REVIEWING indicates an arbitrator has claimed the appeal for review
	AppealStatusReviewing AppealStatus = 2
	// APPEAL_STATUS_APPROVED indicates the appeal was approved
	AppealStatusApproved AppealStatus = 3
	// APPEAL_STATUS_REJECTED indicates the appeal was rejected
	AppealStatusRejected AppealStatus = 4
	// APPEAL_STATUS_WITHDRAWN indicates the submitter withdrew their appeal
	AppealStatusWithdrawn AppealStatus = 5
	// APPEAL_STATUS_EXPIRED indicates the appeal expired without resolution
	AppealStatusExpired AppealStatus = 6
)

var AppealStatus_name = map[int32]string{
	0: "APPEAL_STATUS_UNSPECIFIED",
	1: "APPEAL_STATUS_PENDING",
	2: "APPEAL_STATUS_REVIEWING",
	3: "APPEAL_STATUS_APPROVED",
	4: "APPEAL_STATUS_REJECTED",
	5: "APPEAL_STATUS_WITHDRAWN",
	6: "APPEAL_STATUS_EXPIRED",
}

var AppealStatus_value = map[string]int32{
	"APPEAL_STATUS_UNSPECIFIED": 0,
	"APPEAL_STATUS_PENDING":     1,
	"APPEAL_STATUS_REVIEWING":   2,
	"APPEAL_STATUS_APPROVED":    3,
	"APPEAL_STATUS_REJECTED":    4,
	"APPEAL_STATUS_WITHDRAWN":   5,
	"APPEAL_STATUS_EXPIRED":     6,
}

func (x AppealStatus) String() string {
	return proto.EnumName(AppealStatus_name, int32(x))
}

func (AppealStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{0}
}

// AppealRecord tracks an appeal against a verification decision
type AppealRecord struct {
	// AppealID is the unique identifier for this appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// AccountAddress is the address of the account filing the appeal
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeID is the scope whose verification decision is being appealed
	ScopeId string `protobuf:"bytes,3,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// OriginalStatus is the verification status that prompted the appeal
	OriginalStatus string `protobuf:"bytes,4,opt,name=original_status,json=originalStatus,proto3" json:"original_status" yaml:"original_status"`
	// OriginalScore is the verification score at the time of appeal
	OriginalScore uint32 `protobuf:"varint,5,opt,name=original_score,json=originalScore,proto3" json:"original_score" yaml:"original_score"`
	// AppealReason is the user's explanation for why they are appealing
	AppealReason string `protobuf:"bytes,6,opt,name=appeal_reason,json=appealReason,proto3" json:"appeal_reason" yaml:"appeal_reason"`
	// EvidenceHashes are hashes of supporting evidence documents
	EvidenceHashes []string `protobuf:"bytes,7,rep,name=evidence_hashes,json=evidenceHashes,proto3" json:"evidence_hashes" yaml:"evidence_hashes"`
	// SubmittedAt is the block height when the appeal was submitted
	SubmittedAt int64 `protobuf:"varint,8,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at" yaml:"submitted_at"`
	// SubmittedAtTime is the Unix timestamp when the appeal was submitted
	SubmittedAtTime int64 `protobuf:"varint,9,opt,name=submitted_at_time,json=submittedAtTime,proto3" json:"submitted_at_time" yaml:"submitted_at_time"`
	// Status is the current status of the appeal
	Status AppealStatus `protobuf:"varint,10,opt,name=status,proto3,enum=virtengine.veid.v1.AppealStatus" json:"status" yaml:"status"`
	// ReviewerAddress is the address of the arbitrator reviewing the appeal
	ReviewerAddress string `protobuf:"bytes,11,opt,name=reviewer_address,json=reviewerAddress,proto3" json:"reviewer_address" yaml:"reviewer_address"`
	// ClaimedAt is the block height when the appeal was claimed for review
	ClaimedAt int64 `protobuf:"varint,12,opt,name=claimed_at,json=claimedAt,proto3" json:"claimed_at" yaml:"claimed_at"`
	// ReviewedAt is the block height when the appeal was resolved
	ReviewedAt int64 `protobuf:"varint,13,opt,name=reviewed_at,json=reviewedAt,proto3" json:"reviewed_at" yaml:"reviewed_at"`
	// ReviewedAtTime is the Unix timestamp when the appeal was resolved
	ReviewedAtTime int64 `protobuf:"varint,14,opt,name=reviewed_at_time,json=reviewedAtTime,proto3" json:"reviewed_at_time" yaml:"reviewed_at_time"`
	// ResolutionReason is the arbitrator's explanation for the decision
	ResolutionReason string `protobuf:"bytes,15,opt,name=resolution_reason,json=resolutionReason,proto3" json:"resolution_reason" yaml:"resolution_reason"`
	// ScoreAdjustment is the adjustment to the verification score
	ScoreAdjustment int32 `protobuf:"varint,16,opt,name=score_adjustment,json=scoreAdjustment,proto3" json:"score_adjustment" yaml:"score_adjustment"`
	// AppealNumber tracks which appeal this is for the scope (1st, 2nd, 3rd)
	AppealNumber uint32 `protobuf:"varint,17,opt,name=appeal_number,json=appealNumber,proto3" json:"appeal_number" yaml:"appeal_number"`
}

func (m *AppealRecord) Reset()         { *m = AppealRecord{} }
func (m *AppealRecord) String() string { return proto.CompactTextString(m) }
func (*AppealRecord) ProtoMessage()    {}
func (*AppealRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{0}
}
func (m *AppealRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppealRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppealRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppealRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppealRecord.Merge(m, src)
}
func (m *AppealRecord) XXX_Size() int {
	return m.Size()
}
func (m *AppealRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AppealRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AppealRecord proto.InternalMessageInfo

func (m *AppealRecord) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *AppealRecord) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *AppealRecord) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *AppealRecord) GetOriginalStatus() string {
	if m != nil {
		return m.OriginalStatus
	}
	return ""
}

func (m *AppealRecord) GetOriginalScore() uint32 {
	if m != nil {
		return m.OriginalScore
	}
	return 0
}

func (m *AppealRecord) GetAppealReason() string {
	if m != nil {
		return m.AppealReason
	}
	return ""
}

func (m *AppealRecord) GetEvidenceHashes() []string {
	if m != nil {
		return m.EvidenceHashes
	}
	return nil
}

func (m *AppealRecord) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

func (m *AppealRecord) GetSubmittedAtTime() int64 {
	if m != nil {
		return m.SubmittedAtTime
	}
	return 0
}

func (m *AppealRecord) GetStatus() AppealStatus {
	if m != nil {
		return m.Status
	}
	return AppealStatusUnspecified
}

func (m *AppealRecord) GetReviewerAddress() string {
	if m != nil {
		return m.ReviewerAddress
	}
	return ""
}

func (m *AppealRecord) GetClaimedAt() int64 {
	if m != nil {
		return m.ClaimedAt
	}
	return 0
}

func (m *AppealRecord) GetReviewedAt() int64 {
	if m != nil {
		return m.ReviewedAt
	}
	return 0
}

func (m *AppealRecord) GetReviewedAtTime() int64 {
	if m != nil {
		return m.ReviewedAtTime
	}
	return 0
}

func (m *AppealRecord) GetResolutionReason() string {
	if m != nil {
		return m.ResolutionReason
	}
	return ""
}

func (m *AppealRecord) GetScoreAdjustment() int32 {
	if m != nil {
		return m.ScoreAdjustment
	}
	return 0
}

func (m *AppealRecord) GetAppealNumber() uint32 {
	if m != nil {
		return m.AppealNumber
	}
	return 0
}

// AppealParams defines the parameters for the appeal system
type AppealParams struct {
	// AppealWindowBlocks is how long after rejection can user appeal
	AppealWindowBlocks int64 `protobuf:"varint,1,opt,name=appeal_window_blocks,json=appealWindowBlocks,proto3" json:"appeal_window_blocks" yaml:"appeal_window_blocks"`
	// MaxAppealsPerScope is the maximum appeals allowed per scope
	MaxAppealsPerScope uint32 `protobuf:"varint,2,opt,name=max_appeals_per_scope,json=maxAppealsPerScope,proto3" json:"max_appeals_per_scope" yaml:"max_appeals_per_scope"`
	// MinAppealReasonLength is the minimum characters for appeal reason
	MinAppealReasonLength uint32 `protobuf:"varint,3,opt,name=min_appeal_reason_length,json=minAppealReasonLength,proto3" json:"min_appeal_reason_length" yaml:"min_appeal_reason_length"`
	// ReviewTimeoutBlocks is how long an appeal can stay in reviewing status
	ReviewTimeoutBlocks int64 `protobuf:"varint,4,opt,name=review_timeout_blocks,json=reviewTimeoutBlocks,proto3" json:"review_timeout_blocks" yaml:"review_timeout_blocks"`
	// Enabled indicates whether the appeal system is active
	Enabled bool `protobuf:"varint,5,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
	// RequireEscrowDeposit indicates whether appeals require a deposit
	RequireEscrowDeposit bool `protobuf:"varint,6,opt,name=require_escrow_deposit,json=requireEscrowDeposit,proto3" json:"require_escrow_deposit" yaml:"require_escrow_deposit"`
	// EscrowDepositAmount is the deposit amount required (in base units)
	EscrowDepositAmount int64 `protobuf:"varint,7,opt,name=escrow_deposit_amount,json=escrowDepositAmount,proto3" json:"escrow_deposit_amount" yaml:"escrow_deposit_amount"`
}

func (m *AppealParams) Reset()         { *m = AppealParams{} }
func (m *AppealParams) String() string { return proto.CompactTextString(m) }
func (*AppealParams) ProtoMessage()    {}
func (*AppealParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{1}
}
func (m *AppealParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppealParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppealParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppealParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppealParams.Merge(m, src)
}
func (m *AppealParams) XXX_Size() int {
	return m.Size()
}
func (m *AppealParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AppealParams.DiscardUnknown(m)
}

var xxx_messageInfo_AppealParams proto.InternalMessageInfo

func (m *AppealParams) GetAppealWindowBlocks() int64 {
	if m != nil {
		return m.AppealWindowBlocks
	}
	return 0
}

func (m *AppealParams) GetMaxAppealsPerScope() uint32 {
	if m != nil {
		return m.MaxAppealsPerScope
	}
	return 0
}

func (m *AppealParams) GetMinAppealReasonLength() uint32 {
	if m != nil {
		return m.MinAppealReasonLength
	}
	return 0
}

func (m *AppealParams) GetReviewTimeoutBlocks() int64 {
	if m != nil {
		return m.ReviewTimeoutBlocks
	}
	return 0
}

func (m *AppealParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AppealParams) GetRequireEscrowDeposit() bool {
	if m != nil {
		return m.RequireEscrowDeposit
	}
	return false
}

func (m *AppealParams) GetEscrowDepositAmount() int64 {
	if m != nil {
		return m.EscrowDepositAmount
	}
	return 0
}

// AppealSummary provides a summary of appeals for an account
type AppealSummary struct {
	// TotalAppeals is the total number of appeals
	TotalAppeals uint32 `protobuf:"varint,1,opt,name=total_appeals,json=totalAppeals,proto3" json:"total_appeals" yaml:"total_appeals"`
	// PendingAppeals is the number of pending appeals
	PendingAppeals uint32 `protobuf:"varint,2,opt,name=pending_appeals,json=pendingAppeals,proto3" json:"pending_appeals" yaml:"pending_appeals"`
	// ApprovedAppeals is the number of approved appeals
	ApprovedAppeals uint32 `protobuf:"varint,3,opt,name=approved_appeals,json=approvedAppeals,proto3" json:"approved_appeals" yaml:"approved_appeals"`
	// RejectedAppeals is the number of rejected appeals
	RejectedAppeals uint32 `protobuf:"varint,4,opt,name=rejected_appeals,json=rejectedAppeals,proto3" json:"rejected_appeals" yaml:"rejected_appeals"`
	// WithdrawnAppeals is the number of withdrawn appeals
	WithdrawnAppeals uint32 `protobuf:"varint,5,opt,name=withdrawn_appeals,json=withdrawnAppeals,proto3" json:"withdrawn_appeals" yaml:"withdrawn_appeals"`
}

func (m *AppealSummary) Reset()         { *m = AppealSummary{} }
func (m *AppealSummary) String() string { return proto.CompactTextString(m) }
func (*AppealSummary) ProtoMessage()    {}
func (*AppealSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{2}
}
func (m *AppealSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppealSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppealSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppealSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppealSummary.Merge(m, src)
}
func (m *AppealSummary) XXX_Size() int {
	return m.Size()
}
func (m *AppealSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_AppealSummary.DiscardUnknown(m)
}

var xxx_messageInfo_AppealSummary proto.InternalMessageInfo

func (m *AppealSummary) GetTotalAppeals() uint32 {
	if m != nil {
		return m.TotalAppeals
	}
	return 0
}

func (m *AppealSummary) GetPendingAppeals() uint32 {
	if m != nil {
		return m.PendingAppeals
	}
	return 0
}

func (m *AppealSummary) GetApprovedAppeals() uint32 {
	if m != nil {
		return m.ApprovedAppeals
	}
	return 0
}

func (m *AppealSummary) GetRejectedAppeals() uint32 {
	if m != nil {
		return m.RejectedAppeals
	}
	return 0
}

func (m *AppealSummary) GetWithdrawnAppeals() uint32 {
	if m != nil {
		return m.WithdrawnAppeals
	}
	return 0
}

// MsgSubmitAppeal is the message to submit an appeal against a verification decision
type MsgSubmitAppeal struct {
	// Submitter is the account address submitting the appeal (must own the scope)
	Submitter string `protobuf:"bytes,1,opt,name=submitter,proto3" json:"submitter" yaml:"submitter"`
	// ScopeID is the scope whose verification decision is being appealed
	ScopeId string `protobuf:"bytes,2,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// Reason is the explanation for why the submitter is appealing
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	// EvidenceHashes are hashes of supporting evidence documents
	EvidenceHashes []string `protobuf:"bytes,4,rep,name=evidence_hashes,json=evidenceHashes,proto3" json:"evidence_hashes" yaml:"evidence_hashes"`
}

func (m *MsgSubmitAppeal) Reset()         { *m = MsgSubmitAppeal{} }
func (m *MsgSubmitAppeal) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAppeal) ProtoMessage()    {}
func (*MsgSubmitAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{3}
}
func (m *MsgSubmitAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAppeal.Merge(m, src)
}
func (m *MsgSubmitAppeal) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAppeal proto.InternalMessageInfo

func (m *MsgSubmitAppeal) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *MsgSubmitAppeal) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *MsgSubmitAppeal) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgSubmitAppeal) GetEvidenceHashes() []string {
	if m != nil {
		return m.EvidenceHashes
	}
	return nil
}

// MsgSubmitAppealResponse is the response for MsgSubmitAppeal
type MsgSubmitAppealResponse struct {
	// AppealID is the unique identifier for the created appeal
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// Status is the initial status of the appeal
	Status AppealStatus `protobuf:"varint,2,opt,name=status,proto3,enum=virtengine.veid.v1.AppealStatus" json:"status" yaml:"status"`
	// AppealNumber is which appeal this is for the scope
	AppealNumber uint32 `protobuf:"varint,3,opt,name=appeal_number,json=appealNumber,proto3" json:"appeal_number" yaml:"appeal_number"`
	// SubmittedAt is the block height when submitted
	SubmittedAt int64 `protobuf:"varint,4,opt,name=submitted_at,json=submittedAt,proto3" json:"submitted_at" yaml:"submitted_at"`
}

func (m *MsgSubmitAppealResponse) Reset()         { *m = MsgSubmitAppealResponse{} }
func (m *MsgSubmitAppealResponse) String() string { return proto.CompactTextString(m) }
func (*MsgSubmitAppealResponse) ProtoMessage()    {}
func (*MsgSubmitAppealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{4}
}
func (m *MsgSubmitAppealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgSubmitAppealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgSubmitAppealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgSubmitAppealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgSubmitAppealResponse.Merge(m, src)
}
func (m *MsgSubmitAppealResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgSubmitAppealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgSubmitAppealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgSubmitAppealResponse proto.InternalMessageInfo

func (m *MsgSubmitAppealResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *MsgSubmitAppealResponse) GetStatus() AppealStatus {
	if m != nil {
		return m.Status
	}
	return AppealStatusUnspecified
}

func (m *MsgSubmitAppealResponse) GetAppealNumber() uint32 {
	if m != nil {
		return m.AppealNumber
	}
	return 0
}

func (m *MsgSubmitAppealResponse) GetSubmittedAt() int64 {
	if m != nil {
		return m.SubmittedAt
	}
	return 0
}

// MsgClaimAppeal is the message for an arbitrator to claim an appeal for review
type MsgClaimAppeal struct {
	// Reviewer is the arbitrator claiming the appeal
	Reviewer string `protobuf:"bytes,1,opt,name=reviewer,proto3" json:"reviewer" yaml:"reviewer"`
	// AppealID is the appeal being claimed
	AppealId string `protobuf:"bytes,2,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
}

func (m *MsgClaimAppeal) Reset()         { *m = MsgClaimAppeal{} }
func (m *MsgClaimAppeal) String() string { return proto.CompactTextString(m) }
func (*MsgClaimAppeal) ProtoMessage()    {}
func (*MsgClaimAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{5}
}
func (m *MsgClaimAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimAppeal.Merge(m, src)
}
func (m *MsgClaimAppeal) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimAppeal proto.InternalMessageInfo

func (m *MsgClaimAppeal) GetReviewer() string {
	if m != nil {
		return m.Reviewer
	}
	return ""
}

func (m *MsgClaimAppeal) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

// MsgClaimAppealResponse is the response for MsgClaimAppeal
type MsgClaimAppealResponse struct {
	// AppealID is the claimed appeal ID
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// ClaimedAt is the block height when claimed
	ClaimedAt int64 `protobuf:"varint,2,opt,name=claimed_at,json=claimedAt,proto3" json:"claimed_at" yaml:"claimed_at"`
}

func (m *MsgClaimAppealResponse) Reset()         { *m = MsgClaimAppealResponse{} }
func (m *MsgClaimAppealResponse) String() string { return proto.CompactTextString(m) }
func (*MsgClaimAppealResponse) ProtoMessage()    {}
func (*MsgClaimAppealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{6}
}
func (m *MsgClaimAppealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgClaimAppealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgClaimAppealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgClaimAppealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgClaimAppealResponse.Merge(m, src)
}
func (m *MsgClaimAppealResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgClaimAppealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgClaimAppealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgClaimAppealResponse proto.InternalMessageInfo

func (m *MsgClaimAppealResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *MsgClaimAppealResponse) GetClaimedAt() int64 {
	if m != nil {
		return m.ClaimedAt
	}
	return 0
}

// MsgResolveAppeal is the message to resolve an appeal
type MsgResolveAppeal struct {
	// Resolver is the arbitrator resolving the appeal
	Resolver string `protobuf:"bytes,1,opt,name=resolver,proto3" json:"resolver" yaml:"resolver"`
	// AppealID is the appeal being resolved
	AppealId string `protobuf:"bytes,2,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// Resolution is the resolution status (approved or rejected)
	Resolution AppealStatus `protobuf:"varint,3,opt,name=resolution,proto3,enum=virtengine.veid.v1.AppealStatus" json:"resolution" yaml:"resolution"`
	// Reason is the explanation for the resolution decision
	Reason string `protobuf:"bytes,4,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	// ScoreAdjustment is the adjustment to the verification score
	ScoreAdjustment int32 `protobuf:"varint,5,opt,name=score_adjustment,json=scoreAdjustment,proto3" json:"score_adjustment" yaml:"score_adjustment"`
}

func (m *MsgResolveAppeal) Reset()         { *m = MsgResolveAppeal{} }
func (m *MsgResolveAppeal) String() string { return proto.CompactTextString(m) }
func (*MsgResolveAppeal) ProtoMessage()    {}
func (*MsgResolveAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{7}
}
func (m *MsgResolveAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveAppeal.Merge(m, src)
}
func (m *MsgResolveAppeal) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveAppeal proto.InternalMessageInfo

func (m *MsgResolveAppeal) GetResolver() string {
	if m != nil {
		return m.Resolver
	}
	return ""
}

func (m *MsgResolveAppeal) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *MsgResolveAppeal) GetResolution() AppealStatus {
	if m != nil {
		return m.Resolution
	}
	return AppealStatusUnspecified
}

func (m *MsgResolveAppeal) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *MsgResolveAppeal) GetScoreAdjustment() int32 {
	if m != nil {
		return m.ScoreAdjustment
	}
	return 0
}

// MsgResolveAppealResponse is the response for MsgResolveAppeal
type MsgResolveAppealResponse struct {
	// AppealID is the resolved appeal ID
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// Resolution is the final resolution status
	Resolution AppealStatus `protobuf:"varint,2,opt,name=resolution,proto3,enum=virtengine.veid.v1.AppealStatus" json:"resolution" yaml:"resolution"`
	// ResolvedAt is the block height when resolved
	ResolvedAt int64 `protobuf:"varint,3,opt,name=resolved_at,json=resolvedAt,proto3" json:"resolved_at" yaml:"resolved_at"`
}

func (m *MsgResolveAppealResponse) Reset()         { *m = MsgResolveAppealResponse{} }
func (m *MsgResolveAppealResponse) String() string { return proto.CompactTextString(m) }
func (*MsgResolveAppealResponse) ProtoMessage()    {}
func (*MsgResolveAppealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{8}
}
func (m *MsgResolveAppealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResolveAppealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResolveAppealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResolveAppealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResolveAppealResponse.Merge(m, src)
}
func (m *MsgResolveAppealResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgResolveAppealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResolveAppealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResolveAppealResponse proto.InternalMessageInfo

func (m *MsgResolveAppealResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *MsgResolveAppealResponse) GetResolution() AppealStatus {
	if m != nil {
		return m.Resolution
	}
	return AppealStatusUnspecified
}

func (m *MsgResolveAppealResponse) GetResolvedAt() int64 {
	if m != nil {
		return m.ResolvedAt
	}
	return 0
}

// MsgWithdrawAppeal allows the submitter to withdraw their appeal
type MsgWithdrawAppeal struct {
	// Submitter is the original appeal submitter
	Submitter string `protobuf:"bytes,1,opt,name=submitter,proto3" json:"submitter" yaml:"submitter"`
	// AppealID is the appeal to withdraw
	AppealId string `protobuf:"bytes,2,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
}

func (m *MsgWithdrawAppeal) Reset()         { *m = MsgWithdrawAppeal{} }
func (m *MsgWithdrawAppeal) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawAppeal) ProtoMessage()    {}
func (*MsgWithdrawAppeal) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{9}
}
func (m *MsgWithdrawAppeal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawAppeal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawAppeal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawAppeal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawAppeal.Merge(m, src)
}
func (m *MsgWithdrawAppeal) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawAppeal) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawAppeal.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawAppeal proto.InternalMessageInfo

func (m *MsgWithdrawAppeal) GetSubmitter() string {
	if m != nil {
		return m.Submitter
	}
	return ""
}

func (m *MsgWithdrawAppeal) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

// MsgWithdrawAppealResponse is the response for MsgWithdrawAppeal
type MsgWithdrawAppealResponse struct {
	// AppealID is the withdrawn appeal ID
	AppealId string `protobuf:"bytes,1,opt,name=appeal_id,json=appealId,proto3" json:"appeal_id" yaml:"appeal_id"`
	// WithdrawnAt is the block height when withdrawn
	WithdrawnAt int64 `protobuf:"varint,2,opt,name=withdrawn_at,json=withdrawnAt,proto3" json:"withdrawn_at" yaml:"withdrawn_at"`
}

func (m *MsgWithdrawAppealResponse) Reset()         { *m = MsgWithdrawAppealResponse{} }
func (m *MsgWithdrawAppealResponse) String() string { return proto.CompactTextString(m) }
func (*MsgWithdrawAppealResponse) ProtoMessage()    {}
func (*MsgWithdrawAppealResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9a67efe0d715962e, []int{10}
}
func (m *MsgWithdrawAppealResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgWithdrawAppealResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgWithdrawAppealResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgWithdrawAppealResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgWithdrawAppealResponse.Merge(m, src)
}
func (m *MsgWithdrawAppealResponse) XXX_Size() int {
	return m.Size()
}
func (m *MsgWithdrawAppealResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgWithdrawAppealResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MsgWithdrawAppealResponse proto.InternalMessageInfo

func (m *MsgWithdrawAppealResponse) GetAppealId() string {
	if m != nil {
		return m.AppealId
	}
	return ""
}

func (m *MsgWithdrawAppealResponse) GetWithdrawnAt() int64 {
	if m != nil {
		return m.WithdrawnAt
	}
	return 0
}

func init() {
	proto.RegisterEnum("virtengine.veid.v1.AppealStatus", AppealStatus_name, AppealStatus_value)
	proto.RegisterType((*AppealRecord)(nil), "virtengine.veid.v1.AppealRecord")
	proto.RegisterType((*AppealParams)(nil), "virtengine.veid.v1.AppealParams")
	proto.RegisterType((*AppealSummary)(nil), "virtengine.veid.v1.AppealSummary")
	proto.RegisterType((*MsgSubmitAppeal)(nil), "virtengine.veid.v1.MsgSubmitAppeal")
	proto.RegisterType((*MsgSubmitAppealResponse)(nil), "virtengine.veid.v1.MsgSubmitAppealResponse")
	proto.RegisterType((*MsgClaimAppeal)(nil), "virtengine.veid.v1.MsgClaimAppeal")
	proto.RegisterType((*MsgClaimAppealResponse)(nil), "virtengine.veid.v1.MsgClaimAppealResponse")
	proto.RegisterType((*MsgResolveAppeal)(nil), "virtengine.veid.v1.MsgResolveAppeal")
	proto.RegisterType((*MsgResolveAppealResponse)(nil), "virtengine.veid.v1.MsgResolveAppealResponse")
	proto.RegisterType((*MsgWithdrawAppeal)(nil), "virtengine.veid.v1.MsgWithdrawAppeal")
	proto.RegisterType((*MsgWithdrawAppealResponse)(nil), "virtengine.veid.v1.MsgWithdrawAppealResponse")
}

func init() { proto.RegisterFile("virtengine/veid/v1/appeal.proto", fileDescriptor_9a67efe0d715962e) }

var fileDescriptor_9a67efe0d715962e = []byte{
	// 1775 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0xcb, 0x6f, 0xdb, 0xc8,
	0x19, 0xb7, 0x1e, 0x7e, 0x8d, 0xad, 0x87, 0xe9, 0x97, 0xec, 0x74, 0x3d, 0xea, 0x14, 0x45, 0xbd,
	0x59, 0xc4, 0x42, 0x76, 0x17, 0x5d, 0xd4, 0x05, 0x5a, 0x48, 0xb1, 0x76, 0x57, 0xc1, 0xda, 0x15,
	0x46, 0x76, 0xdc, 0x06, 0xe8, 0x12, 0xb4, 0x38, 0x95, 0xb9, 0x2b, 0x92, 0x5a, 0x92, 0x92, 0x9d,
	0x6b, 0x4f, 0xad, 0x4f, 0x3d, 0xf4, 0x58, 0x03, 0x01, 0x7a, 0xe8, 0x35, 0x87, 0x5e, 0x7b, 0xef,
	0x21, 0x87, 0xa0, 0x40, 0x81, 0x02, 0x05, 0x88, 0x20, 0x39, 0x24, 0xe0, 0xad, 0xfa, 0x0b, 0x0a,
	0xce, 0x0c, 0x39, 0x7c, 0xc8, 0x8b, 0x24, 0x76, 0x2e, 0x86, 0xe7, 0xf7, 0x9b, 0xef, 0x9b, 0x99,
	0xef, 0x4d, 0x01, 0x38, 0xd2, 0x2c, 0x87, 0x18, 0x3d, 0xcd, 0x20, 0xb5, 0x11, 0xd1, 0xd4, 0xda,
	0xe8, 0x6e, 0x4d, 0x19, 0x0c, 0x88, 0xd2, 0xdf, 0x19, 0x58, 0xa6, 0x63, 0x4a, 0x92, 0xd8, 0xb0,
	0xe3, 0x6f, 0xd8, 0x19, 0xdd, 0xdd, 0x5c, 0xe9, 0x99, 0x3d, 0x93, 0xd2, 0x35, 0xff, 0x3f, 0xb6,
	0x73, 0x73, 0xa3, 0x6b, 0xda, 0xba, 0x69, 0xcb, 0x8c, 0x60, 0x0b, 0x4e, 0xad, 0xb3, 0x55, 0x4d,
	0xb7, 0x7b, 0xfe, 0x01, 0xba, 0xdd, 0xe3, 0xc4, 0x92, 0xa2, 0x6b, 0x86, 0x59, 0xa3, 0x7f, 0x19,
	0x84, 0xfe, 0xb1, 0x00, 0x16, 0xeb, 0xf4, 0x06, 0x98, 0x74, 0x4d, 0x4b, 0x95, 0x7e, 0x01, 0xe6,
	0xd9, 0x8d, 0x64, 0x4d, 0xad, 0x64, 0xaa, 0x99, 0xed, 0xf9, 0xc6, 0x0f, 0x3d, 0x17, 0x0a, 0x70,
	0xec, 0xc2, 0xf2, 0x23, 0x45, 0xef, 0xef, 0xa2, 0x10, 0x42, 0x78, 0x8e, 0xfd, 0xdf, 0x52, 0x25,
	0x03, 0x94, 0x94, 0x6e, 0xd7, 0x1c, 0x1a, 0x8e, 0xac, 0xa8, 0xaa, 0x45, 0x6c, 0xbb, 0x92, 0xa5,
	0x5a, 0x9a, 0x9e, 0x0b, 0x93, 0xd4, 0xd8, 0x85, 0x6b, 0x5c, 0x57, 0x9c, 0x40, 0xff, 0xfa, 0xfb,
	0x9d, 0x15, 0xfe, 0xa8, 0x3a, 0x83, 0x3a, 0x8e, 0xa5, 0x19, 0x3d, 0x5c, 0xe4, 0x3b, 0x39, 0x2a,
	0xed, 0x82, 0x39, 0xbb, 0x6b, 0x0e, 0x88, 0x7f, 0xdd, 0x1c, 0x3d, 0x08, 0x7a, 0x2e, 0x0c, 0xb1,
	0xb1, 0x0b, 0x4b, 0xec, 0x84, 0x00, 0x41, 0x78, 0x96, 0xfe, 0xdb, 0x52, 0xa5, 0x07, 0xa0, 0x64,
	0x5a, 0x5a, 0x4f, 0x33, 0x94, 0xbe, 0x6c, 0x3b, 0x8a, 0x33, 0xb4, 0x2b, 0x79, 0xaa, 0xe2, 0x8e,
	0x7f, 0xd7, 0x04, 0x25, 0xee, 0x9a, 0x20, 0x10, 0x2e, 0x06, 0x48, 0x87, 0x02, 0x12, 0x06, 0x45,
	0xb1, 0xa7, 0x6b, 0x5a, 0xa4, 0x32, 0x5d, 0xcd, 0x6c, 0x17, 0x1a, 0x1f, 0x79, 0x2e, 0x4c, 0x30,
	0x63, 0x17, 0xae, 0x26, 0xb5, 0xfa, 0x38, 0xc2, 0x85, 0x50, 0xa9, 0xbf, 0x96, 0x0e, 0x40, 0x81,
	0xdb, 0xdb, 0x22, 0x8a, 0x6d, 0x1a, 0x95, 0x19, 0x7a, 0xd3, 0x0f, 0x3d, 0x17, 0xc6, 0x89, 0xb1,
	0x0b, 0x57, 0x62, 0xfe, 0x61, 0x30, 0xc2, 0x8b, 0x0a, 0xf7, 0xb3, 0xbf, 0xf4, 0xdf, 0x4e, 0x46,
	0x9a, 0x4a, 0x8c, 0x2e, 0x91, 0x4f, 0x15, 0xfb, 0x94, 0xd8, 0x95, 0xd9, 0x6a, 0x2e, 0x78, 0x7b,
	0x82, 0x12, 0x6f, 0x4f, 0x10, 0x08, 0x17, 0x03, 0xe4, 0x4b, 0x0a, 0x48, 0xf7, 0xc1, 0xa2, 0x3d,
	0x3c, 0xd1, 0x35, 0xc7, 0x21, 0xaa, 0xac, 0x38, 0x95, 0xb9, 0x6a, 0x66, 0x3b, 0xd7, 0xf8, 0x89,
	0xe7, 0xc2, 0x18, 0x3e, 0x76, 0xe1, 0x32, 0xf7, 0x4b, 0x04, 0x45, 0x78, 0x21, 0x5c, 0xd6, 0x1d,
	0xe9, 0xb7, 0x60, 0x29, 0xca, 0xca, 0x8e, 0xa6, 0x93, 0xca, 0x3c, 0x55, 0x78, 0xd7, 0x73, 0x61,
	0x9a, 0x1c, 0xbb, 0xb0, 0x92, 0xd6, 0x4a, 0x29, 0x84, 0x4b, 0x11, 0xd5, 0x87, 0x9a, 0x4e, 0xa4,
	0x23, 0x30, 0xc3, 0xbd, 0x0e, 0xaa, 0x99, 0xed, 0xe2, 0xc7, 0xd5, 0x9d, 0x74, 0xf6, 0xed, 0xb0,
	0xe4, 0x60, 0x8e, 0x6d, 0xdc, 0xf2, 0x5c, 0x38, 0x13, 0x86, 0x43, 0x81, 0x1f, 0xc5, 0xa3, 0x80,
	0x13, 0x92, 0x05, 0xca, 0x16, 0x19, 0x69, 0xe4, 0x8c, 0x58, 0x61, 0x0a, 0x2c, 0x50, 0x67, 0x7d,
	0xe1, 0xb9, 0x30, 0xc5, 0x8d, 0x5d, 0xb8, 0xce, 0x14, 0x25, 0x99, 0xab, 0x93, 0xa0, 0x14, 0x6c,
	0x0d, 0xb2, 0xa0, 0x01, 0x40, 0xb7, 0xaf, 0x68, 0x3a, 0xb3, 0xf9, 0x22, 0x35, 0xd1, 0x8f, 0x3c,
	0x17, 0x46, 0xd0, 0xb1, 0x0b, 0x97, 0xd8, 0x39, 0x02, 0x43, 0x78, 0x9e, 0x2f, 0xea, 0x8e, 0xf4,
	0x39, 0x58, 0xe0, 0x6a, 0xa9, 0x92, 0x02, 0x55, 0xf2, 0x63, 0xcf, 0x85, 0x51, 0x78, 0xec, 0x42,
	0x29, 0x76, 0x5b, 0xa6, 0x06, 0x04, 0xab, 0xba, 0x23, 0xfd, 0x26, 0x7c, 0xbf, 0x70, 0x5a, 0x91,
	0x2a, 0xab, 0x45, 0xde, 0x1f, 0xf5, 0xd9, 0x7a, 0x4a, 0x23, 0x77, 0x59, 0x51, 0xa8, 0xa5, 0x1e,
	0xfb, 0x1a, 0x2c, 0x59, 0xc4, 0x36, 0xfb, 0x43, 0x47, 0x33, 0x8d, 0x20, 0x11, 0x4a, 0xd4, 0xb6,
	0x34, 0x20, 0x52, 0xa4, 0x08, 0x88, 0x14, 0x85, 0x70, 0x59, 0x60, 0x3c, 0x29, 0x1e, 0x82, 0x32,
	0xcd, 0x3e, 0x59, 0x51, 0xbf, 0x19, 0xda, 0x8e, 0x4e, 0x0c, 0xa7, 0x52, 0xae, 0x66, 0xb6, 0xa7,
	0xd9, 0xd5, 0x93, 0x9c, 0xb8, 0x7a, 0x92, 0xf1, 0xa3, 0xcd, 0x87, 0xea, 0x21, 0x12, 0x49, 0x60,
	0x63, 0xa8, 0x9f, 0x10, 0xab, 0xb2, 0x44, 0x6b, 0x42, 0x34, 0x81, 0x19, 0x91, 0x4a, 0x60, 0x06,
	0x87, 0x09, 0x7c, 0x40, 0x97, 0xbb, 0xf9, 0xd7, 0x8f, 0x61, 0x06, 0xfd, 0x6f, 0x3a, 0xa8, 0xdf,
	0x6d, 0xc5, 0x52, 0x74, 0x5b, 0xd2, 0xc0, 0x0a, 0x17, 0x3b, 0xd3, 0x0c, 0xd5, 0x3c, 0x93, 0x4f,
	0xfa, 0x66, 0xf7, 0x5b, 0x9b, 0x96, 0xf2, 0x5c, 0xe3, 0x33, 0xcf, 0x85, 0x13, 0xf9, 0xb1, 0x0b,
	0x6f, 0xc5, 0x0e, 0x8d, 0xb1, 0x08, 0x4b, 0x0c, 0x3e, 0xa6, 0x68, 0x83, 0x82, 0x52, 0x1f, 0xac,
	0xea, 0xca, 0xb9, 0xcc, 0x18, 0x5b, 0x1e, 0x10, 0x4b, 0xa6, 0x95, 0x95, 0x16, 0xfc, 0x42, 0xe3,
	0x67, 0x9e, 0x0b, 0x27, 0x6f, 0x18, 0xbb, 0xf0, 0x07, 0xec, 0xb0, 0x89, 0x34, 0xc2, 0x92, 0xae,
	0x9c, 0xb3, 0x57, 0xd9, 0x6d, 0x62, 0x75, 0x7c, 0x50, 0x3a, 0x07, 0x15, 0x5d, 0x33, 0xe4, 0x58,
	0x51, 0x93, 0xfb, 0xc4, 0xe8, 0x39, 0xa7, 0xb4, 0xf0, 0x17, 0x1a, 0xbf, 0xf4, 0x5c, 0x78, 0xe5,
	0x9e, 0xb1, 0x0b, 0x21, 0x3f, 0xf3, 0x8a, 0x1d, 0x08, 0xaf, 0xea, 0x9a, 0x51, 0x8f, 0x14, 0xc9,
	0xaf, 0x28, 0x2e, 0xe9, 0x60, 0x95, 0xc5, 0x21, 0x8d, 0x4a, 0x73, 0xe8, 0x04, 0x36, 0xcd, 0x53,
	0x9b, 0xd2, 0x77, 0x4e, 0xdc, 0x20, 0xde, 0x39, 0x91, 0x46, 0x78, 0x99, 0xe1, 0x87, 0x0c, 0xe6,
	0x66, 0xfd, 0x0c, 0xcc, 0x12, 0x43, 0x39, 0xe9, 0x13, 0x95, 0xb6, 0x8d, 0xb9, 0xc6, 0x07, 0x9e,
	0x0b, 0x03, 0x68, 0xec, 0xc2, 0x22, 0xaf, 0xc4, 0x0c, 0x40, 0x38, 0xa0, 0xa4, 0xef, 0xc0, 0x9a,
	0x45, 0xbe, 0x1b, 0x6a, 0x16, 0x91, 0x89, 0xdd, 0xb5, 0xcc, 0x33, 0x59, 0x25, 0x03, 0xd3, 0xd6,
	0x1c, 0xda, 0x2b, 0xe6, 0x1a, 0x3f, 0xf7, 0x5c, 0x78, 0xc5, 0x8e, 0xb1, 0x0b, 0x3f, 0x08, 0x6e,
	0x3a, 0x89, 0x47, 0x78, 0x85, 0x13, 0x4d, 0x8a, 0xef, 0x31, 0xd8, 0x37, 0x4d, 0x7c, 0xa3, 0xac,
	0xe8, 0x7e, 0x77, 0xae, 0xcc, 0x0a, 0xd3, 0x4c, 0xdc, 0x20, 0x4c, 0x33, 0x91, 0x46, 0x78, 0x99,
	0x44, 0x0f, 0xaa, 0x53, 0x94, 0xc7, 0xfc, 0xbf, 0x73, 0xa0, 0xc0, 0xcb, 0xf2, 0x50, 0xd7, 0x15,
	0xeb, 0x91, 0x9f, 0x5b, 0x8e, 0xe9, 0x28, 0xfd, 0x20, 0x96, 0x68, 0xb4, 0xf3, 0xdc, 0x8a, 0x11,
	0x22, 0xb7, 0x62, 0x30, 0xc2, 0x8b, 0x74, 0xcd, 0x63, 0xce, 0x6f, 0x8e, 0x03, 0x62, 0xa8, 0x9a,
	0xd1, 0x0b, 0x35, 0xb2, 0x98, 0xa6, 0xcd, 0x31, 0x41, 0x89, 0xe6, 0x98, 0x20, 0x10, 0x2e, 0x72,
	0x24, 0xd0, 0xfb, 0x10, 0x94, 0x95, 0xc1, 0xc0, 0x32, 0x47, 0x7e, 0x91, 0xe3, 0x8a, 0x59, 0xec,
	0xd2, 0xfa, 0x92, 0xe4, 0x44, 0x7d, 0x49, 0x32, 0x08, 0x97, 0x02, 0x28, 0xa2, 0xdb, 0x22, 0xdf,
	0x90, 0xae, 0x13, 0xd1, 0x9d, 0x17, 0xba, 0x93, 0x5c, 0xb4, 0xec, 0xc6, 0x19, 0xe4, 0xb7, 0x17,
	0x06, 0x05, 0xba, 0xbf, 0x06, 0x4b, 0x67, 0x9a, 0x73, 0xaa, 0x5a, 0xca, 0x99, 0x11, 0x2a, 0x67,
	0x33, 0x0d, 0xad, 0xbb, 0x29, 0x52, 0xd4, 0xdd, 0x14, 0x85, 0x70, 0x39, 0xc4, 0xb8, 0x7e, 0xee,
	0xd7, 0xe7, 0x59, 0x50, 0xda, 0xb7, 0x7b, 0x1d, 0xda, 0xa6, 0x19, 0x25, 0x1d, 0x83, 0xf9, 0xa0,
	0x6d, 0x5b, 0x7c, 0x1c, 0xf5, 0x83, 0x4a, 0x80, 0x62, 0x1c, 0x0d, 0xa1, 0xab, 0xfb, 0xa6, 0x10,
	0x8b, 0xcd, 0x8d, 0xd9, 0xb7, 0x9c, 0x1b, 0x3f, 0x01, 0x33, 0xbc, 0xf7, 0xb0, 0x89, 0x93, 0x8e,
	0x05, 0x61, 0xc3, 0x29, 0x04, 0x66, 0x65, 0x5d, 0x86, 0x13, 0x93, 0x06, 0xae, 0xfc, 0x0d, 0x0c,
	0x5c, 0xbb, 0x1f, 0xbd, 0x7e, 0x0c, 0xa7, 0x7e, 0xff, 0xea, 0xc9, 0x6d, 0xf1, 0xb8, 0x8b, 0x57,
	0x4f, 0x6e, 0xaf, 0xd0, 0xef, 0x8b, 0x84, 0x39, 0xd1, 0xd3, 0x2c, 0x58, 0x4f, 0x60, 0x98, 0xd8,
	0x03, 0xd3, 0xb0, 0xc9, 0xb5, 0x27, 0x7f, 0x31, 0x4e, 0x65, 0x6f, 0x72, 0x9c, 0x4a, 0xf5, 0xcd,
	0xdc, 0xb5, 0xfa, 0x66, 0x6a, 0x40, 0xcd, 0xbf, 0xfb, 0x80, 0x8a, 0x9e, 0x65, 0x40, 0x71, 0xdf,
	0xee, 0xdd, 0xf3, 0x67, 0x28, 0x1e, 0xb0, 0x1d, 0x30, 0x17, 0x0c, 0x67, 0xdc, 0x88, 0x7e, 0xcf,
	0x0d, 0x31, 0x11, 0x57, 0x01, 0x72, 0x75, 0xb4, 0x86, 0x42, 0x71, 0xd7, 0x64, 0xdf, 0xda, 0x35,
	0xbb, 0x1f, 0x06, 0x31, 0x12, 0xaa, 0xf4, 0x43, 0x64, 0x39, 0x08, 0x91, 0xc8, 0xfd, 0xd1, 0x5f,
	0x32, 0x60, 0x2d, 0x0e, 0xdd, 0x58, 0x80, 0xc4, 0x87, 0xd4, 0xec, 0xbb, 0x0c, 0xa9, 0xe8, 0x69,
	0x0e, 0x94, 0xf7, 0xed, 0x1e, 0xf6, 0x27, 0xb7, 0x11, 0x89, 0xda, 0x9c, 0x02, 0x09, 0x9b, 0x33,
	0x2c, 0x6a, 0x73, 0x86, 0x7c, 0xaf, 0xcd, 0xd9, 0x96, 0xeb, 0xda, 0x5c, 0x22, 0x00, 0x88, 0xf9,
	0x92, 0x06, 0xed, 0x9b, 0xa4, 0x04, 0xb5, 0x87, 0x90, 0x13, 0xf6, 0x10, 0x18, 0x9d, 0xb6, 0x83,
	0x45, 0xa4, 0x16, 0xe5, 0xdf, 0xbc, 0x16, 0x4d, 0x9a, 0x73, 0xa7, 0x6f, 0x66, 0xce, 0x15, 0xf5,
	0x28, 0x34, 0xa5, 0x1f, 0x6b, 0xab, 0x41, 0xac, 0xc5, 0x3c, 0x87, 0xfe, 0x98, 0x05, 0x95, 0x24,
	0x78, 0x63, 0xf1, 0x16, 0xf7, 0x40, 0xf6, 0x7d, 0x79, 0x80, 0x7e, 0x37, 0xd1, 0xfb, 0xd3, 0xb8,
	0xce, 0x45, 0xbf, 0x9b, 0x42, 0x38, 0xfa, 0xdd, 0x14, 0x82, 0x81, 0x9e, 0x11, 0x0d, 0xed, 0xff,
	0x66, 0xc0, 0xd2, 0xbe, 0xdd, 0x3b, 0xe6, 0xcd, 0xf1, 0x7d, 0x37, 0xc0, 0xeb, 0xd6, 0x94, 0x3b,
	0x93, 0xfb, 0xce, 0x5a, 0xe0, 0xe8, 0xf8, 0x3b, 0xd0, 0xdf, 0x32, 0x60, 0x23, 0x85, 0xde, 0x98,
	0xab, 0xef, 0x83, 0xc5, 0xc8, 0xa0, 0x11, 0x14, 0x17, 0x5a, 0xd4, 0xa3, 0xb8, 0x28, 0xea, 0x51,
	0x14, 0xe1, 0x05, 0x31, 0x91, 0x38, 0xb7, 0xff, 0x9c, 0x0b, 0x3e, 0xa9, 0xf8, 0xcf, 0x39, 0xbb,
	0x60, 0xa3, 0xde, 0x6e, 0x37, 0xeb, 0x5f, 0xc9, 0x9d, 0xc3, 0xfa, 0xe1, 0x51, 0x47, 0x3e, 0x3a,
	0xe8, 0xb4, 0x9b, 0xf7, 0x5a, 0x9f, 0xb7, 0x9a, 0x7b, 0xe5, 0xa9, 0xcd, 0x5b, 0x17, 0x97, 0xd5,
	0xf5, 0xa8, 0xc0, 0x91, 0x61, 0x0f, 0x48, 0x57, 0xfb, 0x9d, 0x46, 0x54, 0xe9, 0x63, 0xb0, 0x1a,
	0x97, 0x6d, 0x37, 0x0f, 0xf6, 0x5a, 0x07, 0x5f, 0x94, 0x33, 0x9b, 0xeb, 0x17, 0x97, 0xd5, 0xe5,
	0xa8, 0x5c, 0x9b, 0x0d, 0x8b, 0xd2, 0x4f, 0xc1, 0x7a, 0x5c, 0x06, 0x37, 0x1f, 0xb4, 0x9a, 0xc7,
	0xbe, 0x54, 0x76, 0x73, 0xe3, 0xe2, 0xb2, 0xba, 0x1a, 0x95, 0xc2, 0xb4, 0xa2, 0xfb, 0x72, 0x9f,
	0x82, 0xb5, 0xb8, 0x5c, 0xbd, 0xdd, 0xc6, 0xbf, 0x7a, 0xd0, 0xdc, 0x2b, 0xe7, 0x36, 0x2b, 0x17,
	0x97, 0xd5, 0x95, 0xa8, 0x58, 0x9d, 0x8f, 0x8f, 0x69, 0x29, 0xdc, 0xbc, 0xdf, 0xbc, 0x77, 0xd8,
	0xdc, 0x2b, 0xe7, 0xd3, 0x52, 0x98, 0x0f, 0x86, 0xe9, 0x3b, 0x1e, 0xb7, 0x0e, 0xbf, 0xdc, 0xc3,
	0xf5, 0xe3, 0x83, 0xf2, 0x74, 0xfa, 0x8e, 0x81, 0xd7, 0x8d, 0xb4, 0x3d, 0x9a, 0xbf, 0x6e, 0xb7,
	0x70, 0x73, 0xaf, 0x3c, 0x93, 0xb6, 0x47, 0xf3, 0x7c, 0xa0, 0x59, 0x44, 0xdd, 0xcc, 0xff, 0xe1,
	0xaf, 0x5b, 0x53, 0x8d, 0x83, 0x7f, 0xbe, 0xd8, 0xca, 0x3c, 0x7b, 0xb1, 0x95, 0x79, 0xfe, 0x62,
	0x2b, 0xf3, 0xa7, 0x97, 0x5b, 0x53, 0xcf, 0x5e, 0x6e, 0x4d, 0xfd, 0xe7, 0xe5, 0xd6, 0xd4, 0xc3,
	0x4f, 0x7b, 0x9a, 0x73, 0x3a, 0x3c, 0xd9, 0xe9, 0x9a, 0x7a, 0x2d, 0xfa, 0x03, 0xab, 0xf8, 0xd7,
	0x56, 0xbf, 0xad, 0xf5, 0xcc, 0x9a, 0x61, 0xaa, 0xe1, 0xef, 0xae, 0x27, 0x33, 0xf4, 0x07, 0xd0,
	0x4f, 0xfe, 0x1f, 0x00, 0x00, 0xff, 0xff, 0xbf, 0x0c, 0x0e, 0x68, 0x94, 0x15, 0x00, 0x00,
}

func (this *AppealRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppealRecord)
	if !ok {
		that2, ok := that.(AppealRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppealId != that1.AppealId {
		return false
	}
	if this.AccountAddress != that1.AccountAddress {
		return false
	}
	if this.ScopeId != that1.ScopeId {
		return false
	}
	if this.OriginalStatus != that1.OriginalStatus {
		return false
	}
	if this.OriginalScore != that1.OriginalScore {
		return false
	}
	if this.AppealReason != that1.AppealReason {
		return false
	}
	if len(this.EvidenceHashes) != len(that1.EvidenceHashes) {
		return false
	}
	for i := range this.EvidenceHashes {
		if this.EvidenceHashes[i] != that1.EvidenceHashes[i] {
			return false
		}
	}
	if this.SubmittedAt != that1.SubmittedAt {
		return false
	}
	if this.SubmittedAtTime != that1.SubmittedAtTime {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if this.ReviewerAddress != that1.ReviewerAddress {
		return false
	}
	if this.ClaimedAt != that1.ClaimedAt {
		return false
	}
	if this.ReviewedAt != that1.ReviewedAt {
		return false
	}
	if this.ReviewedAtTime != that1.ReviewedAtTime {
		return false
	}
	if this.ResolutionReason != that1.ResolutionReason {
		return false
	}
	if this.ScoreAdjustment != that1.ScoreAdjustment {
		return false
	}
	if this.AppealNumber != that1.AppealNumber {
		return false
	}
	return true
}
func (this *AppealParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppealParams)
	if !ok {
		that2, ok := that.(AppealParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AppealWindowBlocks != that1.AppealWindowBlocks {
		return false
	}
	if this.MaxAppealsPerScope != that1.MaxAppealsPerScope {
		return false
	}
	if this.MinAppealReasonLength != that1.MinAppealReasonLength {
		return false
	}
	if this.ReviewTimeoutBlocks != that1.ReviewTimeoutBlocks {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.RequireEscrowDeposit != that1.RequireEscrowDeposit {
		return false
	}
	if this.EscrowDepositAmount != that1.EscrowDepositAmount {
		return false
	}
	return true
}
func (this *AppealSummary) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AppealSummary)
	if !ok {
		that2, ok := that.(AppealSummary)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.TotalAppeals != that1.TotalAppeals {
		return false
	}
	if this.PendingAppeals != that1.PendingAppeals {
		return false
	}
	if this.ApprovedAppeals != that1.ApprovedAppeals {
		return false
	}
	if this.RejectedAppeals != that1.RejectedAppeals {
		return false
	}
	if this.WithdrawnAppeals != that1.WithdrawnAppeals {
		return false
	}
	return true
}
func (m *AppealRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppealRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppealRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AppealNumber != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.AppealNumber))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.ScoreAdjustment != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ScoreAdjustment))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if len(m.ResolutionReason) > 0 {
		i -= len(m.ResolutionReason)
		copy(dAtA[i:], m.ResolutionReason)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.ResolutionReason)))
		i--
		dAtA[i] = 0x7a
	}
	if m.ReviewedAtTime != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ReviewedAtTime))
		i--
		dAtA[i] = 0x70
	}
	if m.ReviewedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ReviewedAt))
		i--
		dAtA[i] = 0x68
	}
	if m.ClaimedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ClaimedAt))
		i--
		dAtA[i] = 0x60
	}
	if len(m.ReviewerAddress) > 0 {
		i -= len(m.ReviewerAddress)
		copy(dAtA[i:], m.ReviewerAddress)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.ReviewerAddress)))
		i--
		dAtA[i] = 0x5a
	}
	if m.Status != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x50
	}
	if m.SubmittedAtTime != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.SubmittedAtTime))
		i--
		dAtA[i] = 0x48
	}
	if m.SubmittedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x40
	}
	if len(m.EvidenceHashes) > 0 {
		for iNdEx := len(m.EvidenceHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EvidenceHashes[iNdEx])
			copy(dAtA[i:], m.EvidenceHashes[iNdEx])
			i = encodeVarintAppeal(dAtA, i, uint64(len(m.EvidenceHashes[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.AppealReason) > 0 {
		i -= len(m.AppealReason)
		copy(dAtA[i:], m.AppealReason)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealReason)))
		i--
		dAtA[i] = 0x32
	}
	if m.OriginalScore != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.OriginalScore))
		i--
		dAtA[i] = 0x28
	}
	if len(m.OriginalStatus) > 0 {
		i -= len(m.OriginalStatus)
		copy(dAtA[i:], m.OriginalStatus)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.OriginalStatus)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppealParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppealParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppealParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EscrowDepositAmount != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.EscrowDepositAmount))
		i--
		dAtA[i] = 0x38
	}
	if m.RequireEscrowDeposit {
		i--
		if m.RequireEscrowDeposit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.ReviewTimeoutBlocks != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ReviewTimeoutBlocks))
		i--
		dAtA[i] = 0x20
	}
	if m.MinAppealReasonLength != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.MinAppealReasonLength))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxAppealsPerScope != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.MaxAppealsPerScope))
		i--
		dAtA[i] = 0x10
	}
	if m.AppealWindowBlocks != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.AppealWindowBlocks))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppealSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppealSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppealSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithdrawnAppeals != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.WithdrawnAppeals))
		i--
		dAtA[i] = 0x28
	}
	if m.RejectedAppeals != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.RejectedAppeals))
		i--
		dAtA[i] = 0x20
	}
	if m.ApprovedAppeals != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ApprovedAppeals))
		i--
		dAtA[i] = 0x18
	}
	if m.PendingAppeals != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.PendingAppeals))
		i--
		dAtA[i] = 0x10
	}
	if m.TotalAppeals != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.TotalAppeals))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceHashes) > 0 {
		for iNdEx := len(m.EvidenceHashes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.EvidenceHashes[iNdEx])
			copy(dAtA[i:], m.EvidenceHashes[iNdEx])
			i = encodeVarintAppeal(dAtA, i, uint64(len(m.EvidenceHashes[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgSubmitAppealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgSubmitAppealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgSubmitAppealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SubmittedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.SubmittedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.AppealNumber != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.AppealNumber))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Reviewer) > 0 {
		i -= len(m.Reviewer)
		copy(dAtA[i:], m.Reviewer)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Reviewer)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgClaimAppealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgClaimAppealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgClaimAppealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ClaimedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ClaimedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScoreAdjustment != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ScoreAdjustment))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x22
	}
	if m.Resolution != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.Resolution))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resolver) > 0 {
		i -= len(m.Resolver)
		copy(dAtA[i:], m.Resolver)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Resolver)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResolveAppealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResolveAppealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResolveAppealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ResolvedAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.ResolvedAt))
		i--
		dAtA[i] = 0x18
	}
	if m.Resolution != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.Resolution))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawAppeal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawAppeal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawAppeal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Submitter) > 0 {
		i -= len(m.Submitter)
		copy(dAtA[i:], m.Submitter)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.Submitter)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgWithdrawAppealResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgWithdrawAppealResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgWithdrawAppealResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WithdrawnAt != 0 {
		i = encodeVarintAppeal(dAtA, i, uint64(m.WithdrawnAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AppealId) > 0 {
		i -= len(m.AppealId)
		copy(dAtA[i:], m.AppealId)
		i = encodeVarintAppeal(dAtA, i, uint64(len(m.AppealId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAppeal(dAtA []byte, offset int, v uint64) int {
	offset -= sovAppeal(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AppealRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.OriginalStatus)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.OriginalScore != 0 {
		n += 1 + sovAppeal(uint64(m.OriginalScore))
	}
	l = len(m.AppealReason)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if len(m.EvidenceHashes) > 0 {
		for _, s := range m.EvidenceHashes {
			l = len(s)
			n += 1 + l + sovAppeal(uint64(l))
		}
	}
	if m.SubmittedAt != 0 {
		n += 1 + sovAppeal(uint64(m.SubmittedAt))
	}
	if m.SubmittedAtTime != 0 {
		n += 1 + sovAppeal(uint64(m.SubmittedAtTime))
	}
	if m.Status != 0 {
		n += 1 + sovAppeal(uint64(m.Status))
	}
	l = len(m.ReviewerAddress)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.ClaimedAt != 0 {
		n += 1 + sovAppeal(uint64(m.ClaimedAt))
	}
	if m.ReviewedAt != 0 {
		n += 1 + sovAppeal(uint64(m.ReviewedAt))
	}
	if m.ReviewedAtTime != 0 {
		n += 1 + sovAppeal(uint64(m.ReviewedAtTime))
	}
	l = len(m.ResolutionReason)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.ScoreAdjustment != 0 {
		n += 2 + sovAppeal(uint64(m.ScoreAdjustment))
	}
	if m.AppealNumber != 0 {
		n += 2 + sovAppeal(uint64(m.AppealNumber))
	}
	return n
}

func (m *AppealParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppealWindowBlocks != 0 {
		n += 1 + sovAppeal(uint64(m.AppealWindowBlocks))
	}
	if m.MaxAppealsPerScope != 0 {
		n += 1 + sovAppeal(uint64(m.MaxAppealsPerScope))
	}
	if m.MinAppealReasonLength != 0 {
		n += 1 + sovAppeal(uint64(m.MinAppealReasonLength))
	}
	if m.ReviewTimeoutBlocks != 0 {
		n += 1 + sovAppeal(uint64(m.ReviewTimeoutBlocks))
	}
	if m.Enabled {
		n += 2
	}
	if m.RequireEscrowDeposit {
		n += 2
	}
	if m.EscrowDepositAmount != 0 {
		n += 1 + sovAppeal(uint64(m.EscrowDepositAmount))
	}
	return n
}

func (m *AppealSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TotalAppeals != 0 {
		n += 1 + sovAppeal(uint64(m.TotalAppeals))
	}
	if m.PendingAppeals != 0 {
		n += 1 + sovAppeal(uint64(m.PendingAppeals))
	}
	if m.ApprovedAppeals != 0 {
		n += 1 + sovAppeal(uint64(m.ApprovedAppeals))
	}
	if m.RejectedAppeals != 0 {
		n += 1 + sovAppeal(uint64(m.RejectedAppeals))
	}
	if m.WithdrawnAppeals != 0 {
		n += 1 + sovAppeal(uint64(m.WithdrawnAppeals))
	}
	return n
}

func (m *MsgSubmitAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if len(m.EvidenceHashes) > 0 {
		for _, s := range m.EvidenceHashes {
			l = len(s)
			n += 1 + l + sovAppeal(uint64(l))
		}
	}
	return n
}

func (m *MsgSubmitAppealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAppeal(uint64(m.Status))
	}
	if m.AppealNumber != 0 {
		n += 1 + sovAppeal(uint64(m.AppealNumber))
	}
	if m.SubmittedAt != 0 {
		n += 1 + sovAppeal(uint64(m.SubmittedAt))
	}
	return n
}

func (m *MsgClaimAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Reviewer)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	return n
}

func (m *MsgClaimAppealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.ClaimedAt != 0 {
		n += 1 + sovAppeal(uint64(m.ClaimedAt))
	}
	return n
}

func (m *MsgResolveAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Resolver)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovAppeal(uint64(m.Resolution))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.ScoreAdjustment != 0 {
		n += 1 + sovAppeal(uint64(m.ScoreAdjustment))
	}
	return n
}

func (m *MsgResolveAppealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.Resolution != 0 {
		n += 1 + sovAppeal(uint64(m.Resolution))
	}
	if m.ResolvedAt != 0 {
		n += 1 + sovAppeal(uint64(m.ResolvedAt))
	}
	return n
}

func (m *MsgWithdrawAppeal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Submitter)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	return n
}

func (m *MsgWithdrawAppealResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AppealId)
	if l > 0 {
		n += 1 + l + sovAppeal(uint64(l))
	}
	if m.WithdrawnAt != 0 {
		n += 1 + sovAppeal(uint64(m.WithdrawnAt))
	}
	return n
}

func sovAppeal(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAppeal(x uint64) (n int) {
	return sovAppeal(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AppealRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppealRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppealRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalStatus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalStatus = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalScore", wireType)
			}
			m.OriginalScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OriginalScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceHashes = append(m.EvidenceHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAtTime", wireType)
			}
			m.SubmittedAtTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAtTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppealStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewerAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReviewerAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAt", wireType)
			}
			m.ClaimedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewedAt", wireType)
			}
			m.ReviewedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewedAtTime", wireType)
			}
			m.ReviewedAtTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewedAtTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolutionReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResolutionReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreAdjustment", wireType)
			}
			m.ScoreAdjustment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreAdjustment |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealNumber", wireType)
			}
			m.AppealNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppealNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppealParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppealParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppealParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealWindowBlocks", wireType)
			}
			m.AppealWindowBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppealWindowBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAppealsPerScope", wireType)
			}
			m.MaxAppealsPerScope = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAppealsPerScope |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinAppealReasonLength", wireType)
			}
			m.MinAppealReasonLength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinAppealReasonLength |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReviewTimeoutBlocks", wireType)
			}
			m.ReviewTimeoutBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReviewTimeoutBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireEscrowDeposit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireEscrowDeposit = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EscrowDepositAmount", wireType)
			}
			m.EscrowDepositAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EscrowDepositAmount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppealSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppealSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppealSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalAppeals", wireType)
			}
			m.TotalAppeals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalAppeals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingAppeals", wireType)
			}
			m.PendingAppeals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PendingAppeals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovedAppeals", wireType)
			}
			m.ApprovedAppeals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApprovedAppeals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RejectedAppeals", wireType)
			}
			m.RejectedAppeals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RejectedAppeals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnAppeals", wireType)
			}
			m.WithdrawnAppeals = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawnAppeals |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceHashes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceHashes = append(m.EvidenceHashes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgSubmitAppealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgSubmitAppealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgSubmitAppealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AppealStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealNumber", wireType)
			}
			m.AppealNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppealNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmittedAt", wireType)
			}
			m.SubmittedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SubmittedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reviewer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reviewer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgClaimAppealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgClaimAppealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgClaimAppealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClaimedAt", wireType)
			}
			m.ClaimedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClaimedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolver", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resolver = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resolution |= AppealStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScoreAdjustment", wireType)
			}
			m.ScoreAdjustment = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScoreAdjustment |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResolveAppealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResolveAppealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResolveAppealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Resolution |= AppealStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResolvedAt", wireType)
			}
			m.ResolvedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResolvedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawAppeal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawAppeal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawAppeal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Submitter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Submitter = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgWithdrawAppealResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgWithdrawAppealResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgWithdrawAppealResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppealId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAppeal
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAppeal
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppealId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithdrawnAt", wireType)
			}
			m.WithdrawnAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WithdrawnAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAppeal(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAppeal
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAppeal(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAppeal
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAppeal
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAppeal
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAppeal
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAppeal
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAppeal        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAppeal          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAppeal = fmt.Errorf("proto: unexpected end of group")
)
