// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/veid/v1/query.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	query "github.com/cosmos/cosmos-sdk/types/query"
	_ "github.com/cosmos/gogoproto/gogoproto"
	grpc1 "github.com/cosmos/gogoproto/grpc"
	proto "github.com/cosmos/gogoproto/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// QueryIdentityRequest is the request for the Identity query
type QueryIdentityRequest struct {
	// AccountAddress is the account to query
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryIdentityRequest) Reset()         { *m = QueryIdentityRequest{} }
func (m *QueryIdentityRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityRequest) ProtoMessage()    {}
func (*QueryIdentityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{0}
}
func (m *QueryIdentityRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityRequest.Merge(m, src)
}
func (m *QueryIdentityRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityRequest proto.InternalMessageInfo

func (m *QueryIdentityRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// QueryIdentityResponse is the response for the Identity query
type QueryIdentityResponse struct {
	// Identity is the identity record
	Identity *IdentityRecord `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity" yaml:"identity"`
	// Found indicates if the identity was found
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryIdentityResponse) Reset()         { *m = QueryIdentityResponse{} }
func (m *QueryIdentityResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityResponse) ProtoMessage()    {}
func (*QueryIdentityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{1}
}
func (m *QueryIdentityResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityResponse.Merge(m, src)
}
func (m *QueryIdentityResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityResponse proto.InternalMessageInfo

func (m *QueryIdentityResponse) GetIdentity() *IdentityRecord {
	if m != nil {
		return m.Identity
	}
	return nil
}

func (m *QueryIdentityResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// QueryIdentityRecordRequest is the request for the IdentityRecord query
type QueryIdentityRecordRequest struct {
	// AccountAddress is the account to query
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryIdentityRecordRequest) Reset()         { *m = QueryIdentityRecordRequest{} }
func (m *QueryIdentityRecordRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityRecordRequest) ProtoMessage()    {}
func (*QueryIdentityRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{2}
}
func (m *QueryIdentityRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityRecordRequest.Merge(m, src)
}
func (m *QueryIdentityRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityRecordRequest proto.InternalMessageInfo

func (m *QueryIdentityRecordRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// QueryIdentityRecordResponse is the response for the IdentityRecord query
type QueryIdentityRecordResponse struct {
	// Record is the identity record
	Record *IdentityRecord `protobuf:"bytes,1,opt,name=record,proto3" json:"record" yaml:"record"`
}

func (m *QueryIdentityRecordResponse) Reset()         { *m = QueryIdentityRecordResponse{} }
func (m *QueryIdentityRecordResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityRecordResponse) ProtoMessage()    {}
func (*QueryIdentityRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{3}
}
func (m *QueryIdentityRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityRecordResponse.Merge(m, src)
}
func (m *QueryIdentityRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityRecordResponse proto.InternalMessageInfo

func (m *QueryIdentityRecordResponse) GetRecord() *IdentityRecord {
	if m != nil {
		return m.Record
	}
	return nil
}

// QueryScopeRequest is the request for the Scope query
type QueryScopeRequest struct {
	// AccountAddress is the account that owns the scope
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeID is the scope to query
	ScopeId string `protobuf:"bytes,2,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
}

func (m *QueryScopeRequest) Reset()         { *m = QueryScopeRequest{} }
func (m *QueryScopeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryScopeRequest) ProtoMessage()    {}
func (*QueryScopeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{4}
}
func (m *QueryScopeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopeRequest.Merge(m, src)
}
func (m *QueryScopeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopeRequest proto.InternalMessageInfo

func (m *QueryScopeRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryScopeRequest) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

// QueryScopeResponse is the response for the Scope query
type QueryScopeResponse struct {
	// Scope is the identity scope
	Scope *IdentityScope `protobuf:"bytes,1,opt,name=scope,proto3" json:"scope" yaml:"scope"`
	// Found indicates if the scope was found
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryScopeResponse) Reset()         { *m = QueryScopeResponse{} }
func (m *QueryScopeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryScopeResponse) ProtoMessage()    {}
func (*QueryScopeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{5}
}
func (m *QueryScopeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopeResponse.Merge(m, src)
}
func (m *QueryScopeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopeResponse proto.InternalMessageInfo

func (m *QueryScopeResponse) GetScope() *IdentityScope {
	if m != nil {
		return m.Scope
	}
	return nil
}

func (m *QueryScopeResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// QueryScopesRequest is the request for the Scopes query
type QueryScopesRequest struct {
	// AccountAddress is the account to query scopes for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeType is an optional filter by scope type
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
	// StatusFilter is an optional filter by verification status
	StatusFilter VerificationStatus `protobuf:"varint,3,opt,name=status_filter,json=statusFilter,proto3,enum=virtengine.veid.v1.VerificationStatus" json:"status_filter" yaml:"status_filter"`
	// Pagination is the pagination options
	Pagination *query.PageRequest `protobuf:"bytes,4,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryScopesRequest) Reset()         { *m = QueryScopesRequest{} }
func (m *QueryScopesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryScopesRequest) ProtoMessage()    {}
func (*QueryScopesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{6}
}
func (m *QueryScopesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopesRequest.Merge(m, src)
}
func (m *QueryScopesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopesRequest proto.InternalMessageInfo

func (m *QueryScopesRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryScopesRequest) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

func (m *QueryScopesRequest) GetStatusFilter() VerificationStatus {
	if m != nil {
		return m.StatusFilter
	}
	return VerificationStatusUnknown
}

func (m *QueryScopesRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryScopesResponse is the response for the Scopes query
type QueryScopesResponse struct {
	// Scopes is the list of identity scopes
	Scopes []IdentityScope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes" yaml:"scopes"`
	// Pagination is the pagination response
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryScopesResponse) Reset()         { *m = QueryScopesResponse{} }
func (m *QueryScopesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryScopesResponse) ProtoMessage()    {}
func (*QueryScopesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{7}
}
func (m *QueryScopesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopesResponse.Merge(m, src)
}
func (m *QueryScopesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopesResponse proto.InternalMessageInfo

func (m *QueryScopesResponse) GetScopes() []IdentityScope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *QueryScopesResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryScopesByTypeRequest is the request for the ScopesByType query
type QueryScopesByTypeRequest struct {
	// AccountAddress is the account to query scopes for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeType is the type of scopes to filter by
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
}

func (m *QueryScopesByTypeRequest) Reset()         { *m = QueryScopesByTypeRequest{} }
func (m *QueryScopesByTypeRequest) String() string { return proto.CompactTextString(m) }
func (*QueryScopesByTypeRequest) ProtoMessage()    {}
func (*QueryScopesByTypeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{8}
}
func (m *QueryScopesByTypeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopesByTypeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopesByTypeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopesByTypeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopesByTypeRequest.Merge(m, src)
}
func (m *QueryScopesByTypeRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopesByTypeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopesByTypeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopesByTypeRequest proto.InternalMessageInfo

func (m *QueryScopesByTypeRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryScopesByTypeRequest) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

// QueryScopesByTypeResponse is the response for the ScopesByType query
type QueryScopesByTypeResponse struct {
	// Scopes is the list of identity scopes of the specified type
	Scopes []IdentityScope `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes" yaml:"scopes"`
}

func (m *QueryScopesByTypeResponse) Reset()         { *m = QueryScopesByTypeResponse{} }
func (m *QueryScopesByTypeResponse) String() string { return proto.CompactTextString(m) }
func (*QueryScopesByTypeResponse) ProtoMessage()    {}
func (*QueryScopesByTypeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{9}
}
func (m *QueryScopesByTypeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryScopesByTypeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryScopesByTypeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryScopesByTypeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryScopesByTypeResponse.Merge(m, src)
}
func (m *QueryScopesByTypeResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryScopesByTypeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryScopesByTypeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryScopesByTypeResponse proto.InternalMessageInfo

func (m *QueryScopesByTypeResponse) GetScopes() []IdentityScope {
	if m != nil {
		return m.Scopes
	}
	return nil
}

// QueryIdentityScoreRequest is the request for the IdentityScore query
type QueryIdentityScoreRequest struct {
	// AccountAddress is the account to query the score for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryIdentityScoreRequest) Reset()         { *m = QueryIdentityScoreRequest{} }
func (m *QueryIdentityScoreRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityScoreRequest) ProtoMessage()    {}
func (*QueryIdentityScoreRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{10}
}
func (m *QueryIdentityScoreRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityScoreRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityScoreRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityScoreRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityScoreRequest.Merge(m, src)
}
func (m *QueryIdentityScoreRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityScoreRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityScoreRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityScoreRequest proto.InternalMessageInfo

func (m *QueryIdentityScoreRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// QueryIdentityScoreResponse is the response for the IdentityScore query
type QueryIdentityScoreResponse struct {
	// Score is the identity score details
	Score *IdentityScore `protobuf:"bytes,1,opt,name=score,proto3" json:"score" yaml:"score"`
	// Found indicates if a score was found for the account
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryIdentityScoreResponse) Reset()         { *m = QueryIdentityScoreResponse{} }
func (m *QueryIdentityScoreResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityScoreResponse) ProtoMessage()    {}
func (*QueryIdentityScoreResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{11}
}
func (m *QueryIdentityScoreResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityScoreResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityScoreResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityScoreResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityScoreResponse.Merge(m, src)
}
func (m *QueryIdentityScoreResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityScoreResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityScoreResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityScoreResponse proto.InternalMessageInfo

func (m *QueryIdentityScoreResponse) GetScore() *IdentityScore {
	if m != nil {
		return m.Score
	}
	return nil
}

func (m *QueryIdentityScoreResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// QueryIdentityStatusRequest is the request for the IdentityStatus query
type QueryIdentityStatusRequest struct {
	// AccountAddress is the account to query the status for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryIdentityStatusRequest) Reset()         { *m = QueryIdentityStatusRequest{} }
func (m *QueryIdentityStatusRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityStatusRequest) ProtoMessage()    {}
func (*QueryIdentityStatusRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{12}
}
func (m *QueryIdentityStatusRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityStatusRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityStatusRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityStatusRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityStatusRequest.Merge(m, src)
}
func (m *QueryIdentityStatusRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityStatusRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityStatusRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityStatusRequest proto.InternalMessageInfo

func (m *QueryIdentityStatusRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// QueryIdentityStatusResponse is the response for the IdentityStatus query
type QueryIdentityStatusResponse struct {
	// AccountAddress is the queried address
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Status is the current verification status
	Status AccountStatus `protobuf:"varint,2,opt,name=status,proto3,enum=virtengine.veid.v1.AccountStatus" json:"status" yaml:"status"`
	// Tier is the current identity tier
	Tier IdentityTier `protobuf:"varint,3,opt,name=tier,proto3,enum=virtengine.veid.v1.IdentityTier" json:"tier" yaml:"tier"`
	// Score is the current score
	Score uint32 `protobuf:"varint,4,opt,name=score,proto3" json:"score" yaml:"score"`
	// ModelVersion is the ML model version used
	ModelVersion string `protobuf:"bytes,5,opt,name=model_version,json=modelVersion,proto3" json:"model_version" yaml:"model_version"`
	// LastUpdatedAt is when the status was last updated (Unix timestamp)
	LastUpdatedAt int64 `protobuf:"varint,6,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at" yaml:"last_updated_at"`
	// Found indicates if the account exists
	Found bool `protobuf:"varint,7,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryIdentityStatusResponse) Reset()         { *m = QueryIdentityStatusResponse{} }
func (m *QueryIdentityStatusResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityStatusResponse) ProtoMessage()    {}
func (*QueryIdentityStatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{13}
}
func (m *QueryIdentityStatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityStatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityStatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityStatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityStatusResponse.Merge(m, src)
}
func (m *QueryIdentityStatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityStatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityStatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityStatusResponse proto.InternalMessageInfo

func (m *QueryIdentityStatusResponse) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryIdentityStatusResponse) GetStatus() AccountStatus {
	if m != nil {
		return m.Status
	}
	return AccountStatusUnknown
}

func (m *QueryIdentityStatusResponse) GetTier() IdentityTier {
	if m != nil {
		return m.Tier
	}
	return IdentityTierUnverified
}

func (m *QueryIdentityStatusResponse) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *QueryIdentityStatusResponse) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *QueryIdentityStatusResponse) GetLastUpdatedAt() int64 {
	if m != nil {
		return m.LastUpdatedAt
	}
	return 0
}

func (m *QueryIdentityStatusResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// QueryIdentityWalletRequest is the request for the IdentityWallet query
type QueryIdentityWalletRequest struct {
	// AccountAddress is the account to query the wallet for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryIdentityWalletRequest) Reset()         { *m = QueryIdentityWalletRequest{} }
func (m *QueryIdentityWalletRequest) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityWalletRequest) ProtoMessage()    {}
func (*QueryIdentityWalletRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{14}
}
func (m *QueryIdentityWalletRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityWalletRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityWalletRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityWalletRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityWalletRequest.Merge(m, src)
}
func (m *QueryIdentityWalletRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityWalletRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityWalletRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityWalletRequest proto.InternalMessageInfo

func (m *QueryIdentityWalletRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// PublicWalletInfo contains non-sensitive wallet information
type PublicWalletInfo struct {
	// WalletID is the wallet identifier
	WalletId string `protobuf:"bytes,1,opt,name=wallet_id,json=walletId,proto3" json:"wallet_id" yaml:"wallet_id"`
	// AccountAddress is the owner's address
	AccountAddress string `protobuf:"bytes,2,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Status is the wallet status
	Status WalletStatus `protobuf:"varint,3,opt,name=status,proto3,enum=virtengine.veid.v1.WalletStatus" json:"status" yaml:"status"`
	// Score is the current identity score
	Score uint32 `protobuf:"varint,4,opt,name=score,proto3" json:"score" yaml:"score"`
	// Tier is the current identity tier
	Tier IdentityTier `protobuf:"varint,5,opt,name=tier,proto3,enum=virtengine.veid.v1.IdentityTier" json:"tier" yaml:"tier"`
	// ScopeCount is the number of scopes in the wallet
	ScopeCount int32 `protobuf:"varint,6,opt,name=scope_count,json=scopeCount,proto3" json:"scope_count" yaml:"scope_count"`
	// VerifiedScopeCount is the number of verified scopes
	VerifiedScopeCount int32 `protobuf:"varint,7,opt,name=verified_scope_count,json=verifiedScopeCount,proto3" json:"verified_scope_count" yaml:"verified_scope_count"`
	// CreatedAt is when the wallet was created (Unix timestamp)
	CreatedAt int64 `protobuf:"varint,8,opt,name=created_at,json=createdAt,proto3" json:"created_at" yaml:"created_at"`
	// LastUpdatedAt is when the wallet was last updated (Unix timestamp)
	LastUpdatedAt int64 `protobuf:"varint,9,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at" yaml:"last_updated_at"`
}

func (m *PublicWalletInfo) Reset()         { *m = PublicWalletInfo{} }
func (m *PublicWalletInfo) String() string { return proto.CompactTextString(m) }
func (*PublicWalletInfo) ProtoMessage()    {}
func (*PublicWalletInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{15}
}
func (m *PublicWalletInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicWalletInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicWalletInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicWalletInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicWalletInfo.Merge(m, src)
}
func (m *PublicWalletInfo) XXX_Size() int {
	return m.Size()
}
func (m *PublicWalletInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicWalletInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PublicWalletInfo proto.InternalMessageInfo

func (m *PublicWalletInfo) GetWalletId() string {
	if m != nil {
		return m.WalletId
	}
	return ""
}

func (m *PublicWalletInfo) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *PublicWalletInfo) GetStatus() WalletStatus {
	if m != nil {
		return m.Status
	}
	return WalletStatusUnspecified
}

func (m *PublicWalletInfo) GetScore() uint32 {
	if m != nil {
		return m.Score
	}
	return 0
}

func (m *PublicWalletInfo) GetTier() IdentityTier {
	if m != nil {
		return m.Tier
	}
	return IdentityTierUnverified
}

func (m *PublicWalletInfo) GetScopeCount() int32 {
	if m != nil {
		return m.ScopeCount
	}
	return 0
}

func (m *PublicWalletInfo) GetVerifiedScopeCount() int32 {
	if m != nil {
		return m.VerifiedScopeCount
	}
	return 0
}

func (m *PublicWalletInfo) GetCreatedAt() int64 {
	if m != nil {
		return m.CreatedAt
	}
	return 0
}

func (m *PublicWalletInfo) GetLastUpdatedAt() int64 {
	if m != nil {
		return m.LastUpdatedAt
	}
	return 0
}

// QueryIdentityWalletResponse is the response for the IdentityWallet query
type QueryIdentityWalletResponse struct {
	// Wallet contains non-sensitive wallet information
	Wallet *PublicWalletInfo `protobuf:"bytes,1,opt,name=wallet,proto3" json:"wallet" yaml:"wallet"`
	// Found indicates if the wallet was found
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryIdentityWalletResponse) Reset()         { *m = QueryIdentityWalletResponse{} }
func (m *QueryIdentityWalletResponse) String() string { return proto.CompactTextString(m) }
func (*QueryIdentityWalletResponse) ProtoMessage()    {}
func (*QueryIdentityWalletResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{16}
}
func (m *QueryIdentityWalletResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryIdentityWalletResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryIdentityWalletResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryIdentityWalletResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryIdentityWalletResponse.Merge(m, src)
}
func (m *QueryIdentityWalletResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryIdentityWalletResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryIdentityWalletResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryIdentityWalletResponse proto.InternalMessageInfo

func (m *QueryIdentityWalletResponse) GetWallet() *PublicWalletInfo {
	if m != nil {
		return m.Wallet
	}
	return nil
}

func (m *QueryIdentityWalletResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// WalletScopeInfo represents non-sensitive scope information in a wallet
type WalletScopeInfo struct {
	// ScopeID is the scope identifier
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// ScopeType indicates what kind of identity data this scope contains
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
	// Status is the current verification status
	Status VerificationStatus `protobuf:"varint,3,opt,name=status,proto3,enum=virtengine.veid.v1.VerificationStatus" json:"status" yaml:"status"`
	// AddedAt is when the scope was added (Unix timestamp)
	AddedAt int64 `protobuf:"varint,4,opt,name=added_at,json=addedAt,proto3" json:"added_at" yaml:"added_at"`
	// VerifiedAt is when the scope was verified (Unix timestamp)
	VerifiedAt int64 `protobuf:"varint,5,opt,name=verified_at,json=verifiedAt,proto3" json:"verified_at" yaml:"verified_at"`
	// ExpiresAt is when the verification expires (Unix timestamp)
	ExpiresAt int64 `protobuf:"varint,6,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
	// ConsentGranted indicates if consent is granted for this scope
	ConsentGranted bool `protobuf:"varint,7,opt,name=consent_granted,json=consentGranted,proto3" json:"consent_granted" yaml:"consent_granted"`
}

func (m *WalletScopeInfo) Reset()         { *m = WalletScopeInfo{} }
func (m *WalletScopeInfo) String() string { return proto.CompactTextString(m) }
func (*WalletScopeInfo) ProtoMessage()    {}
func (*WalletScopeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{17}
}
func (m *WalletScopeInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalletScopeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalletScopeInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalletScopeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalletScopeInfo.Merge(m, src)
}
func (m *WalletScopeInfo) XXX_Size() int {
	return m.Size()
}
func (m *WalletScopeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_WalletScopeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_WalletScopeInfo proto.InternalMessageInfo

func (m *WalletScopeInfo) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *WalletScopeInfo) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

func (m *WalletScopeInfo) GetStatus() VerificationStatus {
	if m != nil {
		return m.Status
	}
	return VerificationStatusUnknown
}

func (m *WalletScopeInfo) GetAddedAt() int64 {
	if m != nil {
		return m.AddedAt
	}
	return 0
}

func (m *WalletScopeInfo) GetVerifiedAt() int64 {
	if m != nil {
		return m.VerifiedAt
	}
	return 0
}

func (m *WalletScopeInfo) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *WalletScopeInfo) GetConsentGranted() bool {
	if m != nil {
		return m.ConsentGranted
	}
	return false
}

// QueryWalletScopesRequest is the request for the WalletScopes query
type QueryWalletScopesRequest struct {
	// AccountAddress is the account to query scopes for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeType is an optional filter by scope type
	ScopeType ScopeType `protobuf:"varint,2,opt,name=scope_type,json=scopeType,proto3,enum=virtengine.veid.v1.ScopeType" json:"scope_type" yaml:"scope_type"`
	// StatusFilter is an optional filter by verification status
	StatusFilter VerificationStatus `protobuf:"varint,3,opt,name=status_filter,json=statusFilter,proto3,enum=virtengine.veid.v1.VerificationStatus" json:"status_filter" yaml:"status_filter"`
	// ActiveOnly filters to only active scopes
	ActiveOnly bool `protobuf:"varint,4,opt,name=active_only,json=activeOnly,proto3" json:"active_only" yaml:"active_only"`
}

func (m *QueryWalletScopesRequest) Reset()         { *m = QueryWalletScopesRequest{} }
func (m *QueryWalletScopesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryWalletScopesRequest) ProtoMessage()    {}
func (*QueryWalletScopesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{18}
}
func (m *QueryWalletScopesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryWalletScopesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryWalletScopesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryWalletScopesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryWalletScopesRequest.Merge(m, src)
}
func (m *QueryWalletScopesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryWalletScopesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryWalletScopesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryWalletScopesRequest proto.InternalMessageInfo

func (m *QueryWalletScopesRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryWalletScopesRequest) GetScopeType() ScopeType {
	if m != nil {
		return m.ScopeType
	}
	return ScopeTypeUnspecified
}

func (m *QueryWalletScopesRequest) GetStatusFilter() VerificationStatus {
	if m != nil {
		return m.StatusFilter
	}
	return VerificationStatusUnknown
}

func (m *QueryWalletScopesRequest) GetActiveOnly() bool {
	if m != nil {
		return m.ActiveOnly
	}
	return false
}

// QueryWalletScopesResponse is the response for the WalletScopes query
type QueryWalletScopesResponse struct {
	// Scopes contains non-sensitive scope information
	Scopes []WalletScopeInfo `protobuf:"bytes,1,rep,name=scopes,proto3" json:"scopes" yaml:"scopes"`
	// TotalCount is the total number of scopes in the wallet
	TotalCount int32 `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count" yaml:"total_count"`
	// ActiveCount is the number of active scopes
	ActiveCount int32 `protobuf:"varint,3,opt,name=active_count,json=activeCount,proto3" json:"active_count" yaml:"active_count"`
}

func (m *QueryWalletScopesResponse) Reset()         { *m = QueryWalletScopesResponse{} }
func (m *QueryWalletScopesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryWalletScopesResponse) ProtoMessage()    {}
func (*QueryWalletScopesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{19}
}
func (m *QueryWalletScopesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryWalletScopesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryWalletScopesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryWalletScopesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryWalletScopesResponse.Merge(m, src)
}
func (m *QueryWalletScopesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryWalletScopesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryWalletScopesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryWalletScopesResponse proto.InternalMessageInfo

func (m *QueryWalletScopesResponse) GetScopes() []WalletScopeInfo {
	if m != nil {
		return m.Scopes
	}
	return nil
}

func (m *QueryWalletScopesResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

func (m *QueryWalletScopesResponse) GetActiveCount() int32 {
	if m != nil {
		return m.ActiveCount
	}
	return 0
}

// QueryConsentSettingsRequest is the request for the ConsentSettings query
type QueryConsentSettingsRequest struct {
	// AccountAddress is the account to query consent for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// ScopeID is an optional filter for specific scope consent
	ScopeId string `protobuf:"bytes,2,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
}

func (m *QueryConsentSettingsRequest) Reset()         { *m = QueryConsentSettingsRequest{} }
func (m *QueryConsentSettingsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryConsentSettingsRequest) ProtoMessage()    {}
func (*QueryConsentSettingsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{20}
}
func (m *QueryConsentSettingsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryConsentSettingsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryConsentSettingsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryConsentSettingsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryConsentSettingsRequest.Merge(m, src)
}
func (m *QueryConsentSettingsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryConsentSettingsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryConsentSettingsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryConsentSettingsRequest proto.InternalMessageInfo

func (m *QueryConsentSettingsRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryConsentSettingsRequest) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

// PublicConsentInfo represents non-sensitive consent information
type PublicConsentInfo struct {
	// ScopeID is the scope identifier
	ScopeId string `protobuf:"bytes,1,opt,name=scope_id,json=scopeId,proto3" json:"scope_id" yaml:"scope_id"`
	// Granted indicates if consent is granted
	Granted bool `protobuf:"varint,2,opt,name=granted,proto3" json:"granted" yaml:"granted"`
	// IsActive indicates if consent is currently active
	IsActive bool `protobuf:"varint,3,opt,name=is_active,json=isActive,proto3" json:"is_active" yaml:"is_active"`
	// Purpose is the consent purpose
	Purpose string `protobuf:"bytes,4,opt,name=purpose,proto3" json:"purpose" yaml:"purpose"`
	// ExpiresAt is when consent expires (Unix timestamp)
	ExpiresAt int64 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at" yaml:"expires_at"`
}

func (m *PublicConsentInfo) Reset()         { *m = PublicConsentInfo{} }
func (m *PublicConsentInfo) String() string { return proto.CompactTextString(m) }
func (*PublicConsentInfo) ProtoMessage()    {}
func (*PublicConsentInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{21}
}
func (m *PublicConsentInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicConsentInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicConsentInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicConsentInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicConsentInfo.Merge(m, src)
}
func (m *PublicConsentInfo) XXX_Size() int {
	return m.Size()
}
func (m *PublicConsentInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicConsentInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PublicConsentInfo proto.InternalMessageInfo

func (m *PublicConsentInfo) GetScopeId() string {
	if m != nil {
		return m.ScopeId
	}
	return ""
}

func (m *PublicConsentInfo) GetGranted() bool {
	if m != nil {
		return m.Granted
	}
	return false
}

func (m *PublicConsentInfo) GetIsActive() bool {
	if m != nil {
		return m.IsActive
	}
	return false
}

func (m *PublicConsentInfo) GetPurpose() string {
	if m != nil {
		return m.Purpose
	}
	return ""
}

func (m *PublicConsentInfo) GetExpiresAt() int64 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

// QueryConsentSettingsResponse is the response for the ConsentSettings query
type QueryConsentSettingsResponse struct {
	// GlobalSettings contains global consent settings
	GlobalSettings *ConsentSettings `protobuf:"bytes,1,opt,name=global_settings,json=globalSettings,proto3" json:"global_settings" yaml:"global_settings"`
	// ScopeConsents contains per-scope consent info
	ScopeConsents []PublicConsentInfo `protobuf:"bytes,2,rep,name=scope_consents,json=scopeConsents,proto3" json:"scope_consents" yaml:"scope_consents"`
	// ConsentVersion is the current consent version
	ConsentVersion uint32 `protobuf:"varint,3,opt,name=consent_version,json=consentVersion,proto3" json:"consent_version" yaml:"consent_version"`
	// LastUpdatedAt is when consent was last updated (Unix timestamp)
	LastUpdatedAt int64 `protobuf:"varint,4,opt,name=last_updated_at,json=lastUpdatedAt,proto3" json:"last_updated_at" yaml:"last_updated_at"`
}

func (m *QueryConsentSettingsResponse) Reset()         { *m = QueryConsentSettingsResponse{} }
func (m *QueryConsentSettingsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryConsentSettingsResponse) ProtoMessage()    {}
func (*QueryConsentSettingsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{22}
}
func (m *QueryConsentSettingsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryConsentSettingsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryConsentSettingsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryConsentSettingsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryConsentSettingsResponse.Merge(m, src)
}
func (m *QueryConsentSettingsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryConsentSettingsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryConsentSettingsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryConsentSettingsResponse proto.InternalMessageInfo

func (m *QueryConsentSettingsResponse) GetGlobalSettings() *ConsentSettings {
	if m != nil {
		return m.GlobalSettings
	}
	return nil
}

func (m *QueryConsentSettingsResponse) GetScopeConsents() []PublicConsentInfo {
	if m != nil {
		return m.ScopeConsents
	}
	return nil
}

func (m *QueryConsentSettingsResponse) GetConsentVersion() uint32 {
	if m != nil {
		return m.ConsentVersion
	}
	return 0
}

func (m *QueryConsentSettingsResponse) GetLastUpdatedAt() int64 {
	if m != nil {
		return m.LastUpdatedAt
	}
	return 0
}

// PublicVerificationHistoryEntry represents non-sensitive verification history
type PublicVerificationHistoryEntry struct {
	// EntryID is the entry identifier
	EntryId string `protobuf:"bytes,1,opt,name=entry_id,json=entryId,proto3" json:"entry_id" yaml:"entry_id"`
	// Timestamp is when this verification occurred (Unix timestamp)
	Timestamp int64 `protobuf:"varint,2,opt,name=timestamp,proto3" json:"timestamp" yaml:"timestamp"`
	// BlockHeight is the block height
	BlockHeight int64 `protobuf:"varint,3,opt,name=block_height,json=blockHeight,proto3" json:"block_height" yaml:"block_height"`
	// PreviousScore is the score before verification
	PreviousScore uint32 `protobuf:"varint,4,opt,name=previous_score,json=previousScore,proto3" json:"previous_score" yaml:"previous_score"`
	// NewScore is the score after verification
	NewScore uint32 `protobuf:"varint,5,opt,name=new_score,json=newScore,proto3" json:"new_score" yaml:"new_score"`
	// PreviousStatus is the status before verification
	PreviousStatus AccountStatus `protobuf:"varint,6,opt,name=previous_status,json=previousStatus,proto3,enum=virtengine.veid.v1.AccountStatus" json:"previous_status" yaml:"previous_status"`
	// NewStatus is the status after verification
	NewStatus AccountStatus `protobuf:"varint,7,opt,name=new_status,json=newStatus,proto3,enum=virtengine.veid.v1.AccountStatus" json:"new_status" yaml:"new_status"`
	// ScopeCount is the number of scopes evaluated
	ScopeCount int32 `protobuf:"varint,8,opt,name=scope_count,json=scopeCount,proto3" json:"scope_count" yaml:"scope_count"`
	// ModelVersion is the model version used
	ModelVersion string `protobuf:"bytes,9,opt,name=model_version,json=modelVersion,proto3" json:"model_version" yaml:"model_version"`
}

func (m *PublicVerificationHistoryEntry) Reset()         { *m = PublicVerificationHistoryEntry{} }
func (m *PublicVerificationHistoryEntry) String() string { return proto.CompactTextString(m) }
func (*PublicVerificationHistoryEntry) ProtoMessage()    {}
func (*PublicVerificationHistoryEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{23}
}
func (m *PublicVerificationHistoryEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicVerificationHistoryEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicVerificationHistoryEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicVerificationHistoryEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicVerificationHistoryEntry.Merge(m, src)
}
func (m *PublicVerificationHistoryEntry) XXX_Size() int {
	return m.Size()
}
func (m *PublicVerificationHistoryEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicVerificationHistoryEntry.DiscardUnknown(m)
}

var xxx_messageInfo_PublicVerificationHistoryEntry proto.InternalMessageInfo

func (m *PublicVerificationHistoryEntry) GetEntryId() string {
	if m != nil {
		return m.EntryId
	}
	return ""
}

func (m *PublicVerificationHistoryEntry) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *PublicVerificationHistoryEntry) GetBlockHeight() int64 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *PublicVerificationHistoryEntry) GetPreviousScore() uint32 {
	if m != nil {
		return m.PreviousScore
	}
	return 0
}

func (m *PublicVerificationHistoryEntry) GetNewScore() uint32 {
	if m != nil {
		return m.NewScore
	}
	return 0
}

func (m *PublicVerificationHistoryEntry) GetPreviousStatus() AccountStatus {
	if m != nil {
		return m.PreviousStatus
	}
	return AccountStatusUnknown
}

func (m *PublicVerificationHistoryEntry) GetNewStatus() AccountStatus {
	if m != nil {
		return m.NewStatus
	}
	return AccountStatusUnknown
}

func (m *PublicVerificationHistoryEntry) GetScopeCount() int32 {
	if m != nil {
		return m.ScopeCount
	}
	return 0
}

func (m *PublicVerificationHistoryEntry) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

// QueryVerificationHistoryRequest is the request for the VerificationHistory query
type QueryVerificationHistoryRequest struct {
	// AccountAddress is the account to query history for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Limit is the maximum number of entries to return
	Limit uint32 `protobuf:"varint,2,opt,name=limit,proto3" json:"limit" yaml:"limit"`
	// Offset is the number of entries to skip
	Offset uint32 `protobuf:"varint,3,opt,name=offset,proto3" json:"offset" yaml:"offset"`
}

func (m *QueryVerificationHistoryRequest) Reset()         { *m = QueryVerificationHistoryRequest{} }
func (m *QueryVerificationHistoryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryVerificationHistoryRequest) ProtoMessage()    {}
func (*QueryVerificationHistoryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{24}
}
func (m *QueryVerificationHistoryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerificationHistoryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerificationHistoryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerificationHistoryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerificationHistoryRequest.Merge(m, src)
}
func (m *QueryVerificationHistoryRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerificationHistoryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerificationHistoryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerificationHistoryRequest proto.InternalMessageInfo

func (m *QueryVerificationHistoryRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryVerificationHistoryRequest) GetLimit() uint32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *QueryVerificationHistoryRequest) GetOffset() uint32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

// QueryVerificationHistoryResponse is the response for the VerificationHistory query
type QueryVerificationHistoryResponse struct {
	// Entries contains verification history entries
	Entries []PublicVerificationHistoryEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries" yaml:"entries"`
	// TotalCount is the total number of entries
	TotalCount int32 `protobuf:"varint,2,opt,name=total_count,json=totalCount,proto3" json:"total_count" yaml:"total_count"`
}

func (m *QueryVerificationHistoryResponse) Reset()         { *m = QueryVerificationHistoryResponse{} }
func (m *QueryVerificationHistoryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryVerificationHistoryResponse) ProtoMessage()    {}
func (*QueryVerificationHistoryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{25}
}
func (m *QueryVerificationHistoryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryVerificationHistoryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryVerificationHistoryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryVerificationHistoryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryVerificationHistoryResponse.Merge(m, src)
}
func (m *QueryVerificationHistoryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryVerificationHistoryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryVerificationHistoryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryVerificationHistoryResponse proto.InternalMessageInfo

func (m *QueryVerificationHistoryResponse) GetEntries() []PublicVerificationHistoryEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *QueryVerificationHistoryResponse) GetTotalCount() int32 {
	if m != nil {
		return m.TotalCount
	}
	return 0
}

// QueryApprovedClientsRequest is the request for the ApprovedClients query
type QueryApprovedClientsRequest struct {
	// ActiveOnly filters to only active clients
	ActiveOnly bool `protobuf:"varint,1,opt,name=active_only,json=activeOnly,proto3" json:"active_only" yaml:"active_only"`
	// Pagination is the pagination options
	Pagination *query.PageRequest `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryApprovedClientsRequest) Reset()         { *m = QueryApprovedClientsRequest{} }
func (m *QueryApprovedClientsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryApprovedClientsRequest) ProtoMessage()    {}
func (*QueryApprovedClientsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{26}
}
func (m *QueryApprovedClientsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryApprovedClientsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryApprovedClientsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryApprovedClientsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryApprovedClientsRequest.Merge(m, src)
}
func (m *QueryApprovedClientsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryApprovedClientsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryApprovedClientsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryApprovedClientsRequest proto.InternalMessageInfo

func (m *QueryApprovedClientsRequest) GetActiveOnly() bool {
	if m != nil {
		return m.ActiveOnly
	}
	return false
}

func (m *QueryApprovedClientsRequest) GetPagination() *query.PageRequest {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryApprovedClientsResponse is the response for the ApprovedClients query
type QueryApprovedClientsResponse struct {
	// Clients is the list of approved clients
	Clients []ApprovedClient `protobuf:"bytes,1,rep,name=clients,proto3" json:"clients" yaml:"clients"`
	// Pagination is the pagination response
	Pagination *query.PageResponse `protobuf:"bytes,2,opt,name=pagination,proto3" json:"pagination,omitempty"`
}

func (m *QueryApprovedClientsResponse) Reset()         { *m = QueryApprovedClientsResponse{} }
func (m *QueryApprovedClientsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryApprovedClientsResponse) ProtoMessage()    {}
func (*QueryApprovedClientsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{27}
}
func (m *QueryApprovedClientsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryApprovedClientsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryApprovedClientsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryApprovedClientsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryApprovedClientsResponse.Merge(m, src)
}
func (m *QueryApprovedClientsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryApprovedClientsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryApprovedClientsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryApprovedClientsResponse proto.InternalMessageInfo

func (m *QueryApprovedClientsResponse) GetClients() []ApprovedClient {
	if m != nil {
		return m.Clients
	}
	return nil
}

func (m *QueryApprovedClientsResponse) GetPagination() *query.PageResponse {
	if m != nil {
		return m.Pagination
	}
	return nil
}

// QueryParamsRequest is the request for the Params query
type QueryParamsRequest struct {
}

func (m *QueryParamsRequest) Reset()         { *m = QueryParamsRequest{} }
func (m *QueryParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryParamsRequest) ProtoMessage()    {}
func (*QueryParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{28}
}
func (m *QueryParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsRequest.Merge(m, src)
}
func (m *QueryParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsRequest proto.InternalMessageInfo

// QueryParamsResponse is the response for the Params query
type QueryParamsResponse struct {
	// Params are the module parameters
	Params Params `protobuf:"bytes,1,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *QueryParamsResponse) Reset()         { *m = QueryParamsResponse{} }
func (m *QueryParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryParamsResponse) ProtoMessage()    {}
func (*QueryParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{29}
}
func (m *QueryParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryParamsResponse.Merge(m, src)
}
func (m *QueryParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryParamsResponse proto.InternalMessageInfo

func (m *QueryParamsResponse) GetParams() Params {
	if m != nil {
		return m.Params
	}
	return Params{}
}

// QueryBorderlineParamsRequest is the request for the BorderlineParams query
type QueryBorderlineParamsRequest struct {
}

func (m *QueryBorderlineParamsRequest) Reset()         { *m = QueryBorderlineParamsRequest{} }
func (m *QueryBorderlineParamsRequest) String() string { return proto.CompactTextString(m) }
func (*QueryBorderlineParamsRequest) ProtoMessage()    {}
func (*QueryBorderlineParamsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{30}
}
func (m *QueryBorderlineParamsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBorderlineParamsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBorderlineParamsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBorderlineParamsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBorderlineParamsRequest.Merge(m, src)
}
func (m *QueryBorderlineParamsRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryBorderlineParamsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBorderlineParamsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBorderlineParamsRequest proto.InternalMessageInfo

// QueryBorderlineParamsResponse is the response for the BorderlineParams query
type QueryBorderlineParamsResponse struct {
	// Params are the borderline parameters
	Params BorderlineParams `protobuf:"bytes,1,opt,name=params,proto3" json:"params" yaml:"params"`
}

func (m *QueryBorderlineParamsResponse) Reset()         { *m = QueryBorderlineParamsResponse{} }
func (m *QueryBorderlineParamsResponse) String() string { return proto.CompactTextString(m) }
func (*QueryBorderlineParamsResponse) ProtoMessage()    {}
func (*QueryBorderlineParamsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{31}
}
func (m *QueryBorderlineParamsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryBorderlineParamsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryBorderlineParamsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryBorderlineParamsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryBorderlineParamsResponse.Merge(m, src)
}
func (m *QueryBorderlineParamsResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryBorderlineParamsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryBorderlineParamsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryBorderlineParamsResponse proto.InternalMessageInfo

func (m *QueryBorderlineParamsResponse) GetParams() BorderlineParams {
	if m != nil {
		return m.Params
	}
	return BorderlineParams{}
}

// PublicDerivedFeaturesInfo contains non-sensitive derived features metadata
type PublicDerivedFeaturesInfo struct {
	// HasFaceEmbedding indicates if face embedding hash exists
	HasFaceEmbedding bool `protobuf:"varint,1,opt,name=has_face_embedding,json=hasFaceEmbedding,proto3" json:"has_face_embedding" yaml:"has_face_embedding"`
	// HasBiometric indicates if biometric hash exists
	HasBiometric bool `protobuf:"varint,2,opt,name=has_biometric,json=hasBiometric,proto3" json:"has_biometric" yaml:"has_biometric"`
	// HasLivenessProof indicates if liveness proof hash exists
	HasLivenessProof bool `protobuf:"varint,3,opt,name=has_liveness_proof,json=hasLivenessProof,proto3" json:"has_liveness_proof" yaml:"has_liveness_proof"`
	// DocFieldKeys lists which document fields have hashes
	DocFieldKeys []string `protobuf:"bytes,4,rep,name=doc_field_keys,json=docFieldKeys,proto3" json:"doc_field_keys" yaml:"doc_field_keys"`
	// LastComputedAt is when features were last computed (Unix timestamp)
	LastComputedAt int64 `protobuf:"varint,5,opt,name=last_computed_at,json=lastComputedAt,proto3" json:"last_computed_at" yaml:"last_computed_at"`
	// ModelVersion is the model version used
	ModelVersion string `protobuf:"bytes,6,opt,name=model_version,json=modelVersion,proto3" json:"model_version" yaml:"model_version"`
	// FeatureVersion is the schema version
	FeatureVersion uint32 `protobuf:"varint,7,opt,name=feature_version,json=featureVersion,proto3" json:"feature_version" yaml:"feature_version"`
}

func (m *PublicDerivedFeaturesInfo) Reset()         { *m = PublicDerivedFeaturesInfo{} }
func (m *PublicDerivedFeaturesInfo) String() string { return proto.CompactTextString(m) }
func (*PublicDerivedFeaturesInfo) ProtoMessage()    {}
func (*PublicDerivedFeaturesInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{32}
}
func (m *PublicDerivedFeaturesInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PublicDerivedFeaturesInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PublicDerivedFeaturesInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PublicDerivedFeaturesInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublicDerivedFeaturesInfo.Merge(m, src)
}
func (m *PublicDerivedFeaturesInfo) XXX_Size() int {
	return m.Size()
}
func (m *PublicDerivedFeaturesInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_PublicDerivedFeaturesInfo.DiscardUnknown(m)
}

var xxx_messageInfo_PublicDerivedFeaturesInfo proto.InternalMessageInfo

func (m *PublicDerivedFeaturesInfo) GetHasFaceEmbedding() bool {
	if m != nil {
		return m.HasFaceEmbedding
	}
	return false
}

func (m *PublicDerivedFeaturesInfo) GetHasBiometric() bool {
	if m != nil {
		return m.HasBiometric
	}
	return false
}

func (m *PublicDerivedFeaturesInfo) GetHasLivenessProof() bool {
	if m != nil {
		return m.HasLivenessProof
	}
	return false
}

func (m *PublicDerivedFeaturesInfo) GetDocFieldKeys() []string {
	if m != nil {
		return m.DocFieldKeys
	}
	return nil
}

func (m *PublicDerivedFeaturesInfo) GetLastComputedAt() int64 {
	if m != nil {
		return m.LastComputedAt
	}
	return 0
}

func (m *PublicDerivedFeaturesInfo) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func (m *PublicDerivedFeaturesInfo) GetFeatureVersion() uint32 {
	if m != nil {
		return m.FeatureVersion
	}
	return 0
}

// QueryDerivedFeaturesRequest is the request for the DerivedFeatures query
type QueryDerivedFeaturesRequest struct {
	// AccountAddress is the account to query features for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
}

func (m *QueryDerivedFeaturesRequest) Reset()         { *m = QueryDerivedFeaturesRequest{} }
func (m *QueryDerivedFeaturesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivedFeaturesRequest) ProtoMessage()    {}
func (*QueryDerivedFeaturesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{33}
}
func (m *QueryDerivedFeaturesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivedFeaturesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivedFeaturesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivedFeaturesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivedFeaturesRequest.Merge(m, src)
}
func (m *QueryDerivedFeaturesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivedFeaturesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivedFeaturesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivedFeaturesRequest proto.InternalMessageInfo

func (m *QueryDerivedFeaturesRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

// QueryDerivedFeaturesResponse is the response for the DerivedFeatures query
type QueryDerivedFeaturesResponse struct {
	// Features contains non-sensitive derived features information
	Features *PublicDerivedFeaturesInfo `protobuf:"bytes,1,opt,name=features,proto3" json:"features" yaml:"features"`
	// Found indicates if features were found
	Found bool `protobuf:"varint,2,opt,name=found,proto3" json:"found" yaml:"found"`
}

func (m *QueryDerivedFeaturesResponse) Reset()         { *m = QueryDerivedFeaturesResponse{} }
func (m *QueryDerivedFeaturesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivedFeaturesResponse) ProtoMessage()    {}
func (*QueryDerivedFeaturesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{34}
}
func (m *QueryDerivedFeaturesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivedFeaturesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivedFeaturesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivedFeaturesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivedFeaturesResponse.Merge(m, src)
}
func (m *QueryDerivedFeaturesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivedFeaturesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivedFeaturesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivedFeaturesResponse proto.InternalMessageInfo

func (m *QueryDerivedFeaturesResponse) GetFeatures() *PublicDerivedFeaturesInfo {
	if m != nil {
		return m.Features
	}
	return nil
}

func (m *QueryDerivedFeaturesResponse) GetFound() bool {
	if m != nil {
		return m.Found
	}
	return false
}

// QueryDerivedFeatureHashesRequest is the request for the DerivedFeatureHashes query
// This is used for verification matching by authorized parties
type QueryDerivedFeatureHashesRequest struct {
	// AccountAddress is the account to query hashes for
	AccountAddress string `protobuf:"bytes,1,opt,name=account_address,json=accountAddress,proto3" json:"account_address" yaml:"account_address"`
	// Requester is the address requesting the hashes
	Requester string `protobuf:"bytes,2,opt,name=requester,proto3" json:"requester" yaml:"requester"`
	// Purpose describes why the hashes are being requested
	Purpose string `protobuf:"bytes,3,opt,name=purpose,proto3" json:"purpose" yaml:"purpose"`
}

func (m *QueryDerivedFeatureHashesRequest) Reset()         { *m = QueryDerivedFeatureHashesRequest{} }
func (m *QueryDerivedFeatureHashesRequest) String() string { return proto.CompactTextString(m) }
func (*QueryDerivedFeatureHashesRequest) ProtoMessage()    {}
func (*QueryDerivedFeatureHashesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{35}
}
func (m *QueryDerivedFeatureHashesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivedFeatureHashesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivedFeatureHashesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivedFeatureHashesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivedFeatureHashesRequest.Merge(m, src)
}
func (m *QueryDerivedFeatureHashesRequest) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivedFeatureHashesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivedFeatureHashesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivedFeatureHashesRequest proto.InternalMessageInfo

func (m *QueryDerivedFeatureHashesRequest) GetAccountAddress() string {
	if m != nil {
		return m.AccountAddress
	}
	return ""
}

func (m *QueryDerivedFeatureHashesRequest) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *QueryDerivedFeatureHashesRequest) GetPurpose() string {
	if m != nil {
		return m.Purpose
	}
	return ""
}

// QueryDerivedFeatureHashesResponse is the response for the DerivedFeatureHashes query
// Only returned if consent allows sharing
type QueryDerivedFeatureHashesResponse struct {
	// Allowed indicates if the request was allowed based on consent
	Allowed bool `protobuf:"varint,1,opt,name=allowed,proto3" json:"allowed" yaml:"allowed"`
	// DenialReason is set if Allowed is false
	DenialReason string `protobuf:"bytes,2,opt,name=denial_reason,json=denialReason,proto3" json:"denial_reason" yaml:"denial_reason"`
	// FaceEmbeddingHash is the face embedding hash (if consented)
	FaceEmbeddingHash []byte `protobuf:"bytes,3,opt,name=face_embedding_hash,json=faceEmbeddingHash,proto3" json:"face_embedding_hash" yaml:"face_embedding_hash"`
	// DocFieldHashes are document field hashes (if consented)
	DocFieldHashes map[string][]byte `protobuf:"bytes,4,rep,name=doc_field_hashes,json=docFieldHashes,proto3" json:"doc_field_hashes" yaml:"doc_field_hashes" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// BiometricHash is the biometric hash (if consented)
	BiometricHash []byte `protobuf:"bytes,5,opt,name=biometric_hash,json=biometricHash,proto3" json:"biometric_hash" yaml:"biometric_hash"`
	// ModelVersion is the model version used
	ModelVersion string `protobuf:"bytes,6,opt,name=model_version,json=modelVersion,proto3" json:"model_version" yaml:"model_version"`
}

func (m *QueryDerivedFeatureHashesResponse) Reset()         { *m = QueryDerivedFeatureHashesResponse{} }
func (m *QueryDerivedFeatureHashesResponse) String() string { return proto.CompactTextString(m) }
func (*QueryDerivedFeatureHashesResponse) ProtoMessage()    {}
func (*QueryDerivedFeatureHashesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_3181f0aab6e923d6, []int{36}
}
func (m *QueryDerivedFeatureHashesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDerivedFeatureHashesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDerivedFeatureHashesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDerivedFeatureHashesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDerivedFeatureHashesResponse.Merge(m, src)
}
func (m *QueryDerivedFeatureHashesResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryDerivedFeatureHashesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDerivedFeatureHashesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDerivedFeatureHashesResponse proto.InternalMessageInfo

func (m *QueryDerivedFeatureHashesResponse) GetAllowed() bool {
	if m != nil {
		return m.Allowed
	}
	return false
}

func (m *QueryDerivedFeatureHashesResponse) GetDenialReason() string {
	if m != nil {
		return m.DenialReason
	}
	return ""
}

func (m *QueryDerivedFeatureHashesResponse) GetFaceEmbeddingHash() []byte {
	if m != nil {
		return m.FaceEmbeddingHash
	}
	return nil
}

func (m *QueryDerivedFeatureHashesResponse) GetDocFieldHashes() map[string][]byte {
	if m != nil {
		return m.DocFieldHashes
	}
	return nil
}

func (m *QueryDerivedFeatureHashesResponse) GetBiometricHash() []byte {
	if m != nil {
		return m.BiometricHash
	}
	return nil
}

func (m *QueryDerivedFeatureHashesResponse) GetModelVersion() string {
	if m != nil {
		return m.ModelVersion
	}
	return ""
}

func init() {
	proto.RegisterType((*QueryIdentityRequest)(nil), "virtengine.veid.v1.QueryIdentityRequest")
	proto.RegisterType((*QueryIdentityResponse)(nil), "virtengine.veid.v1.QueryIdentityResponse")
	proto.RegisterType((*QueryIdentityRecordRequest)(nil), "virtengine.veid.v1.QueryIdentityRecordRequest")
	proto.RegisterType((*QueryIdentityRecordResponse)(nil), "virtengine.veid.v1.QueryIdentityRecordResponse")
	proto.RegisterType((*QueryScopeRequest)(nil), "virtengine.veid.v1.QueryScopeRequest")
	proto.RegisterType((*QueryScopeResponse)(nil), "virtengine.veid.v1.QueryScopeResponse")
	proto.RegisterType((*QueryScopesRequest)(nil), "virtengine.veid.v1.QueryScopesRequest")
	proto.RegisterType((*QueryScopesResponse)(nil), "virtengine.veid.v1.QueryScopesResponse")
	proto.RegisterType((*QueryScopesByTypeRequest)(nil), "virtengine.veid.v1.QueryScopesByTypeRequest")
	proto.RegisterType((*QueryScopesByTypeResponse)(nil), "virtengine.veid.v1.QueryScopesByTypeResponse")
	proto.RegisterType((*QueryIdentityScoreRequest)(nil), "virtengine.veid.v1.QueryIdentityScoreRequest")
	proto.RegisterType((*QueryIdentityScoreResponse)(nil), "virtengine.veid.v1.QueryIdentityScoreResponse")
	proto.RegisterType((*QueryIdentityStatusRequest)(nil), "virtengine.veid.v1.QueryIdentityStatusRequest")
	proto.RegisterType((*QueryIdentityStatusResponse)(nil), "virtengine.veid.v1.QueryIdentityStatusResponse")
	proto.RegisterType((*QueryIdentityWalletRequest)(nil), "virtengine.veid.v1.QueryIdentityWalletRequest")
	proto.RegisterType((*PublicWalletInfo)(nil), "virtengine.veid.v1.PublicWalletInfo")
	proto.RegisterType((*QueryIdentityWalletResponse)(nil), "virtengine.veid.v1.QueryIdentityWalletResponse")
	proto.RegisterType((*WalletScopeInfo)(nil), "virtengine.veid.v1.WalletScopeInfo")
	proto.RegisterType((*QueryWalletScopesRequest)(nil), "virtengine.veid.v1.QueryWalletScopesRequest")
	proto.RegisterType((*QueryWalletScopesResponse)(nil), "virtengine.veid.v1.QueryWalletScopesResponse")
	proto.RegisterType((*QueryConsentSettingsRequest)(nil), "virtengine.veid.v1.QueryConsentSettingsRequest")
	proto.RegisterType((*PublicConsentInfo)(nil), "virtengine.veid.v1.PublicConsentInfo")
	proto.RegisterType((*QueryConsentSettingsResponse)(nil), "virtengine.veid.v1.QueryConsentSettingsResponse")
	proto.RegisterType((*PublicVerificationHistoryEntry)(nil), "virtengine.veid.v1.PublicVerificationHistoryEntry")
	proto.RegisterType((*QueryVerificationHistoryRequest)(nil), "virtengine.veid.v1.QueryVerificationHistoryRequest")
	proto.RegisterType((*QueryVerificationHistoryResponse)(nil), "virtengine.veid.v1.QueryVerificationHistoryResponse")
	proto.RegisterType((*QueryApprovedClientsRequest)(nil), "virtengine.veid.v1.QueryApprovedClientsRequest")
	proto.RegisterType((*QueryApprovedClientsResponse)(nil), "virtengine.veid.v1.QueryApprovedClientsResponse")
	proto.RegisterType((*QueryParamsRequest)(nil), "virtengine.veid.v1.QueryParamsRequest")
	proto.RegisterType((*QueryParamsResponse)(nil), "virtengine.veid.v1.QueryParamsResponse")
	proto.RegisterType((*QueryBorderlineParamsRequest)(nil), "virtengine.veid.v1.QueryBorderlineParamsRequest")
	proto.RegisterType((*QueryBorderlineParamsResponse)(nil), "virtengine.veid.v1.QueryBorderlineParamsResponse")
	proto.RegisterType((*PublicDerivedFeaturesInfo)(nil), "virtengine.veid.v1.PublicDerivedFeaturesInfo")
	proto.RegisterType((*QueryDerivedFeaturesRequest)(nil), "virtengine.veid.v1.QueryDerivedFeaturesRequest")
	proto.RegisterType((*QueryDerivedFeaturesResponse)(nil), "virtengine.veid.v1.QueryDerivedFeaturesResponse")
	proto.RegisterType((*QueryDerivedFeatureHashesRequest)(nil), "virtengine.veid.v1.QueryDerivedFeatureHashesRequest")
	proto.RegisterType((*QueryDerivedFeatureHashesResponse)(nil), "virtengine.veid.v1.QueryDerivedFeatureHashesResponse")
	proto.RegisterMapType((map[string][]byte)(nil), "virtengine.veid.v1.QueryDerivedFeatureHashesResponse.DocFieldHashesEntry")
}

func init() { proto.RegisterFile("virtengine/veid/v1/query.proto", fileDescriptor_3181f0aab6e923d6) }

var fileDescriptor_3181f0aab6e923d6 = []byte{
	// 3034 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x4b, 0x8c, 0x1c, 0x47,
	0xf9, 0x77, 0xef, 0xec, 0xec, 0xce, 0xd4, 0x3e, 0x5d, 0xde, 0xfc, 0xb3, 0x1e, 0xc7, 0xdb, 0x76,
	0xe5, 0xef, 0xd8, 0x21, 0xd9, 0x99, 0xf8, 0x15, 0x07, 0x03, 0x86, 0x1d, 0x27, 0x9b, 0x98, 0x47,
	0x70, 0xca, 0x89, 0xa3, 0x04, 0xd0, 0xa8, 0x77, 0xba, 0x76, 0xb6, 0xe3, 0xd9, 0xe9, 0x49, 0x77,
	0xcf, 0x98, 0x55, 0x64, 0x0e, 0x1c, 0x40, 0x08, 0x22, 0x90, 0x90, 0x40, 0x39, 0x46, 0x44, 0x04,
	0x84, 0x22, 0x21, 0x11, 0x09, 0x09, 0x84, 0x38, 0x21, 0x25, 0xb7, 0x08, 0x2e, 0x48, 0x48, 0x2d,
	0x94, 0x20, 0x21, 0x8d, 0xc4, 0x65, 0x2e, 0xb9, 0xa2, 0xfe, 0xbe, 0xea, 0xae, 0xee, 0xde, 0x9e,
	0xd9, 0x19, 0x3f, 0xb2, 0x02, 0x71, 0x9b, 0xfa, 0x7d, 0x5d, 0x55, 0xbf, 0xfa, 0xea, 0x7b, 0x55,
	0x75, 0x0f, 0x59, 0xe9, 0x5a, 0x8e, 0x27, 0x5a, 0x0d, 0xab, 0x25, 0x2a, 0x5d, 0x61, 0x99, 0x95,
	0xee, 0xe9, 0xca, 0xab, 0x1d, 0xe1, 0xec, 0x94, 0xdb, 0x8e, 0xed, 0xd9, 0x94, 0x2a, 0x79, 0x39,
	0x90, 0x97, 0xbb, 0xa7, 0x4b, 0x4b, 0x0d, 0xbb, 0x61, 0x83, 0xb8, 0x12, 0xfc, 0xc2, 0x27, 0x4b,
	0x0f, 0x34, 0x6c, 0xbb, 0xd1, 0x14, 0x15, 0xa3, 0x6d, 0x55, 0x8c, 0x56, 0xcb, 0xf6, 0x0c, 0xcf,
	0xb2, 0x5b, 0xae, 0x94, 0x1e, 0xae, 0xdb, 0xee, 0xb6, 0xed, 0xd6, 0xb0, 0x1b, 0x36, 0xa4, 0xe8,
	0x53, 0xd8, 0xaa, 0x6c, 0x18, 0xae, 0xc0, 0xb9, 0x2b, 0xdd, 0xd3, 0x1b, 0xc2, 0x33, 0x4e, 0x57,
	0xda, 0x46, 0xc3, 0x6a, 0xc1, 0x38, 0xf2, 0xd9, 0x2c, 0xba, 0xde, 0x4e, 0x5b, 0xc8, 0xb1, 0xd8,
	0x77, 0x34, 0xb2, 0xf4, 0x5c, 0x30, 0xc4, 0x15, 0x53, 0xb4, 0x3c, 0xcb, 0xdb, 0xe1, 0xe2, 0xd5,
	0x8e, 0x70, 0x3d, 0xda, 0x22, 0x0b, 0x46, 0xbd, 0x6e, 0x77, 0x5a, 0x5e, 0xcd, 0x30, 0x4d, 0x47,
	0xb8, 0xee, 0xb2, 0x76, 0x4c, 0x3b, 0x55, 0xac, 0x3e, 0xd5, 0xf3, 0xf5, 0xb4, 0xa8, 0xef, 0xeb,
	0xff, 0xb7, 0x63, 0x6c, 0x37, 0x2f, 0xb2, 0x94, 0x80, 0xfd, 0xf9, 0xdd, 0xd5, 0x25, 0x49, 0x7e,
	0x0d, 0xa1, 0x6b, 0x9e, 0x63, 0xb5, 0x1a, 0x7c, 0x5e, 0x3e, 0x29, 0x51, 0xf6, 0x4b, 0x8d, 0xdc,
	0x97, 0x22, 0xe2, 0xb6, 0xed, 0x96, 0x2b, 0x68, 0x8d, 0x14, 0x2c, 0x89, 0x01, 0x85, 0x99, 0x33,
	0xac, 0xbc, 0x5b, 0xc9, 0x65, 0xd5, 0xaf, 0x6e, 0x3b, 0x66, 0x55, 0xef, 0xf9, 0x7a, 0xd4, 0xaf,
	0xef, 0xeb, 0x0b, 0xc8, 0x2f, 0x44, 0x18, 0x8f, 0x84, 0xb4, 0x42, 0xf2, 0x9b, 0x76, 0xa7, 0x65,
	0x2e, 0x4f, 0x1c, 0xd3, 0x4e, 0x15, 0xaa, 0x87, 0x7b, 0xbe, 0x8e, 0x40, 0xdf, 0xd7, 0x67, 0xb1,
	0x1b, 0x34, 0x19, 0x47, 0x98, 0xfd, 0x40, 0x23, 0xa5, 0x14, 0xd7, 0x60, 0xce, 0xfd, 0x52, 0x5d,
	0x97, 0x1c, 0xc9, 0x64, 0x23, 0xf5, 0xf7, 0x22, 0x99, 0x72, 0x00, 0x19, 0x43, 0x7b, 0x47, 0x7a,
	0xbe, 0x2e, 0x7b, 0xf5, 0x7d, 0x7d, 0x0e, 0x09, 0x62, 0x9b, 0x71, 0x29, 0x60, 0x7f, 0xd4, 0xc8,
	0x41, 0x98, 0xf8, 0x5a, 0xdd, 0x6e, 0x8b, 0x7d, 0x5a, 0x3d, 0xbd, 0x48, 0x0a, 0x6e, 0x30, 0x7f,
	0xcd, 0xc2, 0x0d, 0x2c, 0xe2, 0xd6, 0x87, 0x98, 0xda, 0xfa, 0x10, 0x61, 0x7c, 0x1a, 0x7e, 0x5e,
	0x31, 0xd9, 0x1b, 0x1a, 0xa1, 0xf1, 0x15, 0x48, 0x8d, 0x71, 0x92, 0x87, 0x27, 0xa4, 0xc2, 0x8e,
	0x0f, 0x53, 0x18, 0xf4, 0x44, 0x9b, 0x81, 0x3e, 0xca, 0x66, 0xa0, 0xc9, 0x38, 0xc2, 0xe3, 0x1b,
	0xd9, 0xdb, 0xb9, 0x38, 0x37, 0x77, 0xbf, 0xd4, 0x6b, 0x10, 0x82, 0x8a, 0x0b, 0xa2, 0x06, 0x90,
	0x9f, 0x3f, 0x73, 0x34, 0x4b, 0x21, 0x40, 0xf3, 0xf9, 0x9d, 0xb6, 0xa8, 0x3e, 0xd8, 0xf3, 0xf5,
	0x58, 0xa7, 0xbe, 0xaf, 0x1f, 0x8c, 0xef, 0x40, 0x80, 0x31, 0x5e, 0x74, 0xc3, 0xe7, 0x69, 0x97,
	0xcc, 0xb9, 0x9e, 0xe1, 0x75, 0xdc, 0xda, 0xa6, 0xd5, 0xf4, 0x84, 0xb3, 0x9c, 0x83, 0x59, 0x1e,
	0xca, 0x9a, 0xe5, 0xba, 0x70, 0xac, 0x4d, 0xab, 0x0e, 0x21, 0xee, 0x1a, 0x74, 0xaa, 0x3e, 0xdc,
	0xf3, 0xf5, 0xe4, 0x00, 0x7d, 0x5f, 0x5f, 0x92, 0x33, 0xc6, 0x61, 0xc6, 0x67, 0xb1, 0xbd, 0x0e,
	0x4d, 0xba, 0x4e, 0x88, 0x8a, 0x97, 0xcb, 0x93, 0xb0, 0xd7, 0x0f, 0x95, 0xa5, 0x56, 0x82, 0xe0,
	0x5a, 0xc6, 0xc0, 0x2e, 0x83, 0x6b, 0xf9, 0xaa, 0xd1, 0x08, 0xad, 0x9c, 0xc7, 0x7a, 0xb2, 0xdf,
	0x69, 0xe4, 0x50, 0x62, 0xa7, 0xa4, 0x19, 0xbd, 0x4c, 0xa6, 0x60, 0x91, 0xc1, 0x0e, 0xe5, 0x46,
	0xb3, 0x23, 0xfd, 0x3d, 0x5f, 0x3f, 0x10, 0xf8, 0x1e, 0x76, 0x54, 0xbe, 0x87, 0x6d, 0xc6, 0xa5,
	0x80, 0x3e, 0x9d, 0xe0, 0x3e, 0x01, 0xdc, 0x4f, 0xee, 0xc9, 0x1d, 0x89, 0x25, 0xc8, 0xff, 0x4b,
	0x23, 0xcb, 0x31, 0xf2, 0xd5, 0x9d, 0x60, 0x4b, 0xfe, 0x7b, 0x8d, 0x8d, 0xdd, 0x24, 0x87, 0x33,
	0x96, 0x7b, 0xef, 0x77, 0x8c, 0x7d, 0x5f, 0x93, 0x33, 0xc7, 0xfa, 0x3b, 0xfb, 0xa5, 0x69, 0xf6,
	0x66, 0x3a, 0x85, 0x49, 0x36, 0x89, 0x08, 0xe8, 0x8c, 0x1a, 0x01, 0x1d, 0x15, 0x01, 0x9d, 0x64,
	0x04, 0x74, 0x64, 0x04, 0x74, 0xc4, 0x5d, 0x48, 0xb3, 0xe8, 0xf0, 0xfb, 0xa5, 0xb2, 0x3f, 0x4c,
	0xa6, 0xf2, 0x6c, 0x48, 0x47, 0xea, 0xec, 0x93, 0x76, 0x96, 0xeb, 0x64, 0x0a, 0xc3, 0x99, 0x74,
	0x94, 0xcc, 0x4d, 0x5a, 0xc3, 0x3e, 0x32, 0x54, 0x42, 0x5a, 0xc7, 0x4e, 0x31, 0x43, 0x85, 0x76,
	0x60, 0xa8, 0xf0, 0x83, 0x7e, 0x85, 0x4c, 0x7a, 0x56, 0x14, 0x85, 0x8f, 0x0d, 0xdb, 0xfa, 0xe7,
	0x2d, 0xe1, 0x54, 0xef, 0xef, 0xf9, 0x3a, 0xf4, 0xe8, 0xfb, 0xfa, 0x0c, 0x0e, 0x19, 0xb4, 0x18,
	0x07, 0x30, 0xd8, 0x76, 0x34, 0xa5, 0x20, 0xc0, 0xce, 0x8d, 0x60, 0x27, 0xcf, 0x92, 0xb9, 0x6d,
	0xdb, 0x14, 0xcd, 0x5a, 0x57, 0x38, 0x6e, 0x10, 0xdd, 0xf2, 0xa0, 0x45, 0x08, 0xf3, 0x09, 0x81,
	0x0a, 0xf3, 0x09, 0x98, 0xf1, 0x59, 0x68, 0x5f, 0xc7, 0x26, 0x7d, 0x81, 0x2c, 0x34, 0x0d, 0xd7,
	0xab, 0x75, 0xda, 0xa6, 0xe1, 0x09, 0xb3, 0x66, 0x78, 0xcb, 0x53, 0xc7, 0xb4, 0x53, 0xb9, 0xea,
	0x6a, 0xb0, 0x2f, 0x29, 0x91, 0xda, 0x97, 0x94, 0x80, 0xf1, 0xb9, 0x00, 0x79, 0x01, 0x81, 0x35,
	0x4f, 0x99, 0xf3, 0xf4, 0xed, 0x9a, 0xf3, 0x8b, 0x46, 0xb3, 0x29, 0xbc, 0xfd, 0x32, 0xe7, 0x7f,
	0xe6, 0xc9, 0xe2, 0xd5, 0xce, 0x46, 0xd3, 0xaa, 0x23, 0x8f, 0x2b, 0xad, 0x4d, 0x9b, 0x5e, 0x22,
	0xc5, 0x9b, 0xd0, 0x0a, 0xaa, 0x29, 0x9c, 0xfe, 0x78, 0xcf, 0xd7, 0x15, 0xd8, 0xf7, 0xf5, 0x45,
	0x9c, 0x38, 0x82, 0x18, 0x2f, 0xe0, 0xef, 0x2b, 0x66, 0xd6, 0x22, 0x26, 0xee, 0xa5, 0x0f, 0xbc,
	0x10, 0xf9, 0xc0, 0x10, 0x6b, 0xc5, 0xf5, 0x8d, 0xe3, 0x02, 0x63, 0xdb, 0x6c, 0xe8, 0x33, 0xf9,
	0xbb, 0xe3, 0x33, 0xeb, 0x64, 0x06, 0xd3, 0x17, 0x2c, 0x16, 0xcc, 0x35, 0x5f, 0x3d, 0xd1, 0xf3,
	0xf5, 0x38, 0xdc, 0xf7, 0x75, 0x1a, 0x4f, 0x75, 0x00, 0x32, 0x8e, 0xc9, 0xf0, 0x72, 0xd0, 0xa0,
	0x16, 0x59, 0xea, 0x42, 0xc1, 0x24, 0xcc, 0x5a, 0x7c, 0xc0, 0x69, 0x18, 0xf0, 0x42, 0xcf, 0xd7,
	0x33, 0xe5, 0x7d, 0x5f, 0x3f, 0x82, 0x23, 0x67, 0x49, 0x19, 0xa7, 0x21, 0x7c, 0x4d, 0x4d, 0x55,
	0x25, 0xa4, 0xee, 0x88, 0xd0, 0xc1, 0x0a, 0xe0, 0x60, 0x90, 0x9b, 0x15, 0xaa, 0x72, 0xb3, 0xc2,
	0x18, 0x2f, 0xca, 0xc6, 0x9a, 0x97, 0xe5, 0xa9, 0xc5, 0x3b, 0xf7, 0xd4, 0xe0, 0x68, 0x79, 0x24,
	0xd3, 0xf1, 0x64, 0xe0, 0x7e, 0x89, 0x4c, 0xa1, 0x01, 0xcb, 0x6c, 0xf7, 0xff, 0x59, 0xdb, 0x97,
	0x76, 0x15, 0x34, 0x24, 0xec, 0xa7, 0x0c, 0x09, 0xdb, 0x8c, 0x4b, 0xc1, 0xf8, 0x39, 0xef, 0x9d,
	0x49, 0xb2, 0x20, 0xed, 0x15, 0xce, 0x28, 0x81, 0x53, 0xc6, 0x4f, 0x38, 0xda, 0x78, 0x27, 0x9c,
	0x4f, 0xa2, 0x7c, 0xff, 0x5a, 0xca, 0x07, 0x47, 0xad, 0xdb, 0x47, 0xf2, 0xc4, 0x8b, 0xa4, 0x60,
	0x98, 0x26, 0xda, 0xc2, 0x24, 0xd8, 0x02, 0xac, 0x3d, 0xc4, 0xd4, 0xda, 0x43, 0x84, 0xf1, 0x69,
	0xf8, 0xb9, 0xe6, 0x05, 0x5e, 0x14, 0xd9, 0xaf, 0xe1, 0x81, 0x6f, 0xe6, 0xd0, 0x8b, 0x62, 0xb0,
	0xf2, 0xa2, 0x18, 0xc8, 0x38, 0x09, 0x5b, 0x6b, 0x60, 0xda, 0xe2, 0x9b, 0x6d, 0xcb, 0x11, 0xae,
	0xca, 0x1d, 0xa0, 0x24, 0x85, 0x2a, 0x25, 0x29, 0x8c, 0xf1, 0xa2, 0x6c, 0xac, 0x79, 0xf4, 0x3a,
	0x59, 0xa8, 0x07, 0xc6, 0xd6, 0xf2, 0x6a, 0x0d, 0xc7, 0x68, 0x79, 0x22, 0xcc, 0x1b, 0x60, 0xda,
	0x29, 0x91, 0x32, 0xed, 0x94, 0x80, 0xf1, 0x79, 0x89, 0x3c, 0x2d, 0x81, 0x77, 0x72, 0xb2, 0x7c,
	0x8f, 0x19, 0xcd, 0xff, 0xce, 0x8a, 0xf7, 0xe2, 0xac, 0x38, 0x63, 0xd4, 0x3d, 0xab, 0x2b, 0x6a,
	0x76, 0xab, 0xb9, 0x03, 0xa6, 0x58, 0x40, 0x5b, 0x8a, 0xc1, 0xca, 0x96, 0x62, 0x20, 0xe3, 0x04,
	0x5b, 0x5f, 0x0d, 0x1a, 0xaf, 0x4f, 0xc8, 0x53, 0x40, 0x72, 0xbf, 0x64, 0x24, 0xfa, 0x7a, 0xea,
	0xfc, 0xf1, 0xe0, 0x90, 0x74, 0x16, 0x86, 0x87, 0xd1, 0xcf, 0x8c, 0xeb, 0x64, 0xc6, 0xb3, 0x3d,
	0xa3, 0x29, 0x93, 0xc0, 0x84, 0xca, 0x2a, 0x31, 0x58, 0xad, 0x21, 0x06, 0x32, 0x4e, 0xa0, 0x85,
	0xa1, 0xfe, 0x8b, 0x64, 0x56, 0xae, 0x0f, 0x07, 0xca, 0xc1, 0x40, 0x27, 0x7b, 0xbe, 0x9e, 0xc0,
	0xfb, 0xbe, 0x7e, 0x28, 0xa1, 0x0d, 0x39, 0x94, 0xd4, 0x18, 0x8c, 0xc5, 0xde, 0x0f, 0x63, 0xf3,
	0x65, 0xb4, 0xeb, 0x6b, 0xc2, 0xf3, 0xac, 0x56, 0xc3, 0xfd, 0x4f, 0xbc, 0x4d, 0xfa, 0xd3, 0x04,
	0x39, 0x88, 0x69, 0x42, 0x2e, 0xe6, 0x8e, 0xa3, 0xf7, 0x05, 0x32, 0x1d, 0x46, 0x0b, 0x4c, 0x20,
	0x47, 0x7b, 0xbe, 0x3e, 0xad, 0xa2, 0xc4, 0x3c, 0xf6, 0x8c, 0xa2, 0x43, 0x28, 0x0a, 0xea, 0x38,
	0xcb, 0xad, 0xa1, 0xa2, 0x61, 0x7f, 0x0a, 0x58, 0xc7, 0x45, 0xa0, 0xaa, 0xe3, 0x22, 0x88, 0xf1,
	0x82, 0xe5, 0xae, 0xc1, 0xcf, 0x60, 0xe2, 0x76, 0xc7, 0x69, 0xdb, 0x2e, 0x96, 0x40, 0x45, 0x9c,
	0x58, 0x42, 0x6a, 0x62, 0x09, 0x30, 0x1e, 0x8a, 0x52, 0xb1, 0x32, 0x7f, 0x3b, 0xb1, 0x92, 0xbd,
	0x9f, 0x23, 0x0f, 0x64, 0xdb, 0x84, 0x74, 0x93, 0xd7, 0xc8, 0x42, 0xa3, 0x69, 0x6f, 0x18, 0xcd,
	0x9a, 0x2b, 0x45, 0x32, 0x73, 0x67, 0xfa, 0x4b, 0x6a, 0x14, 0x8c, 0xb8, 0xa9, 0xfe, 0xca, 0x72,
	0x52, 0x02, 0xc6, 0xe7, 0x11, 0x09, 0xbb, 0xd3, 0x5b, 0x64, 0x3e, 0x2c, 0x86, 0x60, 0xdc, 0xa0,
	0xc2, 0x0d, 0x7c, 0xf5, 0xc4, 0xe0, 0xaa, 0x21, 0x66, 0x0e, 0xd5, 0x8a, 0xf4, 0xd6, 0xd4, 0x20,
	0x7d, 0x5f, 0xbf, 0x2f, 0x59, 0xcc, 0x21, 0xce, 0xf8, 0x9c, 0xac, 0xe7, 0xb0, 0x1d, 0x4f, 0x24,
	0xe1, 0xf9, 0x28, 0x07, 0x45, 0x6a, 0x22, 0x91, 0xa8, 0x13, 0x52, 0x2a, 0x91, 0x44, 0x67, 0xa4,
	0x30, 0x91, 0x0c, 0x39, 0x25, 0x4d, 0xde, 0x85, 0xda, 0xeb, 0xe3, 0x3c, 0x59, 0x41, 0x25, 0xc4,
	0xa3, 0xf1, 0x33, 0x96, 0xeb, 0xd9, 0xce, 0xce, 0x53, 0x2d, 0xcf, 0xd9, 0x09, 0x1c, 0x44, 0x04,
	0x3f, 0x52, 0x0e, 0x12, 0x62, 0xca, 0x41, 0x42, 0x84, 0xf1, 0x69, 0xf8, 0x79, 0xc5, 0xa4, 0x9f,
	0x27, 0x45, 0xcf, 0xda, 0x16, 0xae, 0x67, 0x6c, 0xb7, 0xc1, 0x45, 0x72, 0x68, 0xe7, 0x11, 0xa8,
	0xec, 0x3c, 0x82, 0x18, 0x57, 0xe2, 0x20, 0x96, 0x6d, 0x34, 0xed, 0xfa, 0x8d, 0xda, 0x96, 0xb0,
	0x1a, 0x5b, 0x18, 0xcb, 0x72, 0x18, 0xcb, 0xe2, 0xb8, 0x8a, 0x65, 0x71, 0x94, 0xf1, 0x19, 0x68,
	0x3e, 0x03, 0x2d, 0xca, 0xc9, 0x7c, 0xdb, 0x11, 0x5d, 0xcb, 0xee, 0xb8, 0xb5, 0xf8, 0xf1, 0xe1,
	0x91, 0x60, 0xbb, 0x93, 0x12, 0xb5, 0xdd, 0x49, 0x9c, 0xf1, 0xb9, 0x10, 0x80, 0x6b, 0x95, 0xc0,
	0x91, 0x5b, 0xe2, 0xa6, 0x1c, 0x2e, 0x0f, 0xc3, 0xc1, 0x02, 0x23, 0x50, 0x2d, 0x30, 0x82, 0x18,
	0x2f, 0xb4, 0xc4, 0x4d, 0xec, 0xbf, 0x43, 0x16, 0xd4, 0x0c, 0x58, 0xa5, 0x4d, 0x8d, 0x7a, 0x5b,
	0x00, 0x3b, 0x9f, 0xea, 0xad, 0x76, 0x3e, 0x25, 0x60, 0x3c, 0x5a, 0x22, 0x76, 0xa7, 0x82, 0x10,
	0xa0, 0x84, 0xb3, 0x4e, 0x8f, 0x3a, 0x2b, 0x44, 0x0b, 0xd5, 0x51, 0x45, 0x0b, 0x85, 0x31, 0x1e,
	0xac, 0x5f, 0x4e, 0x93, 0x3a, 0x2b, 0x15, 0x6e, 0xf7, 0xac, 0xb4, 0xeb, 0xda, 0xa1, 0x78, 0x47,
	0xd7, 0x0e, 0xec, 0x63, 0x8d, 0xe8, 0x10, 0xc5, 0x32, 0x0c, 0x7f, 0xbf, 0xb2, 0x5b, 0x85, 0xe4,
	0x9b, 0xd6, 0xb6, 0x85, 0xb9, 0x5f, 0x9e, 0x6b, 0x01, 0x50, 0xc7, 0x11, 0x68, 0x32, 0x8e, 0x30,
	0x3d, 0x4b, 0xa6, 0xec, 0xcd, 0x4d, 0x57, 0x78, 0x32, 0xc8, 0x40, 0xcd, 0x8e, 0x88, 0xaa, 0x33,
	0xb0, 0xcd, 0xb8, 0x14, 0xb0, 0xbf, 0x69, 0xe4, 0xd8, 0xe0, 0x95, 0xcb, 0x18, 0x6e, 0x13, 0x70,
	0x62, 0x2b, 0xaa, 0x75, 0xce, 0x0c, 0x8e, 0x9f, 0x83, 0x42, 0x47, 0xf5, 0xb8, 0x0c, 0xa6, 0xe1,
	0x50, 0x2a, 0x33, 0x49, 0x40, 0x86, 0x0a, 0xeb, 0xee, 0x55, 0x3f, 0xec, 0x9d, 0xb0, 0x62, 0x59,
	0x6b, 0xb7, 0x1d, 0xbb, 0x2b, 0xcc, 0xcb, 0x4d, 0x2b, 0x88, 0xcc, 0xe1, 0x9e, 0xa6, 0x2a, 0x45,
	0xed, 0x36, 0x2b, 0xc5, 0xd4, 0xdb, 0x89, 0x89, 0xdb, 0x7e, 0x3b, 0xf1, 0x9e, 0x26, 0xb3, 0xe9,
	0x2e, 0xbe, 0xd1, 0xfb, 0xd5, 0xe9, 0x3a, 0x42, 0x72, 0x27, 0x32, 0x5f, 0x10, 0x26, 0x7b, 0x2b,
	0xcd, 0xcb, 0xae, 0x4a, 0xf3, 0x12, 0x60, 0x3c, 0x14, 0xdd, 0xbd, 0x77, 0x15, 0x4b, 0xf2, 0x8d,
	0xd8, 0x55, 0xc3, 0x31, 0xb6, 0x43, 0x85, 0xb3, 0x57, 0xe4, 0xdb, 0x97, 0x10, 0x95, 0xcb, 0xba,
	0x46, 0xa6, 0xda, 0x80, 0xc8, 0xda, 0xa0, 0x94, 0x69, 0x5f, 0xf0, 0x84, 0x2a, 0xa1, 0xb1, 0x87,
	0x32, 0x6d, 0x6c, 0x33, 0x2e, 0x05, 0x6c, 0x45, 0xea, 0xb2, 0x6a, 0x3b, 0xa6, 0x70, 0x9a, 0x56,
	0x4b, 0x24, 0xb9, 0x7c, 0x8b, 0x1c, 0x1d, 0x20, 0x97, 0xac, 0xbe, 0x91, 0x62, 0x95, 0x79, 0xd7,
	0x90, 0xee, 0x3d, 0x3a, 0xbf, 0xef, 0xe6, 0xc9, 0x61, 0xf4, 0x99, 0x27, 0x85, 0x63, 0x75, 0x85,
	0xb9, 0x2e, 0x0c, 0xaf, 0xe3, 0x08, 0x17, 0x4a, 0x51, 0x83, 0xd0, 0x2d, 0xc3, 0xad, 0x6d, 0x1a,
	0x75, 0x51, 0x13, 0xdb, 0x1b, 0xc2, 0x34, 0xad, 0x56, 0x43, 0x5a, 0xe8, 0xd9, 0x9e, 0xaf, 0x67,
	0x48, 0xfb, 0xbe, 0x7e, 0x18, 0xa7, 0xda, 0x2d, 0x63, 0x7c, 0x71, 0xcb, 0x70, 0xd7, 0x8d, 0xba,
	0x78, 0x2a, 0x84, 0x82, 0x28, 0x1a, 0x3c, 0xb8, 0x61, 0xd9, 0xdb, 0xc2, 0x73, 0xac, 0xba, 0xac,
	0x5b, 0x21, 0x8a, 0x26, 0x04, 0x2a, 0x8a, 0x26, 0x60, 0xc6, 0x67, 0xb7, 0x0c, 0xb7, 0x1a, 0x36,
	0x43, 0xca, 0x4d, 0xab, 0x2b, 0x5a, 0xc2, 0x85, 0xcf, 0x21, 0xec, 0x4d, 0x59, 0xd1, 0x46, 0x94,
	0x93, 0xd2, 0x24, 0xe5, 0xa4, 0x0c, 0x29, 0x7f, 0x59, 0x62, 0x57, 0x03, 0x88, 0x3e, 0x47, 0xe6,
	0x4d, 0xbb, 0x5e, 0xdb, 0xb4, 0x44, 0xd3, 0xac, 0xdd, 0x10, 0x3b, 0xee, 0xf2, 0xe4, 0xb1, 0xdc,
	0xa9, 0x22, 0xa6, 0xed, 0xa4, 0x44, 0xa5, 0xed, 0x24, 0xce, 0xf8, 0xac, 0x69, 0xd7, 0xd7, 0x83,
	0xf6, 0x97, 0xc4, 0x8e, 0x4b, 0x5f, 0x22, 0x8b, 0x50, 0x18, 0xd5, 0xed, 0xed, 0x76, 0xc7, 0x8b,
	0x5f, 0x3f, 0x54, 0x7a, 0xbe, 0xbe, 0x4b, 0xd6, 0xf7, 0xf5, 0xfb, 0x63, 0xe5, 0x54, 0x4c, 0xc2,
	0xf8, 0x7c, 0x00, 0x5d, 0x96, 0xc8, 0x5a, 0x46, 0x9a, 0x9a, 0xba, 0xb3, 0xdb, 0xf1, 0xeb, 0x64,
	0x61, 0x13, 0x6d, 0x24, 0x1a, 0x71, 0x5a, 0xd5, 0x93, 0x29, 0x91, 0x4a, 0x41, 0x29, 0x01, 0xe3,
	0xf3, 0x12, 0x09, 0xd3, 0xdf, 0xeb, 0x61, 0x98, 0x4c, 0x19, 0xe2, 0x7e, 0x5d, 0x77, 0xff, 0x3e,
	0x0c, 0x83, 0xbb, 0xf8, 0x48, 0xcf, 0x7c, 0x85, 0x14, 0xe4, 0x12, 0x42, 0xdf, 0x5c, 0x1d, 0x9c,
	0x91, 0x32, 0xbc, 0x0b, 0xab, 0xd6, 0x70, 0x08, 0x55, 0xb5, 0x86, 0x08, 0xe3, 0x91, 0x70, 0xfc,
	0x6b, 0xc1, 0xb7, 0x26, 0x64, 0x4a, 0x4d, 0x4e, 0xfc, 0x8c, 0xe1, 0x6e, 0xed, 0xdf, 0x75, 0xcf,
	0x8b, 0xa4, 0xe8, 0xe0, 0xd4, 0xc2, 0x91, 0x87, 0xe5, 0x4f, 0x07, 0xb5, 0x69, 0x04, 0xaa, 0xda,
	0x34, 0x82, 0x06, 0x8f, 0xae, 0xba, 0xc5, 0x4f, 0x9f, 0xb9, 0x71, 0x4e, 0x9f, 0xec, 0xcd, 0x3c,
	0x39, 0x3e, 0x44, 0x4d, 0x72, 0xa7, 0x2f, 0x90, 0x69, 0xa3, 0xd9, 0xb4, 0x6f, 0x0a, 0x53, 0xc6,
	0x3e, 0x18, 0x5e, 0x42, 0x6a, 0x78, 0x09, 0x30, 0x1e, 0x8a, 0x02, 0xdf, 0x33, 0x45, 0xcb, 0x32,
	0x9a, 0x35, 0x47, 0x18, 0xae, 0xcc, 0x65, 0xd2, 0xf7, 0x12, 0x02, 0xe5, 0x7b, 0x09, 0x38, 0x08,
	0x13, 0xd0, 0xe6, 0xd0, 0xa4, 0x82, 0x1c, 0x4a, 0x46, 0xd4, 0xda, 0x96, 0xe1, 0x6e, 0xc1, 0x9a,
	0x67, 0xab, 0xe7, 0x7b, 0xbe, 0x9e, 0x25, 0xee, 0xfb, 0x7a, 0x49, 0x9a, 0xc8, 0x6e, 0x21, 0xe3,
	0x07, 0x37, 0xe3, 0xf1, 0x38, 0x58, 0x39, 0x7d, 0x4b, 0x23, 0x8b, 0x2a, 0x5e, 0x6d, 0x81, 0x32,
	0x20, 0xc6, 0xcd, 0x9c, 0xb9, 0x92, 0x65, 0xe2, 0x7b, 0x6a, 0xb0, 0xfc, 0xa4, 0x0c, 0x76, 0x08,
	0x63, 0x2d, 0x06, 0x91, 0x2d, 0x3d, 0x8d, 0x8a, 0x6c, 0x69, 0x09, 0xe3, 0xf3, 0x66, 0x62, 0x94,
	0xe0, 0xf8, 0x14, 0xa5, 0x01, 0x54, 0x44, 0x1e, 0x14, 0x01, 0x71, 0x38, 0x29, 0x51, 0x71, 0x38,
	0x89, 0x33, 0x3e, 0x17, 0x01, 0xb0, 0xf4, 0xbb, 0x1c, 0x2d, 0x4b, 0x6b, 0xe4, 0x50, 0xc6, 0xda,
	0xe9, 0x22, 0xc9, 0xdd, 0x10, 0x58, 0xeb, 0x15, 0x79, 0xf0, 0x93, 0x2e, 0x91, 0x7c, 0xd7, 0x68,
	0x76, 0xf0, 0x16, 0x74, 0x96, 0x63, 0xe3, 0xe2, 0xc4, 0x13, 0xda, 0x99, 0xef, 0xdd, 0x47, 0xf2,
	0xa0, 0x61, 0xfa, 0x6b, 0x8d, 0xcc, 0x27, 0xbf, 0xbb, 0xa2, 0xe5, 0x81, 0xfb, 0x91, 0xf9, 0xa9,
	0x59, 0xa9, 0x32, 0xf2, 0xf3, 0xb8, 0x73, 0xec, 0x73, 0xdf, 0xfe, 0xcb, 0x3f, 0x7e, 0x3c, 0x71,
	0x81, 0x9e, 0xaf, 0x64, 0x7c, 0x18, 0x18, 0x7e, 0x11, 0x57, 0xc3, 0x0f, 0xbc, 0x2a, 0xaf, 0xa5,
	0x42, 0xc3, 0x2d, 0xfa, 0x53, 0x8d, 0x14, 0xc2, 0x91, 0xe9, 0xa9, 0x11, 0x26, 0x47, 0x9a, 0x0f,
	0x8f, 0xf0, 0xa4, 0x24, 0xf8, 0x38, 0x10, 0x7c, 0x8c, 0x96, 0x87, 0x11, 0xcc, 0x60, 0xf6, 0x13,
	0x8d, 0xe4, 0xe1, 0x4e, 0x94, 0x9e, 0x18, 0x38, 0x59, 0xfc, 0x3b, 0xb5, 0xd2, 0x43, 0x7b, 0x3d,
	0x26, 0x09, 0x5d, 0x02, 0x42, 0x4f, 0xd0, 0xc7, 0xb3, 0x08, 0xc1, 0xf9, 0x71, 0x37, 0x9b, 0xca,
	0x6b, 0xe1, 0x65, 0xde, 0x2d, 0xfa, 0x43, 0x8d, 0x4c, 0xe1, 0x35, 0x2f, 0xdd, 0x63, 0xca, 0x30,
	0x90, 0x97, 0x4e, 0xee, 0xf9, 0x9c, 0xe4, 0x76, 0x0e, 0xb8, 0x95, 0xe9, 0xa3, 0x03, 0xb9, 0xb9,
	0x19, 0xaa, 0xfa, 0x8d, 0x46, 0x66, 0xe3, 0x9f, 0xbf, 0xd0, 0x47, 0xf7, 0x98, 0x2f, 0xf1, 0x51,
	0x50, 0x69, 0x75, 0xc4, 0xa7, 0x25, 0xc7, 0x75, 0xe0, 0xf8, 0x05, 0x7a, 0x69, 0x1c, 0x8e, 0xf0,
	0x8d, 0x6a, 0xa8, 0xc5, 0xe0, 0xf7, 0x2d, 0xfa, 0x33, 0x8d, 0xcc, 0x25, 0x3e, 0x39, 0xa1, 0xab,
	0x7b, 0x5a, 0x55, 0xfc, 0x13, 0x9b, 0x52, 0x79, 0xd4, 0xc7, 0x25, 0xf1, 0xb3, 0x40, 0x7c, 0x95,
	0x3e, 0x32, 0x80, 0xb8, 0x93, 0xb1, 0xf1, 0xf4, 0xed, 0x98, 0x4f, 0xcb, 0x0b, 0x8a, 0x11, 0xe6,
	0x8d, 0x7f, 0xd7, 0x32, 0x82, 0x4f, 0x27, 0x3f, 0x3c, 0xd9, 0xc3, 0x0a, 0xe0, 0xd9, 0x3d, 0x98,
	0xe2, 0x2b, 0x85, 0x11, 0x98, 0x26, 0x3e, 0x59, 0x18, 0x81, 0x69, 0xf2, 0x4d, 0xeb, 0x70, 0xa6,
	0xf8, 0xca, 0x34, 0x83, 0xe9, 0x2f, 0x34, 0x32, 0x1b, 0x7f, 0x5d, 0x32, 0xc4, 0x5e, 0x33, 0xde,
	0x82, 0x0d, 0xb1, 0xd7, 0xac, 0x77, 0x30, 0xec, 0x33, 0xc0, 0xf1, 0x3c, 0x3d, 0x3b, 0x0e, 0x47,
	0x69, 0xc8, 0xf4, 0x57, 0x1a, 0x59, 0x48, 0xdd, 0x37, 0xd3, 0xc1, 0x5a, 0xca, 0x7e, 0xe7, 0x51,
	0x7a, 0x6c, 0xf4, 0x0e, 0x92, 0xf3, 0x79, 0xe0, 0x5c, 0xa1, 0xab, 0x59, 0x9c, 0xe5, 0x45, 0x6f,
	0x86, 0x62, 0xdf, 0xd5, 0xc8, 0x42, 0xaa, 0x92, 0x1d, 0xc2, 0x36, 0xbb, 0x90, 0x1f, 0xc2, 0x76,
	0x40, 0xa5, 0x3d, 0x3c, 0xa2, 0x9a, 0xd8, 0xa9, 0x16, 0xd6, 0xca, 0x19, 0xb4, 0xdf, 0xd7, 0xc8,
	0x52, 0x56, 0x79, 0x42, 0xcf, 0x8d, 0x59, 0xcd, 0xe0, 0x02, 0xce, 0xdf, 0x56, 0x0d, 0xc4, 0x9e,
	0x84, 0x55, 0x5c, 0xa2, 0x9f, 0x1d, 0x61, 0x15, 0xb2, 0xe6, 0xc9, 0x58, 0xcb, 0x6f, 0x35, 0x72,
	0x28, 0xe3, 0x7a, 0x8b, 0x9e, 0x1d, 0x48, 0x6a, 0xf0, 0x75, 0x62, 0xe9, 0xdc, 0x78, 0x9d, 0x46,
	0x31, 0x9e, 0x2d, 0x7c, 0x38, 0x83, 0xf9, 0x1b, 0x1a, 0x59, 0x48, 0x5d, 0x29, 0x0d, 0x31, 0x9e,
	0xec, 0xcb, 0xb2, 0x21, 0xc6, 0x33, 0xe0, 0xb6, 0x8a, 0x3d, 0x08, 0x6c, 0x8f, 0xd2, 0x23, 0x99,
	0xa6, 0x2e, 0x79, 0xdc, 0x22, 0x53, 0x78, 0x73, 0x32, 0x24, 0xe5, 0x26, 0x2e, 0x6e, 0x86, 0xa4,
	0xdc, 0xe4, 0x05, 0x0e, 0x63, 0x30, 0xff, 0x03, 0xb4, 0x94, 0x35, 0x3f, 0xde, 0xc2, 0xd0, 0x9f,
	0x6b, 0x64, 0x31, 0x7d, 0x87, 0x43, 0x07, 0x2f, 0x75, 0xc0, 0x65, 0x52, 0xe9, 0xf4, 0x18, 0x3d,
	0x24, 0xbb, 0x55, 0x60, 0x77, 0x92, 0x9e, 0xc8, 0x62, 0xb7, 0x11, 0xf5, 0xaa, 0x21, 0xd1, 0xea,
	0xb3, 0xef, 0x7d, 0xb8, 0xa2, 0x7d, 0xf0, 0xe1, 0x8a, 0xf6, 0xf7, 0x0f, 0x57, 0xb4, 0x1f, 0x7d,
	0xb4, 0x72, 0xe0, 0x83, 0x8f, 0x56, 0x0e, 0xfc, 0xf5, 0xa3, 0x95, 0x03, 0x2f, 0x9f, 0x6b, 0x58,
	0xde, 0x56, 0x67, 0xa3, 0x5c, 0xb7, 0xb7, 0x13, 0x43, 0xa9, 0x9f, 0xae, 0x79, 0xa3, 0xd2, 0xb0,
	0x2b, 0x2d, 0xdb, 0x8c, 0x66, 0xd8, 0x98, 0x82, 0x3f, 0x95, 0x9c, 0xfd, 0x77, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xac, 0x06, 0x93, 0xe4, 0x25, 0x33, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// QueryClient is the client API for Query service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type QueryClient interface {
	// IdentityRecord queries an identity record by account address
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityRecord(ctx context.Context, in *QueryIdentityRecordRequest, opts ...grpc.CallOption) (*QueryIdentityRecordResponse, error)
	// Identity queries an identity record by account address (alias for IdentityRecord)
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Identity(ctx context.Context, in *QueryIdentityRequest, opts ...grpc.CallOption) (*QueryIdentityResponse, error)
	// Scope queries a specific scope by ID
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Scope(ctx context.Context, in *QueryScopeRequest, opts ...grpc.CallOption) (*QueryScopeResponse, error)
	// Scopes queries all scopes for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Scopes(ctx context.Context, in *QueryScopesRequest, opts ...grpc.CallOption) (*QueryScopesResponse, error)
	// ScopesByType queries all scopes of a specific type for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ScopesByType(ctx context.Context, in *QueryScopesByTypeRequest, opts ...grpc.CallOption) (*QueryScopesByTypeResponse, error)
	// IdentityScore queries the identity score for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityScore(ctx context.Context, in *QueryIdentityScoreRequest, opts ...grpc.CallOption) (*QueryIdentityScoreResponse, error)
	// IdentityStatus queries the identity status for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityStatus(ctx context.Context, in *QueryIdentityStatusRequest, opts ...grpc.CallOption) (*QueryIdentityStatusResponse, error)
	// IdentityWallet queries an identity wallet by account address
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityWallet(ctx context.Context, in *QueryIdentityWalletRequest, opts ...grpc.CallOption) (*QueryIdentityWalletResponse, error)
	// WalletScopes queries all scope references in a wallet
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	WalletScopes(ctx context.Context, in *QueryWalletScopesRequest, opts ...grpc.CallOption) (*QueryWalletScopesResponse, error)
	// ConsentSettings queries consent settings for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ConsentSettings(ctx context.Context, in *QueryConsentSettingsRequest, opts ...grpc.CallOption) (*QueryConsentSettingsResponse, error)
	// DerivedFeatures queries derived features metadata for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	DerivedFeatures(ctx context.Context, in *QueryDerivedFeaturesRequest, opts ...grpc.CallOption) (*QueryDerivedFeaturesResponse, error)
	// DerivedFeatureHashes queries derived feature hashes for an account (consent-gated)
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	DerivedFeatureHashes(ctx context.Context, in *QueryDerivedFeatureHashesRequest, opts ...grpc.CallOption) (*QueryDerivedFeatureHashesResponse, error)
	// VerificationHistory queries verification history for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	VerificationHistory(ctx context.Context, in *QueryVerificationHistoryRequest, opts ...grpc.CallOption) (*QueryVerificationHistoryResponse, error)
	// ApprovedClients queries all approved clients
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ApprovedClients(ctx context.Context, in *QueryApprovedClientsRequest, opts ...grpc.CallOption) (*QueryApprovedClientsResponse, error)
	// Params queries the module parameters
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error)
	// BorderlineParams queries the borderline parameters
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	BorderlineParams(ctx context.Context, in *QueryBorderlineParamsRequest, opts ...grpc.CallOption) (*QueryBorderlineParamsResponse, error)
}

type queryClient struct {
	cc grpc1.ClientConn
}

func NewQueryClient(cc grpc1.ClientConn) QueryClient {
	return &queryClient{cc}
}

func (c *queryClient) IdentityRecord(ctx context.Context, in *QueryIdentityRecordRequest, opts ...grpc.CallOption) (*QueryIdentityRecordResponse, error) {
	out := new(QueryIdentityRecordResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/IdentityRecord", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Identity(ctx context.Context, in *QueryIdentityRequest, opts ...grpc.CallOption) (*QueryIdentityResponse, error) {
	out := new(QueryIdentityResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/Identity", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Scope(ctx context.Context, in *QueryScopeRequest, opts ...grpc.CallOption) (*QueryScopeResponse, error) {
	out := new(QueryScopeResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/Scope", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Scopes(ctx context.Context, in *QueryScopesRequest, opts ...grpc.CallOption) (*QueryScopesResponse, error) {
	out := new(QueryScopesResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/Scopes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ScopesByType(ctx context.Context, in *QueryScopesByTypeRequest, opts ...grpc.CallOption) (*QueryScopesByTypeResponse, error) {
	out := new(QueryScopesByTypeResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/ScopesByType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IdentityScore(ctx context.Context, in *QueryIdentityScoreRequest, opts ...grpc.CallOption) (*QueryIdentityScoreResponse, error) {
	out := new(QueryIdentityScoreResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/IdentityScore", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IdentityStatus(ctx context.Context, in *QueryIdentityStatusRequest, opts ...grpc.CallOption) (*QueryIdentityStatusResponse, error) {
	out := new(QueryIdentityStatusResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/IdentityStatus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) IdentityWallet(ctx context.Context, in *QueryIdentityWalletRequest, opts ...grpc.CallOption) (*QueryIdentityWalletResponse, error) {
	out := new(QueryIdentityWalletResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/IdentityWallet", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) WalletScopes(ctx context.Context, in *QueryWalletScopesRequest, opts ...grpc.CallOption) (*QueryWalletScopesResponse, error) {
	out := new(QueryWalletScopesResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/WalletScopes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ConsentSettings(ctx context.Context, in *QueryConsentSettingsRequest, opts ...grpc.CallOption) (*QueryConsentSettingsResponse, error) {
	out := new(QueryConsentSettingsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/ConsentSettings", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DerivedFeatures(ctx context.Context, in *QueryDerivedFeaturesRequest, opts ...grpc.CallOption) (*QueryDerivedFeaturesResponse, error) {
	out := new(QueryDerivedFeaturesResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/DerivedFeatures", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) DerivedFeatureHashes(ctx context.Context, in *QueryDerivedFeatureHashesRequest, opts ...grpc.CallOption) (*QueryDerivedFeatureHashesResponse, error) {
	out := new(QueryDerivedFeatureHashesResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/DerivedFeatureHashes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) VerificationHistory(ctx context.Context, in *QueryVerificationHistoryRequest, opts ...grpc.CallOption) (*QueryVerificationHistoryResponse, error) {
	out := new(QueryVerificationHistoryResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/VerificationHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) ApprovedClients(ctx context.Context, in *QueryApprovedClientsRequest, opts ...grpc.CallOption) (*QueryApprovedClientsResponse, error) {
	out := new(QueryApprovedClientsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/ApprovedClients", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) Params(ctx context.Context, in *QueryParamsRequest, opts ...grpc.CallOption) (*QueryParamsResponse, error) {
	out := new(QueryParamsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/Params", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *queryClient) BorderlineParams(ctx context.Context, in *QueryBorderlineParamsRequest, opts ...grpc.CallOption) (*QueryBorderlineParamsResponse, error) {
	out := new(QueryBorderlineParamsResponse)
	err := c.cc.Invoke(ctx, "/virtengine.veid.v1.Query/BorderlineParams", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// QueryServer is the server API for Query service.
type QueryServer interface {
	// IdentityRecord queries an identity record by account address
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityRecord(context.Context, *QueryIdentityRecordRequest) (*QueryIdentityRecordResponse, error)
	// Identity queries an identity record by account address (alias for IdentityRecord)
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Identity(context.Context, *QueryIdentityRequest) (*QueryIdentityResponse, error)
	// Scope queries a specific scope by ID
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Scope(context.Context, *QueryScopeRequest) (*QueryScopeResponse, error)
	// Scopes queries all scopes for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Scopes(context.Context, *QueryScopesRequest) (*QueryScopesResponse, error)
	// ScopesByType queries all scopes of a specific type for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ScopesByType(context.Context, *QueryScopesByTypeRequest) (*QueryScopesByTypeResponse, error)
	// IdentityScore queries the identity score for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityScore(context.Context, *QueryIdentityScoreRequest) (*QueryIdentityScoreResponse, error)
	// IdentityStatus queries the identity status for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityStatus(context.Context, *QueryIdentityStatusRequest) (*QueryIdentityStatusResponse, error)
	// IdentityWallet queries an identity wallet by account address
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	IdentityWallet(context.Context, *QueryIdentityWalletRequest) (*QueryIdentityWalletResponse, error)
	// WalletScopes queries all scope references in a wallet
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	WalletScopes(context.Context, *QueryWalletScopesRequest) (*QueryWalletScopesResponse, error)
	// ConsentSettings queries consent settings for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ConsentSettings(context.Context, *QueryConsentSettingsRequest) (*QueryConsentSettingsResponse, error)
	// DerivedFeatures queries derived features metadata for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	DerivedFeatures(context.Context, *QueryDerivedFeaturesRequest) (*QueryDerivedFeaturesResponse, error)
	// DerivedFeatureHashes queries derived feature hashes for an account (consent-gated)
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	DerivedFeatureHashes(context.Context, *QueryDerivedFeatureHashesRequest) (*QueryDerivedFeatureHashesResponse, error)
	// VerificationHistory queries verification history for an account
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	VerificationHistory(context.Context, *QueryVerificationHistoryRequest) (*QueryVerificationHistoryResponse, error)
	// ApprovedClients queries all approved clients
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	ApprovedClients(context.Context, *QueryApprovedClientsRequest) (*QueryApprovedClientsResponse, error)
	// Params queries the module parameters
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	Params(context.Context, *QueryParamsRequest) (*QueryParamsResponse, error)
	// BorderlineParams queries the borderline parameters
	// buf:lint:ignore RPC_REQUEST_RESPONSE_UNIQUE
	// buf:lint:ignore RPC_RESPONSE_STANDARD_NAME
	BorderlineParams(context.Context, *QueryBorderlineParamsRequest) (*QueryBorderlineParamsResponse, error)
}

// UnimplementedQueryServer can be embedded to have forward compatible implementations.
type UnimplementedQueryServer struct {
}

func (*UnimplementedQueryServer) IdentityRecord(ctx context.Context, req *QueryIdentityRecordRequest) (*QueryIdentityRecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IdentityRecord not implemented")
}
func (*UnimplementedQueryServer) Identity(ctx context.Context, req *QueryIdentityRequest) (*QueryIdentityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Identity not implemented")
}
func (*UnimplementedQueryServer) Scope(ctx context.Context, req *QueryScopeRequest) (*QueryScopeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scope not implemented")
}
func (*UnimplementedQueryServer) Scopes(ctx context.Context, req *QueryScopesRequest) (*QueryScopesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Scopes not implemented")
}
func (*UnimplementedQueryServer) ScopesByType(ctx context.Context, req *QueryScopesByTypeRequest) (*QueryScopesByTypeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ScopesByType not implemented")
}
func (*UnimplementedQueryServer) IdentityScore(ctx context.Context, req *QueryIdentityScoreRequest) (*QueryIdentityScoreResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IdentityScore not implemented")
}
func (*UnimplementedQueryServer) IdentityStatus(ctx context.Context, req *QueryIdentityStatusRequest) (*QueryIdentityStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IdentityStatus not implemented")
}
func (*UnimplementedQueryServer) IdentityWallet(ctx context.Context, req *QueryIdentityWalletRequest) (*QueryIdentityWalletResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IdentityWallet not implemented")
}
func (*UnimplementedQueryServer) WalletScopes(ctx context.Context, req *QueryWalletScopesRequest) (*QueryWalletScopesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WalletScopes not implemented")
}
func (*UnimplementedQueryServer) ConsentSettings(ctx context.Context, req *QueryConsentSettingsRequest) (*QueryConsentSettingsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ConsentSettings not implemented")
}
func (*UnimplementedQueryServer) DerivedFeatures(ctx context.Context, req *QueryDerivedFeaturesRequest) (*QueryDerivedFeaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DerivedFeatures not implemented")
}
func (*UnimplementedQueryServer) DerivedFeatureHashes(ctx context.Context, req *QueryDerivedFeatureHashesRequest) (*QueryDerivedFeatureHashesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DerivedFeatureHashes not implemented")
}
func (*UnimplementedQueryServer) VerificationHistory(ctx context.Context, req *QueryVerificationHistoryRequest) (*QueryVerificationHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VerificationHistory not implemented")
}
func (*UnimplementedQueryServer) ApprovedClients(ctx context.Context, req *QueryApprovedClientsRequest) (*QueryApprovedClientsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApprovedClients not implemented")
}
func (*UnimplementedQueryServer) Params(ctx context.Context, req *QueryParamsRequest) (*QueryParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Params not implemented")
}
func (*UnimplementedQueryServer) BorderlineParams(ctx context.Context, req *QueryBorderlineParamsRequest) (*QueryBorderlineParamsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BorderlineParams not implemented")
}

func RegisterQueryServer(s grpc1.Server, srv QueryServer) {
	s.RegisterService(&_Query_serviceDesc, srv)
}

func _Query_IdentityRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIdentityRecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IdentityRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/IdentityRecord",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IdentityRecord(ctx, req.(*QueryIdentityRecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Identity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIdentityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Identity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/Identity",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Identity(ctx, req.(*QueryIdentityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Scope_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScopeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Scope(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/Scope",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Scope(ctx, req.(*QueryScopeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Scopes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScopesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Scopes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/Scopes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Scopes(ctx, req.(*QueryScopesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ScopesByType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryScopesByTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ScopesByType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/ScopesByType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ScopesByType(ctx, req.(*QueryScopesByTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IdentityScore_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIdentityScoreRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IdentityScore(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/IdentityScore",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IdentityScore(ctx, req.(*QueryIdentityScoreRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IdentityStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIdentityStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IdentityStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/IdentityStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IdentityStatus(ctx, req.(*QueryIdentityStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_IdentityWallet_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryIdentityWalletRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).IdentityWallet(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/IdentityWallet",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).IdentityWallet(ctx, req.(*QueryIdentityWalletRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_WalletScopes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryWalletScopesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).WalletScopes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/WalletScopes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).WalletScopes(ctx, req.(*QueryWalletScopesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ConsentSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryConsentSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ConsentSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/ConsentSettings",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ConsentSettings(ctx, req.(*QueryConsentSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DerivedFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivedFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DerivedFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/DerivedFeatures",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DerivedFeatures(ctx, req.(*QueryDerivedFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_DerivedFeatureHashes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryDerivedFeatureHashesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).DerivedFeatureHashes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/DerivedFeatureHashes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).DerivedFeatureHashes(ctx, req.(*QueryDerivedFeatureHashesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_VerificationHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryVerificationHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).VerificationHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/VerificationHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).VerificationHistory(ctx, req.(*QueryVerificationHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_ApprovedClients_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryApprovedClientsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).ApprovedClients(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/ApprovedClients",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).ApprovedClients(ctx, req.(*QueryApprovedClientsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_Params_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).Params(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/Params",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).Params(ctx, req.(*QueryParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Query_BorderlineParams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryBorderlineParamsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(QueryServer).BorderlineParams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/virtengine.veid.v1.Query/BorderlineParams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(QueryServer).BorderlineParams(ctx, req.(*QueryBorderlineParamsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var Query_serviceDesc = _Query_serviceDesc
var _Query_serviceDesc = grpc.ServiceDesc{
	ServiceName: "virtengine.veid.v1.Query",
	HandlerType: (*QueryServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "IdentityRecord",
			Handler:    _Query_IdentityRecord_Handler,
		},
		{
			MethodName: "Identity",
			Handler:    _Query_Identity_Handler,
		},
		{
			MethodName: "Scope",
			Handler:    _Query_Scope_Handler,
		},
		{
			MethodName: "Scopes",
			Handler:    _Query_Scopes_Handler,
		},
		{
			MethodName: "ScopesByType",
			Handler:    _Query_ScopesByType_Handler,
		},
		{
			MethodName: "IdentityScore",
			Handler:    _Query_IdentityScore_Handler,
		},
		{
			MethodName: "IdentityStatus",
			Handler:    _Query_IdentityStatus_Handler,
		},
		{
			MethodName: "IdentityWallet",
			Handler:    _Query_IdentityWallet_Handler,
		},
		{
			MethodName: "WalletScopes",
			Handler:    _Query_WalletScopes_Handler,
		},
		{
			MethodName: "ConsentSettings",
			Handler:    _Query_ConsentSettings_Handler,
		},
		{
			MethodName: "DerivedFeatures",
			Handler:    _Query_DerivedFeatures_Handler,
		},
		{
			MethodName: "DerivedFeatureHashes",
			Handler:    _Query_DerivedFeatureHashes_Handler,
		},
		{
			MethodName: "VerificationHistory",
			Handler:    _Query_VerificationHistory_Handler,
		},
		{
			MethodName: "ApprovedClients",
			Handler:    _Query_ApprovedClients_Handler,
		},
		{
			MethodName: "Params",
			Handler:    _Query_Params_Handler,
		},
		{
			MethodName: "BorderlineParams",
			Handler:    _Query_BorderlineParams_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "virtengine/veid/v1/query.proto",
}

func (m *QueryIdentityRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Identity != nil {
		{
			size, err := m.Identity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityRecordRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityRecordResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Record != nil {
		{
			size, err := m.Record.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Scope != nil {
		{
			size, err := m.Scope.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.StatusFilter != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.StatusFilter))
		i--
		dAtA[i] = 0x18
	}
	if m.ScopeType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopesByTypeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopesByTypeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopesByTypeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ScopeType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryScopesByTypeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryScopesByTypeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryScopesByTypeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityScoreRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityScoreRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityScoreRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityScoreResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityScoreResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityScoreResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Score != nil {
		{
			size, err := m.Score.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityStatusRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityStatusRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityStatusRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityStatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityStatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityStatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LastUpdatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastUpdatedAt))
		i--
		dAtA[i] = 0x30
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Score != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Tier != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x18
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityWalletRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityWalletRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityWalletRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicWalletInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicWalletInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicWalletInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastUpdatedAt))
		i--
		dAtA[i] = 0x48
	}
	if m.CreatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.CreatedAt))
		i--
		dAtA[i] = 0x40
	}
	if m.VerifiedScopeCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.VerifiedScopeCount))
		i--
		dAtA[i] = 0x38
	}
	if m.ScopeCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeCount))
		i--
		dAtA[i] = 0x30
	}
	if m.Tier != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Tier))
		i--
		dAtA[i] = 0x28
	}
	if m.Score != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Score))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.WalletId) > 0 {
		i -= len(m.WalletId)
		copy(dAtA[i:], m.WalletId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.WalletId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryIdentityWalletResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryIdentityWalletResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryIdentityWalletResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Wallet != nil {
		{
			size, err := m.Wallet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WalletScopeInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalletScopeInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalletScopeInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ConsentGranted {
		i--
		if m.ConsentGranted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x30
	}
	if m.VerifiedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.VerifiedAt))
		i--
		dAtA[i] = 0x28
	}
	if m.AddedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.AddedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.Status != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.ScopeType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryWalletScopesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryWalletScopesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryWalletScopesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveOnly {
		i--
		if m.ActiveOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.StatusFilter != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.StatusFilter))
		i--
		dAtA[i] = 0x18
	}
	if m.ScopeType != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryWalletScopesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryWalletScopesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryWalletScopesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ActiveCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ActiveCount))
		i--
		dAtA[i] = 0x18
	}
	if m.TotalCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Scopes) > 0 {
		for iNdEx := len(m.Scopes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Scopes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryConsentSettingsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryConsentSettingsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryConsentSettingsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicConsentInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicConsentInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicConsentInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Purpose) > 0 {
		i -= len(m.Purpose)
		copy(dAtA[i:], m.Purpose)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Purpose)))
		i--
		dAtA[i] = 0x22
	}
	if m.IsActive {
		i--
		if m.IsActive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Granted {
		i--
		if m.Granted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ScopeId) > 0 {
		i -= len(m.ScopeId)
		copy(dAtA[i:], m.ScopeId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ScopeId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryConsentSettingsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryConsentSettingsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryConsentSettingsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastUpdatedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastUpdatedAt))
		i--
		dAtA[i] = 0x20
	}
	if m.ConsentVersion != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ConsentVersion))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ScopeConsents) > 0 {
		for iNdEx := len(m.ScopeConsents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ScopeConsents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GlobalSettings != nil {
		{
			size, err := m.GlobalSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PublicVerificationHistoryEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicVerificationHistoryEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicVerificationHistoryEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if m.ScopeCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.ScopeCount))
		i--
		dAtA[i] = 0x40
	}
	if m.NewStatus != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.NewStatus))
		i--
		dAtA[i] = 0x38
	}
	if m.PreviousStatus != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PreviousStatus))
		i--
		dAtA[i] = 0x30
	}
	if m.NewScore != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.NewScore))
		i--
		dAtA[i] = 0x28
	}
	if m.PreviousScore != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.PreviousScore))
		i--
		dAtA[i] = 0x20
	}
	if m.BlockHeight != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.Timestamp != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x10
	}
	if len(m.EntryId) > 0 {
		i -= len(m.EntryId)
		copy(dAtA[i:], m.EntryId)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.EntryId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerificationHistoryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerificationHistoryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerificationHistoryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x18
	}
	if m.Limit != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryVerificationHistoryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryVerificationHistoryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryVerificationHistoryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalCount != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.TotalCount))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryApprovedClientsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryApprovedClientsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryApprovedClientsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ActiveOnly {
		i--
		if m.ActiveOnly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryApprovedClientsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryApprovedClientsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryApprovedClientsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pagination != nil {
		{
			size, err := m.Pagination.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Clients) > 0 {
		for iNdEx := len(m.Clients) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Clients[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintQuery(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *QueryBorderlineParamsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBorderlineParamsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBorderlineParamsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *QueryBorderlineParamsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryBorderlineParamsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryBorderlineParamsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Params.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintQuery(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PublicDerivedFeaturesInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PublicDerivedFeaturesInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PublicDerivedFeaturesInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FeatureVersion != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.FeatureVersion))
		i--
		dAtA[i] = 0x38
	}
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastComputedAt != 0 {
		i = encodeVarintQuery(dAtA, i, uint64(m.LastComputedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.DocFieldKeys) > 0 {
		for iNdEx := len(m.DocFieldKeys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.DocFieldKeys[iNdEx])
			copy(dAtA[i:], m.DocFieldKeys[iNdEx])
			i = encodeVarintQuery(dAtA, i, uint64(len(m.DocFieldKeys[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.HasLivenessProof {
		i--
		if m.HasLivenessProof {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.HasBiometric {
		i--
		if m.HasBiometric {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.HasFaceEmbedding {
		i--
		if m.HasFaceEmbedding {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivedFeaturesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivedFeaturesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivedFeaturesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivedFeaturesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivedFeaturesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivedFeaturesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Found {
		i--
		if m.Found {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Features != nil {
		{
			size, err := m.Features.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintQuery(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivedFeatureHashesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivedFeatureHashesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivedFeatureHashesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Purpose) > 0 {
		i -= len(m.Purpose)
		copy(dAtA[i:], m.Purpose)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Purpose)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.AccountAddress) > 0 {
		i -= len(m.AccountAddress)
		copy(dAtA[i:], m.AccountAddress)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.AccountAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryDerivedFeatureHashesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDerivedFeatureHashesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDerivedFeatureHashesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ModelVersion) > 0 {
		i -= len(m.ModelVersion)
		copy(dAtA[i:], m.ModelVersion)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.ModelVersion)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.BiometricHash) > 0 {
		i -= len(m.BiometricHash)
		copy(dAtA[i:], m.BiometricHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.BiometricHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DocFieldHashes) > 0 {
		for k := range m.DocFieldHashes {
			v := m.DocFieldHashes[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintQuery(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintQuery(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintQuery(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.FaceEmbeddingHash) > 0 {
		i -= len(m.FaceEmbeddingHash)
		copy(dAtA[i:], m.FaceEmbeddingHash)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.FaceEmbeddingHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DenialReason) > 0 {
		i -= len(m.DenialReason)
		copy(dAtA[i:], m.DenialReason)
		i = encodeVarintQuery(dAtA, i, uint64(len(m.DenialReason)))
		i--
		dAtA[i] = 0x12
	}
	if m.Allowed {
		i--
		if m.Allowed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintQuery(dAtA []byte, offset int, v uint64) int {
	offset -= sovQuery(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QueryIdentityRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIdentityResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Identity != nil {
		l = m.Identity.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *QueryIdentityRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIdentityRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Record != nil {
		l = m.Record.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryScopeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryScopeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Scope != nil {
		l = m.Scope.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *QueryScopesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovQuery(uint64(m.ScopeType))
	}
	if m.StatusFilter != 0 {
		n += 1 + sovQuery(uint64(m.StatusFilter))
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryScopesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryScopesByTypeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovQuery(uint64(m.ScopeType))
	}
	return n
}

func (m *QueryScopesByTypeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	return n
}

func (m *QueryIdentityScoreRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIdentityScoreResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Score != nil {
		l = m.Score.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *QueryIdentityStatusRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryIdentityStatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	if m.Tier != 0 {
		n += 1 + sovQuery(uint64(m.Tier))
	}
	if m.Score != 0 {
		n += 1 + sovQuery(uint64(m.Score))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.LastUpdatedAt != 0 {
		n += 1 + sovQuery(uint64(m.LastUpdatedAt))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *QueryIdentityWalletRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *PublicWalletInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.WalletId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	if m.Score != 0 {
		n += 1 + sovQuery(uint64(m.Score))
	}
	if m.Tier != 0 {
		n += 1 + sovQuery(uint64(m.Tier))
	}
	if m.ScopeCount != 0 {
		n += 1 + sovQuery(uint64(m.ScopeCount))
	}
	if m.VerifiedScopeCount != 0 {
		n += 1 + sovQuery(uint64(m.VerifiedScopeCount))
	}
	if m.CreatedAt != 0 {
		n += 1 + sovQuery(uint64(m.CreatedAt))
	}
	if m.LastUpdatedAt != 0 {
		n += 1 + sovQuery(uint64(m.LastUpdatedAt))
	}
	return n
}

func (m *QueryIdentityWalletResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Wallet != nil {
		l = m.Wallet.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *WalletScopeInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovQuery(uint64(m.ScopeType))
	}
	if m.Status != 0 {
		n += 1 + sovQuery(uint64(m.Status))
	}
	if m.AddedAt != 0 {
		n += 1 + sovQuery(uint64(m.AddedAt))
	}
	if m.VerifiedAt != 0 {
		n += 1 + sovQuery(uint64(m.VerifiedAt))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovQuery(uint64(m.ExpiresAt))
	}
	if m.ConsentGranted {
		n += 2
	}
	return n
}

func (m *QueryWalletScopesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ScopeType != 0 {
		n += 1 + sovQuery(uint64(m.ScopeType))
	}
	if m.StatusFilter != 0 {
		n += 1 + sovQuery(uint64(m.StatusFilter))
	}
	if m.ActiveOnly {
		n += 2
	}
	return n
}

func (m *QueryWalletScopesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Scopes) > 0 {
		for _, e := range m.Scopes {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.TotalCount != 0 {
		n += 1 + sovQuery(uint64(m.TotalCount))
	}
	if m.ActiveCount != 0 {
		n += 1 + sovQuery(uint64(m.ActiveCount))
	}
	return n
}

func (m *QueryConsentSettingsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *PublicConsentInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ScopeId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Granted {
		n += 2
	}
	if m.IsActive {
		n += 2
	}
	l = len(m.Purpose)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovQuery(uint64(m.ExpiresAt))
	}
	return n
}

func (m *QueryConsentSettingsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GlobalSettings != nil {
		l = m.GlobalSettings.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.ScopeConsents) > 0 {
		for _, e := range m.ScopeConsents {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.ConsentVersion != 0 {
		n += 1 + sovQuery(uint64(m.ConsentVersion))
	}
	if m.LastUpdatedAt != 0 {
		n += 1 + sovQuery(uint64(m.LastUpdatedAt))
	}
	return n
}

func (m *PublicVerificationHistoryEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EntryId)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovQuery(uint64(m.Timestamp))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovQuery(uint64(m.BlockHeight))
	}
	if m.PreviousScore != 0 {
		n += 1 + sovQuery(uint64(m.PreviousScore))
	}
	if m.NewScore != 0 {
		n += 1 + sovQuery(uint64(m.NewScore))
	}
	if m.PreviousStatus != 0 {
		n += 1 + sovQuery(uint64(m.PreviousStatus))
	}
	if m.NewStatus != 0 {
		n += 1 + sovQuery(uint64(m.NewStatus))
	}
	if m.ScopeCount != 0 {
		n += 1 + sovQuery(uint64(m.ScopeCount))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryVerificationHistoryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovQuery(uint64(m.Limit))
	}
	if m.Offset != 0 {
		n += 1 + sovQuery(uint64(m.Offset))
	}
	return n
}

func (m *QueryVerificationHistoryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.TotalCount != 0 {
		n += 1 + sovQuery(uint64(m.TotalCount))
	}
	return n
}

func (m *QueryApprovedClientsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ActiveOnly {
		n += 2
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryApprovedClientsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Clients) > 0 {
		for _, e := range m.Clients {
			l = e.Size()
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.Pagination != nil {
		l = m.Pagination.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *QueryBorderlineParamsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *QueryBorderlineParamsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Params.Size()
	n += 1 + l + sovQuery(uint64(l))
	return n
}

func (m *PublicDerivedFeaturesInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasFaceEmbedding {
		n += 2
	}
	if m.HasBiometric {
		n += 2
	}
	if m.HasLivenessProof {
		n += 2
	}
	if len(m.DocFieldKeys) > 0 {
		for _, s := range m.DocFieldKeys {
			l = len(s)
			n += 1 + l + sovQuery(uint64(l))
		}
	}
	if m.LastComputedAt != 0 {
		n += 1 + sovQuery(uint64(m.LastComputedAt))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.FeatureVersion != 0 {
		n += 1 + sovQuery(uint64(m.FeatureVersion))
	}
	return n
}

func (m *QueryDerivedFeaturesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivedFeaturesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Features != nil {
		l = m.Features.Size()
		n += 1 + l + sovQuery(uint64(l))
	}
	if m.Found {
		n += 2
	}
	return n
}

func (m *QueryDerivedFeatureHashesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AccountAddress)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.Purpose)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func (m *QueryDerivedFeatureHashesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Allowed {
		n += 2
	}
	l = len(m.DenialReason)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.FaceEmbeddingHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	if len(m.DocFieldHashes) > 0 {
		for k, v := range m.DocFieldHashes {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovQuery(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovQuery(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovQuery(uint64(mapEntrySize))
		}
	}
	l = len(m.BiometricHash)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	l = len(m.ModelVersion)
	if l > 0 {
		n += 1 + l + sovQuery(uint64(l))
	}
	return n
}

func sovQuery(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozQuery(x uint64) (n int) {
	return sovQuery(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QueryIdentityRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Identity == nil {
				m.Identity = &IdentityRecord{}
			}
			if err := m.Identity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Record", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Record == nil {
				m.Record = &IdentityRecord{}
			}
			if err := m.Record.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scope", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Scope == nil {
				m.Scope = &IdentityScope{}
			}
			if err := m.Scope.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusFilter", wireType)
			}
			m.StatusFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusFilter |= VerificationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, IdentityScope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopesByTypeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopesByTypeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopesByTypeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryScopesByTypeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryScopesByTypeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryScopesByTypeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, IdentityScope{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityScoreRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityScoreRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityScoreRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityScoreResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityScoreResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityScoreResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Score == nil {
				m.Score = &IdentityScore{}
			}
			if err := m.Score.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityStatusRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityStatusRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityStatusRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityStatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityStatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityStatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= IdentityTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			m.LastUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityWalletRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityWalletRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityWalletRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicWalletInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicWalletInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicWalletInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WalletId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WalletId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= WalletStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Score", wireType)
			}
			m.Score = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Score |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tier", wireType)
			}
			m.Tier = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tier |= IdentityTier(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeCount", wireType)
			}
			m.ScopeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedScopeCount", wireType)
			}
			m.VerifiedScopeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedScopeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			m.CreatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			m.LastUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryIdentityWalletResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryIdentityWalletResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryIdentityWalletResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wallet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wallet == nil {
				m.Wallet = &PublicWalletInfo{}
			}
			if err := m.Wallet.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalletScopeInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalletScopeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalletScopeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= VerificationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedAt", wireType)
			}
			m.AddedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifiedAt", wireType)
			}
			m.VerifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VerifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsentGranted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ConsentGranted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryWalletScopesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryWalletScopesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryWalletScopesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeType", wireType)
			}
			m.ScopeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeType |= ScopeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusFilter", wireType)
			}
			m.StatusFilter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusFilter |= VerificationStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveOnly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryWalletScopesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryWalletScopesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryWalletScopesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Scopes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Scopes = append(m.Scopes, WalletScopeInfo{})
			if err := m.Scopes[len(m.Scopes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveCount", wireType)
			}
			m.ActiveCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ActiveCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryConsentSettingsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryConsentSettingsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryConsentSettingsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicConsentInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicConsentInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicConsentInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Granted = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsActive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsActive = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purpose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryConsentSettingsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryConsentSettingsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryConsentSettingsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GlobalSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GlobalSettings == nil {
				m.GlobalSettings = &ConsentSettings{}
			}
			if err := m.GlobalSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeConsents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ScopeConsents = append(m.ScopeConsents, PublicConsentInfo{})
			if err := m.ScopeConsents[len(m.ScopeConsents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConsentVersion", wireType)
			}
			m.ConsentVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConsentVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastUpdatedAt", wireType)
			}
			m.LastUpdatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastUpdatedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicVerificationHistoryEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicVerificationHistoryEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicVerificationHistoryEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousScore", wireType)
			}
			m.PreviousScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewScore", wireType)
			}
			m.NewScore = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewScore |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousStatus", wireType)
			}
			m.PreviousStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousStatus |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewStatus", wireType)
			}
			m.NewStatus = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewStatus |= AccountStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ScopeCount", wireType)
			}
			m.ScopeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ScopeCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerificationHistoryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerificationHistoryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerificationHistoryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryVerificationHistoryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryVerificationHistoryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryVerificationHistoryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, PublicVerificationHistoryEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalCount", wireType)
			}
			m.TotalCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TotalCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryApprovedClientsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryApprovedClientsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryApprovedClientsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveOnly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ActiveOnly = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageRequest{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryApprovedClientsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryApprovedClientsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryApprovedClientsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Clients = append(m.Clients, ApprovedClient{})
			if err := m.Clients[len(m.Clients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pagination", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pagination == nil {
				m.Pagination = &query.PageResponse{}
			}
			if err := m.Pagination.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBorderlineParamsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBorderlineParamsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBorderlineParamsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryBorderlineParamsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryBorderlineParamsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryBorderlineParamsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Params.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PublicDerivedFeaturesInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PublicDerivedFeaturesInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PublicDerivedFeaturesInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFaceEmbedding", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFaceEmbedding = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasBiometric", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasBiometric = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasLivenessProof", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasLivenessProof = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocFieldKeys", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DocFieldKeys = append(m.DocFieldKeys, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastComputedAt", wireType)
			}
			m.LastComputedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastComputedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FeatureVersion", wireType)
			}
			m.FeatureVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FeatureVersion |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivedFeaturesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivedFeaturesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivedFeaturesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivedFeaturesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivedFeaturesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivedFeaturesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Features", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Features == nil {
				m.Features = &PublicDerivedFeaturesInfo{}
			}
			if err := m.Features.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Found", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Found = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivedFeatureHashesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivedFeatureHashesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivedFeatureHashesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AccountAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purpose = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDerivedFeatureHashesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDerivedFeatureHashesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDerivedFeatureHashesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allowed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Allowed = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DenialReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DenialReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FaceEmbeddingHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FaceEmbeddingHash = append(m.FaceEmbeddingHash[:0], dAtA[iNdEx:postIndex]...)
			if m.FaceEmbeddingHash == nil {
				m.FaceEmbeddingHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocFieldHashes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DocFieldHashes == nil {
				m.DocFieldHashes = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowQuery
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthQuery
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowQuery
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthQuery
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthQuery
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipQuery(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthQuery
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DocFieldHashes[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BiometricHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BiometricHash = append(m.BiometricHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BiometricHash == nil {
				m.BiometricHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModelVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthQuery
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthQuery
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModelVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipQuery(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthQuery
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipQuery(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowQuery
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowQuery
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthQuery
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupQuery
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthQuery
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthQuery        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowQuery          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupQuery = fmt.Errorf("proto: unexpected end of group")
)
