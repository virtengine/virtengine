// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/audit/v1/audit_log.proto

package v1

import (
	bytes "bytes"
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_cosmos_gogoproto_types "github.com/cosmos/gogoproto/types"
	_ "google.golang.org/protobuf/types/known/timestamppb"
	io "io"
	math "math"
	math_bits "math/bits"
	time "time"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = time.Kitchen

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ExportStatus represents the status of an export job
type ExportStatus int32

const (
	// Unspecified / pending export job
	ExportStatusUnspecified ExportStatus = 0
	// Export job is in progress
	ExportStatusInProgress ExportStatus = 1
	// Export job completed successfully
	ExportStatusCompleted ExportStatus = 2
	// Export job failed
	ExportStatusFailed ExportStatus = 3
)

var ExportStatus_name = map[int32]string{
	0: "EXPORT_STATUS_UNSPECIFIED",
	1: "EXPORT_STATUS_IN_PROGRESS",
	2: "EXPORT_STATUS_COMPLETED",
	3: "EXPORT_STATUS_FAILED",
}

var ExportStatus_value = map[string]int32{
	"EXPORT_STATUS_UNSPECIFIED": 0,
	"EXPORT_STATUS_IN_PROGRESS": 1,
	"EXPORT_STATUS_COMPLETED":   2,
	"EXPORT_STATUS_FAILED":      3,
}

func (x ExportStatus) String() string {
	return proto.EnumName(ExportStatus_name, int32(x))
}

func (ExportStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_228dcf4c78a123e0, []int{0}
}

// AuditLogEntry represents an immutable audit log record
type AuditLogEntry struct {
	// Unique identifier for this log entry
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	// Block height when this entry was created
	Height int64 `protobuf:"varint,2,opt,name=height,proto3" json:"height" yaml:"height"`
	// Timestamp when this entry was created
	Timestamp time.Time `protobuf:"bytes,3,opt,name=timestamp,proto3,stdtime" json:"timestamp" yaml:"timestamp"`
	// Actor who performed the action (account address)
	Actor string `protobuf:"bytes,4,opt,name=actor,proto3" json:"actor" yaml:"actor"`
	// Module where the action occurred
	Module string `protobuf:"bytes,5,opt,name=module,proto3" json:"module" yaml:"module"`
	// Action that was performed
	Action string `protobuf:"bytes,6,opt,name=action,proto3" json:"action" yaml:"action"`
	// Resource ID (optional - e.g., order ID, scope ID)
	ResourceId string `protobuf:"bytes,7,opt,name=resource_id,json=resourceId,proto3" json:"resource_id" yaml:"resource_id"`
	// Metadata as JSON string (flexible for different event types)
	Metadata string `protobuf:"bytes,8,opt,name=metadata,proto3" json:"metadata" yaml:"metadata"`
	// Whether this entry has been exported
	Exported bool `protobuf:"varint,9,opt,name=exported,proto3" json:"exported" yaml:"exported"`
	// Export job ID if exported
	ExportJobId string `protobuf:"bytes,10,opt,name=export_job_id,json=exportJobId,proto3" json:"export_job_id,omitempty" yaml:"export_job_id,omitempty"`
}

func (m *AuditLogEntry) Reset()         { *m = AuditLogEntry{} }
func (m *AuditLogEntry) String() string { return proto.CompactTextString(m) }
func (*AuditLogEntry) ProtoMessage()    {}
func (*AuditLogEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_228dcf4c78a123e0, []int{0}
}
func (m *AuditLogEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditLogEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditLogEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditLogEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogEntry.Merge(m, src)
}
func (m *AuditLogEntry) XXX_Size() int {
	return m.Size()
}
func (m *AuditLogEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogEntry.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogEntry proto.InternalMessageInfo

func (m *AuditLogEntry) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *AuditLogEntry) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *AuditLogEntry) GetTimestamp() time.Time {
	if m != nil {
		return m.Timestamp
	}
	return time.Time{}
}

func (m *AuditLogEntry) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *AuditLogEntry) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *AuditLogEntry) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *AuditLogEntry) GetResourceId() string {
	if m != nil {
		return m.ResourceId
	}
	return ""
}

func (m *AuditLogEntry) GetMetadata() string {
	if m != nil {
		return m.Metadata
	}
	return ""
}

func (m *AuditLogEntry) GetExported() bool {
	if m != nil {
		return m.Exported
	}
	return false
}

func (m *AuditLogEntry) GetExportJobId() string {
	if m != nil {
		return m.ExportJobId
	}
	return ""
}

// ExportJob represents a batch export job
type ExportJob struct {
	// Unique identifier for this export job
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id" yaml:"id"`
	// Status of the export job
	Status ExportStatus `protobuf:"varint,2,opt,name=status,proto3,enum=virtengine.audit.v1.ExportStatus" json:"status" yaml:"status"`
	// Timestamp when job was created
	CreatedAt time.Time `protobuf:"bytes,3,opt,name=created_at,json=createdAt,proto3,stdtime" json:"created_at" yaml:"created_at"`
	// Timestamp when job was started
	StartedAt *time.Time `protobuf:"bytes,4,opt,name=started_at,json=startedAt,proto3,stdtime" json:"started_at,omitempty" yaml:"started_at,omitempty"`
	// Timestamp when job was completed
	CompletedAt *time.Time `protobuf:"bytes,5,opt,name=completed_at,json=completedAt,proto3,stdtime" json:"completed_at,omitempty" yaml:"completed_at,omitempty"`
	// Requester who initiated the export
	Requester string `protobuf:"bytes,6,opt,name=requester,proto3" json:"requester" yaml:"requester"`
	// Filter parameters for the export
	Filter *ExportFilter `protobuf:"bytes,7,opt,name=filter,proto3" json:"filter" yaml:"filter"`
	// Export format (json, csv)
	Format string `protobuf:"bytes,8,opt,name=format,proto3" json:"format" yaml:"format"`
	// Number of entries exported
	EntryCount int64 `protobuf:"varint,9,opt,name=entry_count,json=entryCount,proto3" json:"entry_count" yaml:"entry_count"`
	// File path where export was saved
	FilePath string `protobuf:"bytes,10,opt,name=file_path,json=filePath,proto3" json:"file_path,omitempty" yaml:"file_path,omitempty"`
	// Cryptographic signature of the export
	Signature []byte `protobuf:"bytes,11,opt,name=signature,proto3" json:"signature,omitempty" yaml:"signature,omitempty"`
	// Error message if job failed
	Error string `protobuf:"bytes,12,opt,name=error,proto3" json:"error,omitempty" yaml:"error,omitempty"`
}

func (m *ExportJob) Reset()         { *m = ExportJob{} }
func (m *ExportJob) String() string { return proto.CompactTextString(m) }
func (*ExportJob) ProtoMessage()    {}
func (*ExportJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_228dcf4c78a123e0, []int{1}
}
func (m *ExportJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportJob.Merge(m, src)
}
func (m *ExportJob) XXX_Size() int {
	return m.Size()
}
func (m *ExportJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportJob.DiscardUnknown(m)
}

var xxx_messageInfo_ExportJob proto.InternalMessageInfo

func (m *ExportJob) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *ExportJob) GetStatus() ExportStatus {
	if m != nil {
		return m.Status
	}
	return ExportStatusUnspecified
}

func (m *ExportJob) GetCreatedAt() time.Time {
	if m != nil {
		return m.CreatedAt
	}
	return time.Time{}
}

func (m *ExportJob) GetStartedAt() *time.Time {
	if m != nil {
		return m.StartedAt
	}
	return nil
}

func (m *ExportJob) GetCompletedAt() *time.Time {
	if m != nil {
		return m.CompletedAt
	}
	return nil
}

func (m *ExportJob) GetRequester() string {
	if m != nil {
		return m.Requester
	}
	return ""
}

func (m *ExportJob) GetFilter() *ExportFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *ExportJob) GetFormat() string {
	if m != nil {
		return m.Format
	}
	return ""
}

func (m *ExportJob) GetEntryCount() int64 {
	if m != nil {
		return m.EntryCount
	}
	return 0
}

func (m *ExportJob) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *ExportJob) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *ExportJob) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

// ExportFilter defines filter parameters for export jobs
type ExportFilter struct {
	// Filter by actor address
	Actor string `protobuf:"bytes,1,opt,name=actor,proto3" json:"actor,omitempty" yaml:"actor,omitempty"`
	// Filter by module name
	Module string `protobuf:"bytes,2,opt,name=module,proto3" json:"module,omitempty" yaml:"module,omitempty"`
	// Filter by action name
	Action string `protobuf:"bytes,3,opt,name=action,proto3" json:"action,omitempty" yaml:"action,omitempty"`
	// Filter by start time
	StartTime *time.Time `protobuf:"bytes,4,opt,name=start_time,json=startTime,proto3,stdtime" json:"start_time,omitempty" yaml:"start_time,omitempty"`
	// Filter by end time
	EndTime *time.Time `protobuf:"bytes,5,opt,name=end_time,json=endTime,proto3,stdtime" json:"end_time,omitempty" yaml:"end_time,omitempty"`
	// Maximum number of entries to export (0 = no limit)
	Limit int64 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty" yaml:"limit,omitempty"`
}

func (m *ExportFilter) Reset()         { *m = ExportFilter{} }
func (m *ExportFilter) String() string { return proto.CompactTextString(m) }
func (*ExportFilter) ProtoMessage()    {}
func (*ExportFilter) Descriptor() ([]byte, []int) {
	return fileDescriptor_228dcf4c78a123e0, []int{2}
}
func (m *ExportFilter) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExportFilter) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExportFilter.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExportFilter) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExportFilter.Merge(m, src)
}
func (m *ExportFilter) XXX_Size() int {
	return m.Size()
}
func (m *ExportFilter) XXX_DiscardUnknown() {
	xxx_messageInfo_ExportFilter.DiscardUnknown(m)
}

var xxx_messageInfo_ExportFilter proto.InternalMessageInfo

func (m *ExportFilter) GetActor() string {
	if m != nil {
		return m.Actor
	}
	return ""
}

func (m *ExportFilter) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *ExportFilter) GetAction() string {
	if m != nil {
		return m.Action
	}
	return ""
}

func (m *ExportFilter) GetStartTime() *time.Time {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ExportFilter) GetEndTime() *time.Time {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ExportFilter) GetLimit() int64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

// AuditLogParams defines module parameters for audit logging
type AuditLogParams struct {
	// Whether audit logging is enabled
	Enabled bool `protobuf:"varint,1,opt,name=enabled,proto3" json:"enabled" yaml:"enabled"`
	// Retention period in blocks (0 = keep forever)
	RetentionBlocks int64 `protobuf:"varint,2,opt,name=retention_blocks,json=retentionBlocks,proto3" json:"retention_blocks" yaml:"retention_blocks"`
	// Maximum entries per export batch
	MaxExportBatchSize int64 `protobuf:"varint,3,opt,name=max_export_batch_size,json=maxExportBatchSize,proto3" json:"max_export_batch_size" yaml:"max_export_batch_size"`
	// Whether to prune exported entries
	PruneExported bool `protobuf:"varint,4,opt,name=prune_exported,json=pruneExported,proto3" json:"prune_exported" yaml:"prune_exported"`
}

func (m *AuditLogParams) Reset()         { *m = AuditLogParams{} }
func (m *AuditLogParams) String() string { return proto.CompactTextString(m) }
func (*AuditLogParams) ProtoMessage()    {}
func (*AuditLogParams) Descriptor() ([]byte, []int) {
	return fileDescriptor_228dcf4c78a123e0, []int{3}
}
func (m *AuditLogParams) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuditLogParams) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuditLogParams.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuditLogParams) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuditLogParams.Merge(m, src)
}
func (m *AuditLogParams) XXX_Size() int {
	return m.Size()
}
func (m *AuditLogParams) XXX_DiscardUnknown() {
	xxx_messageInfo_AuditLogParams.DiscardUnknown(m)
}

var xxx_messageInfo_AuditLogParams proto.InternalMessageInfo

func (m *AuditLogParams) GetEnabled() bool {
	if m != nil {
		return m.Enabled
	}
	return false
}

func (m *AuditLogParams) GetRetentionBlocks() int64 {
	if m != nil {
		return m.RetentionBlocks
	}
	return 0
}

func (m *AuditLogParams) GetMaxExportBatchSize() int64 {
	if m != nil {
		return m.MaxExportBatchSize
	}
	return 0
}

func (m *AuditLogParams) GetPruneExported() bool {
	if m != nil {
		return m.PruneExported
	}
	return false
}

func init() {
	proto.RegisterEnum("virtengine.audit.v1.ExportStatus", ExportStatus_name, ExportStatus_value)
	proto.RegisterType((*AuditLogEntry)(nil), "virtengine.audit.v1.AuditLogEntry")
	proto.RegisterType((*ExportJob)(nil), "virtengine.audit.v1.ExportJob")
	proto.RegisterType((*ExportFilter)(nil), "virtengine.audit.v1.ExportFilter")
	proto.RegisterType((*AuditLogParams)(nil), "virtengine.audit.v1.AuditLogParams")
}

func init() {
	proto.RegisterFile("virtengine/audit/v1/audit_log.proto", fileDescriptor_228dcf4c78a123e0)
}

var fileDescriptor_228dcf4c78a123e0 = []byte{
	// 1272 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xcf, 0x6f, 0x13, 0x47,
	0x14, 0xce, 0xda, 0xf9, 0x61, 0x4f, 0x7e, 0xe0, 0x0e, 0x90, 0x38, 0xa6, 0x78, 0xcc, 0xa0, 0x4a,
	0x69, 0x69, 0xed, 0x02, 0xa2, 0x88, 0xa0, 0x0a, 0xc5, 0xc1, 0x41, 0xae, 0x28, 0xb1, 0xc6, 0xa1,
	0xaa, 0xb8, 0xac, 0xd6, 0xde, 0x89, 0xb3, 0x65, 0x77, 0xc7, 0xdd, 0x1d, 0x47, 0xc0, 0xa1, 0xe7,
	0x2a, 0x27, 0x8e, 0x5c, 0x22, 0x21, 0xf5, 0x9f, 0xe1, 0xc8, 0xb1, 0xa7, 0x69, 0x05, 0x97, 0x6a,
	0x6f, 0xb5, 0xd4, 0x9e, 0xab, 0x9d, 0xd9, 0x5f, 0x36, 0x6e, 0xa1, 0xb7, 0x7d, 0xdf, 0xf7, 0xbe,
	0xf7, 0x76, 0xf6, 0xcd, 0x37, 0xb3, 0xe0, 0xf2, 0xb1, 0xe5, 0x71, 0xea, 0x0e, 0x2c, 0x97, 0x36,
	0x8c, 0x91, 0x69, 0xf1, 0xc6, 0xf1, 0x55, 0xf5, 0xa0, 0xdb, 0x6c, 0x50, 0x1f, 0x7a, 0x8c, 0x33,
	0x78, 0x36, 0x4d, 0xaa, 0x4b, 0xae, 0x7e, 0x7c, 0xb5, 0x72, 0x6e, 0xc0, 0x06, 0x4c, 0xf2, 0x8d,
	0xf0, 0x49, 0xa5, 0x56, 0xd0, 0x80, 0xb1, 0x81, 0x4d, 0x1b, 0x32, 0xea, 0x8d, 0x0e, 0x1b, 0xdc,
	0x72, 0xa8, 0xcf, 0x0d, 0x67, 0xa8, 0x12, 0xf0, 0x8b, 0x05, 0xb0, 0xba, 0x13, 0xd6, 0xb8, 0xcf,
	0x06, 0x2d, 0x97, 0x7b, 0x4f, 0xe1, 0x65, 0x90, 0xb3, 0xcc, 0xb2, 0x56, 0xd3, 0xb6, 0x8a, 0xcd,
	0xb3, 0x81, 0x40, 0x39, 0xcb, 0x1c, 0x0b, 0x54, 0x7c, 0x6a, 0x38, 0xf6, 0x36, 0xb6, 0x4c, 0x4c,
	0x72, 0x96, 0x09, 0xaf, 0x83, 0xc5, 0x23, 0x6a, 0x0d, 0x8e, 0x78, 0x39, 0x57, 0xd3, 0xb6, 0xf2,
	0xcd, 0x0b, 0x81, 0x40, 0x11, 0x32, 0x16, 0x68, 0x55, 0x25, 0xab, 0x18, 0x93, 0x88, 0x80, 0x7d,
	0x50, 0x4c, 0xda, 0x97, 0xf3, 0x35, 0x6d, 0x6b, 0xf9, 0x5a, 0xa5, 0xae, 0x5e, 0xb0, 0x1e, 0xbf,
	0x60, 0xfd, 0x20, 0xce, 0x68, 0x7e, 0xfa, 0x4a, 0xa0, 0xb9, 0x40, 0xa0, 0x54, 0x34, 0x16, 0xa8,
	0xa4, 0x4a, 0x27, 0x10, 0x7e, 0xfe, 0x1b, 0xd2, 0x48, 0x9a, 0x02, 0x1b, 0x60, 0xc1, 0xe8, 0x73,
	0xe6, 0x95, 0xe7, 0xe5, 0x0a, 0x36, 0x03, 0x81, 0x14, 0x30, 0x16, 0x68, 0x45, 0x89, 0x65, 0x88,
	0x89, 0x82, 0xc3, 0xa5, 0x38, 0xcc, 0x1c, 0xd9, 0xb4, 0xbc, 0x20, 0x15, 0x72, 0x29, 0x0a, 0x49,
	0x97, 0xa2, 0x62, 0x4c, 0x22, 0x22, 0x14, 0x19, 0x7d, 0x6e, 0x31, 0xb7, 0xbc, 0x98, 0x8a, 0x14,
	0x92, 0x8a, 0x54, 0x8c, 0x49, 0x44, 0xc0, 0x3d, 0xb0, 0xec, 0x51, 0x9f, 0x8d, 0xbc, 0x3e, 0xd5,
	0x2d, 0xb3, 0xbc, 0x24, 0x95, 0x9f, 0x04, 0x02, 0x65, 0xe1, 0xb1, 0x40, 0x50, 0xc9, 0x33, 0x20,
	0x26, 0x20, 0x8e, 0xda, 0x26, 0xbc, 0x0d, 0x0a, 0x0e, 0xe5, 0x86, 0x69, 0x70, 0xa3, 0x5c, 0x90,
	0x45, 0x50, 0x20, 0x50, 0x82, 0x8d, 0x05, 0x3a, 0x13, 0xbd, 0x75, 0x84, 0x60, 0x92, 0x90, 0xa1,
	0x98, 0x3e, 0x19, 0x32, 0x8f, 0x53, 0xb3, 0x5c, 0xac, 0x69, 0x5b, 0x05, 0x25, 0x8e, 0xb1, 0x54,
	0x1c, 0x23, 0x98, 0x24, 0x24, 0x34, 0xc0, 0xaa, 0x7a, 0xd6, 0x7f, 0x60, 0xbd, 0x70, 0x0d, 0x40,
	0xb6, 0xff, 0x3a, 0x10, 0x68, 0x63, 0x82, 0xf8, 0x9c, 0x39, 0x16, 0xa7, 0xce, 0x90, 0x3f, 0x1d,
	0x0b, 0x54, 0xcd, 0x16, 0x7c, 0x27, 0x01, 0x93, 0x65, 0xc5, 0x7c, 0xc3, 0x7a, 0x6d, 0x73, 0xbb,
	0xf0, 0xe2, 0x25, 0xd2, 0xfe, 0x78, 0x89, 0x34, 0xfc, 0xf7, 0x12, 0x28, 0xb6, 0x62, 0xe6, 0xc3,
	0xb6, 0xe5, 0x77, 0x60, 0xd1, 0xe7, 0x06, 0x1f, 0xf9, 0x72, 0x5b, 0xae, 0x5d, 0xbb, 0x54, 0x9f,
	0x61, 0x95, 0xba, 0x2a, 0xda, 0x95, 0x89, 0x6a, 0x72, 0x4a, 0x94, 0x4e, 0x4e, 0xc5, 0x98, 0x44,
	0x04, 0x3c, 0x04, 0xa0, 0xef, 0x51, 0x83, 0x53, 0x53, 0x37, 0xf8, 0x07, 0x6c, 0xdd, 0x2b, 0xd1,
	0xd6, 0xcd, 0xa8, 0xc6, 0x02, 0x7d, 0xa4, 0x8a, 0xa7, 0x58, 0xb4, 0x79, 0x23, 0x60, 0x87, 0xc3,
	0x63, 0x00, 0x7c, 0x6e, 0x78, 0x51, 0x9f, 0xf9, 0xf7, 0xf6, 0xb9, 0x1d, 0x08, 0x74, 0x2e, 0x55,
	0x4c, 0x7c, 0xf5, 0x0b, 0xc9, 0x52, 0xde, 0x61, 0xa3, 0xbe, 0x11, 0xb5, 0xc3, 0xe1, 0x4f, 0x60,
	0xa5, 0xcf, 0x9c, 0xa1, 0x4d, 0xa3, 0xce, 0x0b, 0xef, 0xed, 0x7c, 0x27, 0x10, 0x68, 0x3d, 0xab,
	0x99, 0xe8, 0x7d, 0x31, 0x5a, 0xe9, 0x4c, 0x5e, 0x75, 0x5f, 0x4e, 0xc8, 0x1d, 0x0e, 0xef, 0x80,
	0xa2, 0x47, 0x7f, 0x1c, 0x51, 0x9f, 0x53, 0x2f, 0x72, 0xd4, 0xa5, 0xd0, 0xf9, 0x09, 0x98, 0x3a,
	0x3f, 0x81, 0x30, 0x49, 0xe9, 0x70, 0xf0, 0x87, 0x96, 0x1d, 0xaa, 0x97, 0xe4, 0xab, 0xff, 0xd7,
	0xe0, 0xf7, 0x64, 0xa2, 0x1a, 0xbc, 0x12, 0xa5, 0x83, 0x57, 0x31, 0x26, 0x11, 0x11, 0xfa, 0xfc,
	0x90, 0x79, 0x8e, 0xc1, 0x23, 0xa3, 0x29, 0x91, 0x44, 0x32, 0x22, 0x19, 0x87, 0x22, 0xf9, 0x10,
	0xfa, 0x9c, 0x86, 0x47, 0xa9, 0xde, 0x67, 0x23, 0x97, 0x4b, 0x97, 0xe5, 0x95, 0xcf, 0x33, 0x70,
	0xea, 0xf3, 0x0c, 0x88, 0x09, 0x90, 0xd1, 0x6e, 0x18, 0x40, 0x02, 0x8a, 0x87, 0x96, 0x4d, 0xf5,
	0xa1, 0xc1, 0x8f, 0x22, 0xa7, 0xdd, 0x08, 0x04, 0x3a, 0x9b, 0x80, 0x13, 0xdf, 0xbc, 0x92, 0xac,
	0x60, 0x9a, 0xc4, 0xa4, 0x10, 0xa2, 0x1d, 0x83, 0x1f, 0xc1, 0x2e, 0x28, 0xfa, 0xd6, 0xc0, 0x35,
	0xf8, 0xc8, 0xa3, 0xe5, 0xe5, 0x9a, 0xb6, 0xb5, 0xa2, 0x6a, 0x26, 0xe0, 0xac, 0x9a, 0x33, 0x48,
	0x4c, 0xd2, 0x3a, 0x70, 0x17, 0x2c, 0x50, 0xcf, 0x63, 0x5e, 0x79, 0x45, 0xbe, 0xe4, 0x17, 0x81,
	0x40, 0x67, 0x24, 0x30, 0x51, 0x6c, 0x3d, 0x5a, 0xee, 0x24, 0x81, 0x89, 0xd2, 0x66, 0x8c, 0xff,
	0x62, 0x1e, 0xac, 0x64, 0x47, 0x15, 0xd6, 0x57, 0x67, 0xba, 0x96, 0xd6, 0x97, 0xc0, 0xac, 0xfa,
	0x53, 0x44, 0x72, 0xce, 0xdf, 0x4b, 0xce, 0xf9, 0x9c, 0xac, 0xd2, 0x08, 0x04, 0x2a, 0x29, 0x64,
	0xa2, 0xcc, 0x46, 0xf6, 0xc4, 0xcf, 0xd6, 0x89, 0xcf, 0xfe, 0x7b, 0xc9, 0xd9, 0x9f, 0x4f, 0x0b,
	0x29, 0x64, 0x56, 0xa1, 0x69, 0x26, 0xbd, 0x0f, 0x62, 0xb7, 0xeb, 0xe1, 0xed, 0xf5, 0xbf, 0xdc,
	0x2e, 0x15, 0xff, 0xea, 0xf6, 0x29, 0x36, 0xeb, 0xf6, 0xb0, 0x18, 0x74, 0x41, 0x81, 0xba, 0xa6,
	0xea, 0xfa, 0x7e, 0xa7, 0xdf, 0x0c, 0x04, 0x82, 0x71, 0xfe, 0x44, 0xcf, 0xcd, 0x78, 0xff, 0x9a,
	0x33, 0x3b, 0x2e, 0x51, 0xd7, 0x94, 0xfd, 0x76, 0xc1, 0x82, 0x6d, 0x39, 0x16, 0x97, 0xce, 0xce,
	0xab, 0xf1, 0x49, 0x60, 0xd6, 0xf8, 0xa6, 0x08, 0x4c, 0x94, 0x76, 0x7b, 0x5e, 0x6e, 0x8d, 0x3f,
	0x73, 0x60, 0x2d, 0xfe, 0x5d, 0xe9, 0x18, 0x9e, 0xe1, 0xf8, 0xf0, 0x26, 0x58, 0xa2, 0xae, 0xd1,
	0xb3, 0xa9, 0xba, 0x1d, 0x0a, 0xcd, 0x8b, 0x81, 0x40, 0x31, 0x34, 0x16, 0x68, 0x2d, 0x7e, 0x4b,
	0x09, 0x60, 0x12, 0x53, 0xf0, 0x11, 0x28, 0x79, 0x94, 0x53, 0x37, 0x9c, 0x85, 0xde, 0xb3, 0x59,
	0xff, 0xb1, 0x1f, 0xfd, 0xcd, 0xc8, 0x89, 0x4e, 0x73, 0xe9, 0x44, 0xa7, 0x19, 0x4c, 0xce, 0x24,
	0x50, 0x53, 0x22, 0xd0, 0x06, 0xe7, 0x1d, 0xe3, 0x89, 0x1e, 0x5d, 0x79, 0x3d, 0x83, 0xf7, 0x8f,
	0x74, 0xdf, 0x7a, 0x46, 0xe5, 0x96, 0xc9, 0x37, 0x6f, 0x05, 0x02, 0xcd, 0x4e, 0x18, 0x0b, 0xf4,
	0x71, 0xb4, 0x01, 0x67, 0xd1, 0x98, 0x40, 0xc7, 0x78, 0xa2, 0xcc, 0xd1, 0x0c, 0xd1, 0xae, 0xf5,
	0x8c, 0x42, 0x02, 0xd6, 0x86, 0xde, 0xc8, 0xa5, 0x7a, 0x72, 0xb3, 0xcf, 0xcb, 0x2f, 0x71, 0x25,
	0x10, 0x68, 0x8a, 0x19, 0x0b, 0x74, 0x5e, 0xd5, 0x9f, 0xc4, 0x31, 0x59, 0x95, 0x40, 0x2b, 0x8a,
	0x53, 0x3b, 0x7e, 0xf6, 0x97, 0x16, 0xdb, 0x51, 0x5d, 0x99, 0x70, 0x1b, 0x6c, 0xb6, 0xbe, 0xef,
	0xec, 0x93, 0x03, 0xbd, 0x7b, 0xb0, 0x73, 0xf0, 0xb0, 0xab, 0x3f, 0x7c, 0xd0, 0xed, 0xb4, 0x76,
	0xdb, 0x7b, 0xed, 0xd6, 0xdd, 0xd2, 0x5c, 0xe5, 0xc2, 0xc9, 0x69, 0x6d, 0x23, 0x2b, 0x78, 0xe8,
	0xfa, 0x43, 0xda, 0xb7, 0x0e, 0x2d, 0x6a, 0xc2, 0x5b, 0xd3, 0xda, 0xf6, 0x03, 0xbd, 0x43, 0xf6,
	0xef, 0x91, 0x56, 0xb7, 0x5b, 0xd2, 0x2a, 0x95, 0x93, 0xd3, 0xda, 0x7a, 0x56, 0xdb, 0x76, 0x3b,
	0x1e, 0x1b, 0x78, 0xd4, 0xf7, 0xe1, 0x57, 0x60, 0x63, 0x52, 0xba, 0xbb, 0xff, 0x6d, 0xe7, 0x7e,
	0xeb, 0xa0, 0x75, 0xb7, 0x94, 0xab, 0x6c, 0x9e, 0x9c, 0xd6, 0xce, 0x67, 0x85, 0xbb, 0xf1, 0xf5,
	0x02, 0xbf, 0x04, 0xe7, 0x26, 0x75, 0x7b, 0x3b, 0xed, 0xfb, 0xad, 0xbb, 0xa5, 0x7c, 0x65, 0xfd,
	0xe4, 0xb4, 0x06, 0xb3, 0xa2, 0x3d, 0xc3, 0xb2, 0xa9, 0x59, 0x99, 0xff, 0xf9, 0x97, 0xea, 0x5c,
	0x73, 0xff, 0xd5, 0x9b, 0xaa, 0xf6, 0xfa, 0x4d, 0x55, 0xfb, 0xfd, 0x4d, 0x55, 0x7b, 0xfe, 0xb6,
	0x3a, 0xf7, 0xfa, 0x6d, 0x75, 0xee, 0xd7, 0xb7, 0xd5, 0xb9, 0x47, 0x37, 0x06, 0x16, 0x3f, 0x1a,
	0xf5, 0xea, 0x7d, 0xe6, 0x34, 0x32, 0x3f, 0xec, 0x99, 0x47, 0xdf, 0x7c, 0xdc, 0x18, 0xb0, 0x86,
	0xcb, 0xcc, 0xf4, 0x3f, 0xbe, 0xb7, 0x28, 0xdd, 0x75, 0xfd, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x8c, 0x52, 0xbf, 0x2a, 0xe5, 0x0b, 0x00, 0x00,
}

func (this *AuditLogEntry) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuditLogEntry)
	if !ok {
		that2, ok := that.(AuditLogEntry)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if !this.Timestamp.Equal(that1.Timestamp) {
		return false
	}
	if this.Actor != that1.Actor {
		return false
	}
	if this.Module != that1.Module {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if this.ResourceId != that1.ResourceId {
		return false
	}
	if this.Metadata != that1.Metadata {
		return false
	}
	if this.Exported != that1.Exported {
		return false
	}
	if this.ExportJobId != that1.ExportJobId {
		return false
	}
	return true
}
func (this *ExportJob) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExportJob)
	if !ok {
		that2, ok := that.(ExportJob)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Status != that1.Status {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if that1.StartedAt == nil {
		if this.StartedAt != nil {
			return false
		}
	} else if !this.StartedAt.Equal(*that1.StartedAt) {
		return false
	}
	if that1.CompletedAt == nil {
		if this.CompletedAt != nil {
			return false
		}
	} else if !this.CompletedAt.Equal(*that1.CompletedAt) {
		return false
	}
	if this.Requester != that1.Requester {
		return false
	}
	if !this.Filter.Equal(that1.Filter) {
		return false
	}
	if this.Format != that1.Format {
		return false
	}
	if this.EntryCount != that1.EntryCount {
		return false
	}
	if this.FilePath != that1.FilePath {
		return false
	}
	if !bytes.Equal(this.Signature, that1.Signature) {
		return false
	}
	if this.Error != that1.Error {
		return false
	}
	return true
}
func (this *ExportFilter) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ExportFilter)
	if !ok {
		that2, ok := that.(ExportFilter)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Actor != that1.Actor {
		return false
	}
	if this.Module != that1.Module {
		return false
	}
	if this.Action != that1.Action {
		return false
	}
	if that1.StartTime == nil {
		if this.StartTime != nil {
			return false
		}
	} else if !this.StartTime.Equal(*that1.StartTime) {
		return false
	}
	if that1.EndTime == nil {
		if this.EndTime != nil {
			return false
		}
	} else if !this.EndTime.Equal(*that1.EndTime) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	return true
}
func (this *AuditLogParams) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AuditLogParams)
	if !ok {
		that2, ok := that.(AuditLogParams)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Enabled != that1.Enabled {
		return false
	}
	if this.RetentionBlocks != that1.RetentionBlocks {
		return false
	}
	if this.MaxExportBatchSize != that1.MaxExportBatchSize {
		return false
	}
	if this.PruneExported != that1.PruneExported {
		return false
	}
	return true
}
func (m *AuditLogEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditLogEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditLogEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExportJobId) > 0 {
		i -= len(m.ExportJobId)
		copy(dAtA[i:], m.ExportJobId)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.ExportJobId)))
		i--
		dAtA[i] = 0x52
	}
	if m.Exported {
		i--
		if m.Exported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.Metadata) > 0 {
		i -= len(m.Metadata)
		copy(dAtA[i:], m.Metadata)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Metadata)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ResourceId) > 0 {
		i -= len(m.ResourceId)
		copy(dAtA[i:], m.ResourceId)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.ResourceId)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0x22
	}
	n1, err1 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.Timestamp, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp):])
	if err1 != nil {
		return 0, err1
	}
	i -= n1
	i = encodeVarintAuditLog(dAtA, i, uint64(n1))
	i--
	dAtA[i] = 0x1a
	if m.Height != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportJob) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportJob) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.FilePath) > 0 {
		i -= len(m.FilePath)
		copy(dAtA[i:], m.FilePath)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.FilePath)))
		i--
		dAtA[i] = 0x52
	}
	if m.EntryCount != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.EntryCount))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Format) > 0 {
		i -= len(m.Format)
		copy(dAtA[i:], m.Format)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Format)))
		i--
		dAtA[i] = 0x42
	}
	if m.Filter != nil {
		{
			size, err := m.Filter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuditLog(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Requester) > 0 {
		i -= len(m.Requester)
		copy(dAtA[i:], m.Requester)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Requester)))
		i--
		dAtA[i] = 0x32
	}
	if m.CompletedAt != nil {
		n3, err3 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.CompletedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt):])
		if err3 != nil {
			return 0, err3
		}
		i -= n3
		i = encodeVarintAuditLog(dAtA, i, uint64(n3))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartedAt != nil {
		n4, err4 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartedAt):])
		if err4 != nil {
			return 0, err4
		}
		i -= n4
		i = encodeVarintAuditLog(dAtA, i, uint64(n4))
		i--
		dAtA[i] = 0x22
	}
	n5, err5 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(m.CreatedAt, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt):])
	if err5 != nil {
		return 0, err5
	}
	i -= n5
	i = encodeVarintAuditLog(dAtA, i, uint64(n5))
	i--
	dAtA[i] = 0x1a
	if m.Status != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExportFilter) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExportFilter) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExportFilter) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x30
	}
	if m.EndTime != nil {
		n6, err6 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.EndTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime):])
		if err6 != nil {
			return 0, err6
		}
		i -= n6
		i = encodeVarintAuditLog(dAtA, i, uint64(n6))
		i--
		dAtA[i] = 0x2a
	}
	if m.StartTime != nil {
		n7, err7 := github_com_cosmos_gogoproto_types.StdTimeMarshalTo(*m.StartTime, dAtA[i-github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartTime):])
		if err7 != nil {
			return 0, err7
		}
		i -= n7
		i = encodeVarintAuditLog(dAtA, i, uint64(n7))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Action) > 0 {
		i -= len(m.Action)
		copy(dAtA[i:], m.Action)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Action)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Module) > 0 {
		i -= len(m.Module)
		copy(dAtA[i:], m.Module)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Module)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Actor) > 0 {
		i -= len(m.Actor)
		copy(dAtA[i:], m.Actor)
		i = encodeVarintAuditLog(dAtA, i, uint64(len(m.Actor)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuditLogParams) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuditLogParams) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuditLogParams) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PruneExported {
		i--
		if m.PruneExported {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.MaxExportBatchSize != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.MaxExportBatchSize))
		i--
		dAtA[i] = 0x18
	}
	if m.RetentionBlocks != 0 {
		i = encodeVarintAuditLog(dAtA, i, uint64(m.RetentionBlocks))
		i--
		dAtA[i] = 0x10
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuditLog(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuditLog(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuditLogEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovAuditLog(uint64(m.Height))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.Timestamp)
	n += 1 + l + sovAuditLog(uint64(l))
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.ResourceId)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Metadata)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.Exported {
		n += 2
	}
	l = len(m.ExportJobId)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	return n
}

func (m *ExportJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovAuditLog(uint64(m.Status))
	}
	l = github_com_cosmos_gogoproto_types.SizeOfStdTime(m.CreatedAt)
	n += 1 + l + sovAuditLog(uint64(l))
	if m.StartedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartedAt)
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.CompletedAt != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.CompletedAt)
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Requester)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.Filter != nil {
		l = m.Filter.Size()
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Format)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.EntryCount != 0 {
		n += 1 + sovAuditLog(uint64(m.EntryCount))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	return n
}

func (m *ExportFilter) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Actor)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Module)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	l = len(m.Action)
	if l > 0 {
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.StartTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.StartTime)
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.EndTime != nil {
		l = github_com_cosmos_gogoproto_types.SizeOfStdTime(*m.EndTime)
		n += 1 + l + sovAuditLog(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovAuditLog(uint64(m.Limit))
	}
	return n
}

func (m *AuditLogParams) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	if m.RetentionBlocks != 0 {
		n += 1 + sovAuditLog(uint64(m.RetentionBlocks))
	}
	if m.MaxExportBatchSize != 0 {
		n += 1 + sovAuditLog(uint64(m.MaxExportBatchSize))
	}
	if m.PruneExported {
		n += 2
	}
	return n
}

func sovAuditLog(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuditLog(x uint64) (n int) {
	return sovAuditLog(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuditLogEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuditLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.Timestamp, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Exported = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExportJobId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExportJobId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuditLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuditLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuditLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ExportStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(&m.CreatedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartedAt == nil {
				m.StartedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedAt == nil {
				m.CompletedAt = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.CompletedAt, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requester", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requester = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Filter == nil {
				m.Filter = &ExportFilter{}
			}
			if err := m.Filter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Format", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Format = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryCount", wireType)
			}
			m.EntryCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryCount |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuditLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuditLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExportFilter) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuditLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExportFilter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExportFilter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actor", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actor = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Module", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Module = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Action = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StartTime == nil {
				m.StartTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.StartTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndTime", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuditLog
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuditLog
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndTime == nil {
				m.EndTime = new(time.Time)
			}
			if err := github_com_cosmos_gogoproto_types.StdTimeUnmarshal(m.EndTime, dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuditLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuditLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuditLogParams) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuditLog
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuditLogParams: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuditLogParams: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetentionBlocks", wireType)
			}
			m.RetentionBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetentionBlocks |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxExportBatchSize", wireType)
			}
			m.MaxExportBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxExportBatchSize |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PruneExported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PruneExported = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAuditLog(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuditLog
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuditLog(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuditLog
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuditLog
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuditLog
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuditLog
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuditLog
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuditLog        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuditLog          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuditLog = fmt.Errorf("proto: unexpected end of group")
)
