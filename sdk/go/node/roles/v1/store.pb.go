// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/roles/v1/store.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// ParamsStore is the internal storage format for module parameters
type ParamsStore struct {
	// MaxRolesPerAccount is the maximum number of roles an account can have
	MaxRolesPerAccount uint32 `protobuf:"varint,1,opt,name=max_roles_per_account,json=maxRolesPerAccount,proto3" json:"max_roles_per_account" yaml:"max_roles_per_account"`
	// AllowSelfRevoke determines if accounts can revoke their own roles
	AllowSelfRevoke bool `protobuf:"varint,2,opt,name=allow_self_revoke,json=allowSelfRevoke,proto3" json:"allow_self_revoke" yaml:"allow_self_revoke"`
}

func (m *ParamsStore) Reset()         { *m = ParamsStore{} }
func (m *ParamsStore) String() string { return proto.CompactTextString(m) }
func (*ParamsStore) ProtoMessage()    {}
func (*ParamsStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7111deeebf50da3, []int{0}
}
func (m *ParamsStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParamsStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParamsStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParamsStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParamsStore.Merge(m, src)
}
func (m *ParamsStore) XXX_Size() int {
	return m.Size()
}
func (m *ParamsStore) XXX_DiscardUnknown() {
	xxx_messageInfo_ParamsStore.DiscardUnknown(m)
}

var xxx_messageInfo_ParamsStore proto.InternalMessageInfo

func (m *ParamsStore) GetMaxRolesPerAccount() uint32 {
	if m != nil {
		return m.MaxRolesPerAccount
	}
	return 0
}

func (m *ParamsStore) GetAllowSelfRevoke() bool {
	if m != nil {
		return m.AllowSelfRevoke
	}
	return false
}

// RoleAssignmentStore is the internal storage format for role assignments
type RoleAssignmentStore struct {
	// AssignedBy is the address that assigned this role
	AssignedBy string `protobuf:"bytes,1,opt,name=assigned_by,json=assignedBy,proto3" json:"assigned_by" yaml:"assigned_by"`
	// AssignedAt is the Unix timestamp when the role was assigned
	AssignedAt int64 `protobuf:"varint,2,opt,name=assigned_at,json=assignedAt,proto3" json:"assigned_at" yaml:"assigned_at"`
}

func (m *RoleAssignmentStore) Reset()         { *m = RoleAssignmentStore{} }
func (m *RoleAssignmentStore) String() string { return proto.CompactTextString(m) }
func (*RoleAssignmentStore) ProtoMessage()    {}
func (*RoleAssignmentStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7111deeebf50da3, []int{1}
}
func (m *RoleAssignmentStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleAssignmentStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleAssignmentStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleAssignmentStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleAssignmentStore.Merge(m, src)
}
func (m *RoleAssignmentStore) XXX_Size() int {
	return m.Size()
}
func (m *RoleAssignmentStore) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleAssignmentStore.DiscardUnknown(m)
}

var xxx_messageInfo_RoleAssignmentStore proto.InternalMessageInfo

func (m *RoleAssignmentStore) GetAssignedBy() string {
	if m != nil {
		return m.AssignedBy
	}
	return ""
}

func (m *RoleAssignmentStore) GetAssignedAt() int64 {
	if m != nil {
		return m.AssignedAt
	}
	return 0
}

// AccountStateStore is the internal storage format for account states
type AccountStateStore struct {
	// State is the current account state (as uint32 for storage)
	State uint32 `protobuf:"varint,1,opt,name=state,proto3" json:"state" yaml:"state"`
	// Reason is the reason for the current state
	Reason string `protobuf:"bytes,2,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	// ModifiedBy is the address that last modified the state
	ModifiedBy string `protobuf:"bytes,3,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by" yaml:"modified_by"`
	// ModifiedAt is the Unix timestamp when the state was last modified
	ModifiedAt int64 `protobuf:"varint,4,opt,name=modified_at,json=modifiedAt,proto3" json:"modified_at" yaml:"modified_at"`
	// PreviousState is the previous account state (as uint32 for storage)
	PreviousState uint32 `protobuf:"varint,5,opt,name=previous_state,json=previousState,proto3" json:"previous_state" yaml:"previous_state"`
}

func (m *AccountStateStore) Reset()         { *m = AccountStateStore{} }
func (m *AccountStateStore) String() string { return proto.CompactTextString(m) }
func (*AccountStateStore) ProtoMessage()    {}
func (*AccountStateStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_b7111deeebf50da3, []int{2}
}
func (m *AccountStateStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountStateStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountStateStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountStateStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountStateStore.Merge(m, src)
}
func (m *AccountStateStore) XXX_Size() int {
	return m.Size()
}
func (m *AccountStateStore) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountStateStore.DiscardUnknown(m)
}

var xxx_messageInfo_AccountStateStore proto.InternalMessageInfo

func (m *AccountStateStore) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *AccountStateStore) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *AccountStateStore) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *AccountStateStore) GetModifiedAt() int64 {
	if m != nil {
		return m.ModifiedAt
	}
	return 0
}

func (m *AccountStateStore) GetPreviousState() uint32 {
	if m != nil {
		return m.PreviousState
	}
	return 0
}

func init() {
	proto.RegisterType((*ParamsStore)(nil), "virtengine.roles.v1.ParamsStore")
	proto.RegisterType((*RoleAssignmentStore)(nil), "virtengine.roles.v1.RoleAssignmentStore")
	proto.RegisterType((*AccountStateStore)(nil), "virtengine.roles.v1.AccountStateStore")
}

func init() { proto.RegisterFile("virtengine/roles/v1/store.proto", fileDescriptor_b7111deeebf50da3) }

var fileDescriptor_b7111deeebf50da3 = []byte{
	// 526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x93, 0x4f, 0x6f, 0xd3, 0x30,
	0x18, 0xc6, 0x9b, 0xfd, 0x13, 0xf3, 0x28, 0x68, 0xd9, 0x26, 0x75, 0x03, 0xc5, 0x93, 0x25, 0xa4,
	0x49, 0x88, 0x46, 0xd5, 0xc4, 0x81, 0x49, 0x1c, 0x92, 0x03, 0x57, 0x26, 0xf7, 0x86, 0x04, 0x91,
	0xdb, 0xb8, 0x21, 0x5a, 0x12, 0x57, 0xb6, 0x1b, 0xd6, 0x6f, 0xc1, 0x47, 0xe0, 0x43, 0xf0, 0x0d,
	0xb8, 0x70, 0x9c, 0x38, 0x71, 0xb2, 0xa6, 0xf6, 0x82, 0x72, 0xcc, 0x95, 0x0b, 0x8a, 0x9d, 0x92,
	0x8c, 0x55, 0xdc, 0xfc, 0xfe, 0x9e, 0xd7, 0x8f, 0xf3, 0x3e, 0xd1, 0x0b, 0x60, 0x1e, 0x73, 0x49,
	0xb3, 0x28, 0xce, 0xa8, 0xcb, 0x59, 0x42, 0x85, 0x9b, 0x0f, 0x5c, 0x21, 0x19, 0xa7, 0xfd, 0x29,
	0x67, 0x92, 0xd9, 0x07, 0x4d, 0x43, 0x5f, 0x37, 0xf4, 0xf3, 0xc1, 0xc9, 0x61, 0xc4, 0x22, 0xa6,
	0x75, 0xb7, 0x3a, 0x99, 0xd6, 0x93, 0xe3, 0x31, 0x13, 0x29, 0x13, 0x81, 0x11, 0x4c, 0x61, 0x24,
	0x74, 0x6b, 0x81, 0xbd, 0x4b, 0xc2, 0x49, 0x2a, 0x86, 0x95, 0xb7, 0x9d, 0x80, 0xa3, 0x94, 0x5c,
	0x07, 0xda, 0x30, 0x98, 0x52, 0x1e, 0x90, 0xf1, 0x98, 0xcd, 0x32, 0xd9, 0xb3, 0x4e, 0xad, 0xb3,
	0xae, 0xff, 0xaa, 0x50, 0x70, 0x7d, 0x43, 0xa9, 0xe0, 0xd3, 0x39, 0x49, 0x93, 0x0b, 0xb4, 0x56,
	0x46, 0xd8, 0x4e, 0xc9, 0x35, 0xae, 0xf0, 0x25, 0xe5, 0x9e, 0x81, 0xf6, 0x7b, 0xb0, 0x4f, 0x92,
	0x84, 0x7d, 0x0a, 0x04, 0x4d, 0x26, 0x01, 0xa7, 0x39, 0xbb, 0xa2, 0xbd, 0x8d, 0x53, 0xeb, 0xec,
	0x81, 0x3f, 0x28, 0x14, 0xbc, 0x2f, 0x96, 0x0a, 0xf6, 0xcc, 0x2b, 0xf7, 0x24, 0x84, 0x1f, 0x6b,
	0x36, 0xa4, 0xc9, 0x04, 0x6b, 0x72, 0xb1, 0xf5, 0xeb, 0x0b, 0xb4, 0xd0, 0x37, 0x0b, 0x1c, 0x54,
	0x0f, 0x7b, 0x42, 0xc4, 0x51, 0x96, 0xd2, 0x4c, 0x9a, 0x51, 0x3f, 0x80, 0x3d, 0xa2, 0x11, 0x0d,
	0x83, 0xd1, 0x5c, 0x0f, 0xb8, 0xeb, 0xbf, 0x2e, 0x14, 0x6c, 0xe3, 0x52, 0x41, 0xbb, 0x7e, 0xb0,
	0x81, 0xe8, 0xc7, 0xd7, 0x17, 0x87, 0x75, 0x8c, 0x5e, 0x18, 0x72, 0x2a, 0xc4, 0x50, 0xf2, 0x38,
	0x8b, 0x30, 0x58, 0x75, 0xf9, 0x73, 0xfb, 0x4d, 0xcb, 0x9f, 0x48, 0x3d, 0xd6, 0xa6, 0xff, 0xec,
	0x8e, 0x3f, 0x91, 0x6b, 0xfc, 0x89, 0x44, 0x8d, 0x8f, 0x27, 0xeb, 0x29, 0x7e, 0x6f, 0x80, 0xfd,
	0x3a, 0xb6, 0xa1, 0x24, 0x92, 0x9a, 0x19, 0x5c, 0xb0, 0x2d, 0xaa, 0xaa, 0xfe, 0x3d, 0xc7, 0x85,
	0x82, 0x06, 0x94, 0x0a, 0x3e, 0x34, 0xbe, 0xba, 0x44, 0xd8, 0x60, 0xfb, 0x1c, 0xec, 0x70, 0x4a,
	0x04, 0xcb, 0xf4, 0xf7, 0xec, 0xfa, 0x4f, 0x0a, 0x05, 0x6b, 0x52, 0x2a, 0xd8, 0x35, 0x57, 0x4c,
	0x8d, 0x70, 0x2d, 0x54, 0x49, 0xa5, 0x2c, 0x8c, 0x27, 0xb1, 0x49, 0x6a, 0xb3, 0x49, 0xaa, 0x85,
	0x9b, 0x49, 0x5a, 0xf0, 0x3f, 0x49, 0xad, 0xba, 0x4c, 0x52, 0x7f, 0xef, 0x10, 0xd9, 0xdb, 0x6a,
	0x92, 0x6a, 0xe1, 0x35, 0xfe, 0x3a, 0xa9, 0x55, 0xe5, 0x49, 0x1b, 0x83, 0x47, 0x53, 0x4e, 0xf3,
	0x98, 0xcd, 0x44, 0x60, 0x62, 0xd9, 0xd6, 0xb1, 0x3c, 0x2f, 0x14, 0xfc, 0x47, 0x29, 0x15, 0x3c,
	0x32, 0x6e, 0x77, 0x39, 0xc2, 0xdd, 0x15, 0xd0, 0x31, 0x9b, 0xf4, 0xfd, 0xb7, 0xdf, 0x17, 0x8e,
	0x75, 0xb3, 0x70, 0xac, 0xdb, 0x85, 0x63, 0x7d, 0x5e, 0x3a, 0x9d, 0x9b, 0xa5, 0xd3, 0xf9, 0xb9,
	0x74, 0x3a, 0xef, 0x5e, 0x46, 0xb1, 0xfc, 0x38, 0x1b, 0xf5, 0xc7, 0x2c, 0x75, 0x5b, 0x2b, 0xdb,
	0x3a, 0x8a, 0xf0, 0xca, 0x8d, 0x98, 0x9b, 0xb1, 0xb0, 0xd9, 0xe4, 0xd1, 0x8e, 0x5e, 0xbf, 0xf3,
	0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x73, 0x15, 0x91, 0x92, 0xe7, 0x03, 0x00, 0x00,
}

func (this *ParamsStore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ParamsStore)
	if !ok {
		that2, ok := that.(ParamsStore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRolesPerAccount != that1.MaxRolesPerAccount {
		return false
	}
	if this.AllowSelfRevoke != that1.AllowSelfRevoke {
		return false
	}
	return true
}
func (this *RoleAssignmentStore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleAssignmentStore)
	if !ok {
		that2, ok := that.(RoleAssignmentStore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.AssignedBy != that1.AssignedBy {
		return false
	}
	if this.AssignedAt != that1.AssignedAt {
		return false
	}
	return true
}
func (this *AccountStateStore) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountStateStore)
	if !ok {
		that2, ok := that.(AccountStateStore)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.ModifiedBy != that1.ModifiedBy {
		return false
	}
	if this.ModifiedAt != that1.ModifiedAt {
		return false
	}
	if this.PreviousState != that1.PreviousState {
		return false
	}
	return true
}
func (m *ParamsStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParamsStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParamsStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowSelfRevoke {
		i--
		if m.AllowSelfRevoke {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRolesPerAccount != 0 {
		i = encodeVarintStore(dAtA, i, uint64(m.MaxRolesPerAccount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RoleAssignmentStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleAssignmentStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleAssignmentStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssignedAt != 0 {
		i = encodeVarintStore(dAtA, i, uint64(m.AssignedAt))
		i--
		dAtA[i] = 0x10
	}
	if len(m.AssignedBy) > 0 {
		i -= len(m.AssignedBy)
		copy(dAtA[i:], m.AssignedBy)
		i = encodeVarintStore(dAtA, i, uint64(len(m.AssignedBy)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountStateStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountStateStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountStateStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != 0 {
		i = encodeVarintStore(dAtA, i, uint64(m.PreviousState))
		i--
		dAtA[i] = 0x28
	}
	if m.ModifiedAt != 0 {
		i = encodeVarintStore(dAtA, i, uint64(m.ModifiedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.ModifiedBy) > 0 {
		i -= len(m.ModifiedBy)
		copy(dAtA[i:], m.ModifiedBy)
		i = encodeVarintStore(dAtA, i, uint64(len(m.ModifiedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintStore(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x12
	}
	if m.State != 0 {
		i = encodeVarintStore(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintStore(dAtA []byte, offset int, v uint64) int {
	offset -= sovStore(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ParamsStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRolesPerAccount != 0 {
		n += 1 + sovStore(uint64(m.MaxRolesPerAccount))
	}
	if m.AllowSelfRevoke {
		n += 2
	}
	return n
}

func (m *RoleAssignmentStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.AssignedBy)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.AssignedAt != 0 {
		n += 1 + sovStore(uint64(m.AssignedAt))
	}
	return n
}

func (m *AccountStateStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovStore(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	l = len(m.ModifiedBy)
	if l > 0 {
		n += 1 + l + sovStore(uint64(l))
	}
	if m.ModifiedAt != 0 {
		n += 1 + sovStore(uint64(m.ModifiedAt))
	}
	if m.PreviousState != 0 {
		n += 1 + sovStore(uint64(m.PreviousState))
	}
	return n
}

func sovStore(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStore(x uint64) (n int) {
	return sovStore(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ParamsStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParamsStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParamsStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRolesPerAccount", wireType)
			}
			m.MaxRolesPerAccount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRolesPerAccount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowSelfRevoke", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowSelfRevoke = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RoleAssignmentStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleAssignmentStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleAssignmentStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedAt", wireType)
			}
			m.AssignedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountStateStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStore
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountStateStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountStateStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStore
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStore
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			m.ModifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
			}
			m.PreviousState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStore
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousState |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStore(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStore
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStore(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStore
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStore
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStore
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStore
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStore
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStore        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStore          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStore = fmt.Errorf("proto: unexpected end of group")
)

