// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: virtengine/roles/v1/types.proto

package v1

import (
	fmt "fmt"
	_ "github.com/cosmos/cosmos-proto"
	_ "github.com/cosmos/cosmos-sdk/types/tx/amino"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Role represents the different roles in the VirtEngine system
type Role int32

const (
	// ROLE_UNSPECIFIED is the default/invalid role
	RoleUnspecified Role = 0
	// ROLE_GENESIS_ACCOUNT represents the highest privilege role - initial chain authority
	RoleGenesisAccount Role = 1
	// ROLE_ADMINISTRATOR represents platform operations with high trust level
	RoleAdministrator Role = 2
	// ROLE_MODERATOR represents content/user moderation with medium-high trust level
	RoleModerator Role = 3
	// ROLE_VALIDATOR represents consensus participants with high trust level
	RoleValidator Role = 4
	// ROLE_SERVICE_PROVIDER represents infrastructure operators with medium trust level
	RoleServiceProvider Role = 5
	// ROLE_CUSTOMER represents end users with standard trust level
	RoleCustomer Role = 6
	// ROLE_SUPPORT_AGENT represents customer support with medium trust level
	RoleSupportAgent Role = 7
)

var Role_name = map[int32]string{
	0: "ROLE_UNSPECIFIED",
	1: "ROLE_GENESIS_ACCOUNT",
	2: "ROLE_ADMINISTRATOR",
	3: "ROLE_MODERATOR",
	4: "ROLE_VALIDATOR",
	5: "ROLE_SERVICE_PROVIDER",
	6: "ROLE_CUSTOMER",
	7: "ROLE_SUPPORT_AGENT",
}

var Role_value = map[string]int32{
	"ROLE_UNSPECIFIED":      0,
	"ROLE_GENESIS_ACCOUNT":  1,
	"ROLE_ADMINISTRATOR":    2,
	"ROLE_MODERATOR":        3,
	"ROLE_VALIDATOR":        4,
	"ROLE_SERVICE_PROVIDER": 5,
	"ROLE_CUSTOMER":         6,
	"ROLE_SUPPORT_AGENT":    7,
}

func (x Role) String() string {
	return proto.EnumName(Role_name, int32(x))
}

func (Role) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{0}
}

// AccountState represents the state of an account
type AccountState int32

const (
	// ACCOUNT_STATE_UNSPECIFIED is the default/invalid state
	AccountStateUnspecified AccountState = 0
	// ACCOUNT_STATE_ACTIVE represents an active account
	AccountStateActive AccountState = 1
	// ACCOUNT_STATE_SUSPENDED represents a temporarily suspended account
	AccountStateSuspended AccountState = 2
	// ACCOUNT_STATE_TERMINATED represents a permanently terminated account
	AccountStateTerminated AccountState = 3
)

var AccountState_name = map[int32]string{
	0: "ACCOUNT_STATE_UNSPECIFIED",
	1: "ACCOUNT_STATE_ACTIVE",
	2: "ACCOUNT_STATE_SUSPENDED",
	3: "ACCOUNT_STATE_TERMINATED",
}

var AccountState_value = map[string]int32{
	"ACCOUNT_STATE_UNSPECIFIED": 0,
	"ACCOUNT_STATE_ACTIVE":      1,
	"ACCOUNT_STATE_SUSPENDED":   2,
	"ACCOUNT_STATE_TERMINATED":  3,
}

func (x AccountState) String() string {
	return proto.EnumName(AccountState_name, int32(x))
}

func (AccountState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{1}
}

// RoleAssignment represents a role assigned to an account
type RoleAssignment struct {
	// Address is the account address that has the role
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// Role is the assigned role
	Role Role `protobuf:"varint,2,opt,name=role,proto3,enum=virtengine.roles.v1.Role" json:"role" yaml:"role"`
	// AssignedBy is the address that assigned this role
	AssignedBy string `protobuf:"bytes,3,opt,name=assigned_by,json=assignedBy,proto3" json:"assigned_by" yaml:"assigned_by"`
	// AssignedAt is the Unix timestamp when the role was assigned
	AssignedAt int64 `protobuf:"varint,4,opt,name=assigned_at,json=assignedAt,proto3" json:"assigned_at" yaml:"assigned_at"`
}

func (m *RoleAssignment) Reset()         { *m = RoleAssignment{} }
func (m *RoleAssignment) String() string { return proto.CompactTextString(m) }
func (*RoleAssignment) ProtoMessage()    {}
func (*RoleAssignment) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{0}
}
func (m *RoleAssignment) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RoleAssignment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RoleAssignment.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RoleAssignment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RoleAssignment.Merge(m, src)
}
func (m *RoleAssignment) XXX_Size() int {
	return m.Size()
}
func (m *RoleAssignment) XXX_DiscardUnknown() {
	xxx_messageInfo_RoleAssignment.DiscardUnknown(m)
}

var xxx_messageInfo_RoleAssignment proto.InternalMessageInfo

func (m *RoleAssignment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RoleAssignment) GetRole() Role {
	if m != nil {
		return m.Role
	}
	return RoleUnspecified
}

func (m *RoleAssignment) GetAssignedBy() string {
	if m != nil {
		return m.AssignedBy
	}
	return ""
}

func (m *RoleAssignment) GetAssignedAt() int64 {
	if m != nil {
		return m.AssignedAt
	}
	return 0
}

// AccountStateRecord represents the stored state of an account
type AccountStateRecord struct {
	// Address is the account address
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// State is the current account state
	State AccountState `protobuf:"varint,2,opt,name=state,proto3,enum=virtengine.roles.v1.AccountState" json:"state" yaml:"state"`
	// Reason is the reason for the current state
	Reason string `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason" yaml:"reason"`
	// ModifiedBy is the address that last modified the state
	ModifiedBy string `protobuf:"bytes,4,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by" yaml:"modified_by"`
	// ModifiedAt is the Unix timestamp when the state was last modified
	ModifiedAt int64 `protobuf:"varint,5,opt,name=modified_at,json=modifiedAt,proto3" json:"modified_at" yaml:"modified_at"`
	// PreviousState is the previous account state
	PreviousState AccountState `protobuf:"varint,6,opt,name=previous_state,json=previousState,proto3,enum=virtengine.roles.v1.AccountState" json:"previous_state" yaml:"previous_state"`
}

func (m *AccountStateRecord) Reset()         { *m = AccountStateRecord{} }
func (m *AccountStateRecord) String() string { return proto.CompactTextString(m) }
func (*AccountStateRecord) ProtoMessage()    {}
func (*AccountStateRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{1}
}
func (m *AccountStateRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountStateRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountStateRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountStateRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountStateRecord.Merge(m, src)
}
func (m *AccountStateRecord) XXX_Size() int {
	return m.Size()
}
func (m *AccountStateRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountStateRecord.DiscardUnknown(m)
}

var xxx_messageInfo_AccountStateRecord proto.InternalMessageInfo

func (m *AccountStateRecord) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *AccountStateRecord) GetState() AccountState {
	if m != nil {
		return m.State
	}
	return AccountStateUnspecified
}

func (m *AccountStateRecord) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *AccountStateRecord) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *AccountStateRecord) GetModifiedAt() int64 {
	if m != nil {
		return m.ModifiedAt
	}
	return 0
}

func (m *AccountStateRecord) GetPreviousState() AccountState {
	if m != nil {
		return m.PreviousState
	}
	return AccountStateUnspecified
}

// Params defines the parameters for the roles module
type Params struct {
	// MaxRolesPerAccount is the maximum number of roles an account can have
	MaxRolesPerAccount uint32 `protobuf:"varint,1,opt,name=max_roles_per_account,json=maxRolesPerAccount,proto3" json:"max_roles_per_account" yaml:"max_roles_per_account"`
	// AllowSelfRevoke determines if accounts can revoke their own roles
	AllowSelfRevoke bool `protobuf:"varint,2,opt,name=allow_self_revoke,json=allowSelfRevoke,proto3" json:"allow_self_revoke" yaml:"allow_self_revoke"`
}

func (m *Params) Reset()         { *m = Params{} }
func (m *Params) String() string { return proto.CompactTextString(m) }
func (*Params) ProtoMessage()    {}
func (*Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{2}
}
func (m *Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Params.Merge(m, src)
}
func (m *Params) XXX_Size() int {
	return m.Size()
}
func (m *Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Params proto.InternalMessageInfo

func (m *Params) GetMaxRolesPerAccount() uint32 {
	if m != nil {
		return m.MaxRolesPerAccount
	}
	return 0
}

func (m *Params) GetAllowSelfRevoke() bool {
	if m != nil {
		return m.AllowSelfRevoke
	}
	return false
}

// EventRoleAssigned is emitted when a role is assigned to an account
type EventRoleAssigned struct {
	// Address is the account that received the role
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// Role is the assigned role
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role" yaml:"role"`
	// AssignedBy is the address that assigned the role
	AssignedBy string `protobuf:"bytes,3,opt,name=assigned_by,json=assignedBy,proto3" json:"assigned_by" yaml:"assigned_by"`
}

func (m *EventRoleAssigned) Reset()         { *m = EventRoleAssigned{} }
func (m *EventRoleAssigned) String() string { return proto.CompactTextString(m) }
func (*EventRoleAssigned) ProtoMessage()    {}
func (*EventRoleAssigned) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{3}
}
func (m *EventRoleAssigned) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRoleAssigned) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRoleAssigned.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRoleAssigned) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRoleAssigned.Merge(m, src)
}
func (m *EventRoleAssigned) XXX_Size() int {
	return m.Size()
}
func (m *EventRoleAssigned) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRoleAssigned.DiscardUnknown(m)
}

var xxx_messageInfo_EventRoleAssigned proto.InternalMessageInfo

func (m *EventRoleAssigned) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventRoleAssigned) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *EventRoleAssigned) GetAssignedBy() string {
	if m != nil {
		return m.AssignedBy
	}
	return ""
}

// EventRoleRevoked is emitted when a role is revoked from an account
type EventRoleRevoked struct {
	// Address is the account that lost the role
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// Role is the revoked role
	Role string `protobuf:"bytes,2,opt,name=role,proto3" json:"role" yaml:"role"`
	// RevokedBy is the address that revoked the role
	RevokedBy string `protobuf:"bytes,3,opt,name=revoked_by,json=revokedBy,proto3" json:"revoked_by" yaml:"revoked_by"`
}

func (m *EventRoleRevoked) Reset()         { *m = EventRoleRevoked{} }
func (m *EventRoleRevoked) String() string { return proto.CompactTextString(m) }
func (*EventRoleRevoked) ProtoMessage()    {}
func (*EventRoleRevoked) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{4}
}
func (m *EventRoleRevoked) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventRoleRevoked) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventRoleRevoked.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventRoleRevoked) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventRoleRevoked.Merge(m, src)
}
func (m *EventRoleRevoked) XXX_Size() int {
	return m.Size()
}
func (m *EventRoleRevoked) XXX_DiscardUnknown() {
	xxx_messageInfo_EventRoleRevoked.DiscardUnknown(m)
}

var xxx_messageInfo_EventRoleRevoked proto.InternalMessageInfo

func (m *EventRoleRevoked) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventRoleRevoked) GetRole() string {
	if m != nil {
		return m.Role
	}
	return ""
}

func (m *EventRoleRevoked) GetRevokedBy() string {
	if m != nil {
		return m.RevokedBy
	}
	return ""
}

// EventAccountStateChanged is emitted when an account state changes
type EventAccountStateChanged struct {
	// Address is the account whose state changed
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// PreviousState is the previous state
	PreviousState string `protobuf:"bytes,2,opt,name=previous_state,json=previousState,proto3" json:"previous_state" yaml:"previous_state"`
	// NewState is the new state
	NewState string `protobuf:"bytes,3,opt,name=new_state,json=newState,proto3" json:"new_state" yaml:"new_state"`
	// ModifiedBy is the address that modified the state
	ModifiedBy string `protobuf:"bytes,4,opt,name=modified_by,json=modifiedBy,proto3" json:"modified_by" yaml:"modified_by"`
	// Reason is the reason for the state change
	Reason string `protobuf:"bytes,5,opt,name=reason,proto3" json:"reason" yaml:"reason"`
}

func (m *EventAccountStateChanged) Reset()         { *m = EventAccountStateChanged{} }
func (m *EventAccountStateChanged) String() string { return proto.CompactTextString(m) }
func (*EventAccountStateChanged) ProtoMessage()    {}
func (*EventAccountStateChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{5}
}
func (m *EventAccountStateChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAccountStateChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAccountStateChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAccountStateChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAccountStateChanged.Merge(m, src)
}
func (m *EventAccountStateChanged) XXX_Size() int {
	return m.Size()
}
func (m *EventAccountStateChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAccountStateChanged.DiscardUnknown(m)
}

var xxx_messageInfo_EventAccountStateChanged proto.InternalMessageInfo

func (m *EventAccountStateChanged) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventAccountStateChanged) GetPreviousState() string {
	if m != nil {
		return m.PreviousState
	}
	return ""
}

func (m *EventAccountStateChanged) GetNewState() string {
	if m != nil {
		return m.NewState
	}
	return ""
}

func (m *EventAccountStateChanged) GetModifiedBy() string {
	if m != nil {
		return m.ModifiedBy
	}
	return ""
}

func (m *EventAccountStateChanged) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

// EventAdminNominated is emitted when a new administrator is nominated
type EventAdminNominated struct {
	// Address is the nominated administrator
	Address string `protobuf:"bytes,1,opt,name=address,proto3" json:"address" yaml:"address"`
	// NominatedBy is the address that made the nomination
	NominatedBy string `protobuf:"bytes,2,opt,name=nominated_by,json=nominatedBy,proto3" json:"nominated_by" yaml:"nominated_by"`
}

func (m *EventAdminNominated) Reset()         { *m = EventAdminNominated{} }
func (m *EventAdminNominated) String() string { return proto.CompactTextString(m) }
func (*EventAdminNominated) ProtoMessage()    {}
func (*EventAdminNominated) Descriptor() ([]byte, []int) {
	return fileDescriptor_a7c0cfaff734a171, []int{6}
}
func (m *EventAdminNominated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventAdminNominated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventAdminNominated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventAdminNominated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventAdminNominated.Merge(m, src)
}
func (m *EventAdminNominated) XXX_Size() int {
	return m.Size()
}
func (m *EventAdminNominated) XXX_DiscardUnknown() {
	xxx_messageInfo_EventAdminNominated.DiscardUnknown(m)
}

var xxx_messageInfo_EventAdminNominated proto.InternalMessageInfo

func (m *EventAdminNominated) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *EventAdminNominated) GetNominatedBy() string {
	if m != nil {
		return m.NominatedBy
	}
	return ""
}

func init() {
	proto.RegisterEnum("virtengine.roles.v1.Role", Role_name, Role_value)
	proto.RegisterEnum("virtengine.roles.v1.AccountState", AccountState_name, AccountState_value)
	proto.RegisterType((*RoleAssignment)(nil), "virtengine.roles.v1.RoleAssignment")
	proto.RegisterType((*AccountStateRecord)(nil), "virtengine.roles.v1.AccountStateRecord")
	proto.RegisterType((*Params)(nil), "virtengine.roles.v1.Params")
	proto.RegisterType((*EventRoleAssigned)(nil), "virtengine.roles.v1.EventRoleAssigned")
	proto.RegisterType((*EventRoleRevoked)(nil), "virtengine.roles.v1.EventRoleRevoked")
	proto.RegisterType((*EventAccountStateChanged)(nil), "virtengine.roles.v1.EventAccountStateChanged")
	proto.RegisterType((*EventAdminNominated)(nil), "virtengine.roles.v1.EventAdminNominated")
}

func init() { proto.RegisterFile("virtengine/roles/v1/types.proto", fileDescriptor_a7c0cfaff734a171) }

var fileDescriptor_a7c0cfaff734a171 = []byte{
	// 1175 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x51, 0x6b, 0xdb, 0x56,
	0x14, 0x8e, 0x12, 0x27, 0x6d, 0x6e, 0x93, 0x54, 0x56, 0x92, 0xc6, 0x51, 0x87, 0xaf, 0xaa, 0x51,
	0xe8, 0xd2, 0xd5, 0x5e, 0x5a, 0x3a, 0xb6, 0x8c, 0x6d, 0xc8, 0xb6, 0x12, 0x0c, 0x8d, 0x6d, 0x24,
	0x39, 0x0f, 0x85, 0x4d, 0x28, 0xd6, 0x8d, 0x2b, 0x6a, 0xe9, 0x1a, 0x49, 0x76, 0x9a, 0x7f, 0x30,
	0xfc, 0x34, 0xd8, 0xdb, 0xc0, 0x30, 0xd8, 0x1f, 0xd8, 0xc3, 0x7e, 0xc4, 0x1e, 0xc3, 0x5e, 0xb6,
	0x27, 0x31, 0x92, 0x87, 0x0d, 0xc3, 0x5e, 0xc4, 0x60, 0xaf, 0x43, 0xf7, 0x4a, 0xb1, 0x9c, 0x3a,
	0xa3, 0xb0, 0x85, 0xbe, 0x04, 0xdf, 0xef, 0x7c, 0xe7, 0xdc, 0x73, 0xce, 0x77, 0xcf, 0x89, 0x00,
	0xec, 0x5b, 0xae, 0x8f, 0x9c, 0xb6, 0xe5, 0xa0, 0xa2, 0x8b, 0x3b, 0xc8, 0x2b, 0xf6, 0xb7, 0x8b,
	0xfe, 0x49, 0x17, 0x79, 0x85, 0xae, 0x8b, 0x7d, 0xcc, 0xad, 0x8e, 0x09, 0x05, 0x42, 0x28, 0xf4,
	0xb7, 0xf9, 0xb5, 0x36, 0x6e, 0x63, 0x62, 0x2f, 0x46, 0xbf, 0x28, 0x95, 0xdf, 0x6c, 0x61, 0xcf,
	0xc6, 0x9e, 0x4e, 0x0d, 0xf4, 0x10, 0x9b, 0xb2, 0x86, 0x6d, 0x39, 0xb8, 0x48, 0xfe, 0x52, 0x48,
	0xfc, 0x65, 0x16, 0xac, 0x28, 0xb8, 0x83, 0x24, 0xcf, 0xb3, 0xda, 0x8e, 0x8d, 0x1c, 0x9f, 0xab,
	0x83, 0x1b, 0x86, 0x69, 0xba, 0xc8, 0xf3, 0x72, 0x8c, 0xc0, 0x3c, 0x58, 0x2c, 0x3d, 0x1d, 0x05,
	0x30, 0x81, 0xc2, 0x00, 0xae, 0x9c, 0x18, 0x76, 0x67, 0x47, 0x8c, 0x01, 0xf1, 0xe7, 0x1f, 0x1f,
	0xad, 0xc5, 0xb7, 0x48, 0x14, 0x52, 0x7d, 0xd7, 0x72, 0xda, 0x4a, 0xe2, 0xc2, 0xed, 0x82, 0x4c,
	0x94, 0x73, 0x6e, 0x56, 0x60, 0x1e, 0xac, 0x3c, 0xde, 0x2c, 0x4c, 0xa9, 0xa5, 0x10, 0xe5, 0x50,
	0xda, 0x18, 0x05, 0x90, 0x50, 0xc3, 0x00, 0xde, 0xa2, 0xb7, 0x44, 0x27, 0x51, 0x21, 0x20, 0xf7,
	0x25, 0xb8, 0x65, 0x90, 0x34, 0x91, 0xa9, 0x1f, 0x9e, 0xe4, 0xe6, 0x48, 0x72, 0x9f, 0x8e, 0x02,
	0x98, 0x86, 0xc3, 0x00, 0x72, 0x71, 0x82, 0x63, 0xf0, 0xea, 0x24, 0x41, 0xc2, 0x2a, 0x9d, 0x70,
	0xbb, 0xa9, 0xf8, 0x86, 0x9f, 0xcb, 0x08, 0xcc, 0x83, 0xb9, 0xd2, 0xfd, 0x89, 0xf8, 0x86, 0x3f,
	0x25, 0xbe, 0xe1, 0x8b, 0xe3, 0x38, 0x92, 0xbf, 0x93, 0xf9, 0xe3, 0x3b, 0xc8, 0x88, 0xdf, 0x64,
	0x00, 0x27, 0xb5, 0x5a, 0xb8, 0xe7, 0xf8, 0xaa, 0x6f, 0xf8, 0x48, 0x41, 0x2d, 0xec, 0x9a, 0xff,
	0x7f, 0x77, 0x15, 0x30, 0xef, 0x45, 0xf1, 0xe3, 0xf6, 0xde, 0x9b, 0xda, 0xde, 0x74, 0x22, 0xa5,
	0xcd, 0x51, 0x00, 0xa9, 0x4f, 0x18, 0xc0, 0x25, 0x7a, 0x1f, 0x39, 0x8a, 0x0a, 0x85, 0xb9, 0x27,
	0x60, 0xc1, 0x45, 0x86, 0x87, 0x9d, 0xb8, 0xc9, 0x77, 0x47, 0x01, 0x8c, 0x91, 0x30, 0x80, 0xcb,
	0xb1, 0x34, 0xe4, 0x2c, 0x2a, 0xb1, 0x21, 0x92, 0xc7, 0xc6, 0xa6, 0x75, 0x64, 0x51, 0x79, 0x32,
	0x63, 0x79, 0x52, 0xf0, 0xb8, 0x7d, 0x29, 0xf0, 0x5f, 0xe4, 0x49, 0x58, 0x54, 0x9e, 0x0b, 0x1f,
	0xc3, 0xcf, 0xcd, 0x8f, 0xe5, 0x49, 0xc1, 0x53, 0xe2, 0x13, 0x79, 0x92, 0x93, 0xe4, 0x73, 0x3d,
	0xb0, 0xd2, 0x75, 0x51, 0xdf, 0xc2, 0x3d, 0x4f, 0xa7, 0x9d, 0x5b, 0x78, 0xd3, 0xce, 0x3d, 0x1c,
	0x05, 0xf0, 0x92, 0x73, 0x18, 0xc0, 0x75, 0x7a, 0xe1, 0x24, 0x2e, 0x2a, 0xcb, 0x09, 0x40, 0x7c,
	0xe3, 0x57, 0xf1, 0x37, 0x03, 0x16, 0x1a, 0x86, 0x6b, 0xd8, 0x1e, 0xd7, 0x01, 0xeb, 0xb6, 0xf1,
	0x4a, 0x27, 0x37, 0xe9, 0x5d, 0xe4, 0xea, 0x06, 0xbd, 0x8a, 0xbc, 0x8b, 0xe5, 0xd2, 0xc7, 0xa3,
	0x00, 0x4e, 0x27, 0x84, 0x01, 0x7c, 0x27, 0xae, 0x71, 0x9a, 0x59, 0x54, 0x38, 0xdb, 0x78, 0x15,
	0x0d, 0x94, 0xd7, 0x40, 0x6e, 0x9c, 0x3f, 0xf7, 0x05, 0xc8, 0x1a, 0x9d, 0x0e, 0x3e, 0xd6, 0x3d,
	0xd4, 0x39, 0xd2, 0x5d, 0xd4, 0xc7, 0x2f, 0xe9, 0x93, 0xb9, 0x59, 0xda, 0x1e, 0x05, 0xf0, 0x75,
	0x63, 0x18, 0xc0, 0x5c, 0xfc, 0x16, 0x2f, 0x9b, 0x44, 0xe5, 0x36, 0xc1, 0x54, 0xd4, 0x39, 0x52,
	0x08, 0xb2, 0x23, 0x44, 0xd5, 0x0d, 0x7e, 0xff, 0x61, 0x6b, 0xe3, 0xb5, 0x55, 0x46, 0xcb, 0x8d,
	0x2a, 0xcf, 0xca, 0x7d, 0xe4, 0xf8, 0xe3, 0x75, 0x83, 0xae, 0x61, 0x1c, 0x1e, 0xa6, 0x96, 0xcd,
	0xe2, 0x5b, 0xde, 0x28, 0xb1, 0xe6, 0x21, 0x03, 0xd8, 0x8b, 0xca, 0x69, 0xbf, 0xde, 0x76, 0xe1,
	0xcf, 0x01, 0xa0, 0x52, 0xa6, 0xea, 0xfe, 0x64, 0x14, 0xc0, 0x14, 0x1a, 0x06, 0x30, 0x9b, 0x0c,
	0x7a, 0x82, 0x5d, 0x9d, 0xc6, 0x62, 0x4c, 0xba, 0x28, 0xfa, 0xdb, 0x39, 0x90, 0x23, 0x45, 0xa7,
	0x07, 0xa8, 0xfc, 0xc2, 0x70, 0xda, 0xe8, 0x5a, 0x96, 0xe0, 0xe5, 0x99, 0xa6, 0x6d, 0xf8, 0x0f,
	0x03, 0xcb, 0x7d, 0x06, 0x16, 0x1d, 0x74, 0x1c, 0x87, 0xa3, 0x2d, 0xba, 0x37, 0x0a, 0xe0, 0x18,
	0x0c, 0x03, 0xc8, 0xd2, 0x48, 0x17, 0x90, 0xa8, 0xdc, 0x74, 0xd0, 0x31, 0xf5, 0xbf, 0xee, 0x7d,
	0x38, 0x5e, 0xd2, 0xf3, 0x6f, 0xbc, 0xa4, 0x63, 0x71, 0x4e, 0x19, 0xb0, 0x4a, 0xc5, 0x31, 0x6d,
	0xcb, 0xa9, 0x61, 0xdb, 0x72, 0x0c, 0xff, 0x3a, 0x74, 0x39, 0x04, 0x4b, 0x4e, 0x12, 0x3d, 0x6a,
	0x02, 0x55, 0xe5, 0xf3, 0x51, 0x00, 0x27, 0xf0, 0x30, 0x80, 0xab, 0x71, 0x27, 0x53, 0xe8, 0xd5,
	0xf1, 0x6f, 0x5d, 0xd0, 0x92, 0xf7, 0xb6, 0xf5, 0xe7, 0x2c, 0xc8, 0x44, 0xf3, 0xc5, 0xbd, 0x07,
	0x58, 0xa5, 0xfe, 0x4c, 0xd6, 0x9b, 0x35, 0xb5, 0x21, 0x97, 0xab, 0xbb, 0x55, 0xb9, 0xc2, 0xce,
	0xf0, 0xab, 0x83, 0xa1, 0x70, 0x3b, 0xb2, 0x37, 0x1d, 0xaf, 0x8b, 0x5a, 0xa4, 0x87, 0xdc, 0x07,
	0x60, 0x8d, 0x50, 0xf7, 0xe4, 0x9a, 0xac, 0x56, 0x55, 0x5d, 0x2a, 0x97, 0xeb, 0xcd, 0x9a, 0xc6,
	0x32, 0xfc, 0x9d, 0xc1, 0x50, 0xe0, 0x22, 0xfa, 0x1e, 0x72, 0x90, 0x67, 0x79, 0xc9, 0x16, 0x7d,
	0x04, 0x38, 0xe2, 0x21, 0x55, 0xf6, 0xab, 0xb5, 0xaa, 0xaa, 0x29, 0x92, 0x56, 0x57, 0xd8, 0x59,
	0x7e, 0x7d, 0x30, 0x14, 0xb2, 0x64, 0xb1, 0x45, 0x0d, 0xb5, 0x3c, 0xdf, 0x35, 0x7c, 0xec, 0x72,
	0xf7, 0xc1, 0x0a, 0xa1, 0xef, 0xd7, 0x2b, 0x32, 0xa5, 0xce, 0xf1, 0xd9, 0xc1, 0x50, 0x58, 0x8e,
	0xa8, 0xfb, 0xd8, 0x44, 0x93, 0xb4, 0x03, 0xe9, 0x59, 0xb5, 0x42, 0x68, 0x99, 0x31, 0xed, 0xc0,
	0xe8, 0x58, 0x26, 0xa1, 0x3d, 0x06, 0xeb, 0x84, 0xa6, 0xca, 0xca, 0x41, 0xb5, 0x2c, 0xeb, 0x0d,
	0xa5, 0x7e, 0x50, 0xad, 0xc8, 0x0a, 0x3b, 0xcf, 0x6f, 0x0c, 0x86, 0xc2, 0x6a, 0xc4, 0x56, 0x91,
	0xdb, 0xb7, 0x5a, 0xa8, 0xe1, 0xe2, 0xbe, 0x65, 0x22, 0x97, 0x7b, 0x17, 0x2c, 0x13, 0x9f, 0x72,
	0x53, 0xd5, 0xea, 0xfb, 0xb2, 0xc2, 0x2e, 0xf0, 0xec, 0x60, 0x28, 0x2c, 0x45, 0xdc, 0x72, 0xcf,
	0xf3, 0xb1, 0x8d, 0x5c, 0xee, 0xfd, 0xb8, 0x2a, 0xb5, 0xd9, 0x68, 0xd4, 0x15, 0x4d, 0x97, 0xf6,
	0xe4, 0x9a, 0xc6, 0xde, 0xe0, 0xd7, 0x06, 0x43, 0x81, 0x25, 0x51, 0x7b, 0xdd, 0x2e, 0x76, 0x7d,
	0xa9, 0x8d, 0x1c, 0x9f, 0xcf, 0x7c, 0xf5, 0x7d, 0x7e, 0x66, 0xeb, 0x2f, 0x06, 0x2c, 0xa5, 0x47,
	0x9b, 0xdb, 0x01, 0x9b, 0x71, 0xff, 0x74, 0x55, 0x93, 0xb4, 0xcb, 0x02, 0xdc, 0x1d, 0x0c, 0x85,
	0x8d, 0xb4, 0xc3, 0x25, 0x21, 0x26, 0x7d, 0xa5, 0xb2, 0x56, 0x3d, 0x90, 0x13, 0x21, 0xd2, 0x6e,
	0x52, 0xcb, 0xb7, 0xfa, 0x88, 0xfb, 0x10, 0x6c, 0x4c, 0x7a, 0xa8, 0x4d, 0xb5, 0x21, 0xd7, 0x2a,
	0x72, 0x85, 0x9d, 0xe5, 0x37, 0x07, 0x43, 0x61, 0x3d, 0xed, 0xa4, 0xf6, 0xbc, 0x2e, 0x72, 0x4c,
	0x64, 0x72, 0x1f, 0x81, 0xdc, 0xa4, 0x9f, 0x26, 0x2b, 0xfb, 0xd5, 0x9a, 0xa4, 0xc9, 0x15, 0x76,
	0x8e, 0xe7, 0x07, 0x43, 0xe1, 0x4e, 0xda, 0x51, 0x43, 0x6e, 0xfc, 0xd0, 0x68, 0xd9, 0xa5, 0xfa,
	0x4f, 0x67, 0x79, 0xe6, 0xf4, 0x2c, 0xcf, 0xfc, 0x76, 0x96, 0x67, 0xbe, 0x3e, 0xcf, 0xcf, 0x9c,
	0x9e, 0xe7, 0x67, 0x7e, 0x3d, 0xcf, 0xcf, 0x3c, 0x7f, 0xda, 0xb6, 0xfc, 0x17, 0xbd, 0xc3, 0x42,
	0x0b, 0xdb, 0xc5, 0xd4, 0xff, 0xc0, 0xd4, 0x4f, 0xcf, 0x7c, 0x59, 0x6c, 0xe3, 0xa2, 0x83, 0xcd,
	0xf1, 0x57, 0xfe, 0xe1, 0x02, 0xf9, 0x0e, 0x7f, 0xf2, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x9d,
	0xea, 0x1d, 0xdc, 0x03, 0x0c, 0x00, 0x00,
}

func (this *RoleAssignment) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RoleAssignment)
	if !ok {
		that2, ok := that.(RoleAssignment)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.AssignedBy != that1.AssignedBy {
		return false
	}
	if this.AssignedAt != that1.AssignedAt {
		return false
	}
	return true
}
func (this *AccountStateRecord) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountStateRecord)
	if !ok {
		that2, ok := that.(AccountStateRecord)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.ModifiedBy != that1.ModifiedBy {
		return false
	}
	if this.ModifiedAt != that1.ModifiedAt {
		return false
	}
	if this.PreviousState != that1.PreviousState {
		return false
	}
	return true
}
func (this *Params) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Params)
	if !ok {
		that2, ok := that.(Params)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.MaxRolesPerAccount != that1.MaxRolesPerAccount {
		return false
	}
	if this.AllowSelfRevoke != that1.AllowSelfRevoke {
		return false
	}
	return true
}
func (this *EventRoleAssigned) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventRoleAssigned)
	if !ok {
		that2, ok := that.(EventRoleAssigned)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.AssignedBy != that1.AssignedBy {
		return false
	}
	return true
}
func (this *EventRoleRevoked) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventRoleRevoked)
	if !ok {
		that2, ok := that.(EventRoleRevoked)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.Role != that1.Role {
		return false
	}
	if this.RevokedBy != that1.RevokedBy {
		return false
	}
	return true
}
func (this *EventAccountStateChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventAccountStateChanged)
	if !ok {
		that2, ok := that.(EventAccountStateChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.PreviousState != that1.PreviousState {
		return false
	}
	if this.NewState != that1.NewState {
		return false
	}
	if this.ModifiedBy != that1.ModifiedBy {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	return true
}
func (this *EventAdminNominated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*EventAdminNominated)
	if !ok {
		that2, ok := that.(EventAdminNominated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Address != that1.Address {
		return false
	}
	if this.NominatedBy != that1.NominatedBy {
		return false
	}
	return true
}
func (m *RoleAssignment) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RoleAssignment) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RoleAssignment) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AssignedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.AssignedAt))
		i--
		dAtA[i] = 0x20
	}
	if len(m.AssignedBy) > 0 {
		i -= len(m.AssignedBy)
		copy(dAtA[i:], m.AssignedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssignedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Role != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountStateRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountStateRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountStateRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PreviousState != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.PreviousState))
		i--
		dAtA[i] = 0x30
	}
	if m.ModifiedAt != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.ModifiedAt))
		i--
		dAtA[i] = 0x28
	}
	if len(m.ModifiedBy) > 0 {
		i -= len(m.ModifiedBy)
		copy(dAtA[i:], m.ModifiedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModifiedBy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AllowSelfRevoke {
		i--
		if m.AllowSelfRevoke {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MaxRolesPerAccount != 0 {
		i = encodeVarintTypes(dAtA, i, uint64(m.MaxRolesPerAccount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *EventRoleAssigned) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRoleAssigned) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRoleAssigned) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AssignedBy) > 0 {
		i -= len(m.AssignedBy)
		copy(dAtA[i:], m.AssignedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.AssignedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventRoleRevoked) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventRoleRevoked) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventRoleRevoked) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevokedBy) > 0 {
		i -= len(m.RevokedBy)
		copy(dAtA[i:], m.RevokedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.RevokedBy)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Role) > 0 {
		i -= len(m.Role)
		copy(dAtA[i:], m.Role)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Role)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAccountStateChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAccountStateChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAccountStateChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ModifiedBy) > 0 {
		i -= len(m.ModifiedBy)
		copy(dAtA[i:], m.ModifiedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.ModifiedBy)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewState) > 0 {
		i -= len(m.NewState)
		copy(dAtA[i:], m.NewState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NewState)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.PreviousState) > 0 {
		i -= len(m.PreviousState)
		copy(dAtA[i:], m.PreviousState)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PreviousState)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventAdminNominated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventAdminNominated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventAdminNominated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NominatedBy) > 0 {
		i -= len(m.NominatedBy)
		copy(dAtA[i:], m.NominatedBy)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.NominatedBy)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Address) > 0 {
		i -= len(m.Address)
		copy(dAtA[i:], m.Address)
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RoleAssignment) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovTypes(uint64(m.Role))
	}
	l = len(m.AssignedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.AssignedAt != 0 {
		n += 1 + sovTypes(uint64(m.AssignedAt))
	}
	return n
}

func (m *AccountStateRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModifiedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.ModifiedAt != 0 {
		n += 1 + sovTypes(uint64(m.ModifiedAt))
	}
	if m.PreviousState != 0 {
		n += 1 + sovTypes(uint64(m.PreviousState))
	}
	return n
}

func (m *Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxRolesPerAccount != 0 {
		n += 1 + sovTypes(uint64(m.MaxRolesPerAccount))
	}
	if m.AllowSelfRevoke {
		n += 2
	}
	return n
}

func (m *EventRoleAssigned) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.AssignedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventRoleRevoked) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.RevokedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventAccountStateChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PreviousState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NewState)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.ModifiedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EventAdminNominated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.NominatedBy)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func sovTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RoleAssignment) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RoleAssignment: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RoleAssignment: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= Role(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedAt", wireType)
			}
			m.AssignedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AssignedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountStateRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountStateRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountStateRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= AccountState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedAt", wireType)
			}
			m.ModifiedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ModifiedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
			}
			m.PreviousState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreviousState |= AccountState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRolesPerAccount", wireType)
			}
			m.MaxRolesPerAccount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRolesPerAccount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowSelfRevoke", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowSelfRevoke = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRoleAssigned) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRoleAssigned: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRoleAssigned: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AssignedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AssignedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventRoleRevoked) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventRoleRevoked: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventRoleRevoked: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RevokedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAccountStateChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAccountStateChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAccountStateChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreviousState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreviousState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewState", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewState = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ModifiedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ModifiedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventAdminNominated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventAdminNominated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventAdminNominated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NominatedBy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NominatedBy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTypes = fmt.Errorf("proto: unexpected end of group")
)

