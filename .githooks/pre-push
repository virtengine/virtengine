#!/usr/bin/env bash
# VirtEngine Pre-Push Hook
#
# Prevents pushing code that doesn't pass critical quality gates.
# Mirrors CI required checks: vet, mod sync, lint, proto, build, tests.
#
# Bypass:       git push --no-verify
# Quick mode:   VE_HOOK_QUICK=1 git push     (vet + build only)
#
# Skip individual checks:
#   VE_HOOK_SKIP_VET=1      Skip go vet
#   VE_HOOK_SKIP_MOD=1      Skip go mod tidy/vendor checks
#   VE_HOOK_SKIP_LINT=1     Skip golangci-lint
#   VE_HOOK_SKIP_PROTO=1    Skip proto staleness check
#   VE_HOOK_SKIP_BUILD=1    Skip build
#   VE_HOOK_SKIP_TEST=1     Skip unit tests

set -euo pipefail

HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=common.sh
source "$HOOK_DIR/common.sh"

# --- Parse push info from stdin ---
# Git passes: <local ref> <local sha> <remote ref> <remote sha>
# Skip checks for delete pushes (local sha is all zeros).
while read -r _local_ref local_sha _remote_ref _remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        exit 0
    fi
done

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

echo ""
hook_header "========================================="
hook_header " VirtEngine Pre-Push Quality Gate"
hook_header "========================================="
hook_info "Bypass: git push --no-verify"
echo ""

# --- Load environment ---
ensure_direnv_env

TOTAL_START=$(hook_time_start)
FAILED=0
PASSED=0
SKIPPED=0
TOTAL_CHECKS=7

# Helper to run a check
run_check() {
    local num=$1
    local name=$2
    local skip_var=$3
    shift 3

    if [ "${!skip_var:-}" = "1" ]; then
        hook_warn "[$num/$TOTAL_CHECKS] $name (skipped)"
        SKIPPED=$((SKIPPED + 1))
        return 0
    fi

    hook_info "[$num/$TOTAL_CHECKS] $name"
    local step_start
    step_start=$(hook_time_start)

    if "$@"; then
        hook_pass "$name passed ($(hook_time_elapsed "$step_start")s)"
        PASSED=$((PASSED + 1))
        return 0
    else
        hook_fail "$name FAILED ($(hook_time_elapsed "$step_start")s)"
        FAILED=$((FAILED + 1))
        return 1
    fi
}

# =========================================================================
# Check 1: go vet
# =========================================================================
check_vet() {
    make test-vet 2>&1
}

# =========================================================================
# Check 2: go mod tidy (dirty check)
# =========================================================================
check_mod_tidy() {
    # Save current state of go.mod and go.sum
    local mod_backup sum_backup
    mod_backup=$(cat go.mod)
    sum_backup=$(cat go.sum 2>/dev/null || true)

    go mod tidy 2>&1

    # Check if files changed
    local mod_after sum_after
    mod_after=$(cat go.mod)
    sum_after=$(cat go.sum 2>/dev/null || true)

    if [ "$mod_backup" != "$mod_after" ] || [ "$sum_backup" != "$sum_after" ]; then
        # Restore originals so we don't modify the working tree
        echo "$mod_backup" > go.mod
        if [ -n "$sum_backup" ]; then
            echo "$sum_backup" > go.sum
        fi
        hook_fail "go.mod or go.sum is out of sync. Run 'go mod tidy' and commit the result."
        return 1
    fi
    return 0
}

# =========================================================================
# Check 3: go mod vendor (dirty check)
# =========================================================================
check_mod_vendor() {
    go mod vendor 2>&1

    # Check if vendor directory changed
    if ! git diff --quiet vendor/ 2>/dev/null; then
        # Restore vendor to committed state
        git checkout -- vendor/ 2>/dev/null || true
        hook_fail "vendor/ is out of sync. Run 'go mod vendor' and commit the result."
        return 1
    fi
    return 0
}

# =========================================================================
# Check 4: golangci-lint
# =========================================================================
check_lint() {
    make lint-go 2>&1
}

# =========================================================================
# Check 5: proto-gen staleness check
# =========================================================================
check_proto() {
    local stale=0
    local proto_dirs=("sdk/proto" "proto")

    for dir in "${proto_dirs[@]}"; do
        if [ ! -d "$dir" ]; then
            continue
        fi

        # Find .proto files modified more recently than their .pb.go counterparts
        while IFS= read -r -d '' proto_file; do
            # Derive expected .pb.go location patterns
            local base_name
            base_name=$(basename "$proto_file" .proto)

            # Search for corresponding .pb.go files
            local pb_files
            pb_files=$(find . -name "${base_name}.pb.go" -newer "$proto_file" 2>/dev/null || true)

            # If proto file exists but no .pb.go is newer, check if any .pb.go exists at all
            if [ -z "$pb_files" ]; then
                local any_pb
                any_pb=$(find . -name "${base_name}.pb.go" 2>/dev/null || true)
                if [ -n "$any_pb" ]; then
                    # .pb.go exists but is older than .proto â€” stale
                    # Only flag if .proto was modified in the commits being pushed
                    if git diff --name-only HEAD~1..HEAD 2>/dev/null | grep -q "$proto_file"; then
                        hook_warn "  Stale: $proto_file is newer than its .pb.go output"
                        stale=$((stale + 1))
                    fi
                fi
            fi
        done < <(find "$dir" -name "*.proto" -print0 2>/dev/null)
    done

    if [ "$stale" -gt 0 ]; then
        hook_fail "$stale proto file(s) appear to have stale generated code."
        hook_fail "Run proto generation and commit the output."
        return 1
    fi
    return 0
}

# =========================================================================
# Check 6: Build
# =========================================================================
check_build() {
    make bins 2>&1
}

# =========================================================================
# Check 7: Unit tests
# =========================================================================
check_test() {
    make test 2>&1
}

# =========================================================================
# Run checks
# =========================================================================

# Quick mode: only vet + build
if [ "${VE_HOOK_QUICK:-}" = "1" ]; then
    TOTAL_CHECKS=2
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
else
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "go mod tidy (sync check)" VE_HOOK_SKIP_MOD check_mod_tidy || true
    run_check 3 "go mod vendor (sync check)" VE_HOOK_SKIP_MOD check_mod_vendor || true
    run_check 4 "golangci-lint" VE_HOOK_SKIP_LINT check_lint || true
    run_check 5 "Proto generation (staleness check)" VE_HOOK_SKIP_PROTO check_proto || true
    run_check 6 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
    run_check 7 "Unit tests" VE_HOOK_SKIP_TEST check_test || true
fi

# =========================================================================
# Summary
# =========================================================================
TOTAL_ELAPSED=$(hook_time_elapsed "$TOTAL_START")
echo ""

if [ "$FAILED" -gt 0 ]; then
    hook_header "========================================="
    hook_fail " $FAILED of $((PASSED + FAILED)) checks FAILED (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    echo ""
    hook_fail "Fix the errors above, then try again."
    hook_info "Bypass:     git push --no-verify"
    hook_info "Quick mode: VE_HOOK_QUICK=1 git push"
    hook_info "Skip one:   VE_HOOK_SKIP_LINT=1 git push"
    exit 1
else
    hook_header "========================================="
    hook_pass " All $PASSED checks passed (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    exit 0
fi
