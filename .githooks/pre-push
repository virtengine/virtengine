#!/usr/bin/env bash
# VirtEngine Pre-Push Hook
#
# Prevents pushing code that doesn't pass critical quality gates.
# Mirrors CI required checks: vet, lint, build, tests.
#
# NOTE: gofmt auto-formatting and go mod tidy/vendor are handled by pre-commit hook.
# This keeps pre-push fast and ensures formatted code is always committed.
#
# Bypass:       git push --no-verify
# Quick mode:   $env:VE_HOOK_QUICK=1; git push     (vet + build only)
#
# Skip individual checks:
#   $env:VE_HOOK_SKIP_VET=1;      Skip go vet
#   $env:VE_HOOK_SKIP_MOD=1;      Skip go mod tidy/vendor checks
#   $env:VE_HOOK_SKIP_LINT=1;     Skip golangci-lint
#   $env:VE_HOOK_SKIP_BUILD=1;    Skip build
#   $env:VE_HOOK_SKIP_TEST=1;     Skip unit tests
set -euo pipefail

HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=common.sh
source "$HOOK_DIR/common.sh"

# --- Parse push info from stdin ---
# Git passes: <local ref> <local sha> <remote ref> <remote sha>
# Skip checks for delete pushes (local sha is all zeros).
while read -r _local_ref local_sha _remote_ref _remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        exit 0
    fi
done

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

echo ""
hook_header "========================================="
hook_header " VirtEngine Pre-Push Quality Gate"
hook_header "========================================="
hook_info "Bypass: git push --no-verify"
echo ""

# --- Load environment ---
ensure_direnv_env

TOTAL_START=$(hook_time_start)
FAILED=0
PASSED=0
SKIPPED=0
TOTAL_CHECKS=5  # Reduced from 6 - mod tidy moved to pre-commit

# Helper to run a check
run_check() {
    local num=$1
    local name=$2
    local skip_var=$3
    shift 3

    if [ "${!skip_var:-}" = "1" ]; then
        hook_warn "[$num/$TOTAL_CHECKS] $name (skipped)"
        SKIPPED=$((SKIPPED + 1))
        return 0
    fi

    hook_info "[$num/$TOTAL_CHECKS] $name"
    local step_start
    step_start=$(hook_time_start)

    if "$@"; then
        hook_pass "$name passed ($(hook_time_elapsed "$step_start")s)"
        PASSED=$((PASSED + 1))
        return 0
    else
        hook_fail "$name FAILED ($(hook_time_elapsed "$step_start")s)"
        FAILED=$((FAILED + 1))
        return 1
    fi
}

# =========================================================================
# Check 1: go vet
# =========================================================================
check_vet() {
    # Optimization: only vet packages with changes since origin/main
    # Falls back to ./... if no commits yet or on main branch
    local changed_packages
    local base_branch="origin/main"

    # Check if we're on main or have no diverged commits
    if git rev-parse --verify "$base_branch" &>/dev/null; then
        # Exclude vendor/ and tests/ as they have build constraints or separate modules
        # NOTE: sdk/ is now included to catch SDK build errors early
        # Filter out directories that no longer exist (deleted packages)
        changed_packages=$(git diff --name-only "$base_branch" -- '*.go' 2>/dev/null | \
            grep -v '^vendor/' | \
            grep -v '^tests/' | \
            xargs -r dirname 2>/dev/null | sort -u | \
            while read -r dir; do [ -d "$dir" ] && echo "./$dir"; done | \
            paste -sd ' ' - 2>/dev/null || echo "")
    fi

    if [ -n "${changed_packages:-}" ]; then
        hook_step "Vetting changed packages only ($(echo "$changed_packages" | wc -w | tr -d ' ') packages)"
        # shellcheck disable=SC2086
        go vet $changed_packages 2>&1
    else
        # Exclude tests/ and local temp/ scratch dirs which may have build constraints
        go vet $(go list ./... 2>/dev/null | grep -v '/tests/' | grep -Ev '/temp($|/)' | head -100) 2>&1
    fi
}

# =========================================================================
# Check 2: go mod vendor (fast sync - only if needed)
# =========================================================================
check_mod_vendor() {
    # Quick vendor sync - only runs vendor command if vendor is missing or stale.
    # Full go mod tidy is handled by pre-commit hook when go.mod changes.

    # In workspace mode, use 'go work vendor' instead of 'go mod vendor'
    local vendor_cmd="go mod vendor"
    if [ -f "$REPO_ROOT/go.work" ] && [ "${GOWORK:-}" != "off" ]; then
        vendor_cmd="go work vendor"
    fi

    # Quick check: if vendor exists and is in sync, skip
    if [ -f vendor/modules.txt ]; then
        # In workspace mode, -mod=vendor is not used so just check vendor exists
        if [ "$vendor_cmd" = "go work vendor" ]; then
            hook_step "Workspace mode active - vendor sync skipped (not used at runtime)"
            return 0
        fi
        # Use go list to verify vendor consistency (faster than go mod verify)
        if go list -mod=vendor ./... >/dev/null 2>&1; then
            hook_step "Vendor directory already in sync"
            return 0
        fi
    fi

    # Vendor is missing or out of sync - run vendor command
    hook_step "Syncing vendor directory..."
    if ! $vendor_cmd 2>&1; then
        hook_fail "$vendor_cmd failed"
        return 1
    fi

    hook_step "Vendor directory synced"
    return 0
}

# =========================================================================
# Check 4: golangci-lint
# =========================================================================
check_lint() {
    # Find golangci-lint binary
    local lint_bin=""
    
    # Check common locations
    if command -v golangci-lint &>/dev/null; then
        lint_bin="golangci-lint"
    elif [ -x "$REPO_ROOT/.cache/bin/golangci-lint" ]; then
        lint_bin="$REPO_ROOT/.cache/bin/golangci-lint"
    elif [ -x "$HOME/go/bin/golangci-lint" ]; then
        lint_bin="$HOME/go/bin/golangci-lint"
    fi
    
    if [ -z "$lint_bin" ]; then
        hook_warn "golangci-lint not found - install with: go install github.com/golangci/golangci-lint/v2/cmd/golangci-lint@latest"
        hook_fail "golangci-lint is required for pre-push checks"
        return 1
    fi
    
    # Get version to check compatibility
    local lint_version
    lint_version=$($lint_bin version 2>&1 | head -1 || echo "unknown")
    hook_step "Using: $lint_bin ($lint_version)"
    
    # Run lint on changed files only (faster) with origin/main as base
    local base_branch="origin/main"
    if git rev-parse --verify "$base_branch" &>/dev/null; then
        hook_step "Linting changes since $base_branch"
        $lint_bin run --timeout=10m --new-from-rev="$base_branch" 2>&1
    else
        # No base branch - lint all (slower but complete)
        hook_step "Linting all packages (no base branch found)"
        $lint_bin run --timeout=10m 2>&1
    fi
}

# =========================================================================
# Check 5: Build
# =========================================================================
check_build() {
    # Try make first, fall back to direct go build
    if make bins 2>&1; then
        return 0
    fi
    hook_warn "make bins failed, trying direct go build..."
    # Build cmd/ and sdk/go/ to catch missing types in SDK packages
    go build ./cmd/... ./sdk/go/... 2>&1
}

# =========================================================================
# Check 6: Unit tests
# =========================================================================
check_test() {
    # Run tests with robust timeout handling for pre-push hook reliability.
    # Key optimizations:
    # - Go's native -timeout flag (more reliable than external timeout)
    # - Limited parallelism (avoids resource contention)
    # - Short mode (skips long-running tests)
    # - Failfast (immediate feedback on first failure)
    # - Compiled test caching (faster repeated runs)
    # - Exclude slow/integration test packages

    local go_timeout="180s"    # Per-package timeout (keeper tests need >60s on some machines)
    local parallel_limit=4     # Limit parallel test execution

    # Packages to exclude from pre-push tests (slow, integration, or special setup)
    local exclude_patterns=(
        "tests/e2e"
        "tests/integration"
        "tests/chaos"
        "pkg/chaos"
    )

    # Optimization: only test changed packages if possible
    local changed_packages=""
    local base_branch="origin/main"

    if git rev-parse --verify "$base_branch" &>/dev/null; then
        # Get changed Go files, exclude vendor/tests, filter to existing dirs
        # NOTE: sdk/ is now included to catch SDK test failures early
        changed_packages=$(git diff --name-only "$base_branch" -- '*.go' 2>/dev/null | \
            grep -v '_test\.go$' | \
            grep -v '^vendor/' | \
            grep -v '^tests/' | \
            xargs -r dirname 2>/dev/null | sort -u | \
            while read -r dir; do [ -d "$dir" ] && echo "./$dir"; done | \
            paste -sd ' ' - 2>/dev/null || echo "")
    fi

    # Build test arguments - rely on Go's internal timeout, not external wrapper
    local test_args="-short -timeout $go_timeout -failfast -p $parallel_limit -count=1"

    if [ -n "${changed_packages:-}" ]; then
        local pkg_count
        pkg_count=$(echo "$changed_packages" | wc -w | tr -d ' ')
        hook_step "Testing changed packages only ($pkg_count packages)"

        # shellcheck disable=SC2086
        go test $test_args $changed_packages 2>&1
        return $?
    else
        # Fallback: run fast unit test packages only
        # List packages explicitly to avoid slow discovery and exclude problematic dirs
        hook_step "Testing fast packages (no changed files detected)"
        
        # Get list of packages with test files, excluding slow ones
        local test_packages
        test_packages=$(go list ./x/... ./pkg/... 2>/dev/null | \
            grep -v '/tests/' | \
            grep -v '/e2e' | \
            grep -v '/integration' | \
            grep -v '/chaos' | \
            grep -v '/simulation' | \
            head -50 || echo "")  # Limit to 50 packages max
        
        if [ -z "$test_packages" ]; then
            hook_step "No testable packages found"
            return 0
        fi
        
        local pkg_count
        pkg_count=$(echo "$test_packages" | wc -l | tr -d ' ')
        hook_step "Running $pkg_count packages"

        # Run tests with explicit package list (avoids discovery overhead)
        echo "$test_packages" | xargs go test $test_args 2>&1
        return $?
    fi
}

# =========================================================================
# Run checks
# =========================================================================

# Quick mode: only vet + build
if [ "${VE_HOOK_QUICK:-}" = "1" ]; then
    TOTAL_CHECKS=2
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
else
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "go mod vendor (sync)" VE_HOOK_SKIP_MOD check_mod_vendor || true
    run_check 3 "golangci-lint" VE_HOOK_SKIP_LINT check_lint || true
    run_check 4 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
    run_check 5 "Unit tests" VE_HOOK_SKIP_TEST check_test || true
fi

# =========================================================================
# Summary
# =========================================================================
TOTAL_ELAPSED=$(hook_time_elapsed "$TOTAL_START")
echo ""

if [ "$FAILED" -gt 0 ]; then
    hook_header "========================================="
    hook_fail " $FAILED of $((PASSED + FAILED)) checks FAILED (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    echo ""
    hook_fail "Fix the errors above, then try again."
    hook_info "Bypass:       git push --no-verify"
    hook_info "Quick mode:   VE_HOOK_QUICK=1 git push"
    hook_info "Skip one:     VE_HOOK_SKIP_LINT=1 git push"
    exit 1
else
    hook_header "========================================="
    hook_pass " All $PASSED checks passed (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    exit 0
fi
