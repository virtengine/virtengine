#!/usr/bin/env bash
# VirtEngine Pre-Push Hook — Smart Quality Gate
#
# Only runs checks relevant to changed files. Mirrors CI required checks.
#
# Categories detected:
#   GO       — .go files outside vendor/tests/scripts
#   PORTAL   — portal/ and lib/portal/ TypeScript/JS/CSS files
#   SDK_TS   — sdk/ts/ TypeScript/JS files
#   DEPS     — go.mod, go.sum, pnpm-lock.yaml, package.json
#   WORKFLOW — .github/workflows/ YAML files
#   DOCS     — .md files, _docs/, docs/ (skip all checks)
#   CODEX_MONITOR — scripts/codex-monitor/ (run codex-monitor tests)
#   TERRAFORM — infra/terraform .tf files
#
# Bypass:      git push --no-verify
# Quick mode:  VE_HOOK_QUICK=1 git push     (vet + build only for Go)
#
# Skip individual checks:
#   VE_HOOK_SKIP_VET=1       Skip go vet
#   VE_HOOK_SKIP_FMT=1       Skip gofmt + prettier auto-format
#   VE_HOOK_SKIP_TF=1        Skip terraform fmt
#   VE_HOOK_SKIP_PNPM=1      Skip pnpm lockfile check
#   VE_HOOK_SKIP_MOD=1       Skip go mod tidy/vendor checks
#   VE_HOOK_SKIP_LINT=1      Skip golangci-lint
#   VE_HOOK_SKIP_BUILD=1     Skip build
#   VE_HOOK_SKIP_TEST=1      Skip unit tests (Go + Portal)
#   VE_HOOK_SKIP_PORTAL=1    Skip ALL portal checks (lint, type-check, tests, build)
#   VE_HOOK_SKIP_CODEX_MONITOR=1  Skip codex-monitor tests
set -euo pipefail

HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=common.sh
source "$HOOK_DIR/common.sh"

# --- Parse push info from stdin ---
PUSH_LOCAL_SHA=""
PUSH_REMOTE_SHA=""
while read -r _local_ref local_sha _remote_ref remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        exit 0
    fi
    PUSH_LOCAL_SHA="$local_sha"
    PUSH_REMOTE_SHA="$remote_sha"
done

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

echo ""
hook_header "========================================="
hook_header " VirtEngine Pre-Push Quality Gate"
hook_header "========================================="
hook_info "Bypass: git push --no-verify"
echo ""

# --- Load environment ---
ensure_direnv_env

TOTAL_START=$(hook_time_start)
FAILED=0
PASSED=0
SKIPPED=0
TOTAL_CHECKS=0

# =========================================================================
# FILE CHANGE DETECTION
# =========================================================================
# Determine which files are actually being pushed (not the entire branch).
# Priority:
#   1. Diff between remote SHA and local SHA (exact push range)
#   2. Diff between remote tracking branch and HEAD (new branch or fallback)
#   3. Full branch diff vs origin/main (last resort)
BASE_BRANCH="origin/main"
HAS_GO=false
HAS_PORTAL=false
HAS_SDK_TS=false
HAS_DEPS_JS=false
HAS_DEPS_GO=false
HAS_ONLY_DOCS=false
HAS_TERRAFORM=false
HAS_CODEX_MONITOR=false

CHANGED_FILES=""
DIFF_SOURCE=""

# Option 1: Use the exact push range (remote_sha..local_sha)
if [ -n "$PUSH_REMOTE_SHA" ] && [ "$PUSH_REMOTE_SHA" != "0000000000000000000000000000000000000000" ] && [ -n "$PUSH_LOCAL_SHA" ]; then
    CHANGED_FILES=$(git diff --name-only "$PUSH_REMOTE_SHA" "$PUSH_LOCAL_SHA" 2>/dev/null || echo "")
    [ -n "$CHANGED_FILES" ] && DIFF_SOURCE="push-range"
fi

# Option 2: New branch push — diff vs remote tracking branch
if [ -z "$CHANGED_FILES" ]; then
    TRACKING_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || echo "")
    if [ -n "$TRACKING_BRANCH" ]; then
        CHANGED_FILES=$(git diff --name-only "$TRACKING_BRANCH" HEAD 2>/dev/null || echo "")
        [ -n "$CHANGED_FILES" ] && DIFF_SOURCE="tracking-branch"
    fi
fi

# Option 3: Fallback — full branch diff vs origin/main
if [ -z "$CHANGED_FILES" ] && git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
    CHANGED_FILES=$(git diff --name-only "$BASE_BRANCH" 2>/dev/null || echo "")
    [ -n "$CHANGED_FILES" ] && DIFF_SOURCE="base-branch"
fi

# Option 4: Last resort — diff vs previous commit
if [ -z "$CHANGED_FILES" ]; then
    CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "")
    [ -n "$CHANGED_FILES" ] && DIFF_SOURCE="head~1"
fi

if [ -z "$CHANGED_FILES" ]; then
    HAS_GO=true
    HAS_PORTAL=true
    HAS_SDK_TS=true
    HAS_DEPS_JS=true
    HAS_DEPS_GO=true
    hook_warn "Could not detect changed files — running all checks"
else
    GO_FILES=$(echo "$CHANGED_FILES" | grep -E '\.go$' | grep -v '^vendor/' | grep -v '^tests/' | grep -v '^scripts/' || true)
    PORTAL_FILES=$(echo "$CHANGED_FILES" | grep -E '^(portal|lib/portal|lib/capture|lib/admin)/' || true)
    SDK_TS_FILES=$(echo "$CHANGED_FILES" | grep -E '^sdk/ts/' || true)
    JS_DEP_FILES=$(echo "$CHANGED_FILES" | \
        grep -E '(pnpm-lock\.yaml|pnpm-workspace\.yaml|package-lock\.json)' || true)
    # Only count package.json changes that affect the pnpm workspace (root, portal, lib, sdk/ts)
    JS_DEP_PKG=$(echo "$CHANGED_FILES" | \
        grep -E '^(package\.json|portal/package\.json|lib/.*/package\.json|sdk/ts/package\.json)$' || true)
    [ -n "$JS_DEP_PKG" ] && JS_DEP_FILES=$(printf '%s\n%s' "$JS_DEP_FILES" "$JS_DEP_PKG")
    JS_DEP_FILES=$(echo "$JS_DEP_FILES" | sed '/^$/d' || true)
    GO_DEP_FILES=$(echo "$CHANGED_FILES" | grep -E '^go\.(mod|sum|work)$' || true)
    TF_FILES=$(echo "$CHANGED_FILES" | grep -E '^infra/terraform/.*\.tf$' || true)
    NON_DOC_FILES=$(echo "$CHANGED_FILES" | grep -vE '(\.md$|^_docs/|^docs/|^\.github/)' || true)
    CODEX_MONITOR_FILES=$(echo "$CHANGED_FILES" | grep -E '^scripts/codex-monitor/' || true)

    [ -n "$GO_FILES" ]     && HAS_GO=true
    [ -n "$PORTAL_FILES" ] && HAS_PORTAL=true
    [ -n "$SDK_TS_FILES" ] && HAS_SDK_TS=true
    [ -n "$JS_DEP_FILES" ] && HAS_DEPS_JS=true
    [ -n "$GO_DEP_FILES" ] && HAS_DEPS_GO=true
    [ -n "$TF_FILES" ] && HAS_TERRAFORM=true
    [ -n "$CODEX_MONITOR_FILES" ] && HAS_CODEX_MONITOR=true
    [ -z "$NON_DOC_FILES" ] && [ -z "$CODEX_MONITOR_FILES" ] && HAS_ONLY_DOCS=true

    hook_info "Changed file categories (diff: ${DIFF_SOURCE}):"
    $HAS_GO       && hook_step "Go files: $(echo "$GO_FILES" | wc -l | tr -d ' ') files"
    $HAS_PORTAL   && hook_step "Portal/Frontend: $(echo "$PORTAL_FILES" | wc -l | tr -d ' ') files"
    $HAS_SDK_TS   && hook_step "SDK TypeScript: $(echo "$SDK_TS_FILES" | wc -l | tr -d ' ') files"
    $HAS_DEPS_JS  && hook_step "JS dependencies changed"
    $HAS_DEPS_GO  && hook_step "Go dependencies changed"
    $HAS_TERRAFORM && hook_step "Terraform: $(echo "$TF_FILES" | wc -l | tr -d ' ') files"
    [ -n "$CODEX_MONITOR_FILES" ] && hook_step "Codex Monitor: $(echo "$CODEX_MONITOR_FILES" | wc -l | tr -d ' ') files"
    $HAS_ONLY_DOCS && hook_step "Docs/workflows/tooling only — skipping code checks"
    echo ""
fi

if $HAS_ONLY_DOCS; then
    hook_header "========================================="
    hook_pass " No code changes — skipping quality gate"
    hook_header "========================================="
    exit 0
fi

# =========================================================================
# DETERMINE WHICH CHECKS TO RUN
# =========================================================================
RUN_GO_VET=false; RUN_GOFMT=false; RUN_GO_LINT=false
RUN_GO_BUILD=false; RUN_GO_TEST=false; RUN_MOD_VENDOR=false
RUN_PRETTIER=false; RUN_PORTAL_LINT=false
RUN_PORTAL_TYPECHECK=false; RUN_PORTAL_TEST=false; RUN_PORTAL_BUILD=false; RUN_PNPM_LOCK=false
RUN_TERRAFORM_FMT=false
RUN_CODEX_MONITOR_SYNTAX=false
RUN_CODEX_MONITOR_TEST=false

# Go checks: Only if .go files or go.mod/sum/work changed
if $HAS_GO || $HAS_DEPS_GO; then
    RUN_GO_VET=true; RUN_GOFMT=true; RUN_GO_LINT=true
    RUN_GO_BUILD=true; RUN_GO_TEST=true
fi
$HAS_DEPS_GO && RUN_MOD_VENDOR=true

# Portal checks: Only if portal/lib files changed OR if portal/lib/sdk package.json changed
# Don't run portal checks just because scripts/codex-monitor or other unrelated packages changed
if $HAS_PORTAL; then
    RUN_PRETTIER=true; RUN_PORTAL_LINT=true
    RUN_PORTAL_TYPECHECK=true; RUN_PORTAL_TEST=true; RUN_PORTAL_BUILD=true
fi

# JS dependency checks: Only if workspace-level or portal-related package files changed
if $HAS_DEPS_JS; then
    # If portal/lib files also changed, we already enabled all portal checks above
    # If ONLY deps changed (no portal file changes), run a limited check
    if ! $HAS_PORTAL; then
        RUN_PNPM_LOCK=true
        # Only run portal linting if root/portal/lib package files changed (not scripts/codex-monitor)
        PORTAL_PKG_FILES=$(echo "$JS_DEP_FILES" | grep -E '^(package\.json|portal/package\.json|lib/.*/package\.json|pnpm-lock\.yaml)' || true)
        if [ -n "$PORTAL_PKG_FILES" ]; then
            hook_step "Portal package files changed — running portal checks"
            RUN_PORTAL_LINT=true
            RUN_PORTAL_TYPECHECK=true
            RUN_PORTAL_TEST=true
        fi
    fi
fi

# Terraform formatting
$HAS_TERRAFORM && RUN_TERRAFORM_FMT=true

# Codex Monitor checks: Only if scripts/codex-monitor changed
if $HAS_CODEX_MONITOR; then
    RUN_CODEX_MONITOR_SYNTAX=true
    RUN_CODEX_MONITOR_TEST=true
fi

for flag in $RUN_GO_VET $RUN_GOFMT $RUN_GO_LINT $RUN_GO_BUILD $RUN_GO_TEST \
            $RUN_MOD_VENDOR $RUN_PRETTIER $RUN_PORTAL_LINT $RUN_PORTAL_TYPECHECK \
            $RUN_PORTAL_TEST $RUN_PORTAL_BUILD $RUN_PNPM_LOCK $RUN_TERRAFORM_FMT \
            $RUN_CODEX_MONITOR_SYNTAX $RUN_CODEX_MONITOR_TEST; do
    $flag && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
done

CHECK_NUM=0
hook_info "Running $TOTAL_CHECKS checks (smart mode)"
echo ""

# =========================================================================
# GIT PUSH REQUIREMENTS CHECK (fast-fail before expensive tests)
# =========================================================================
hook_info "[pre-flight] Checking git push requirements..."
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
if [ -n "$CURRENT_BRANCH" ] && [ "$CURRENT_BRANCH" != "HEAD" ]; then
    REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || echo "")
    if [ -n "$REMOTE_BRANCH" ]; then
        # Check if we're behind the remote (would cause non-fast-forward rejection)
        LOCAL_COMMIT=$(git rev-parse HEAD 2>/dev/null)
        REMOTE_COMMIT=$(git rev-parse "$REMOTE_BRANCH" 2>/dev/null || echo "")
        if [ -n "$REMOTE_COMMIT" ] && [ "$LOCAL_COMMIT" != "$REMOTE_COMMIT" ]; then
            MERGE_BASE=$(git merge-base HEAD "$REMOTE_BRANCH" 2>/dev/null || echo "")
            if [ "$MERGE_BASE" != "$REMOTE_COMMIT" ] && [ "$MERGE_BASE" != "$LOCAL_COMMIT" ]; then
                # Branches have diverged
                BEHIND=$(git rev-list --count HEAD.."$REMOTE_BRANCH" 2>/dev/null || echo "0")
                AHEAD=$(git rev-list --count "$REMOTE_BRANCH"..HEAD 2>/dev/null || echo "0")
                if [ "$BEHIND" != "0" ]; then
                    hook_fail "Branch has diverged: $BEHIND commit(s) behind, $AHEAD commit(s) ahead"
                    hook_fail "Remote: $REMOTE_BRANCH"
                    hook_fail "Push will be rejected (non-fast-forward)"
                    echo ""
                    hook_info "Options:"
                    hook_info "  1. git pull --rebase    # Rebase your commits"
                    hook_info "  2. git pull             # Merge remote changes"
                    hook_info "  3. git push --force     # Force push (dangerous)"
                    hook_info "  4. git push --no-verify # Skip this check"
                    exit 1
                fi
            fi
        fi
    fi
fi
hook_pass "[pre-flight] Git push requirements OK"
echo ""

# =========================================================================
# HELPERS
# =========================================================================
run_check() {
    local name=$1
    local skip_var=$2
    shift 2
    CHECK_NUM=$((CHECK_NUM + 1))

    if [ "${!skip_var:-}" = "1" ]; then
        hook_warn "[$CHECK_NUM/$TOTAL_CHECKS] $name (skipped via $skip_var)"
        SKIPPED=$((SKIPPED + 1))
        return 0
    fi

    hook_info "[$CHECK_NUM/$TOTAL_CHECKS] $name"
    local step_start
    step_start=$(hook_time_start)

    if "$@"; then
        hook_pass "$name passed ($(hook_time_elapsed "$step_start")s)"
        PASSED=$((PASSED + 1))
        return 0
    else
        hook_fail "$name FAILED ($(hook_time_elapsed "$step_start")s)"
        FAILED=$((FAILED + 1))
        return 1
    fi
}

ensure_portal_deps() {
    if [ ! -d "$REPO_ROOT/portal/node_modules" ]; then
        if command -v pnpm >/dev/null 2>&1; then
            hook_step "Installing portal dependencies (first run)..."
            pnpm install --frozen-lockfile 2>&1 || pnpm install 2>&1
        else
            hook_warn "pnpm not available — cannot install portal deps"
            return 1
        fi
    fi
    return 0
}

# =========================================================================
# CODEX MONITOR CHECKS
# =========================================================================
ensure_codex_monitor_deps() {
    local monitor_dir="$REPO_ROOT/scripts/codex-monitor"
    if [ ! -f "$monitor_dir/package.json" ]; then
        hook_warn "Codex Monitor package.json not found — skipping tests"
        return 1
    fi
    if [ ! -d "$monitor_dir/node_modules" ]; then
        if command -v npm >/dev/null 2>&1; then
            hook_step "Installing codex-monitor dependencies..."
            (cd "$monitor_dir" && npm install --ignore-scripts 2>&1)
        else
            hook_warn "npm not available — cannot install codex-monitor deps"
            return 1
        fi
    fi
    return 0
}

check_codex_monitor_syntax() {
    local monitor_dir="$REPO_ROOT/scripts/codex-monitor"
    hook_step "Syntax-checking codex-monitor .mjs files (node --check)..."
    local fail=0
    local checked=0
    for f in "$monitor_dir"/*.mjs; do
        [ -f "$f" ] || continue
        checked=$((checked + 1))
        if ! node --check "$f" 2>&1; then
            hook_fail "Syntax error: $(basename "$f")"
            fail=1
        fi
    done
    hook_step "Checked $checked .mjs files"
    # Also verify ESM import/export linkage for the main entry point.
    # node --check only catches parse errors; missing named exports are
    # module instantiation errors that only surface at import time.
    if [ $fail -eq 0 ]; then
        hook_step "Validating ESM exports (import check)..."
        if ! VITEST=1 node -e "
          import('file://${monitor_dir}/monitor.mjs')
            .then(() => process.exit(0))
            .catch(e => {
              if (e instanceof SyntaxError || /does not provide an export named/.test(e.message)) {
                console.error('ESM linkage error: ' + e.message);
                process.exit(1);
              }
              // Other runtime errors (missing env vars, network, etc.) are OK — we
              // only care about import-time failures here.
              process.exit(0);
            });
        " 2>&1; then
            hook_fail "ESM import validation failed for monitor.mjs"
            fail=1
        fi
    fi

    # Parse-check PowerShell .ps1 files bundled with codex-monitor.
    # PowerShell treats "$var:" as a scope reference, so unescaped colons
    # after variable names cause parser errors that only surface at runtime.
    if [ $fail -eq 0 ] && command -v pwsh >/dev/null 2>&1; then
        hook_step "Syntax-checking .ps1 files (pwsh parser)..."
        local ps1_checked=0
        for f in "$monitor_dir"/*.ps1; do
            [ -f "$f" ] || continue
            ps1_checked=$((ps1_checked + 1))
            local ps1_errors
            ps1_errors=$(pwsh -NoProfile -Command "
                \$tokens = \$null; \$errors = \$null
                [void][System.Management.Automation.Language.Parser]::ParseFile('$f', [ref]\$tokens, [ref]\$errors)
                foreach (\$e in \$errors) {
                    Write-Output ('{0}:{1}:{2} — {3}' -f (Split-Path '$f' -Leaf), \$e.Extent.StartLineNumber, \$e.Extent.StartColumnNumber, \$e.Message)
                }
                if (\$errors.Count -gt 0) { exit 1 } else { exit 0 }
            " 2>&1)
            if [ $? -ne 0 ]; then
                echo "$ps1_errors"
                hook_fail "PS1 syntax error: $(basename "$f")"
                fail=1
            fi
        done
        hook_step "Checked $ps1_checked .ps1 files"
    fi

    return $fail
}

check_codex_monitor_test() {
    if ! ensure_codex_monitor_deps; then
        hook_warn "Cannot run codex-monitor tests — deps not available"
        return 1
    fi
    hook_step "Running codex-monitor tests (vitest)..."
    (cd "$REPO_ROOT/scripts/codex-monitor" && npm test 2>&1)
}

# =========================================================================
# GO CHECKS
# =========================================================================
check_vet() {
    local changed_packages=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_packages=$(git diff --name-only "$BASE_BRANCH" -- '*.go' 2>/dev/null | \
            grep -v '^vendor/' | grep -v '^tests/' | grep -v '^scripts/' | \
            grep -v '^sdk/github.com/virtengine/virtengine/sdk/go/' | \
            xargs -r dirname 2>/dev/null | sort -u | \
            while read -r dir; do [ -d "$dir" ] && echo "./$dir"; done | \
            paste -sd ' ' - 2>/dev/null || echo "")
    fi
    if [ -n "${changed_packages:-}" ]; then
        hook_step "Vetting $(echo "$changed_packages" | wc -w | tr -d ' ') changed packages"
        # shellcheck disable=SC2086
        go vet $changed_packages 2>&1
    else
        go vet $(go list ./... 2>/dev/null | grep -v '/tests/' | grep -v '/scripts/' | grep -Ev '/temp($|/)' | head -100) 2>&1
    fi
}

check_gofmt() {
    local changed_files=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_files=$(git diff --name-only "$BASE_BRANCH" -- '*.go' 2>/dev/null | \
            grep -v '^vendor/' | grep -v '^tests/' | \
            while read -r f; do [ -f "$f" ] && echo "$f"; done || true)
    fi
    if [ -z "${changed_files:-}" ]; then
        hook_step "No Go files changed"
        return 0
    fi
    local unformatted
    # shellcheck disable=SC2086
    unformatted=$(gofmt -l $changed_files 2>/dev/null || true)
    if [ -n "$unformatted" ]; then
        hook_step "Auto-formatting $(echo "$unformatted" | wc -l | tr -d ' ') file(s)..."
        for file in $unformatted; do
            [ -f "$file" ] || continue
            gofmt -w "$file"
            hook_step "Formatted: $file"
        done
        # shellcheck disable=SC2086
        git add $unformatted
        git commit --amend --no-edit --no-verify
        hook_pass "Auto-formatted and amended commit"
    fi
    return 0
}

check_lint() {
    local lint_bin=""
    if command -v golangci-lint &>/dev/null; then
        lint_bin="golangci-lint"
    elif [ -x "$REPO_ROOT/.cache/bin/golangci-lint" ]; then
        lint_bin="$REPO_ROOT/.cache/bin/golangci-lint"
    elif [ -x "$HOME/go/bin/golangci-lint" ]; then
        lint_bin="$HOME/go/bin/golangci-lint"
    fi
    if [ -z "$lint_bin" ]; then
        hook_warn "golangci-lint not found"
        hook_fail "golangci-lint is required"
        return 1
    fi
    local lint_version
    lint_version=$($lint_bin version 2>&1 | head -1 || echo "unknown")
    hook_step "Using: $lint_bin ($lint_version)"
    export GOLANGCI_LINT_CACHE="$REPO_ROOT/.cache/golangci-lint"
    mkdir -p "$GOLANGCI_LINT_CACHE"
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        hook_step "Linting changes since $BASE_BRANCH"
        $lint_bin run --timeout=10m --allow-parallel-runners --new-from-rev="$BASE_BRANCH" 2>&1
    else
        $lint_bin run --timeout=10m --allow-parallel-runners 2>&1
    fi
}

check_mod_vendor() {
    local vendor_cmd="go mod vendor"
    if [ -f "$REPO_ROOT/go.work" ] && [ "${GOWORK:-}" != "off" ]; then
        vendor_cmd="go work vendor"
    fi
    if [ -f vendor/modules.txt ]; then
        if [ "$vendor_cmd" = "go work vendor" ]; then
            hook_step "Workspace mode — vendor sync skipped"
            return 0
        fi
        if go list -mod=vendor ./... >/dev/null 2>&1; then
            hook_step "Vendor directory already in sync"
            return 0
        fi
    fi
    hook_step "Syncing vendor directory..."
    $vendor_cmd 2>&1
}

check_build() {
    if make bins 2>&1; then
        return 0
    fi
    hook_warn "make bins failed, trying direct go build..."
    go build ./cmd/... ./sdk/go/... 2>&1
}

check_test_go() {
    local go_timeout="180s"
    local parallel_limit=4
    local changed_packages=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_packages=$(git diff --name-only "$BASE_BRANCH" -- '*.go' 2>/dev/null | \
            grep -v '_test\.go$' | grep -v '^vendor/' | grep -v '^tests/' | grep -v '^scripts/' | \
            grep -v '^sdk/github.com/virtengine/virtengine/sdk/go/' | \
            xargs -r dirname 2>/dev/null | sort -u | \
            while read -r dir; do [ -d "$dir" ] && echo "./$dir"; done | \
            paste -sd ' ' - 2>/dev/null || echo "")
    fi
    local test_args="-short -timeout $go_timeout -failfast -p $parallel_limit -count=1"
    if [ -n "${changed_packages:-}" ]; then
        local pkg_count
        pkg_count=$(echo "$changed_packages" | wc -w | tr -d ' ')
        hook_step "Testing $pkg_count changed Go packages"
        # shellcheck disable=SC2086
        go test $test_args $changed_packages 2>&1
        return $?
    else
        hook_step "Testing fast packages (no specific changes detected)"
        local test_packages
        test_packages=$(go list ./x/... ./pkg/... 2>/dev/null | \
            grep -v '/tests/' | grep -v '/scripts/' | grep -v '/e2e' | \
            grep -v '/integration' | grep -v '/chaos' | grep -v '/simulation' | \
            head -50 || echo "")
        if [ -z "$test_packages" ]; then
            hook_step "No testable packages found"
            return 0
        fi
        echo "$test_packages" | xargs go test $test_args 2>&1
        return $?
    fi
}

# =========================================================================
# PORTAL / FRONTEND CHECKS
# =========================================================================
check_prettier() {
    local changed_files=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_files=$(git diff --name-only "$BASE_BRANCH" -- \
            'portal/src/**/*.ts' 'portal/src/**/*.tsx' 'portal/src/**/*.js' 'portal/src/**/*.jsx' \
            'portal/src/**/*.css' 'portal/src/**/*.json' 'portal/src/**/*.md' \
            'lib/portal/src/**/*.ts' 'lib/portal/src/**/*.tsx' 2>/dev/null | \
            while read -r f; do [ -f "$f" ] && echo "$f"; done || true)
    fi
    if [ -z "${changed_files:-}" ]; then
        hook_step "No Portal files to format"
        return 0
    fi
    if ! ensure_portal_deps; then
        hook_fail "Portal dependencies not available — cannot run prettier"
        return 1
    fi
    local unformatted=""
    for file in $changed_files; do
        [ -f "$file" ] || continue
        if ! pnpm -C portal exec prettier --check "$REPO_ROOT/$file" >/dev/null 2>&1; then
            unformatted="$unformatted $file"
        fi
    done
    unformatted=$(echo "$unformatted" | xargs)
    if [ -n "$unformatted" ]; then
        hook_step "Auto-formatting $(echo "$unformatted" | wc -w | tr -d ' ') Portal file(s)..."
        for file in $unformatted; do
            [ -f "$file" ] || continue
            pnpm -C portal exec prettier --write "$REPO_ROOT/$file" >/dev/null 2>&1
            hook_step "Formatted: $file"
        done
        # shellcheck disable=SC2086
        git add $unformatted
        git commit --amend --no-edit --no-verify
        hook_pass "Auto-formatted Portal files and amended commit"
    fi
    return 0
}

check_portal_lint() {
    if ! ensure_portal_deps; then
        hook_warn "Cannot run portal lint — deps not available"
        return 1
    fi
    hook_step "Running ESLint on portal (next lint)..."
    (cd "$REPO_ROOT/portal" && pnpm lint -- --max-warnings=0 2>&1)
}

check_portal_typecheck() {
    if ! ensure_portal_deps; then
        hook_warn "Cannot run portal type-check — deps not available"
        return 1
    fi
    hook_step "Running TypeScript type-check (tsc --noEmit)..."
    (cd "$REPO_ROOT/portal" && pnpm type-check 2>&1)
}

check_portal_test() {
    if ! ensure_portal_deps; then
        hook_warn "Cannot run portal tests — deps not available"
        return 1
    fi
    local exit_code=0
    if echo "$CHANGED_FILES" | grep -qE '^lib/portal/'; then
        hook_step "Testing lib/portal..."
        if ! (cd "$REPO_ROOT/lib/portal" && pnpm test 2>&1); then
            exit_code=1
        fi
    fi
    if echo "$CHANGED_FILES" | grep -qE '^portal/'; then
        hook_step "Testing portal app..."
        if ! (cd "$REPO_ROOT/portal" && pnpm test 2>&1); then
            exit_code=1
        fi
    fi
    # If only JS deps changed, test both
    if ! echo "$CHANGED_FILES" | grep -qE '^(portal|lib/portal)/'; then
        hook_step "JS deps changed — testing portal + lib/portal..."
        (cd "$REPO_ROOT/lib/portal" && pnpm test 2>&1) || exit_code=1
        (cd "$REPO_ROOT/portal" && pnpm test 2>&1) || exit_code=1
    fi
    return $exit_code
}

check_portal_build() {
    if ! ensure_portal_deps; then
        hook_warn "Cannot run portal build — deps not available"
        return 1
    fi
    hook_step "Running portal build (Next.js)..."
    (cd "$REPO_ROOT/portal" && pnpm build 2>&1)
}

check_pnpm_lock() {
    local changed_files=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_files=$(git diff --name-only "$BASE_BRANCH" -- 'pnpm-lock.yaml' '**/package.json' '**/package-lock.json' 2>/dev/null || true)
    fi
    if [ -z "${changed_files:-}" ]; then
        hook_step "No JS dependency files changed"
        return 0
    fi
    if ! command -v pnpm >/dev/null 2>&1; then
        hook_warn "pnpm not found; skipping lockfile check"
        return 0
    fi
    hook_step "Validating pnpm lockfile"
    pnpm install --frozen-lockfile 2>&1
}

# =========================================================================
# TERRAFORM CHECKS
# =========================================================================
check_terraform_fmt() {
    local changed_files=""
    if git rev-parse --verify "$BASE_BRANCH" &>/dev/null; then
        changed_files=$(git diff --name-only "$BASE_BRANCH" -- 'infra/terraform/**/*.tf' 2>/dev/null || true)
    fi
    if [ -z "${changed_files:-}" ]; then
        hook_step "No Terraform files to format"
        return 0
    fi
    if ! command -v terraform >/dev/null 2>&1; then
        hook_fail "terraform not found — install Terraform to auto-format"
        return 1
    fi

    local fmt_dirs
    fmt_dirs=$(echo "$changed_files" | xargs -n1 dirname | sort -u | tr '\n' ' ')
    hook_step "Formatting Terraform files..."
    for dir in $fmt_dirs; do
        [ -d "$dir" ] || continue
        terraform fmt -recursive "$dir" >/dev/null 2>&1
    done

    if ! git diff --quiet -- $changed_files 2>/dev/null; then
        # shellcheck disable=SC2086
        git add $changed_files
        git commit --amend --no-edit --no-verify
        hook_pass "Auto-formatted Terraform files and amended commit"
    fi
    return 0
}

# =========================================================================
# RUN CHECKS
# =========================================================================
if [ "${VE_HOOK_QUICK:-}" = "1" ]; then
    TOTAL_CHECKS=0
    $RUN_GO_VET && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    $RUN_GO_BUILD && TOTAL_CHECKS=$((TOTAL_CHECKS + 1))
    $RUN_GO_VET && { run_check "go vet" VE_HOOK_SKIP_VET check_vet || true; }
    $RUN_GO_BUILD && { run_check "Build binaries" VE_HOOK_SKIP_BUILD check_build || true; }
    [ "$TOTAL_CHECKS" -eq 0 ] && hook_pass "Quick mode: no relevant files changed"
else
    # === Go checks ===
    $RUN_GO_VET     && { run_check "go vet" VE_HOOK_SKIP_VET check_vet || true; }
    $RUN_GOFMT      && { run_check "gofmt" VE_HOOK_SKIP_FMT check_gofmt || true; }
    $RUN_MOD_VENDOR  && { run_check "go mod vendor" VE_HOOK_SKIP_MOD check_mod_vendor || true; }
    $RUN_GO_LINT    && { run_check "golangci-lint" VE_HOOK_SKIP_LINT check_lint || true; }
    $RUN_GO_BUILD   && { run_check "Build binaries" VE_HOOK_SKIP_BUILD check_build || true; }
    $RUN_GO_TEST    && { run_check "Go unit tests" VE_HOOK_SKIP_TEST check_test_go || true; }
    # === Portal / Frontend checks ===
    $RUN_PRETTIER       && { run_check "prettier (portal)" VE_HOOK_SKIP_FMT check_prettier || true; }
    $RUN_PORTAL_LINT    && { run_check "Portal ESLint" VE_HOOK_SKIP_PORTAL check_portal_lint || true; }
    $RUN_PORTAL_TYPECHECK && { run_check "Portal TypeScript" VE_HOOK_SKIP_PORTAL check_portal_typecheck || true; }
    $RUN_PORTAL_TEST    && { run_check "Portal tests" VE_HOOK_SKIP_PORTAL check_portal_test || true; }
    $RUN_PORTAL_BUILD   && { run_check "Portal build" VE_HOOK_SKIP_PORTAL check_portal_build || true; }
    # === JS dependency checks ===
    $RUN_PNPM_LOCK  && { run_check "pnpm lockfile" VE_HOOK_SKIP_PNPM check_pnpm_lock || true; }
    # === Codex Monitor checks ===
    $RUN_CODEX_MONITOR_SYNTAX && { run_check "Codex Monitor syntax" VE_HOOK_SKIP_CODEX_MONITOR check_codex_monitor_syntax || true; }
    $RUN_CODEX_MONITOR_TEST && { run_check "Codex Monitor tests" VE_HOOK_SKIP_CODEX_MONITOR check_codex_monitor_test || true; }
    # === Terraform formatting ===
    $RUN_TERRAFORM_FMT && { run_check "terraform fmt" VE_HOOK_SKIP_TF check_terraform_fmt || true; }
fi

# =========================================================================
# Summary
# =========================================================================
TOTAL_ELAPSED=$(hook_time_elapsed "$TOTAL_START")
echo ""

TOTAL_RAN=$((PASSED + FAILED))
if [ "$TOTAL_RAN" -eq 0 ] && [ "$SKIPPED" -eq 0 ]; then
    hook_header "========================================="
    hook_pass " No relevant checks for changed files (${TOTAL_ELAPSED}s)"
    hook_header "========================================="
    exit 0
fi

if [ "$FAILED" -gt 0 ]; then
    hook_header "========================================="
    hook_fail " $FAILED of $TOTAL_RAN checks FAILED (${TOTAL_ELAPSED}s)"
    [ "$SKIPPED" -gt 0 ] && hook_warn " $SKIPPED checks skipped"
    hook_header "========================================="
    echo ""
    hook_fail "Fix the errors above, then try again."
    hook_info "Bypass:       git push --no-verify"
    hook_info "Quick mode:   VE_HOOK_QUICK=1 git push"
    hook_info "Skip one:     VE_HOOK_SKIP_LINT=1 git push"
    hook_info "Skip portal:  VE_HOOK_SKIP_PORTAL=1 git push"
    exit 1
else
    hook_header "========================================="
    hook_pass " All $PASSED checks passed (${TOTAL_ELAPSED}s)"
    [ "$SKIPPED" -gt 0 ] && hook_warn " $SKIPPED checks skipped"
    hook_header "========================================="
    exit 0
fi
