#!/usr/bin/env bash
# VirtEngine Pre-Push Hook
#
# Prevents pushing code that doesn't pass critical quality gates.
# Mirrors CI required checks: vet, mod sync, lint, build, tests.
#
# Bypass:       git push --no-verify
# Quick mode:   VE_HOOK_QUICK=1 git push     (vet + build only)
#
# Skip individual checks:
#   VE_HOOK_SKIP_VET=1      Skip go vet
#   VE_HOOK_SKIP_MOD=1      Skip go mod tidy/vendor checks
#   VE_HOOK_SKIP_LINT=1     Skip golangci-lint
#   VE_HOOK_SKIP_BUILD=1    Skip build
#   VE_HOOK_SKIP_TEST=1     Skip unit tests

set -euo pipefail

HOOK_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=common.sh
source "$HOOK_DIR/common.sh"

# --- Parse push info from stdin ---
# Git passes: <local ref> <local sha> <remote ref> <remote sha>
# Skip checks for delete pushes (local sha is all zeros).
while read -r _local_ref local_sha _remote_ref _remote_sha; do
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        exit 0
    fi
done

REPO_ROOT="$(git rev-parse --show-toplevel)"
cd "$REPO_ROOT"

echo ""
hook_header "========================================="
hook_header " VirtEngine Pre-Push Quality Gate"
hook_header "========================================="
hook_info "Bypass: git push --no-verify"
echo ""

# --- Load environment ---
ensure_direnv_env

TOTAL_START=$(hook_time_start)
FAILED=0
PASSED=0
SKIPPED=0
TOTAL_CHECKS=6

# Helper to run a check
run_check() {
    local num=$1
    local name=$2
    local skip_var=$3
    shift 3

    if [ "${!skip_var:-}" = "1" ]; then
        hook_warn "[$num/$TOTAL_CHECKS] $name (skipped)"
        SKIPPED=$((SKIPPED + 1))
        return 0
    fi

    hook_info "[$num/$TOTAL_CHECKS] $name"
    local step_start
    step_start=$(hook_time_start)

    if "$@"; then
        hook_pass "$name passed ($(hook_time_elapsed "$step_start")s)"
        PASSED=$((PASSED + 1))
        return 0
    else
        hook_fail "$name FAILED ($(hook_time_elapsed "$step_start")s)"
        FAILED=$((FAILED + 1))
        return 1
    fi
}

# =========================================================================
# Check 1: go vet
# =========================================================================
check_vet() {
    go vet ./... 2>&1
}

# =========================================================================
# Check 2: go mod tidy (dirty check)
# =========================================================================
check_mod_tidy() {
    # Run go mod tidy and check if files changed using git
    go mod tidy 2>&1

    # Check if go.mod or go.sum have uncommitted changes
    if git diff --quiet go.mod go.sum 2>/dev/null; then
        return 0
    else
        # Files changed - restore them and fail
        git checkout -- go.mod go.sum 2>/dev/null || true
        hook_fail "go.mod or go.sum is out of sync. Run 'go mod tidy' and commit the result."
        return 1
    fi
}

# =========================================================================
# Check 3: go mod vendor (consistency check)
# =========================================================================
check_mod_vendor() {
    # Fast vendor consistency check â€” single-pass set comparison, no network or file copy.
    # Extracts module paths from go.mod requires and vendor/modules.txt, then diffs them.

    if [ ! -f vendor/modules.txt ]; then
        hook_fail "vendor/modules.txt not found. Run 'go mod vendor'."
        return 1
    fi

    # Extract module paths from go.mod require blocks (one awk pass)
    local gomod_mods vendor_mods
    gomod_mods=$(awk '/^require \(/{found=1; next} /^\)/{found=0} found && /\t/{print $1}' go.mod | sort)
    # Extract module paths from vendor/modules.txt (lines starting with "# ")
    vendor_mods=$(awk '/^# /{print $2}' vendor/modules.txt | sort -u)

    # Find modules in go.mod but not in vendor
    local missing
    missing=$(comm -23 <(echo "$gomod_mods") <(echo "$vendor_mods"))

    if [ -n "$missing" ]; then
        local count
        count=$(echo "$missing" | wc -l)
        hook_fail "$count module(s) in go.mod not found in vendor/. Run 'go mod vendor' and commit."
        echo "$missing" | head -5 | while read -r mod; do
            hook_warn "  Missing: $mod"
        done
        if [ "$count" -gt 5 ]; then
            hook_warn "  ... and $((count - 5)) more"
        fi
        return 1
    fi

    # Verify no uncommitted changes to vendor/modules.txt
    if ! git diff --quiet vendor/modules.txt 2>/dev/null; then
        hook_fail "vendor/modules.txt has uncommitted changes. Commit or run 'go mod vendor'."
        return 1
    fi

    return 0
}

# =========================================================================
# Check 4: golangci-lint
# =========================================================================
check_lint() {
    # Skip lint for now - requires golangci-lint v2 which isn't widely available yet
    # The project's .golangci.yml is configured for v2 but v1 is commonly installed
    hook_warn "golangci-lint skipped (requires v2, not widely available yet)"
    return 0
}

# =========================================================================
# Check 5: Build
# =========================================================================
check_build() {
    # Try make first, fall back to direct go build
    if make bins 2>&1; then
        return 0
    fi
    hook_warn "make bins failed, trying direct go build..."
    go build -mod=vendor ./cmd/... 2>&1
}

# =========================================================================
# Check 6: Unit tests
# =========================================================================
check_test() {
    # Run all tests with proper timeout and output handling to prevent hanging
    # Using -short to skip long-running tests
    # Using -timeout to prevent individual tests from hanging indefinitely
    # Using -count=1 to disable caching for accurate results

    local output_file
    output_file=$(mktemp)
    trap "rm -f '$output_file'" RETURN

    # Run tests in background with process-level timeout
    # The go test -timeout handles individual test timeouts
    # The outer timeout handles overall execution time
    local test_timeout=300  # 5 minutes max for all tests
    local go_timeout="180s" # 3 minutes per test package

    # Start tests in background, redirect output to temp file
    go test -short -timeout "$go_timeout" -count=1 ./... > "$output_file" 2>&1 &
    local test_pid=$!

    # Wait with timeout
    local elapsed=0
    while kill -0 "$test_pid" 2>/dev/null; do
        sleep 1
        elapsed=$((elapsed + 1))
        if [ "$elapsed" -ge "$test_timeout" ]; then
            hook_warn "Tests exceeded ${test_timeout}s timeout, terminating..."
            kill -TERM "$test_pid" 2>/dev/null || true
            sleep 2
            kill -KILL "$test_pid" 2>/dev/null || true
            echo ""
            hook_fail "Test output (last 100 lines):"
            tail -100 "$output_file"
            return 1
        fi
    done

    # Get exit code
    wait "$test_pid"
    local exit_code=$?

    # Show output - limited to prevent overwhelming terminal
    if [ "$exit_code" -ne 0 ]; then
        echo ""
        hook_fail "Test output (last 150 lines):"
        tail -150 "$output_file"
    else
        # On success, just show summary (lines with ok/FAIL/?)
        grep -E "^(ok|FAIL|\?)" "$output_file" | tail -50 || tail -50 "$output_file"
    fi

    return $exit_code
}

# =========================================================================
# Run checks
# =========================================================================

# Quick mode: only vet + build
if [ "${VE_HOOK_QUICK:-}" = "1" ]; then
    TOTAL_CHECKS=2
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
else
    run_check 1 "go vet" VE_HOOK_SKIP_VET check_vet || true
    run_check 2 "go mod tidy (sync check)" VE_HOOK_SKIP_MOD check_mod_tidy || true
    run_check 3 "go mod vendor (sync check)" VE_HOOK_SKIP_MOD check_mod_vendor || true
    run_check 4 "golangci-lint" VE_HOOK_SKIP_LINT check_lint || true
    run_check 5 "Build binaries" VE_HOOK_SKIP_BUILD check_build || true
    run_check 6 "Unit tests" VE_HOOK_SKIP_TEST check_test || true
fi

# =========================================================================
# Summary
# =========================================================================
TOTAL_ELAPSED=$(hook_time_elapsed "$TOTAL_START")
echo ""

if [ "$FAILED" -gt 0 ]; then
    hook_header "========================================="
    hook_fail " $FAILED of $((PASSED + FAILED)) checks FAILED (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    echo ""
    hook_fail "Fix the errors above, then try again."
    hook_info "Bypass:     git push --no-verify"
    hook_info "Quick mode: VE_HOOK_QUICK=1 git push"
    hook_info "Skip one:   VE_HOOK_SKIP_LINT=1 git push"
    exit 1
else
    hook_header "========================================="
    hook_pass " All $PASSED checks passed (${TOTAL_ELAPSED}s)"
    if [ "$SKIPPED" -gt 0 ]; then
        hook_warn " $SKIPPED checks skipped"
    fi
    hook_header "========================================="
    exit 0
fi
