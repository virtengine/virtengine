# VirtEngine Infrastructure CI/CD

name: Infrastructure
permissions:
  contents: read

on:
  push:
    branches:
      - main
      - 'release/**'
    paths:
      - 'infra/**'
      - 'deploy/**'
      - '.github/workflows/infrastructure.yml'
  pull_request:
    branches:
      - main
    paths:
      - 'infra/**'
      - 'deploy/**'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        type: choice
        options:
          - dev
          - staging
          - prod
      action:
        description: 'Action to perform'
        required: true
        type: choice
        options:
          - plan
          - apply
          - destroy

env:
  TF_VERSION: '1.6.6'
  TERRAGRUNT_VERSION: '0.54.8'
  AWS_REGION: 'us-east-1'
  GOWORK: 'off'  # Disable workspace mode for infra tests

jobs:
  # ============================================================================
  # Validation
  # ============================================================================
  validate:
    name: Validate
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Terraform Format Check
        run: |
          cd infra/terraform
          # Run terraform fmt and show diffs
          terraform fmt -recursive -diff
          # Check if any files changed
          if ! git diff --quiet; then
            echo "::error::Terraform files need formatting. Run 'terraform fmt -recursive' and commit."
            git diff --stat
            exit 1
          fi
          echo "✅ Terraform files are properly formatted"

      - name: Validate Terraform Modules
        run: |
          for module in infra/terraform/modules/*/; do
            echo "Validating $module"
            cd "$module"
            if grep -R "configuration_aliases" -n . >/dev/null 2>&1 || grep -R "provider = aws\\." -n . >/dev/null 2>&1; then
              cat > .ci-providers.tf <<'EOF'
provider "aws" {
  region = "us-east-1"
}

provider "aws" {
  alias  = "primary"
  region = "us-east-1"
}

provider "aws" {
  alias  = "secondary"
  region = "us-west-2"
}

provider "aws" {
  alias  = "tertiary"
  region = "us-west-1"
}
EOF
            fi
            terraform init -backend=false
            terraform validate
            rm -f .ci-providers.tf
            cd -
          done

      - name: Collect Kubernetes manifests
        id: k8s-manifests
        run: |
          {
            echo "files<<EOF"
            if [ -d deploy/kubernetes/base ]; then
              find deploy/kubernetes/base -maxdepth 1 -name '*.yaml' -print
            fi
            if [ -d deploy/kubernetes/overlays ]; then
              find deploy/kubernetes/overlays -name '*.yaml' -print
            fi
            if [ -d deploy/argocd ]; then
              find deploy/argocd -name '*.yaml' -print
            fi
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

      - name: Install kubeval
        run: |
          KUBEVAL_VERSION=0.16.1
          curl -sSL -o kubeval.tar.gz https://github.com/instrumenta/kubeval/releases/download/v${KUBEVAL_VERSION}/kubeval-linux-amd64.tar.gz
          tar -xzf kubeval.tar.gz
          sudo mv kubeval /usr/local/bin/kubeval

      - name: Lint Kubernetes Manifests
        run: |
          files="${{ steps.k8s-manifests.outputs.files }}"
          if [ -z "$files" ]; then
            echo "No Kubernetes manifests found to lint."
            exit 0
          fi
          echo "$files" | xargs -r kubeval \
            --kubernetes-version 1.29.0 \
            --schema-location https://raw.githubusercontent.com/yannh/kubernetes-json-schema/master \
            --ignore-missing-schemas

  # ============================================================================
  # Security Scanning
  # NOTE: This job always runs for static analysis (no credentials needed)
  # ============================================================================
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: validate
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Checkov
        uses: bridgecrewio/checkov-action@v12
        with:
          directory: infra/terraform
          framework: terraform
          output_format: sarif
          output_file_path: checkov-results.sarif
          soft_fail: true

      - name: Upload Checkov Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: checkov-results.sarif

      - name: Run Trivy on Kubernetes Manifests
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'config'
          scan-ref: 'deploy/kubernetes'
          format: 'sarif'
          output: 'trivy-k8s-results.sarif'

      - name: Upload Trivy Results
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        continue-on-error: true
        with:
          sarif_file: trivy-k8s-results.sarif

  # ============================================================================
  # Check AWS Credentials Availability
  # ============================================================================
  check-credentials:
    name: Check AWS Credentials
    runs-on: ubuntu-latest
    outputs:
      aws-available: ${{ steps.check.outputs.available }}
    steps:
      - name: Check if AWS credentials are configured
        id: check
        run: |
          # Check if required secrets are available (they won't be visible, but we can check if they exist)
          # For now, we'll assume credentials are only available for workflow_dispatch events
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "available=true" >> "$GITHUB_OUTPUT"
            echo "✅ Running in workflow_dispatch mode - AWS credentials expected"
          else
            echo "available=false" >> "$GITHUB_OUTPUT"
            echo "⏭️  Skipping AWS operations - use workflow_dispatch to deploy infrastructure"
          fi

  # ============================================================================
  # Terraform Plan (Requires AWS Credentials)
  # ============================================================================
  plan:
    name: Plan (${{ matrix.environment }})
    runs-on: ubuntu-latest
    needs: [validate, security, check-credentials]
    if: |
      needs.check-credentials.outputs.aws-available == 'true' &&
      (github.event_name == 'pull_request' || (github.event_name == 'workflow_dispatch' && github.event.inputs.action == 'plan'))
    strategy:
      matrix:
        environment: [dev, staging, prod]
    environment:
      name: ${{ matrix.environment }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup Terragrunt
        run: |
          curl -Lo terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Terragrunt Plan
        run: |
          cd infra/terraform/environments/${{ matrix.environment }}
          terragrunt plan -out=tfplan -no-color 2>&1 | tee plan.txt

      - name: Upload Plan
        uses: actions/upload-artifact@v4
        with:
          name: tfplan-${{ matrix.environment }}
          path: infra/terraform/environments/${{ matrix.environment }}/tfplan

      - name: Comment PR with Plan
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('infra/terraform/environments/${{ matrix.environment }}/plan.txt', 'utf8');
            const truncatedPlan = plan.length > 65000 ? plan.substring(0, 65000) + '\n...(truncated)' : plan;
            
            github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## Terraform Plan - ${{ matrix.environment }}\n\n\`\`\`hcl\n${truncatedPlan}\n\`\`\``
            });

  # ============================================================================
  # Terraform Apply - Dev (Requires AWS Credentials via workflow_dispatch)
  # ============================================================================
  apply-dev:
    name: Apply (dev)
    runs-on: ubuntu-latest
    needs: [validate, security, check-credentials]
    if: |
      needs.check-credentials.outputs.aws-available == 'true' &&
      github.ref == 'refs/heads/main' &&
      github.event_name == 'workflow_dispatch'
    environment:
      name: dev
      url: https://dev.virtengine.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup Terragrunt
        run: |
          curl -Lo terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Terragrunt Apply
        run: |
          cd infra/terraform/environments/dev
          terragrunt apply -auto-approve

  # ============================================================================
  # Terraform Apply - Staging (Manual via workflow_dispatch)
  # ============================================================================
  apply-staging:
    name: Apply (staging)
    runs-on: ubuntu-latest
    needs: [apply-dev, check-credentials]
    if: |
      needs.check-credentials.outputs.aws-available == 'true' &&
      github.event_name == 'workflow_dispatch' &&
      github.event.inputs.environment == 'staging'
    environment:
      name: staging
      url: https://staging.virtengine.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup Terragrunt
        run: |
          curl -Lo terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Terragrunt Apply
        run: |
          cd infra/terraform/environments/staging
          terragrunt apply -auto-approve

  # ============================================================================
  # Terraform Apply - Production (Manual)
  # ============================================================================
  apply-prod:
    name: Apply (prod)
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'prod' && github.event.inputs.action == 'apply'
    environment:
      name: prod
      url: https://virtengine.io
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TF_VERSION }}

      - name: Setup Terragrunt
        run: |
          curl -Lo terragrunt https://github.com/gruntwork-io/terragrunt/releases/download/v${{ env.TERRAGRUNT_VERSION }}/terragrunt_linux_amd64
          chmod +x terragrunt
          sudo mv terragrunt /usr/local/bin/

      - name: Terragrunt Plan
        run: |
          cd infra/terraform/environments/prod
          terragrunt plan -out=tfplan

      - name: Terragrunt Apply
        run: |
          cd infra/terraform/environments/prod
          terragrunt apply tfplan

  # ============================================================================
  # ArgoCD Sync
  # ============================================================================
  argocd-sync:
    name: ArgoCD Sync
    runs-on: ubuntu-latest
    needs: [apply-dev, apply-staging]
    if: always() && (needs.apply-dev.result == 'success' || needs.apply-staging.result == 'success')
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install ArgoCD CLI
        run: |
          curl -sSL -o argocd https://github.com/argoproj/argo-cd/releases/download/v2.10.0/argocd-linux-amd64
          chmod +x argocd
          sudo mv argocd /usr/local/bin/

      - name: Login to ArgoCD
        run: |
          argocd login ${{ secrets.ARGOCD_SERVER }} \
            --username admin \
            --password ${{ secrets.ARGOCD_PASSWORD }} \
            --insecure

      - name: Sync Applications
        run: |
          # Determine environment from trigger
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            ENV="dev"
          elif [[ "${{ github.ref }}" == refs/heads/release/* ]]; then
            ENV="staging"
          fi
          
          # Sync all applications for the environment
          for app in virtengine provider-daemon monitoring; do
            argocd app sync ${app}-${ENV} --prune || true
          done

  # ============================================================================
  # Infrastructure Tests (Skipped if AWS credentials not available)
  # ============================================================================
  test:
    name: Infrastructure Tests
    runs-on: ubuntu-latest
    needs: check-credentials
    if: |
      github.event_name == 'pull_request' &&
      needs.check-credentials.outputs.aws-available == 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.25.5'

      - name: Run Terratest
        run: |
          cd infra/tests
          go test -v -timeout 30m -short
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_DEFAULT_REGION: ${{ env.AWS_REGION }}
