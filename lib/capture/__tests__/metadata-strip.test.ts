/**
 * Metadata Strip Tests
 * VE-210: Unit tests for EXIF/GPS metadata removal
 */

import { describe, it, expect } from 'vitest';
import { stripMetadata, hasMetadata } from '../utils/metadata-strip';

describe('metadata-strip', () => {
  /**
   * Helper to create a minimal JPEG blob
   */
  function createMinimalJpeg(): Blob {
    // Minimal valid JPEG: SOI + APP0 + DQT + SOF + DHT + SOS + EOI
    // This is a simplified JPEG structure for testing
    const bytes = new Uint8Array([
      // SOI (Start of Image)
      0xff, 0xd8,
      // APP0 (JFIF marker - should be kept)
      0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00,
      0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
      // DQT (Define Quantization Table)
      0xff, 0xdb, 0x00, 0x43, 0x00,
      ...new Array(64).fill(0x10),
      // SOF0 (Start of Frame)
      0xff, 0xc0, 0x00, 0x0b, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00,
      // DHT (Define Huffman Table)
      0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
      0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
      // SOS (Start of Scan) - minimal
      0xff, 0xda, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3f, 0x00,
      // Some scan data
      0x00,
      // EOI (End of Image)
      0xff, 0xd9,
    ]);

    return new Blob([bytes], { type: 'image/jpeg' });
  }

  /**
   * Helper to create a JPEG with EXIF data
   */
  function createJpegWithExif(): Blob {
    const bytes = new Uint8Array([
      // SOI
      0xff, 0xd8,
      // APP0 (JFIF - should be kept)
      0xff, 0xe0, 0x00, 0x10, 0x4a, 0x46, 0x49, 0x46, 0x00, 0x01, 0x01, 0x00,
      0x00, 0x01, 0x00, 0x01, 0x00, 0x00,
      // APP1 (EXIF - should be REMOVED)
      0xff, 0xe1, 0x00, 0x16, 0x45, 0x78, 0x69, 0x66, 0x00, 0x00, // "Exif\0\0"
      0x4d, 0x4d, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00,
      // APP13 (IPTC - should be REMOVED)
      0xff, 0xed, 0x00, 0x0c, 0x50, 0x68, 0x6f, 0x74, 0x6f, 0x73, 0x68, 0x6f, 0x70, 0x00,
      // COM (Comment - should be REMOVED)
      0xff, 0xfe, 0x00, 0x0d, 0x54, 0x65, 0x73, 0x74, 0x20, 0x43, 0x6f, 0x6d, 0x6d, 0x65, 0x6e,
      // DQT
      0xff, 0xdb, 0x00, 0x43, 0x00,
      ...new Array(64).fill(0x10),
      // SOF0
      0xff, 0xc0, 0x00, 0x0b, 0x08, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x11, 0x00,
      // DHT
      0xff, 0xc4, 0x00, 0x1f, 0x00, 0x00, 0x01, 0x05, 0x01, 0x01, 0x01, 0x01,
      0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02,
      0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b,
      // SOS
      0xff, 0xda, 0x00, 0x08, 0x01, 0x01, 0x00, 0x00, 0x3f, 0x00,
      0x00,
      // EOI
      0xff, 0xd9,
    ]);

    return new Blob([bytes], { type: 'image/jpeg' });
  }

  /**
   * Helper to create a minimal PNG
   */
  function createMinimalPng(): Blob {
    const bytes = new Uint8Array([
      // PNG signature
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
      // IHDR chunk
      0x00, 0x00, 0x00, 0x0d, // length
      0x49, 0x48, 0x44, 0x52, // type "IHDR"
      0x00, 0x00, 0x00, 0x01, // width
      0x00, 0x00, 0x00, 0x01, // height
      0x08, 0x02, // bit depth, color type
      0x00, 0x00, 0x00, // compression, filter, interlace
      0x90, 0x77, 0x53, 0xde, // CRC
      // IDAT chunk (minimal)
      0x00, 0x00, 0x00, 0x0c, // length
      0x49, 0x44, 0x41, 0x54, // type "IDAT"
      0x08, 0xd7, 0x63, 0xf8, 0xff, 0xff, 0xff, 0x00,
      0x05, 0xfe, 0x02, 0xfe, // CRC
      // IEND chunk
      0x00, 0x00, 0x00, 0x00, // length
      0x49, 0x45, 0x4e, 0x44, // type "IEND"
      0xae, 0x42, 0x60, 0x82, // CRC
    ]);

    return new Blob([bytes], { type: 'image/png' });
  }

  /**
   * Helper to create a PNG with text metadata
   */
  function createPngWithMetadata(): Blob {
    const bytes = new Uint8Array([
      // PNG signature
      0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a,
      // IHDR chunk
      0x00, 0x00, 0x00, 0x0d,
      0x49, 0x48, 0x44, 0x52,
      0x00, 0x00, 0x00, 0x01,
      0x00, 0x00, 0x00, 0x01,
      0x08, 0x02,
      0x00, 0x00, 0x00,
      0x90, 0x77, 0x53, 0xde,
      // tEXt chunk (should be REMOVED)
      0x00, 0x00, 0x00, 0x0b, // length
      0x74, 0x45, 0x58, 0x74, // type "tEXt"
      0x41, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x00, 0x54, 0x65, 0x73, 0x74, // "Author\0Test"
      0x00, 0x00, 0x00, 0x00, // CRC (placeholder)
      // IDAT chunk
      0x00, 0x00, 0x00, 0x0c,
      0x49, 0x44, 0x41, 0x54,
      0x08, 0xd7, 0x63, 0xf8, 0xff, 0xff, 0xff, 0x00,
      0x05, 0xfe, 0x02, 0xfe,
      // IEND chunk
      0x00, 0x00, 0x00, 0x00,
      0x49, 0x45, 0x4e, 0x44,
      0xae, 0x42, 0x60, 0x82,
    ]);

    return new Blob([bytes], { type: 'image/png' });
  }

  describe('stripMetadata', () => {
    it('should return result object with required properties', async () => {
      const blob = createMinimalJpeg();
      const result = await stripMetadata(blob);

      expect(result).toHaveProperty('cleanBlob');
      expect(result).toHaveProperty('originalSize');
      expect(result).toHaveProperty('cleanedSize');
      expect(result).toHaveProperty('metadataRemoved');
      expect(result).toHaveProperty('removedTypes');
      expect(result).toHaveProperty('processingTimeMs');
    });

    it('should preserve JPEG without metadata markers', async () => {
      const blob = createMinimalJpeg();
      const result = await stripMetadata(blob);

      expect(result.cleanBlob).toBeInstanceOf(Blob);
      expect(result.cleanedSize).toBeGreaterThan(0);
    });

    it('should remove EXIF data from JPEG', async () => {
      const blob = createJpegWithExif();
      const result = await stripMetadata(blob);

      expect(result.metadataRemoved).toBe(true);
      expect(result.removedTypes).toContain('EXIF');
      expect(result.cleanedSize).toBeLessThan(result.originalSize);
    });

    it('should remove comment data from JPEG', async () => {
      const blob = createJpegWithExif();
      const result = await stripMetadata(blob);

      expect(result.removedTypes).toContain('Comment');
    });

    it('should preserve PNG without metadata chunks', async () => {
      const blob = createMinimalPng();
      const result = await stripMetadata(blob);

      expect(result.cleanBlob).toBeInstanceOf(Blob);
      expect(result.cleanedSize).toBeGreaterThan(0);
    });

    it('should track processing time', async () => {
      const blob = createMinimalJpeg();
      const result = await stripMetadata(blob);

      expect(result.processingTimeMs).toBeGreaterThanOrEqual(0);
    });
  });

  describe('hasMetadata', () => {
    it('should return false for clean JPEG', async () => {
      const blob = createMinimalJpeg();
      const buffer = await blob.arrayBuffer();
      const data = new Uint8Array(buffer);

      // Note: This minimal JPEG only has APP0 which we don't remove
      // so hasMetadata would check for APP1, APP2, etc.
      expect(hasMetadata(data)).toBe(false);
    });

    it('should return true for JPEG with EXIF', async () => {
      const blob = createJpegWithExif();
      const buffer = await blob.arrayBuffer();
      const data = new Uint8Array(buffer);

      expect(hasMetadata(data)).toBe(true);
    });

    it('should return true for unknown formats', () => {
      // Random bytes that aren't JPEG or PNG
      const data = new Uint8Array([0x00, 0x01, 0x02, 0x03]);

      expect(hasMetadata(data)).toBe(true);
    });
  });
});
